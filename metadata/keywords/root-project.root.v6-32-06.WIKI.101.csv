id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65925,Testability,test,testingEventVector,65925,"reak;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; ",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65954,Testability,test,testingEventVector,65954,"reak;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; ",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:66195,Testability,test,testingEventVector,66195,".end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479/////////////////////",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:66219,Testability,test,testingEventVector,66219,".end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479/////////////////////",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:66593,Testability,test,testing,66593,"ear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights e",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:66645,Testability,test,testingEventVector,66645,"ear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights e",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:67048,Testability,test,testing,67048,"Name())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 Va",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:67199,Testability,test,testingEventVector,67199," // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEvents() < 1){; 1466 Log() << kFATAL << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any training events, I better stop here and let you fix that one first "" << Endl;; 1467 }; 1468 ; 1469 if (ds->GetNTestEvents() < 1) {; 1470 Log() << kERROR << ""Dataset "" << std::string(dsi.GetName()) << "" does not have any testing events, guess that will cause problems later..but for now, I continue "" << Endl;; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 Numb",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:68139,Testability,test,testingSumWeightsPerClass,68139,"; 1471 }; 1472 ; 1473 delete trainingEventVector;; 1474 delete testingEventVector;; 1475 return ds;; 1476 ; 1477}; 1478 ; 1479////////////////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 NumberPerClass testingSizePerClass( dsi.GetNClasses() );; 1503 ; 1504 Double_t trainingSumSignalWeights = 0;; 1505 Double_t trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1506 Double_t testingSumSignalWeights = 0;; 1507 Double_t testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1508 ; 1509 ; 1510 ; 1511 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1512 trainingSizePerClass.at(cls) = tmpEventVector[Types::kTraining].at(cls).size();; 1513 testingSizePerClass.at(cls) = tmpEventVector[Types::kTesting].at(cls).size();; 1514 ; 1515 // the functional solution; 1516 // sum up the weights in Double_t although the individual weights are Float_t to prevent rounding issues in addition of floating points; 1517 //; 1518 // accumulate --> does what the name says; 1519 // begin() a",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:68279,Testability,test,testingSizePerClass,68279,"//////////////////////////////////////////////////////////////////////; 1480/// renormalisation of the TRAINING event weights; 1481/// - none (kind of obvious) .. use the weights as supplied by the; 1482/// user.. (we store however the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 NumberPerClass testingSizePerClass( dsi.GetNClasses() );; 1503 ; 1504 Double_t trainingSumSignalWeights = 0;; 1505 Double_t trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1506 Double_t testingSumSignalWeights = 0;; 1507 Double_t testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1508 ; 1509 ; 1510 ; 1511 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1512 trainingSizePerClass.at(cls) = tmpEventVector[Types::kTraining].at(cls).size();; 1513 testingSizePerClass.at(cls) = tmpEventVector[Types::kTesting].at(cls).size();; 1514 ; 1515 // the functional solution; 1516 // sum up the weights in Double_t although the individual weights are Float_t to prevent rounding issues in addition of floating points; 1517 //; 1518 // accumulate --> does what the name says; 1519 // begin() and end() denote the range of the vector to be accumulated; 1520 // Double_t(0) tells accumulate the type and the starting value; 1521 // ",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:68485,Testability,test,testingSumSignalWeights,68485,"wever the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 NumberPerClass testingSizePerClass( dsi.GetNClasses() );; 1503 ; 1504 Double_t trainingSumSignalWeights = 0;; 1505 Double_t trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1506 Double_t testingSumSignalWeights = 0;; 1507 Double_t testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1508 ; 1509 ; 1510 ; 1511 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1512 trainingSizePerClass.at(cls) = tmpEventVector[Types::kTraining].at(cls).size();; 1513 testingSizePerClass.at(cls) = tmpEventVector[Types::kTesting].at(cls).size();; 1514 ; 1515 // the functional solution; 1516 // sum up the weights in Double_t although the individual weights are Float_t to prevent rounding issues in addition of floating points; 1517 //; 1518 // accumulate --> does what the name says; 1519 // begin() and end() denote the range of the vector to be accumulated; 1520 // Double_t(0) tells accumulate the type and the starting value; 1521 // compose_binary creates a BinaryFunction of ...; 1522 // std::plus<Double_t>() knows how to sum up two doubles; 1523 // null<Double_t>() leaves the first argument (the running sum) unchanged and returns it; 1524 //; 1525 // al",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:68529,Testability,test,testingSumBackgrWeights,68529,"wever the relative weight for later use); 1483/// - numEvents; 1484/// - equalNumEvents reweight the training events such that the sum of all; 1485/// backgr. (class > 0) weights equal that of the signal (class 0); 1486 ; 1487void; 1488TMVA::DataSetFactory::RenormEvents( TMVA::DataSetInfo& dsi,; 1489 EventVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 NumberPerClass testingSizePerClass( dsi.GetNClasses() );; 1503 ; 1504 Double_t trainingSumSignalWeights = 0;; 1505 Double_t trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1506 Double_t testingSumSignalWeights = 0;; 1507 Double_t testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1508 ; 1509 ; 1510 ; 1511 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1512 trainingSizePerClass.at(cls) = tmpEventVector[Types::kTraining].at(cls).size();; 1513 testingSizePerClass.at(cls) = tmpEventVector[Types::kTesting].at(cls).size();; 1514 ; 1515 // the functional solution; 1516 // sum up the weights in Double_t although the individual weights are Float_t to prevent rounding issues in addition of floating points; 1517 //; 1518 // accumulate --> does what the name says; 1519 // begin() and end() denote the range of the vector to be accumulated; 1520 // Double_t(0) tells accumulate the type and the starting value; 1521 // compose_binary creates a BinaryFunction of ...; 1522 // std::plus<Double_t>() knows how to sum up two doubles; 1523 // null<Double_t>() leaves the first argument (the running sum) unchanged and returns it; 1524 //; 1525 // al",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:68801,Testability,test,testingSizePerClass,68801,"tVectorOfClassesOfTreeType& tmpEventVector,; 1490 const EvtStatsPerClass& eventCounts,; 1491 const TString& normMode ); 1492{; 1493 ; 1494 ; 1495 // print rescaling info; 1496 // ---------------------------------; 1497 // compute sums of weights; 1498 ValuePerClass trainingSumWeightsPerClass( dsi.GetNClasses() );; 1499 ValuePerClass testingSumWeightsPerClass( dsi.GetNClasses() );; 1500 ; 1501 NumberPerClass trainingSizePerClass( dsi.GetNClasses() );; 1502 NumberPerClass testingSizePerClass( dsi.GetNClasses() );; 1503 ; 1504 Double_t trainingSumSignalWeights = 0;; 1505 Double_t trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1506 Double_t testingSumSignalWeights = 0;; 1507 Double_t testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1508 ; 1509 ; 1510 ; 1511 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1512 trainingSizePerClass.at(cls) = tmpEventVector[Types::kTraining].at(cls).size();; 1513 testingSizePerClass.at(cls) = tmpEventVector[Types::kTesting].at(cls).size();; 1514 ; 1515 // the functional solution; 1516 // sum up the weights in Double_t although the individual weights are Float_t to prevent rounding issues in addition of floating points; 1517 //; 1518 // accumulate --> does what the name says; 1519 // begin() and end() denote the range of the vector to be accumulated; 1520 // Double_t(0) tells accumulate the type and the starting value; 1521 // compose_binary creates a BinaryFunction of ...; 1522 // std::plus<Double_t>() knows how to sum up two doubles; 1523 // null<Double_t>() leaves the first argument (the running sum) unchanged and returns it; 1524 //; 1525 // all together sums up all the event-weights of the events in the vector and returns it; 1526 trainingSumWeightsPerClass.at(cls) =; 1527 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1528 tmpEventVector[Types::kTraining].at(cls).end(),; 1529 Double_t(0), [](Double_t w, const TMVA::Event *",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:69861,Testability,test,testingSumWeightsPerClass,69861,"Class.at(cls) = tmpEventVector[Types::kTesting].at(cls).size();; 1514 ; 1515 // the functional solution; 1516 // sum up the weights in Double_t although the individual weights are Float_t to prevent rounding issues in addition of floating points; 1517 //; 1518 // accumulate --> does what the name says; 1519 // begin() and end() denote the range of the vector to be accumulated; 1520 // Double_t(0) tells accumulate the type and the starting value; 1521 // compose_binary creates a BinaryFunction of ...; 1522 // std::plus<Double_t>() knows how to sum up two doubles; 1523 // null<Double_t>() leaves the first argument (the running sum) unchanged and returns it; 1524 //; 1525 // all together sums up all the event-weights of the events in the vector and returns it; 1526 trainingSumWeightsPerClass.at(cls) =; 1527 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1528 tmpEventVector[Types::kTraining].at(cls).end(),; 1529 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1530 ; 1531 testingSumWeightsPerClass.at(cls) =; 1532 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1533 tmpEventVector[Types::kTesting].at(cls).end(),; 1534 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:70247,Testability,test,testingSumSignalWeights,70247,"521 // compose_binary creates a BinaryFunction of ...; 1522 // std::plus<Double_t>() knows how to sum up two doubles; 1523 // null<Double_t>() leaves the first argument (the running sum) unchanged and returns it; 1524 //; 1525 // all together sums up all the event-weights of the events in the vector and returns it; 1526 trainingSumWeightsPerClass.at(cls) =; 1527 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1528 tmpEventVector[Types::kTraining].at(cls).end(),; 1529 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1530 ; 1531 testingSumWeightsPerClass.at(cls) =; 1532 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1533 tmpEventVector[Types::kTesting].at(cls).end(),; 1534 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!; 1555 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1556 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1557 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1558 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1559 ; 1560 ; 1561 if (normMode == ""NONE"") {; 1562 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""No weight renormalisation applied: use original global and event weights"" << Endl;",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:70274,Testability,test,testingSumWeightsPerClass,70274,"521 // compose_binary creates a BinaryFunction of ...; 1522 // std::plus<Double_t>() knows how to sum up two doubles; 1523 // null<Double_t>() leaves the first argument (the running sum) unchanged and returns it; 1524 //; 1525 // all together sums up all the event-weights of the events in the vector and returns it; 1526 trainingSumWeightsPerClass.at(cls) =; 1527 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1528 tmpEventVector[Types::kTraining].at(cls).end(),; 1529 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1530 ; 1531 testingSumWeightsPerClass.at(cls) =; 1532 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1533 tmpEventVector[Types::kTesting].at(cls).end(),; 1534 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!; 1555 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1556 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1557 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1558 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1559 ; 1560 ; 1561 if (normMode == ""NONE"") {; 1562 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""No weight renormalisation applied: use original global and event weights"" << Endl;",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:70398,Testability,test,testingSumBackgrWeights,70398,"he first argument (the running sum) unchanged and returns it; 1524 //; 1525 // all together sums up all the event-weights of the events in the vector and returns it; 1526 trainingSumWeightsPerClass.at(cls) =; 1527 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1528 tmpEventVector[Types::kTraining].at(cls).end(),; 1529 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1530 ; 1531 testingSumWeightsPerClass.at(cls) =; 1532 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1533 tmpEventVector[Types::kTesting].at(cls).end(),; 1534 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!; 1555 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1556 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1557 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1558 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1559 ; 1560 ; 1561 if (normMode == ""NONE"") {; 1562 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""No weight renormalisation applied: use original global and event weights"" << Endl;; 1563 return;; 1564 }; 1565 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently wa",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:70425,Testability,test,testingSumWeightsPerClass,70425,"he first argument (the running sum) unchanged and returns it; 1524 //; 1525 // all together sums up all the event-weights of the events in the vector and returns it; 1526 trainingSumWeightsPerClass.at(cls) =; 1527 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1528 tmpEventVector[Types::kTraining].at(cls).end(),; 1529 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1530 ; 1531 testingSumWeightsPerClass.at(cls) =; 1532 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1533 tmpEventVector[Types::kTesting].at(cls).end(),; 1534 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!; 1555 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1556 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1557 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1558 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1559 ; 1560 ; 1561 if (normMode == ""NONE"") {; 1562 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""No weight renormalisation applied: use original global and event weights"" << Endl;; 1563 return;; 1564 }; 1565 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently wa",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:70984,Testability,test,testingSumSignalWeights,70984,"[Types::kTesting].at(cls).end(),; 1534 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!; 1555 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1556 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1557 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1558 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1559 ; 1560 ; 1561 if (normMode == ""NONE"") {; 1562 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""No weight renormalisation applied: use original global and event weights"" << Endl;; 1563 return;; 1564 }; 1565 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently was; 1566 //NOT understood by the 'programmer' :) .. the idea was to have SAME amount of effective TRAINING data for signal and background.; 1567 // Testing events are totally irrelevant for this and might actually skew the whole normalisation!!; 1568 else if (normMode == ""NUMEVENTS"") {; 1569 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1570 << ""\tWeight renormalisation mode: \""NumEvents\"": renormalises all event classes "" << Endl;; 1571 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1572 << "" such that the effective (weighted) number of even",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:71047,Testability,test,testingSumBackgrWeights,71047,"etOriginalWeight(); });; 1535 ; 1536 if ( cls == dsi.GetSignalClassIndex()){; 1537 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1538 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1539 }else{; 1540 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1541 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1542 }; 1543 }; 1544 ; 1545 // ---------------------------------; 1546 // compute renormalization factors; 1547 ; 1548 ValuePerClass renormFactor( dsi.GetNClasses() );; 1549 ; 1550 ; 1551 // for information purposes; 1552 dsi.SetNormalization( normMode );; 1553 // !! these will be overwritten later by the 'rescaled' ones if; 1554 // NormMode != None !!!; 1555 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1556 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1557 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1558 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1559 ; 1560 ; 1561 if (normMode == ""NONE"") {; 1562 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""No weight renormalisation applied: use original global and event weights"" << Endl;; 1563 return;; 1564 }; 1565 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently was; 1566 //NOT understood by the 'programmer' :) .. the idea was to have SAME amount of effective TRAINING data for signal and background.; 1567 // Testing events are totally irrelevant for this and might actually skew the whole normalisation!!; 1568 else if (normMode == ""NUMEVENTS"") {; 1569 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1570 << ""\tWeight renormalisation mode: \""NumEvents\"": renormalises all event classes "" << Endl;; 1571 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1572 << "" such that the effective (weighted) number of events in each class equals the respective "" << Endl;; 1573 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.Get",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:72862,Testability,test,testingSizePerClass,72862,"571 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1572 << "" such that the effective (weighted) number of events in each class equals the respective "" << Endl;; 1573 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1574 << "" number of events (entries) that you demanded in PrepareTrainingAndTestTree(\""\"",\""nTrain_Signal=.. )"" << Endl;; 1575 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1576 << "" ... i.e. such that Sum[i=1..N_j]{w_i} = N_j, j=0,1,2..."" << Endl;; 1577 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1578 << "" ... (note that N_j is the sum of TRAINING events (nTrain_j...with j=Signal,Background.."" << Endl;; 1579 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1580 << "" ..... Testing events are not renormalised nor included in the renormalisation factor! )""<< Endl;; 1581 ; 1582 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1583 // renormFactor.at(cls) = ( (trainingSizePerClass.at(cls) + testingSizePerClass.at(cls))/; 1584 // (trainingSumWeightsPerClass.at(cls) + testingSumWeightsPerClass.at(cls)) );; 1585 //changed by Helge 27.5.2013; 1586 renormFactor.at(cls) = ((Float_t)trainingSizePerClass.at(cls) )/; 1587 (trainingSumWeightsPerClass.at(cls)) ;; 1588 }; 1589 }; 1590 else if (normMode == ""EQUALNUMEVENTS"") {; 1591 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently was; 1592 //NOT understood by the 'programmer' :) .. the idea was to have SAME amount of effective TRAINING data for signal and background.; 1593 //done here was something like having each data source normalized to its number of entries and this even for training+testing together.; 1594 // what should this have been good for ???; 1595 ; 1596 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Weight renormalisation mode: \""EqualNumEvents\"": renormalises all event classes ..."" << Endl;; 1597 Log() << kINFO << Form(""Dataset[%s] : "",dsi.Get",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:72939,Testability,test,testingSumWeightsPerClass,72939,"at the effective (weighted) number of events in each class equals the respective "" << Endl;; 1573 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1574 << "" number of events (entries) that you demanded in PrepareTrainingAndTestTree(\""\"",\""nTrain_Signal=.. )"" << Endl;; 1575 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1576 << "" ... i.e. such that Sum[i=1..N_j]{w_i} = N_j, j=0,1,2..."" << Endl;; 1577 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1578 << "" ... (note that N_j is the sum of TRAINING events (nTrain_j...with j=Signal,Background.."" << Endl;; 1579 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1580 << "" ..... Testing events are not renormalised nor included in the renormalisation factor! )""<< Endl;; 1581 ; 1582 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1583 // renormFactor.at(cls) = ( (trainingSizePerClass.at(cls) + testingSizePerClass.at(cls))/; 1584 // (trainingSumWeightsPerClass.at(cls) + testingSumWeightsPerClass.at(cls)) );; 1585 //changed by Helge 27.5.2013; 1586 renormFactor.at(cls) = ((Float_t)trainingSizePerClass.at(cls) )/; 1587 (trainingSumWeightsPerClass.at(cls)) ;; 1588 }; 1589 }; 1590 else if (normMode == ""EQUALNUMEVENTS"") {; 1591 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently was; 1592 //NOT understood by the 'programmer' :) .. the idea was to have SAME amount of effective TRAINING data for signal and background.; 1593 //done here was something like having each data source normalized to its number of entries and this even for training+testing together.; 1594 // what should this have been good for ???; 1595 ; 1596 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Weight renormalisation mode: \""EqualNumEvents\"": renormalises all event classes ..."" << Endl;; 1597 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" such that the effective (weighted) number of events in each class i",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:73581,Testability,test,testing,73581,"."" << Endl;; 1579 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1580 << "" ..... Testing events are not renormalised nor included in the renormalisation factor! )""<< Endl;; 1581 ; 1582 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1583 // renormFactor.at(cls) = ( (trainingSizePerClass.at(cls) + testingSizePerClass.at(cls))/; 1584 // (trainingSumWeightsPerClass.at(cls) + testingSumWeightsPerClass.at(cls)) );; 1585 //changed by Helge 27.5.2013; 1586 renormFactor.at(cls) = ((Float_t)trainingSizePerClass.at(cls) )/; 1587 (trainingSumWeightsPerClass.at(cls)) ;; 1588 }; 1589 }; 1590 else if (normMode == ""EQUALNUMEVENTS"") {; 1591 //changed by Helge 27.5.2013 What on earth was done here before? I still remember the idea behind this which apparently was; 1592 //NOT understood by the 'programmer' :) .. the idea was to have SAME amount of effective TRAINING data for signal and background.; 1593 //done here was something like having each data source normalized to its number of entries and this even for training+testing together.; 1594 // what should this have been good for ???; 1595 ; 1596 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Weight renormalisation mode: \""EqualNumEvents\"": renormalises all event classes ..."" << Endl;; 1597 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" such that the effective (weighted) number of events in each class is the same "" << Endl;; 1598 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" (and equals the number of events (entries) given for class=0 )"" << Endl;; 1599 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""... i.e. such that Sum[i=1..N_j]{w_i} = N_classA, j=classA, classB, ..."" << Endl;; 1600 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""... (note that N_j is the sum of TRAINING events"" << Endl;; 1601 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" ..... Testing events are not renormalised nor included in the renormalisation fact",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:75935,Testability,test,testing,75935,"ode << Endl;; 1612 }; 1613 ; 1614 // ---------------------------------; 1615 // now apply the normalization factors; 1616 Int_t maxL = dsi.GetClassNameMaxLength();; 1617 for (UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls<clsEnd; ++cls) {; 1618 Log() << kDEBUG //<< Form(""Dataset[%s] : "",dsi.GetName()); 1619 << ""--> Rescale "" << setiosflags(ios::left) << std::setw(maxL); 1620 << dsi.GetClassInfo(cls)->GetName() << "" event weights by factor: "" << renormFactor.at(cls) << Endl;; 1621 for (EventVector::iterator it = tmpEventVector[Types::kTraining].at(cls).begin(),; 1622 itEnd = tmpEventVector[Types::kTraining].at(cls).end(); it != itEnd; ++it){; 1623 (*it)->SetWeight ((*it)->GetWeight() * renormFactor.at(cls));; 1624 }; 1625 ; 1626 }; 1627 ; 1628 ; 1629 // print out the result; 1630 // (same code as before --> this can be done nicer ); 1631 //; 1632 ; 1633 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1634 << ""Number of training and testing events"" << Endl;; 1635 Log() << kDEBUG << ""\tafter rescaling:"" << Endl;; 1636 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1637 << ""---------------------------------------------------------------------------"" << Endl;; 1638 ; 1639 trainingSumSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:76311,Testability,test,testingSumSignalWeights,76311,"s::left) << std::setw(maxL); 1620 << dsi.GetClassInfo(cls)->GetName() << "" event weights by factor: "" << renormFactor.at(cls) << Endl;; 1621 for (EventVector::iterator it = tmpEventVector[Types::kTraining].at(cls).begin(),; 1622 itEnd = tmpEventVector[Types::kTraining].at(cls).end(); it != itEnd; ++it){; 1623 (*it)->SetWeight ((*it)->GetWeight() * renormFactor.at(cls));; 1624 }; 1625 ; 1626 }; 1627 ; 1628 ; 1629 // print out the result; 1630 // (same code as before --> this can be done nicer ); 1631 //; 1632 ; 1633 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1634 << ""Number of training and testing events"" << Endl;; 1635 Log() << kDEBUG << ""\tafter rescaling:"" << Endl;; 1636 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1637 << ""---------------------------------------------------------------------------"" << Endl;; 1638 ; 1639 trainingSumSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:76346,Testability,test,testingSumBackgrWeights,76346,"s::left) << std::setw(maxL); 1620 << dsi.GetClassInfo(cls)->GetName() << "" event weights by factor: "" << renormFactor.at(cls) << Endl;; 1621 for (EventVector::iterator it = tmpEventVector[Types::kTraining].at(cls).begin(),; 1622 itEnd = tmpEventVector[Types::kTraining].at(cls).end(); it != itEnd; ++it){; 1623 (*it)->SetWeight ((*it)->GetWeight() * renormFactor.at(cls));; 1624 }; 1625 ; 1626 }; 1627 ; 1628 ; 1629 // print out the result; 1630 // (same code as before --> this can be done nicer ); 1631 //; 1632 ; 1633 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1634 << ""Number of training and testing events"" << Endl;; 1635 Log() << kDEBUG << ""\tafter rescaling:"" << Endl;; 1636 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1637 << ""---------------------------------------------------------------------------"" << Endl;; 1638 ; 1639 trainingSumSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:76791,Testability,test,testingSumWeightsPerClass,76791,"int out the result; 1630 // (same code as before --> this can be done nicer ); 1631 //; 1632 ; 1633 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1634 << ""Number of training and testing events"" << Endl;; 1635 Log() << kDEBUG << ""\tafter rescaling:"" << Endl;; 1636 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1637 << ""---------------------------------------------------------------------------"" << Endl;; 1638 ; 1639 trainingSumSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPe",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:77177,Testability,test,testingSumSignalWeights,77177,"umSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:77204,Testability,test,testingSumWeightsPerClass,77204,"umSignalWeights = 0;; 1640 trainingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1641 testingSumSignalWeights = 0;; 1642 testingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:77328,Testability,test,testingSumBackgrWeights,77328,"estingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName(",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:77355,Testability,test,testingSumWeightsPerClass,77355,"estingSumBackgrWeights = 0; // Backgr. includes all classes that are not signal; 1643 ; 1644 for( UInt_t cls = 0, clsEnd = dsi.GetNClasses(); cls < clsEnd; ++cls ){; 1645 trainingSumWeightsPerClass.at(cls) =; 1646 std::accumulate(tmpEventVector[Types::kTraining].at(cls).begin(),; 1647 tmpEventVector[Types::kTraining].at(cls).end(),; 1648 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1649 ; 1650 testingSumWeightsPerClass.at(cls) =; 1651 std::accumulate(tmpEventVector[Types::kTesting].at(cls).begin(),; 1652 tmpEventVector[Types::kTesting].at(cls).end(),; 1653 Double_t(0), [](Double_t w, const TMVA::Event *E) { return w + E->GetOriginalWeight(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName(",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:78041,Testability,test,testing,78041,"ght(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1678 << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:78063,Testability,test,testingSizePerClass,78063,"ght(); });; 1654 ; 1655 if ( cls == dsi.GetSignalClassIndex()){; 1656 trainingSumSignalWeights += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1678 << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:78150,Testability,test,testingSumWeightsPerClass,78150,"ts += trainingSumWeightsPerClass.at(cls);; 1657 testingSumSignalWeights += testingSumWeightsPerClass.at(cls);; 1658 }else{; 1659 trainingSumBackgrWeights += trainingSumWeightsPerClass.at(cls);; 1660 testingSumBackgrWeights += testingSumWeightsPerClass.at(cls);; 1661 }; 1662 ; 1663 // output statistics; 1664 ; 1665 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1678 << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kI",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:78476,Testability,test,testing,78476,"(""Dataset[%s] : "",dsi.GetName()); 1666 << setiosflags(ios::left) << std::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1678 << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kINFO << Endl;; 1692 ; 1693 // for information purposes; 1694 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1695 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1696 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1697 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1698 ; 1699 ; 1700}; Configur",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:78533,Testability,test,testingSizePerClass,78533,"d::setw(maxL); 1667 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1668 << ""training events : "" << trainingSizePerClass.at(cls) << Endl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1678 << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kINFO << Endl;; 1692 ; 1693 // for information purposes; 1694 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1695 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1696 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1697 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1698 ; 1699 ; 1700}; Configurable.h; DataInputHandler.h; DataSetFactory.h; DataSetInfo.h; DataSet.",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:78663,Testability,test,testingSumWeightsPerClass,78663,"dl;; 1669 Log() << kDEBUG << ""\t(sum of weights: "" << trainingSumWeightsPerClass.at(cls) << "")""; 1670 << "" - requested were "" << eventCounts[cls].nTrainingEventsRequested << "" events"" << Endl;; 1671 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1672 << setiosflags(ios::left) << std::setw(maxL); 1673 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1674 << ""testing events : "" << testingSizePerClass.at(cls) << Endl;; 1675 Log() << kDEBUG << ""\t(sum of weights: "" << testingSumWeightsPerClass.at(cls) << "")""; 1676 << "" - requested were "" << eventCounts[cls].nTestingEventsRequested << "" events"" << Endl;; 1677 Log() << kINFO //<< Form(""Dataset[%s] : "",dsi.GetName()); 1678 << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kINFO << Endl;; 1692 ; 1693 // for information purposes; 1694 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1695 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1696 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1697 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1698 ; 1699 ; 1700}; Configurable.h; DataInputHandler.h; DataSetFactory.h; DataSetInfo.h; DataSet.h; Event.h; MsgLogger.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RS",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:79351,Testability,test,testingSumSignalWeights,79351," << setiosflags(ios::left) << std::setw(maxL); 1679 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kINFO << Endl;; 1692 ; 1693 // for information purposes; 1694 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1695 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1696 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1697 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1698 ; 1699 ; 1700}; Configurable.h; DataInputHandler.h; DataSetFactory.h; DataSetInfo.h; DataSet.h; Event.h; MsgLogger.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TBranch.h; TEventList.h; TFile.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTex",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:79414,Testability,test,testingSumBackgrWeights,79414,"->GetName() << "" -- ""; 1680 << ""training and testing events: ""; 1681 << (trainingSizePerClass.at(cls)+testingSizePerClass.at(cls)) << Endl;; 1682 Log() << kDEBUG << ""\t(sum of weights: ""; 1683 << (trainingSumWeightsPerClass.at(cls)+testingSumWeightsPerClass.at(cls)) << "")"" << Endl;; 1684 if(eventCounts[cls].nEvAfterCut<eventCounts[cls].nEvBeforeCut) {; 1685 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << setiosflags(ios::left) << std::setw(maxL); 1686 << dsi.GetClassInfo(cls)->GetName() << "" -- ""; 1687 << ""due to the preselection a scaling factor has been applied to the numbers of requested events: ""; 1688 << eventCounts[cls].cutScaling() << Endl;; 1689 }; 1690 }; 1691 Log() << kINFO << Endl;; 1692 ; 1693 // for information purposes; 1694 dsi.SetTrainingSumSignalWeights(trainingSumSignalWeights);; 1695 dsi.SetTrainingSumBackgrWeights(trainingSumBackgrWeights);; 1696 dsi.SetTestingSumSignalWeights(testingSumSignalWeights);; 1697 dsi.SetTestingSumBackgrWeights(testingSumBackgrWeights);; 1698 ; 1699 ; 1700}; Configurable.h; DataInputHandler.h; DataSetFactory.h; DataSetInfo.h; DataSet.h; Event.h; MsgLogger.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TBranch.h; TEventList.h; TFile.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; TMath.h; TMatrixDT",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:84356,Testability,test,testing,84356,"::DataSetFactory::EventStats::varAvLengthFloat_t * varAvLengthDefinition DataSetFactory.h:137; TMVA::DataSetFactory::EventStats::nWeEvBeforeCutFloat_t nWeEvBeforeCutDefinition DataSetFactory.h:134; TMVA::DataSetFactory::EventStats::nNegWeightsDouble_t nNegWeightsDefinition DataSetFactory.h:136; TMVA::DataSetFactory::~DataSetFactory~DataSetFactory()destructorDefinition DataSetFactory.cxx:107; TMVA::DataSetFactory::BuildInitialDataSetDataSet * BuildInitialDataSet(DataSetInfo &, TMVA::DataInputHandler &)if no entries, than create a DataSet with one Event which uses dynamic variables (pointers to variabl...Definition DataSetFactory.cxx:202; TMVA::DataSetFactory::DataSetFactoryDataSetFactory()constructorDefinition DataSetFactory.cxx:93; TMVA::DataSetFactory::EventVectorOfClassesOfTreeTypestd::map< Types::ETreeType, EventVectorOfClasses > EventVectorOfClassesOfTreeTypeDefinition DataSetFactory.h:120; TMVA::DataSetFactory::ChangeToNewTreevoid ChangeToNewTree(TreeInfo &, const DataSetInfo &)While the data gets copied into the local training and testing trees, the input tree can change (for ...Definition DataSetFactory.cxx:293; TMVA::DataSetFactory::BuildEventVectorvoid BuildEventVector(DataSetInfo &dsi, DataInputHandler &dataInput, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts)build empty event vectors distributes events between kTraining/kTesting/kMaxTreeTypeDefinition DataSetFactory.cxx:728; TMVA::DataSetFactory::CreateDataSetDataSet * CreateDataSet(DataSetInfo &, DataInputHandler &)steering the creation of a new datasetDefinition DataSetFactory.cxx:123; TMVA::DataSetFactory::MixEventsDataSet * MixEvents(DataSetInfo &dsi, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts, const TString &splitMode, const TString &mixMode, const TString &normMode, UInt_t splitSeed)Select and distribute unassigned events to kTraining and kTesting.Definition DataSetFactory.cxx:1063; TMVA::DataSetFactory::NumberPerClassstd::vector< int > NumberP",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:88652,Testability,test,testingSumSignalWeights,88652,"DataSetInfo::GetVarArraySizeInt_t GetVarArraySize(const TString &expression) constDefinition DataSetInfo.h:108; TMVA::DataSetInfo::AddClassClassInfo * AddClass(const TString &className)Definition DataSetInfo.cxx:113; TMVA::DataSetInfo::GetNamevirtual const char * GetName() constReturns name of object.Definition DataSetInfo.h:71; TMVA::DataSetInfo::IsVariableFromArrayBool_t IsVariableFromArray(Int_t i) constDefinition DataSetInfo.h:112; TMVA::DataSetInfo::GetSpectatorInfosstd::vector< VariableInfo > & GetSpectatorInfos()Definition DataSetInfo.h:122; TMVA::DataSetInfo::SetNormalizationvoid SetNormalization(const TString &norm)Definition DataSetInfo.h:132; TMVA::DataSetInfo::GetNClassesUInt_t GetNClasses() constDefinition DataSetInfo.h:155; TMVA::DataSetInfo::GetSplitOptionsconst TString & GetSplitOptions() constDefinition DataSetInfo.h:186; TMVA::DataSetInfo::GetNTargetsUInt_t GetNTargets() constDefinition DataSetInfo.h:128; TMVA::DataSetInfo::SetTestingSumSignalWeightsvoid SetTestingSumSignalWeights(Double_t testingSumSignalWeights)Definition DataSetInfo.h:138; TMVA::DataSetInfo::GetSignalClassIndexUInt_t GetSignalClassIndex()Definition DataSetInfo.h:158; TMVA::DataSetInfo::SetTrainingSumSignalWeightsvoid SetTrainingSumSignalWeights(Double_t trainingSumSignalWeights)Definition DataSetInfo.h:134; TMVA::DataSetInfo::GetClassInfoClassInfo * GetClassInfo(Int_t clNum) constDefinition DataSetInfo.cxx:146; TMVA::DataSetInfo::SetTestingSumBackgrWeightsvoid SetTestingSumBackgrWeights(Double_t testingSumBackgrWeights)Definition DataSetInfo.h:139; TMVA::DataSetInfo::GetClassNameMaxLengthInt_t GetClassNameMaxLength() constDefinition DataSetInfo.cxx:524; TMVA::DataSetInfo::PrintCorrelationMatrixvoid PrintCorrelationMatrix(const TString &className)calculates the correlation matrices for signal and background, prints them to standard output,...Definition DataSetInfo.cxx:419; TMVA::DataSetInfo::GetVariableInfoVariableInfo & GetVariableInfo(Int_t i)Definition DataSetInfo.h:105; TMVA:",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:89137,Testability,test,testingSumBackgrWeights,89137,"tor< VariableInfo > & GetSpectatorInfos()Definition DataSetInfo.h:122; TMVA::DataSetInfo::SetNormalizationvoid SetNormalization(const TString &norm)Definition DataSetInfo.h:132; TMVA::DataSetInfo::GetNClassesUInt_t GetNClasses() constDefinition DataSetInfo.h:155; TMVA::DataSetInfo::GetSplitOptionsconst TString & GetSplitOptions() constDefinition DataSetInfo.h:186; TMVA::DataSetInfo::GetNTargetsUInt_t GetNTargets() constDefinition DataSetInfo.h:128; TMVA::DataSetInfo::SetTestingSumSignalWeightsvoid SetTestingSumSignalWeights(Double_t testingSumSignalWeights)Definition DataSetInfo.h:138; TMVA::DataSetInfo::GetSignalClassIndexUInt_t GetSignalClassIndex()Definition DataSetInfo.h:158; TMVA::DataSetInfo::SetTrainingSumSignalWeightsvoid SetTrainingSumSignalWeights(Double_t trainingSumSignalWeights)Definition DataSetInfo.h:134; TMVA::DataSetInfo::GetClassInfoClassInfo * GetClassInfo(Int_t clNum) constDefinition DataSetInfo.cxx:146; TMVA::DataSetInfo::SetTestingSumBackgrWeightsvoid SetTestingSumBackgrWeights(Double_t testingSumBackgrWeights)Definition DataSetInfo.h:139; TMVA::DataSetInfo::GetClassNameMaxLengthInt_t GetClassNameMaxLength() constDefinition DataSetInfo.cxx:524; TMVA::DataSetInfo::PrintCorrelationMatrixvoid PrintCorrelationMatrix(const TString &className)calculates the correlation matrices for signal and background, prints them to standard output,...Definition DataSetInfo.cxx:419; TMVA::DataSetInfo::GetVariableInfoVariableInfo & GetVariableInfo(Int_t i)Definition DataSetInfo.h:105; TMVA::DataSetInfo::SetTrainingSumBackgrWeightsvoid SetTrainingSumBackgrWeights(Double_t trainingSumBackgrWeights)Definition DataSetInfo.h:137; TMVA::DataSetInfo::GetTargetInfoVariableInfo & GetTargetInfo(Int_t i)Definition DataSetInfo.h:119; TMVA::DataSetInfo::GetSpectatorInfoVariableInfo & GetSpectatorInfo(Int_t i)Definition DataSetInfo.h:124; TMVA::DataSetInfo::SetCorrelationMatrixvoid SetCorrelationMatrix(const TString &className, TMatrixD *matrix)Definition DataSetInfo.cxx:365; TM",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:92910,Testability,test,testing,92910,Float_t GetSpectator(UInt_t ivar) constreturn spectator contentDefinition Event.cxx:261; TMVA::Event::GetClassUInt_t GetClass() constDefinition Event.h:86; TMVA::Event::SetSpectatorTypesvoid SetSpectatorTypes(const std::vector< char > &types)Definition Event.h:119; TMVA::Event::GetTargetFloat_t GetTarget(UInt_t itgt) constDefinition Event.h:102; TMVA::IncrementDefinition DataSetFactory.h:85; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::RandomGeneratorDefinition Tools.h:299; TMVA::TreeInfoDefinition DataInputHandler.h:52; TMVA::TreeInfo::GetTreeTypeTypes::ETreeType GetTreeType() constDefinition DataInputHandler.h:64; TMVA::TreeInfo::GetClassNameconst TString & GetClassName() constDefinition DataInputHandler.h:65; TMVA::TreeInfo::GetWeightDouble_t GetWeight() constDefinition DataInputHandler.h:62; TMVA::TreeInfo::GetTreeTTree * GetTree() constDefinition DataInputHandler.h:61; TMVA::Types::kMaxTreeType@ kMaxTreeTypealso used as temporary storage for trees not yet assigned for testing;training...Definition Types.h:145; TMVA::Types::kTraining@ kTrainingDefinition Types.h:143; TMVA::Types::kTesting@ kTestingDefinition Types.h:144; TMVA::VariableInfo::SetMaxvoid SetMax(Double_t v)Definition VariableInfo.h:72; TMVA::VariableInfo::GetExpressionconst TString & GetExpression() constDefinition VariableInfo.h:57; TMVA::VariableInfo::SetMinvoid SetMin(Double_t v)Definition VariableInfo.h:71; TMVA::VariableInfo::GetInternalNameconst TString & GetInternalName() constDefinition VariableInfo.h:58; TMatrixT< Double_t >; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Dat,MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:12145,Usability,clear,clear,12145,"nstance when changing from; 289/// signal to background tree, or using TChains as input) The; 290/// TTreeFormulas, that hold the input expressions need to be; 291/// re-associated with the new tree, which is done here; 292 ; 293void TMVA::DataSetFactory::ChangeToNewTree( TreeInfo& tinfo, const DataSetInfo & dsi ); 294{; 295 TTree *tr = tinfo.GetTree()->GetTree();; 296 ; 297 //tr->SetBranchStatus(""*"",1); // nor needed when using TTReeFormula; 298 tr->ResetBranchAddresses();; 299 ; 300 Bool_t hasDollar = kTRUE; // Set to false if wants to enable only some branch in the tree; 301 ; 302 // 1) the input variable formulas; 303 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" create input formulas for tree "" << tr->GetName() << Endl;; 304 std::vector<TTreeFormula*>::const_iterator formIt, formItEnd;; 305 for (formIt = fInputFormulas.begin(), formItEnd=fInputFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 306 fInputFormulas.clear();; 307 TTreeFormula* ttf = 0;; 308 fInputTableFormulas.clear(); // this contains shallow pointer copies; 309 ; 310 bool firstArrayVar = kTRUE;; 311 int firstArrayVarIndex = -1;; 312 int arraySize = -1;; 313 for (UInt_t i = 0; i < dsi.GetNVariables(); i++) {; 314 ; 315 // create TTreeformula; 316 if (! dsi.IsVariableFromArray(i) ) {; 317 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 318 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 319 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);; 320 fInputFormulas.emplace_back(ttf);; 321 fInputTableFormulas.emplace_back(std::make_pair(ttf, (Int_t) 0));; 322 } else {; 323 // it is a variable from an array; 324 if (firstArrayVar) {; 325 ; 326 // create a new TFormula; 327 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 328 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 329 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:12207,Usability,clear,clear,12207," hold the input expressions need to be; 291/// re-associated with the new tree, which is done here; 292 ; 293void TMVA::DataSetFactory::ChangeToNewTree( TreeInfo& tinfo, const DataSetInfo & dsi ); 294{; 295 TTree *tr = tinfo.GetTree()->GetTree();; 296 ; 297 //tr->SetBranchStatus(""*"",1); // nor needed when using TTReeFormula; 298 tr->ResetBranchAddresses();; 299 ; 300 Bool_t hasDollar = kTRUE; // Set to false if wants to enable only some branch in the tree; 301 ; 302 // 1) the input variable formulas; 303 Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << "" create input formulas for tree "" << tr->GetName() << Endl;; 304 std::vector<TTreeFormula*>::const_iterator formIt, formItEnd;; 305 for (formIt = fInputFormulas.begin(), formItEnd=fInputFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 306 fInputFormulas.clear();; 307 TTreeFormula* ttf = 0;; 308 fInputTableFormulas.clear(); // this contains shallow pointer copies; 309 ; 310 bool firstArrayVar = kTRUE;; 311 int firstArrayVarIndex = -1;; 312 int arraySize = -1;; 313 for (UInt_t i = 0; i < dsi.GetNVariables(); i++) {; 314 ; 315 // create TTreeformula; 316 if (! dsi.IsVariableFromArray(i) ) {; 317 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 318 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 319 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);; 320 fInputFormulas.emplace_back(ttf);; 321 fInputTableFormulas.emplace_back(std::make_pair(ttf, (Int_t) 0));; 322 } else {; 323 // it is a variable from an array; 324 if (firstArrayVar) {; 325 ; 326 // create a new TFormula; 327 ttf = new TTreeFormula(Form(""Formula%s"", dsi.GetVariableInfo(i).GetInternalName().Data()),; 328 dsi.GetVariableInfo(i).GetExpression().Data(), tr);; 329 CheckTTreeFormula(ttf, dsi.GetVariableInfo(i).GetExpression(), hasDollar);; 330 fInputFormulas.push_back(ttf);; 331 ; 332 arraySize = dsi.GetVarArraySize(dsi.GetVariableInfo(i).GetExpression());;",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:14248,Usability,clear,clear,14248,"iableInfo(i).GetExpression());; 333 firstArrayVar = kFALSE;; 334 firstArrayVarIndex = i;; 335 ; 336 Log() << kINFO << ""Using variable "" << dsi.GetVariableInfo(i).GetInternalName() <<; 337 "" from array expression "" << dsi.GetVariableInfo(i).GetExpression() << "" of size "" << arraySize << Endl;; 338 }; 339 fInputTableFormulas.push_back(std::make_pair(ttf, (Int_t) i-firstArrayVarIndex));; 340 if (int(i)-firstArrayVarIndex == arraySize-1 ) {; 341 // I am the last element of the array; 342 firstArrayVar = kTRUE;; 343 firstArrayVarIndex = -1;; 344 Log() << kDEBUG << ""Using Last variable from array : "" << dsi.GetVariableInfo(i).GetInternalName() << Endl;; 345 }; 346 }; 347 ; 348 }; 349 ; 350 //; 351 // targets; 352 //; 353 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform regression targets"" << Endl;; 354 for (formIt = fTargetFormulas.begin(), formItEnd = fTargetFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 355 fTargetFormulas.clear();; 356 for (UInt_t i=0; i<dsi.GetNTargets(); i++) {; 357 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetTargetInfo(i).GetInternalName().Data() ),; 358 dsi.GetTargetInfo(i).GetExpression().Data(), tr );; 359 CheckTTreeFormula( ttf, dsi.GetTargetInfo(i).GetExpression(), hasDollar );; 360 fTargetFormulas.push_back( ttf );; 361 }; 362 ; 363 //; 364 // spectators; 365 //; 366 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform spectator variables"" << Endl;; 367 for (formIt = fSpectatorFormulas.begin(), formItEnd = fSpectatorFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 368 fSpectatorFormulas.clear();; 369 for (UInt_t i=0; i<dsi.GetNSpectators(); i++) {; 370 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetSpectatorInfo(i).GetInternalName().Data() ),; 371 dsi.GetSpectatorInfo(i).GetExpression().Data(), tr );; 372 CheckTTreeFormula( ttf, dsi.GetSpectatorInfo(i).GetExpression(), hasDollar );; 373 fSpectatorFormulas.push_back( ttf );;",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:14910,Usability,clear,clear,14910," 346 }; 347 ; 348 }; 349 ; 350 //; 351 // targets; 352 //; 353 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform regression targets"" << Endl;; 354 for (formIt = fTargetFormulas.begin(), formItEnd = fTargetFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 355 fTargetFormulas.clear();; 356 for (UInt_t i=0; i<dsi.GetNTargets(); i++) {; 357 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetTargetInfo(i).GetInternalName().Data() ),; 358 dsi.GetTargetInfo(i).GetExpression().Data(), tr );; 359 CheckTTreeFormula( ttf, dsi.GetTargetInfo(i).GetExpression(), hasDollar );; 360 fTargetFormulas.push_back( ttf );; 361 }; 362 ; 363 //; 364 // spectators; 365 //; 366 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform spectator variables"" << Endl;; 367 for (formIt = fSpectatorFormulas.begin(), formItEnd = fSpectatorFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 368 fSpectatorFormulas.clear();; 369 for (UInt_t i=0; i<dsi.GetNSpectators(); i++) {; 370 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetSpectatorInfo(i).GetInternalName().Data() ),; 371 dsi.GetSpectatorInfo(i).GetExpression().Data(), tr );; 372 CheckTTreeFormula( ttf, dsi.GetSpectatorInfo(i).GetExpression(), hasDollar );; 373 fSpectatorFormulas.push_back( ttf );; 374 }; 375 ; 376 //; 377 // the cuts (one per class, if non-existent: formula pointer = 0); 378 //; 379 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform cuts"" << Endl;; 380 for (formIt = fCutFormulas.begin(), formItEnd = fCutFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 381 fCutFormulas.clear();; 382 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 383 const TCut& tmpCut = dsi.GetClassInfo(clIdx)->GetCut();; 384 const TString tmpCutExp(tmpCut.GetTitle());; 385 ttf = 0;; 386 if (tmpCutExp!="""") {; 387 ttf = new TTreeFormula( Form(""CutClass%i"",clIdx), tmpCutExp, tr );; 388 Bool_t worked = CheckTTre",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:15606,Usability,clear,clear,15606,"s; 365 //; 366 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform spectator variables"" << Endl;; 367 for (formIt = fSpectatorFormulas.begin(), formItEnd = fSpectatorFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 368 fSpectatorFormulas.clear();; 369 for (UInt_t i=0; i<dsi.GetNSpectators(); i++) {; 370 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetSpectatorInfo(i).GetInternalName().Data() ),; 371 dsi.GetSpectatorInfo(i).GetExpression().Data(), tr );; 372 CheckTTreeFormula( ttf, dsi.GetSpectatorInfo(i).GetExpression(), hasDollar );; 373 fSpectatorFormulas.push_back( ttf );; 374 }; 375 ; 376 //; 377 // the cuts (one per class, if non-existent: formula pointer = 0); 378 //; 379 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform cuts"" << Endl;; 380 for (formIt = fCutFormulas.begin(), formItEnd = fCutFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 381 fCutFormulas.clear();; 382 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 383 const TCut& tmpCut = dsi.GetClassInfo(clIdx)->GetCut();; 384 const TString tmpCutExp(tmpCut.GetTitle());; 385 ttf = 0;; 386 if (tmpCutExp!="""") {; 387 ttf = new TTreeFormula( Form(""CutClass%i"",clIdx), tmpCutExp, tr );; 388 Bool_t worked = CheckTTreeFormula( ttf, tmpCutExp, hasDollar );; 389 if( !worked ){; 390 Log() << kWARNING << ""Please check class \"""" << dsi.GetClassInfo(clIdx)->GetName(); 391 << ""\"" cut \"""" << dsi.GetClassInfo(clIdx)->GetCut() << Endl;; 392 }; 393 }; 394 fCutFormulas.push_back( ttf );; 395 }; 396 ; 397 //; 398 // the weights (one per class, if non-existent: formula pointer = 0); 399 //; 400 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform weights"" << Endl;; 401 for (formIt = fWeightFormula.begin(), formItEnd = fWeightFormula.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 402 fWeightFormula.clear();; 403 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 404 const TStr",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:16543,Usability,clear,clear,16543,"ormIt) delete *formIt;; 381 fCutFormulas.clear();; 382 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 383 const TCut& tmpCut = dsi.GetClassInfo(clIdx)->GetCut();; 384 const TString tmpCutExp(tmpCut.GetTitle());; 385 ttf = 0;; 386 if (tmpCutExp!="""") {; 387 ttf = new TTreeFormula( Form(""CutClass%i"",clIdx), tmpCutExp, tr );; 388 Bool_t worked = CheckTTreeFormula( ttf, tmpCutExp, hasDollar );; 389 if( !worked ){; 390 Log() << kWARNING << ""Please check class \"""" << dsi.GetClassInfo(clIdx)->GetName(); 391 << ""\"" cut \"""" << dsi.GetClassInfo(clIdx)->GetCut() << Endl;; 392 }; 393 }; 394 fCutFormulas.push_back( ttf );; 395 }; 396 ; 397 //; 398 // the weights (one per class, if non-existent: formula pointer = 0); 399 //; 400 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform weights"" << Endl;; 401 for (formIt = fWeightFormula.begin(), formItEnd = fWeightFormula.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 402 fWeightFormula.clear();; 403 for (UInt_t clIdx=0; clIdx<dsi.GetNClasses(); clIdx++) {; 404 const TString tmpWeight = dsi.GetClassInfo(clIdx)->GetWeight();; 405 ; 406 if (dsi.GetClassInfo(clIdx)->GetName() != tinfo.GetClassName() ) { // if the tree is of another class; 407 fWeightFormula.push_back( 0 );; 408 continue;; 409 }; 410 ; 411 ttf = 0;; 412 if (tmpWeight!="""") {; 413 ttf = new TTreeFormula( ""FormulaWeight"", tmpWeight, tr );; 414 Bool_t worked = CheckTTreeFormula( ttf, tmpWeight, hasDollar );; 415 if( !worked ){; 416 Log() << kWARNING << Form(""Dataset[%s] : "",dsi.GetName()) << ""Please check class \"""" << dsi.GetClassInfo(clIdx)->GetName(); 417 << ""\"" weight \"""" << dsi.GetClassInfo(clIdx)->GetWeight() << Endl;; 418 }; 419 }; 420 else {; 421 ttf = 0;; 422 }; 423 fWeightFormula.push_back( ttf );; 424 }; 425 return;; 426 // all this code below is not needed when using TTReeFormula; 427 ; 428 Log() << kDEBUG << Form(""Dataset[%s] : "", dsi.GetName()) << ""enable branches"" << Endl;; 429 // now enable only branches that are nee",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:57227,Usability,clear,clear,57227,"d<(useForTraining-availableTraining) ||; 1284 availableUndefined<(useForTesting -availableTesting ) ||; 1285 availableUndefined<(useForTraining+useForTesting-availableTraining-availableTesting ) ){; 1286 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested than available!"" << Endl;; 1287 }; 1288 ; 1289 // select the events; 1290 if (useForTraining>availableTraining){; 1291 eventVectorTraining.insert( eventVectorTraining.end() , eventVectorUndefined.begin(), eventVectorUndefined.begin()+ useForTraining- availableTraining );; 1292 eventVectorUndefined.erase( eventVectorUndefined.begin(), eventVectorUndefined.begin() + useForTraining- availableTraining);; 1293 }; 1294 if (useForTesting>availableTesting){; 1295 eventVectorTesting.insert( eventVectorTesting.end() , eventVectorUndefined.begin(), eventVectorUndefined.begin()+ useForTesting- availableTesting );; 1296 }; 1297 }; 1298 eventVectorUndefined.clear();; 1299 ; 1300 // finally shorten the event vectors to the requested size by removing random events; 1301 if (splitMode.Contains( ""RANDOM"" )){; 1302 UInt_t sizeTraining = eventVectorTraining.size();; 1303 if( sizeTraining > UInt_t(requestedTraining) ){; 1304 std::vector<UInt_t> indicesTraining( sizeTraining );; 1305 // make indices; 1306 std::generate( indicesTraining.begin(), indicesTraining.end(), TMVA::Increment<UInt_t>(0) );; 1307 // shuffle indices; 1308 std::shuffle(indicesTraining.begin(), indicesTraining.end(), rndm);; 1309 // erase indices of not needed events; 1310 indicesTraining.erase( indicesTraining.begin()+sizeTraining-UInt_t(requestedTraining), indicesTraining.end() );; 1311 // delete all events with the given indices; 1312 for( std::vector<UInt_t>::iterator it = indicesTraining.begin(), itEnd = indicesTraining.end(); it != itEnd; ++it ){; 1313 delete eventVectorTraining.at( (*it) ); // delete event; 1314 eventVectorTraining.at( (*it) ) = NULL; // set pointer to NULL; 1315 }; 1316 // now remove and erase all events with point",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65571,Usability,clear,clear,65571," ++itEvent ){; 1423 // if( std::distance( itTarget, testingEventVector->end()) < Int_t(cls+1) ) {; 1424 if( ( testingEventVector->end() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal te",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65618,Usability,clear,clear,65618,"estingEventVector->end()) < Int_t(cls+1) ) {; 1424 if( ( testingEventVector->end() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(te",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65676,Usability,clear,clear,65676,"d() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEv",MatchSource.WIKI,doc/master/DataSetFactory_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:429,Deployability,integrat,integrated,429,". ROOT: tmva/tmva/inc/TMVA/DataSetFactory.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. DataSetFactory.h. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Helge Voss; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : DataSetFactory *; 8 * *; 9 * *; 10 * Description: *; 11 * Contains all the data information *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 16 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 17 * Eckhard von Toerne <evt@physik.uni-bonn.de> - U. of Bonn, Germany *; 18 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 19 * *; 20 * Copyright (c) 2006: *; 21 * CERN, Switzerland *; 22 * MPI-K Heidelberg, Germany *; 23 * *; 24 * Redistribution and use in source and binary forms, with or without *; 25 * modification, are permitted according to the terms listed in LICENSE *; 26 * (see tmva/doc/LICENSE) *; 27 **********************************************************************************/; 28 ; 29#ifndef ROOT_TMVA_DataSetFactory; 30#define ROOT_TMVA_DataSetFactory; 31 ; 32//////////////////////////////////////////////////////////////////////////; 33// //; 34// DataSetFactory //; 35// //; 36// Class that contains all the data information //; 37// //; 38//////////////////////////////////////////////////////////////////////////; 39 ; 40#include <vector>; 41#include <map>; 42 ; 43#include ""TString.h""; 44#include ""TTree.h""; 45#include ""TCut.h""; 46#include ""TTreeFormula.h""; 47#include ""TMatrixDfwd.h""; 48#include ""TPrincipal.h""; 49#include ""TRandom3.h""; 50 ; 51#include ""TMVA/Types.h""; 52#include ""TMVA/VariableIn",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:429,Integrability,integrat,integrated,429,". ROOT: tmva/tmva/inc/TMVA/DataSetFactory.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. DataSetFactory.h. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Eckhard von Toerne, Helge Voss; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : DataSetFactory *; 8 * *; 9 * *; 10 * Description: *; 11 * Contains all the data information *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 16 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 17 * Eckhard von Toerne <evt@physik.uni-bonn.de> - U. of Bonn, Germany *; 18 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 19 * *; 20 * Copyright (c) 2006: *; 21 * CERN, Switzerland *; 22 * MPI-K Heidelberg, Germany *; 23 * *; 24 * Redistribution and use in source and binary forms, with or without *; 25 * modification, are permitted according to the terms listed in LICENSE *; 26 * (see tmva/doc/LICENSE) *; 27 **********************************************************************************/; 28 ; 29#ifndef ROOT_TMVA_DataSetFactory; 30#define ROOT_TMVA_DataSetFactory; 31 ; 32//////////////////////////////////////////////////////////////////////////; 33// //; 34// DataSetFactory //; 35// //; 36// Class that contains all the data information //; 37// //; 38//////////////////////////////////////////////////////////////////////////; 39 ; 40#include <vector>; 41#include <map>; 42 ; 43#include ""TString.h""; 44#include ""TTree.h""; 45#include ""TCut.h""; 46#include ""TTreeFormula.h""; 47#include ""TMatrixDfwd.h""; 48#include ""TPrincipal.h""; 49#include ""TRandom3.h""; 50 ; 51#include ""TMVA/Types.h""; 52#include ""TMVA/VariableIn",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:7524,Integrability,message,message,7524,"; 194 ; 195 // ------------------------; 196 ; 197 // auxiliary functions to compute correlations; 198 TMatrixD* CalcCorrelationMatrix( DataSet*, const UInt_t classNumber );; 199 TMatrixD* CalcCovarianceMatrix ( DataSet*, const UInt_t classNumber );; 200 void CalcMinMax ( DataSet*, DataSetInfo& dsi );; 201 ; 202 // resets branch addresses to current event; 203 void ResetBranchAndEventAddresses( TTree* );; 204 void ResetCurrentTree() { fCurrentTree = nullptr; }; 205 void ChangeToNewTree( TreeInfo&, const DataSetInfo & );; 206 Bool_t CheckTTreeFormula( TTreeFormula* ttf, const TString& expression, Bool_t& hasDollar );; 207 ; 208 // verbosity; 209 Bool_t Verbose() { return fVerbose; }; 210 ; 211 // data members; 212 ; 213 // verbosity; 214 Bool_t fVerbose; ///< Verbosity; 215 TString fVerboseLevel; ///< VerboseLevel; 216 ; 217 // Printing; 218 Bool_t fCorrelations = kFALSE; ///< Whether to print correlations or not; 219 Bool_t fComputeCorrelations = kFALSE; ///< Whether to force computation of correlations or not; 220 ; 221 Bool_t fScaleWithPreselEff; ///< how to deal with requested #events in connection with preselection cuts; 222 ; 223 // the event; 224 TTree* fCurrentTree; ///< the tree, events are currently read from; 225 UInt_t fCurrentEvtIdx; ///< the current event (to avoid reading of the same event); 226 ; 227 // the formulas for reading the original tree; 228 std::vector<TTreeFormula*> fInputFormulas; ///< input variables; 229 std::vector<std::pair<TTreeFormula*, Int_t>> fInputTableFormulas; ///<! input variables expression for arrays; 230 std::vector<TTreeFormula *> fTargetFormulas; ///< targets; 231 std::vector<TTreeFormula*> fCutFormulas; ///< cuts; 232 std::vector<TTreeFormula*> fWeightFormula; ///< weights; 233 std::vector<TTreeFormula*> fSpectatorFormulas; ///< spectators; 234 ; 235 MsgLogger* fLogger; ///<! message logger; 236 MsgLogger& Log() const { return *fLogger; }; 237 public:; 238 ClassDef(DataSetFactory, 2);; 239 };; 240}; 241 ; 242#endif; Event.",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:14435,Integrability,message,message,14435,"DynamicDataSetDataSet * BuildDynamicDataSet(DataSetInfo &)Definition DataSetFactory.cxx:149; TMVA::DataSetFactory::EvtStatsPerClassstd::vector< EventStats > EvtStatsPerClassDefinition DataSetFactory.h:155; TMVA::DataSetFactory::fVerboseLevelTString fVerboseLevelVerboseLevel.Definition DataSetFactory.h:215; TMVA::DataSetFactory::fTargetFormulasstd::vector< TTreeFormula * > fTargetFormulastargetsDefinition DataSetFactory.h:230; TMVA::DataSetFactory::CheckTTreeFormulaBool_t CheckTTreeFormula(TTreeFormula *ttf, const TString &expression, Bool_t &hasDollar)checks a TTreeFormula for problemsDefinition DataSetFactory.cxx:251; TMVA::DataSetFactory::fCutFormulasstd::vector< TTreeFormula * > fCutFormulascutsDefinition DataSetFactory.h:231; TMVA::DataSetFactory::ResetBranchAndEventAddressesvoid ResetBranchAndEventAddresses(TTree *); TMVA::DataSetFactory::fCorrelationsBool_t fCorrelationsWhether to print correlations or not.Definition DataSetFactory.h:218; TMVA::DataSetFactory::fLoggerMsgLogger * fLogger! message loggerDefinition DataSetFactory.h:235; TMVA::DataSetFactory::ValuePerClassOfTreeTypestd::map< Types::ETreeType, ValuePerClass > ValuePerClassOfTreeTypeDefinition DataSetFactory.h:124; TMVA::DataSetFactory::RenormEventsvoid RenormEvents(DataSetInfo &dsi, EventVectorOfClassesOfTreeType &eventsmap, const EvtStatsPerClass &eventCounts, const TString &normMode)renormalisation of the TRAINING event weightsDefinition DataSetFactory.cxx:1488; TMVA::DataSetFactory::fComputeCorrelationsBool_t fComputeCorrelationsWhether to force computation of correlations or not.Definition DataSetFactory.h:219; TMVA::DataSetFactory::ResetCurrentTreevoid ResetCurrentTree()Definition DataSetFactory.h:204; TMVA::DataSetFactory::CalcCorrelationMatrixTMatrixD * CalcCorrelationMatrix(DataSet *, const UInt_t classNumber)computes correlation matrix for variables ""theVars"" in tree; ""theType"" defines the required event ""ty...Definition DataSetFactory.cxx:548; TMVA::DataSetFactory::CalcCovarianceMatrixTMat",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:16636,Integrability,rout,routine,16636,"the required event ""ty...Definition DataSetFactory.cxx:548; TMVA::DataSetFactory::CalcCovarianceMatrixTMatrixD * CalcCovarianceMatrix(DataSet *, const UInt_t classNumber)compute covariance matrixDefinition DataSetFactory.cxx:579; TMVA::DataSetFactory::EventVectorstd::vector< Event * > EventVectorDefinition DataSetFactory.h:118; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::IncrementDefinition DataSetFactory.h:85; TMVA::Increment::IncrementIncrement(T start)Definition DataSetFactory.h:88; TMVA::Increment::operator()T operator()()Definition DataSetFactory.h:89; TMVA::Increment::valueT valueDefinition DataSetFactory.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::TreeInfoDefinition DataInputHandler.h:52; TMVA::null_tDefinition DataSetFactory.h:98; TMVA::null_t::operator()F operator()(const F &argF) constDefinition DataSetFactory.h:103; TMVA::null_t::argument_typeF argument_typeDefinition DataSetFactory.h:102; TMatrixT< Double_t >; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; double; int; unsigned int; F#define F(x, y, z); TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::DeleteFunctorDeleteFunctor_t< const T > DeleteFunctor()Definition DataSetFactory.h:78; TMVA::nullnull_t< F > null()Definition DataSetFactory.h:110; TMVA::DeleteFunctor_tDefinition DataSetFactory.h:70; TMVA::DeleteFunctor_t::operator()DeleteFunctor_t & operator()(const T *p)Definition DataSetFactory.h:71; Types.h. tmvatmvaincTMVADataSetFactory.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:57 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:7114,Modifiability,variab,variables,7114,"; 194 ; 195 // ------------------------; 196 ; 197 // auxiliary functions to compute correlations; 198 TMatrixD* CalcCorrelationMatrix( DataSet*, const UInt_t classNumber );; 199 TMatrixD* CalcCovarianceMatrix ( DataSet*, const UInt_t classNumber );; 200 void CalcMinMax ( DataSet*, DataSetInfo& dsi );; 201 ; 202 // resets branch addresses to current event; 203 void ResetBranchAndEventAddresses( TTree* );; 204 void ResetCurrentTree() { fCurrentTree = nullptr; }; 205 void ChangeToNewTree( TreeInfo&, const DataSetInfo & );; 206 Bool_t CheckTTreeFormula( TTreeFormula* ttf, const TString& expression, Bool_t& hasDollar );; 207 ; 208 // verbosity; 209 Bool_t Verbose() { return fVerbose; }; 210 ; 211 // data members; 212 ; 213 // verbosity; 214 Bool_t fVerbose; ///< Verbosity; 215 TString fVerboseLevel; ///< VerboseLevel; 216 ; 217 // Printing; 218 Bool_t fCorrelations = kFALSE; ///< Whether to print correlations or not; 219 Bool_t fComputeCorrelations = kFALSE; ///< Whether to force computation of correlations or not; 220 ; 221 Bool_t fScaleWithPreselEff; ///< how to deal with requested #events in connection with preselection cuts; 222 ; 223 // the event; 224 TTree* fCurrentTree; ///< the tree, events are currently read from; 225 UInt_t fCurrentEvtIdx; ///< the current event (to avoid reading of the same event); 226 ; 227 // the formulas for reading the original tree; 228 std::vector<TTreeFormula*> fInputFormulas; ///< input variables; 229 std::vector<std::pair<TTreeFormula*, Int_t>> fInputTableFormulas; ///<! input variables expression for arrays; 230 std::vector<TTreeFormula *> fTargetFormulas; ///< targets; 231 std::vector<TTreeFormula*> fCutFormulas; ///< cuts; 232 std::vector<TTreeFormula*> fWeightFormula; ///< weights; 233 std::vector<TTreeFormula*> fSpectatorFormulas; ///< spectators; 234 ; 235 MsgLogger* fLogger; ///<! message logger; 236 MsgLogger& Log() const { return *fLogger; }; 237 public:; 238 ClassDef(DataSetFactory, 2);; 239 };; 240}; 241 ; 242#endif; Event.",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:7207,Modifiability,variab,variables,7207,"; 194 ; 195 // ------------------------; 196 ; 197 // auxiliary functions to compute correlations; 198 TMatrixD* CalcCorrelationMatrix( DataSet*, const UInt_t classNumber );; 199 TMatrixD* CalcCovarianceMatrix ( DataSet*, const UInt_t classNumber );; 200 void CalcMinMax ( DataSet*, DataSetInfo& dsi );; 201 ; 202 // resets branch addresses to current event; 203 void ResetBranchAndEventAddresses( TTree* );; 204 void ResetCurrentTree() { fCurrentTree = nullptr; }; 205 void ChangeToNewTree( TreeInfo&, const DataSetInfo & );; 206 Bool_t CheckTTreeFormula( TTreeFormula* ttf, const TString& expression, Bool_t& hasDollar );; 207 ; 208 // verbosity; 209 Bool_t Verbose() { return fVerbose; }; 210 ; 211 // data members; 212 ; 213 // verbosity; 214 Bool_t fVerbose; ///< Verbosity; 215 TString fVerboseLevel; ///< VerboseLevel; 216 ; 217 // Printing; 218 Bool_t fCorrelations = kFALSE; ///< Whether to print correlations or not; 219 Bool_t fComputeCorrelations = kFALSE; ///< Whether to force computation of correlations or not; 220 ; 221 Bool_t fScaleWithPreselEff; ///< how to deal with requested #events in connection with preselection cuts; 222 ; 223 // the event; 224 TTree* fCurrentTree; ///< the tree, events are currently read from; 225 UInt_t fCurrentEvtIdx; ///< the current event (to avoid reading of the same event); 226 ; 227 // the formulas for reading the original tree; 228 std::vector<TTreeFormula*> fInputFormulas; ///< input variables; 229 std::vector<std::pair<TTreeFormula*, Int_t>> fInputTableFormulas; ///<! input variables expression for arrays; 230 std::vector<TTreeFormula *> fTargetFormulas; ///< targets; 231 std::vector<TTreeFormula*> fCutFormulas; ///< cuts; 232 std::vector<TTreeFormula*> fWeightFormula; ///< weights; 233 std::vector<TTreeFormula*> fSpectatorFormulas; ///< spectators; 234 ; 235 MsgLogger* fLogger; ///<! message logger; 236 MsgLogger& Log() const { return *fLogger; }; 237 public:; 238 ClassDef(DataSetFactory, 2);; 239 };; 240}; 241 ; 242#endif; Event.",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:10492,Modifiability,variab,variables,10492,"nNegWeightsDefinition DataSetFactory.h:136; TMVA::DataSetFactory::EventStats::nTestingEventsRequestedInt_t nTestingEventsRequestedDefinition DataSetFactory.h:129; TMVA::DataSetFactoryClass that contains all the data information.Definition DataSetFactory.h:116; TMVA::DataSetFactory::~DataSetFactory~DataSetFactory()destructorDefinition DataSetFactory.cxx:107; TMVA::DataSetFactory::fSpectatorFormulasstd::vector< TTreeFormula * > fSpectatorFormulasspectatorsDefinition DataSetFactory.h:233; TMVA::DataSetFactory::fWeightFormulastd::vector< TTreeFormula * > fWeightFormulaweightsDefinition DataSetFactory.h:232; TMVA::DataSetFactory::fCurrentTreeTTree * fCurrentTreethe tree, events are currently read fromDefinition DataSetFactory.h:224; TMVA::DataSetFactory::VerboseBool_t Verbose()Definition DataSetFactory.h:209; TMVA::DataSetFactory::LogMsgLogger & Log() constDefinition DataSetFactory.h:236; TMVA::DataSetFactory::BuildInitialDataSetDataSet * BuildInitialDataSet(DataSetInfo &, TMVA::DataInputHandler &)if no entries, than create a DataSet with one Event which uses dynamic variables (pointers to variabl...Definition DataSetFactory.cxx:202; TMVA::DataSetFactory::DataSetFactoryDataSetFactory()constructorDefinition DataSetFactory.cxx:93; TMVA::DataSetFactory::EventVectorOfClassesOfTreeTypestd::map< Types::ETreeType, EventVectorOfClasses > EventVectorOfClassesOfTreeTypeDefinition DataSetFactory.h:120; TMVA::DataSetFactory::fCurrentEvtIdxUInt_t fCurrentEvtIdxthe current event (to avoid reading of the same event)Definition DataSetFactory.h:225; TMVA::DataSetFactory::ChangeToNewTreevoid ChangeToNewTree(TreeInfo &, const DataSetInfo &)While the data gets copied into the local training and testing trees, the input tree can change (for ...Definition DataSetFactory.cxx:293; TMVA::DataSetFactory::EventVectorOfTreeTypestd::map< Types::ETreeType, EventVector > EventVectorOfTreeTypeDefinition DataSetFactory.h:121; TMVA::DataSetFactory::fScaleWithPreselEffBool_t fScaleWithPreselEffhow to deal",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:10515,Modifiability,variab,variabl,10515,"nNegWeightsDefinition DataSetFactory.h:136; TMVA::DataSetFactory::EventStats::nTestingEventsRequestedInt_t nTestingEventsRequestedDefinition DataSetFactory.h:129; TMVA::DataSetFactoryClass that contains all the data information.Definition DataSetFactory.h:116; TMVA::DataSetFactory::~DataSetFactory~DataSetFactory()destructorDefinition DataSetFactory.cxx:107; TMVA::DataSetFactory::fSpectatorFormulasstd::vector< TTreeFormula * > fSpectatorFormulasspectatorsDefinition DataSetFactory.h:233; TMVA::DataSetFactory::fWeightFormulastd::vector< TTreeFormula * > fWeightFormulaweightsDefinition DataSetFactory.h:232; TMVA::DataSetFactory::fCurrentTreeTTree * fCurrentTreethe tree, events are currently read fromDefinition DataSetFactory.h:224; TMVA::DataSetFactory::VerboseBool_t Verbose()Definition DataSetFactory.h:209; TMVA::DataSetFactory::LogMsgLogger & Log() constDefinition DataSetFactory.h:236; TMVA::DataSetFactory::BuildInitialDataSetDataSet * BuildInitialDataSet(DataSetInfo &, TMVA::DataInputHandler &)if no entries, than create a DataSet with one Event which uses dynamic variables (pointers to variabl...Definition DataSetFactory.cxx:202; TMVA::DataSetFactory::DataSetFactoryDataSetFactory()constructorDefinition DataSetFactory.cxx:93; TMVA::DataSetFactory::EventVectorOfClassesOfTreeTypestd::map< Types::ETreeType, EventVectorOfClasses > EventVectorOfClassesOfTreeTypeDefinition DataSetFactory.h:120; TMVA::DataSetFactory::fCurrentEvtIdxUInt_t fCurrentEvtIdxthe current event (to avoid reading of the same event)Definition DataSetFactory.h:225; TMVA::DataSetFactory::ChangeToNewTreevoid ChangeToNewTree(TreeInfo &, const DataSetInfo &)While the data gets copied into the local training and testing trees, the input tree can change (for ...Definition DataSetFactory.cxx:293; TMVA::DataSetFactory::EventVectorOfTreeTypestd::map< Types::ETreeType, EventVector > EventVectorOfTreeTypeDefinition DataSetFactory.h:121; TMVA::DataSetFactory::fScaleWithPreselEffBool_t fScaleWithPreselEffhow to deal",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:11624,Modifiability,variab,variables,11624,"actoryDataSetFactory()constructorDefinition DataSetFactory.cxx:93; TMVA::DataSetFactory::EventVectorOfClassesOfTreeTypestd::map< Types::ETreeType, EventVectorOfClasses > EventVectorOfClassesOfTreeTypeDefinition DataSetFactory.h:120; TMVA::DataSetFactory::fCurrentEvtIdxUInt_t fCurrentEvtIdxthe current event (to avoid reading of the same event)Definition DataSetFactory.h:225; TMVA::DataSetFactory::ChangeToNewTreevoid ChangeToNewTree(TreeInfo &, const DataSetInfo &)While the data gets copied into the local training and testing trees, the input tree can change (for ...Definition DataSetFactory.cxx:293; TMVA::DataSetFactory::EventVectorOfTreeTypestd::map< Types::ETreeType, EventVector > EventVectorOfTreeTypeDefinition DataSetFactory.h:121; TMVA::DataSetFactory::fScaleWithPreselEffBool_t fScaleWithPreselEffhow to deal with requested #events in connection with preselection cutsDefinition DataSetFactory.h:221; TMVA::DataSetFactory::fInputTableFormulasstd::vector< std::pair< TTreeFormula *, Int_t > > fInputTableFormulas! input variables expression for arraysDefinition DataSetFactory.h:229; TMVA::DataSetFactory::BuildEventVectorvoid BuildEventVector(DataSetInfo &dsi, DataInputHandler &dataInput, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts)build empty event vectors distributes events between kTraining/kTesting/kMaxTreeTypeDefinition DataSetFactory.cxx:728; TMVA::DataSetFactory::CreateDataSetDataSet * CreateDataSet(DataSetInfo &, DataInputHandler &)steering the creation of a new datasetDefinition DataSetFactory.cxx:123; TMVA::DataSetFactory::MixEventsDataSet * MixEvents(DataSetInfo &dsi, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts, const TString &splitMode, const TString &mixMode, const TString &normMode, UInt_t splitSeed)Select and distribute unassigned events to kTraining and kTesting.Definition DataSetFactory.cxx:1063; TMVA::DataSetFactory::NumberPerClassstd::vector< int > NumberPerClassDefinition DataSetFactory.h:154",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:12678,Modifiability,variab,variablesDefinition,12678,"arraysDefinition DataSetFactory.h:229; TMVA::DataSetFactory::BuildEventVectorvoid BuildEventVector(DataSetInfo &dsi, DataInputHandler &dataInput, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts)build empty event vectors distributes events between kTraining/kTesting/kMaxTreeTypeDefinition DataSetFactory.cxx:728; TMVA::DataSetFactory::CreateDataSetDataSet * CreateDataSet(DataSetInfo &, DataInputHandler &)steering the creation of a new datasetDefinition DataSetFactory.cxx:123; TMVA::DataSetFactory::MixEventsDataSet * MixEvents(DataSetInfo &dsi, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts, const TString &splitMode, const TString &mixMode, const TString &normMode, UInt_t splitSeed)Select and distribute unassigned events to kTraining and kTesting.Definition DataSetFactory.cxx:1063; TMVA::DataSetFactory::NumberPerClassstd::vector< int > NumberPerClassDefinition DataSetFactory.h:154; TMVA::DataSetFactory::fInputFormulasstd::vector< TTreeFormula * > fInputFormulasinput variablesDefinition DataSetFactory.h:228; TMVA::DataSetFactory::EventVectorOfClassesstd::vector< EventVector > EventVectorOfClassesDefinition DataSetFactory.h:119; TMVA::DataSetFactory::InitOptionsvoid InitOptions(DataSetInfo &dsi, EvtStatsPerClass &eventsmap, TString &normMode, UInt_t &splitSeed, TString &splitMode, TString &mixMode)the dataset splittingDefinition DataSetFactory.cxx:638; TMVA::DataSetFactory::fVerboseBool_t fVerboseVerbosity.Definition DataSetFactory.h:214; TMVA::DataSetFactory::CalcMinMaxvoid CalcMinMax(DataSet *, DataSetInfo &dsi)compute covariance matrixDefinition DataSetFactory.cxx:479; TMVA::DataSetFactory::ValuePerClassstd::vector< Double_t > ValuePerClassDefinition DataSetFactory.h:123; TMVA::DataSetFactory::BuildDynamicDataSetDataSet * BuildDynamicDataSet(DataSetInfo &)Definition DataSetFactory.cxx:149; TMVA::DataSetFactory::EvtStatsPerClassstd::vector< EventStats > EvtStatsPerClassDefinition DataSetFactory.h:155; TMVA::DataSetFact",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:15274,Modifiability,variab,variables,15274,"ndEventAddresses(TTree *); TMVA::DataSetFactory::fCorrelationsBool_t fCorrelationsWhether to print correlations or not.Definition DataSetFactory.h:218; TMVA::DataSetFactory::fLoggerMsgLogger * fLogger! message loggerDefinition DataSetFactory.h:235; TMVA::DataSetFactory::ValuePerClassOfTreeTypestd::map< Types::ETreeType, ValuePerClass > ValuePerClassOfTreeTypeDefinition DataSetFactory.h:124; TMVA::DataSetFactory::RenormEventsvoid RenormEvents(DataSetInfo &dsi, EventVectorOfClassesOfTreeType &eventsmap, const EvtStatsPerClass &eventCounts, const TString &normMode)renormalisation of the TRAINING event weightsDefinition DataSetFactory.cxx:1488; TMVA::DataSetFactory::fComputeCorrelationsBool_t fComputeCorrelationsWhether to force computation of correlations or not.Definition DataSetFactory.h:219; TMVA::DataSetFactory::ResetCurrentTreevoid ResetCurrentTree()Definition DataSetFactory.h:204; TMVA::DataSetFactory::CalcCorrelationMatrixTMatrixD * CalcCorrelationMatrix(DataSet *, const UInt_t classNumber)computes correlation matrix for variables ""theVars"" in tree; ""theType"" defines the required event ""ty...Definition DataSetFactory.cxx:548; TMVA::DataSetFactory::CalcCovarianceMatrixTMatrixD * CalcCovarianceMatrix(DataSet *, const UInt_t classNumber)compute covariance matrixDefinition DataSetFactory.cxx:579; TMVA::DataSetFactory::EventVectorstd::vector< Event * > EventVectorDefinition DataSetFactory.h:118; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::IncrementDefinition DataSetFactory.h:85; TMVA::Increment::IncrementIncrement(T start)Definition DataSetFactory.h:88; TMVA::Increment::operator()T operator()()Definition DataSetFactory.h:89; TMVA::Increment::valueT valueDefinition DataSetFactory.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::TreeInfoDefinition DataInputHandler.h:52; TMVA::nu",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:16805,Modifiability,variab,variable,16805,"the required event ""ty...Definition DataSetFactory.cxx:548; TMVA::DataSetFactory::CalcCovarianceMatrixTMatrixD * CalcCovarianceMatrix(DataSet *, const UInt_t classNumber)compute covariance matrixDefinition DataSetFactory.cxx:579; TMVA::DataSetFactory::EventVectorstd::vector< Event * > EventVectorDefinition DataSetFactory.h:118; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetClass that contains all the data information.Definition DataSet.h:58; TMVA::IncrementDefinition DataSetFactory.h:85; TMVA::Increment::IncrementIncrement(T start)Definition DataSetFactory.h:88; TMVA::Increment::operator()T operator()()Definition DataSetFactory.h:89; TMVA::Increment::valueT valueDefinition DataSetFactory.h:86; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::TreeInfoDefinition DataInputHandler.h:52; TMVA::null_tDefinition DataSetFactory.h:98; TMVA::null_t::operator()F operator()(const F &argF) constDefinition DataSetFactory.h:103; TMVA::null_t::argument_typeF argument_typeDefinition DataSetFactory.h:102; TMatrixT< Double_t >; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; double; int; unsigned int; F#define F(x, y, z); TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::DeleteFunctorDeleteFunctor_t< const T > DeleteFunctor()Definition DataSetFactory.h:78; TMVA::nullnull_t< F > null()Definition DataSetFactory.h:110; TMVA::DeleteFunctor_tDefinition DataSetFactory.h:70; TMVA::DeleteFunctor_t::operator()DeleteFunctor_t & operator()(const T *p)Definition DataSetFactory.h:71; Types.h. tmvatmvaincTMVADataSetFactory.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:57 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:6965,Safety,avoid,avoid,6965,"; 194 ; 195 // ------------------------; 196 ; 197 // auxiliary functions to compute correlations; 198 TMatrixD* CalcCorrelationMatrix( DataSet*, const UInt_t classNumber );; 199 TMatrixD* CalcCovarianceMatrix ( DataSet*, const UInt_t classNumber );; 200 void CalcMinMax ( DataSet*, DataSetInfo& dsi );; 201 ; 202 // resets branch addresses to current event; 203 void ResetBranchAndEventAddresses( TTree* );; 204 void ResetCurrentTree() { fCurrentTree = nullptr; }; 205 void ChangeToNewTree( TreeInfo&, const DataSetInfo & );; 206 Bool_t CheckTTreeFormula( TTreeFormula* ttf, const TString& expression, Bool_t& hasDollar );; 207 ; 208 // verbosity; 209 Bool_t Verbose() { return fVerbose; }; 210 ; 211 // data members; 212 ; 213 // verbosity; 214 Bool_t fVerbose; ///< Verbosity; 215 TString fVerboseLevel; ///< VerboseLevel; 216 ; 217 // Printing; 218 Bool_t fCorrelations = kFALSE; ///< Whether to print correlations or not; 219 Bool_t fComputeCorrelations = kFALSE; ///< Whether to force computation of correlations or not; 220 ; 221 Bool_t fScaleWithPreselEff; ///< how to deal with requested #events in connection with preselection cuts; 222 ; 223 // the event; 224 TTree* fCurrentTree; ///< the tree, events are currently read from; 225 UInt_t fCurrentEvtIdx; ///< the current event (to avoid reading of the same event); 226 ; 227 // the formulas for reading the original tree; 228 std::vector<TTreeFormula*> fInputFormulas; ///< input variables; 229 std::vector<std::pair<TTreeFormula*, Int_t>> fInputTableFormulas; ///<! input variables expression for arrays; 230 std::vector<TTreeFormula *> fTargetFormulas; ///< targets; 231 std::vector<TTreeFormula*> fCutFormulas; ///< cuts; 232 std::vector<TTreeFormula*> fWeightFormula; ///< weights; 233 std::vector<TTreeFormula*> fSpectatorFormulas; ///< spectators; 234 ; 235 MsgLogger* fLogger; ///<! message logger; 236 MsgLogger& Log() const { return *fLogger; }; 237 public:; 238 ClassDef(DataSetFactory, 2);; 239 };; 240}; 241 ; 242#endif; Event.",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:10902,Safety,avoid,avoid,10902,"tFactory.h:233; TMVA::DataSetFactory::fWeightFormulastd::vector< TTreeFormula * > fWeightFormulaweightsDefinition DataSetFactory.h:232; TMVA::DataSetFactory::fCurrentTreeTTree * fCurrentTreethe tree, events are currently read fromDefinition DataSetFactory.h:224; TMVA::DataSetFactory::VerboseBool_t Verbose()Definition DataSetFactory.h:209; TMVA::DataSetFactory::LogMsgLogger & Log() constDefinition DataSetFactory.h:236; TMVA::DataSetFactory::BuildInitialDataSetDataSet * BuildInitialDataSet(DataSetInfo &, TMVA::DataInputHandler &)if no entries, than create a DataSet with one Event which uses dynamic variables (pointers to variabl...Definition DataSetFactory.cxx:202; TMVA::DataSetFactory::DataSetFactoryDataSetFactory()constructorDefinition DataSetFactory.cxx:93; TMVA::DataSetFactory::EventVectorOfClassesOfTreeTypestd::map< Types::ETreeType, EventVectorOfClasses > EventVectorOfClassesOfTreeTypeDefinition DataSetFactory.h:120; TMVA::DataSetFactory::fCurrentEvtIdxUInt_t fCurrentEvtIdxthe current event (to avoid reading of the same event)Definition DataSetFactory.h:225; TMVA::DataSetFactory::ChangeToNewTreevoid ChangeToNewTree(TreeInfo &, const DataSetInfo &)While the data gets copied into the local training and testing trees, the input tree can change (for ...Definition DataSetFactory.cxx:293; TMVA::DataSetFactory::EventVectorOfTreeTypestd::map< Types::ETreeType, EventVector > EventVectorOfTreeTypeDefinition DataSetFactory.h:121; TMVA::DataSetFactory::fScaleWithPreselEffBool_t fScaleWithPreselEffhow to deal with requested #events in connection with preselection cutsDefinition DataSetFactory.h:221; TMVA::DataSetFactory::fInputTableFormulasstd::vector< std::pair< TTreeFormula *, Int_t > > fInputTableFormulas! input variables expression for arraysDefinition DataSetFactory.h:229; TMVA::DataSetFactory::BuildEventVectorvoid BuildEventVector(DataSetInfo &dsi, DataInputHandler &dataInput, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts)build empty event ve",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:7532,Testability,log,logger,7532,"; 194 ; 195 // ------------------------; 196 ; 197 // auxiliary functions to compute correlations; 198 TMatrixD* CalcCorrelationMatrix( DataSet*, const UInt_t classNumber );; 199 TMatrixD* CalcCovarianceMatrix ( DataSet*, const UInt_t classNumber );; 200 void CalcMinMax ( DataSet*, DataSetInfo& dsi );; 201 ; 202 // resets branch addresses to current event; 203 void ResetBranchAndEventAddresses( TTree* );; 204 void ResetCurrentTree() { fCurrentTree = nullptr; }; 205 void ChangeToNewTree( TreeInfo&, const DataSetInfo & );; 206 Bool_t CheckTTreeFormula( TTreeFormula* ttf, const TString& expression, Bool_t& hasDollar );; 207 ; 208 // verbosity; 209 Bool_t Verbose() { return fVerbose; }; 210 ; 211 // data members; 212 ; 213 // verbosity; 214 Bool_t fVerbose; ///< Verbosity; 215 TString fVerboseLevel; ///< VerboseLevel; 216 ; 217 // Printing; 218 Bool_t fCorrelations = kFALSE; ///< Whether to print correlations or not; 219 Bool_t fComputeCorrelations = kFALSE; ///< Whether to force computation of correlations or not; 220 ; 221 Bool_t fScaleWithPreselEff; ///< how to deal with requested #events in connection with preselection cuts; 222 ; 223 // the event; 224 TTree* fCurrentTree; ///< the tree, events are currently read from; 225 UInt_t fCurrentEvtIdx; ///< the current event (to avoid reading of the same event); 226 ; 227 // the formulas for reading the original tree; 228 std::vector<TTreeFormula*> fInputFormulas; ///< input variables; 229 std::vector<std::pair<TTreeFormula*, Int_t>> fInputTableFormulas; ///<! input variables expression for arrays; 230 std::vector<TTreeFormula *> fTargetFormulas; ///< targets; 231 std::vector<TTreeFormula*> fCutFormulas; ///< cuts; 232 std::vector<TTreeFormula*> fWeightFormula; ///< weights; 233 std::vector<TTreeFormula*> fSpectatorFormulas; ///< spectators; 234 ; 235 MsgLogger* fLogger; ///<! message logger; 236 MsgLogger& Log() const { return *fLogger; }; 237 public:; 238 ClassDef(DataSetFactory, 2);; 239 };; 240}; 241 ; 242#endif; Event.",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:11112,Testability,test,testing,11112,"Tree * fCurrentTreethe tree, events are currently read fromDefinition DataSetFactory.h:224; TMVA::DataSetFactory::VerboseBool_t Verbose()Definition DataSetFactory.h:209; TMVA::DataSetFactory::LogMsgLogger & Log() constDefinition DataSetFactory.h:236; TMVA::DataSetFactory::BuildInitialDataSetDataSet * BuildInitialDataSet(DataSetInfo &, TMVA::DataInputHandler &)if no entries, than create a DataSet with one Event which uses dynamic variables (pointers to variabl...Definition DataSetFactory.cxx:202; TMVA::DataSetFactory::DataSetFactoryDataSetFactory()constructorDefinition DataSetFactory.cxx:93; TMVA::DataSetFactory::EventVectorOfClassesOfTreeTypestd::map< Types::ETreeType, EventVectorOfClasses > EventVectorOfClassesOfTreeTypeDefinition DataSetFactory.h:120; TMVA::DataSetFactory::fCurrentEvtIdxUInt_t fCurrentEvtIdxthe current event (to avoid reading of the same event)Definition DataSetFactory.h:225; TMVA::DataSetFactory::ChangeToNewTreevoid ChangeToNewTree(TreeInfo &, const DataSetInfo &)While the data gets copied into the local training and testing trees, the input tree can change (for ...Definition DataSetFactory.cxx:293; TMVA::DataSetFactory::EventVectorOfTreeTypestd::map< Types::ETreeType, EventVector > EventVectorOfTreeTypeDefinition DataSetFactory.h:121; TMVA::DataSetFactory::fScaleWithPreselEffBool_t fScaleWithPreselEffhow to deal with requested #events in connection with preselection cutsDefinition DataSetFactory.h:221; TMVA::DataSetFactory::fInputTableFormulasstd::vector< std::pair< TTreeFormula *, Int_t > > fInputTableFormulas! input variables expression for arraysDefinition DataSetFactory.h:229; TMVA::DataSetFactory::BuildEventVectorvoid BuildEventVector(DataSetInfo &dsi, DataInputHandler &dataInput, EventVectorOfClassesOfTreeType &eventsmap, EvtStatsPerClass &eventCounts)build empty event vectors distributes events between kTraining/kTesting/kMaxTreeTypeDefinition DataSetFactory.cxx:728; TMVA::DataSetFactory::CreateDataSetDataSet * CreateDataSet(DataSetInfo &,",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/DataSetFactory_8h_source.html:14443,Testability,log,loggerDefinition,14443,"DynamicDataSetDataSet * BuildDynamicDataSet(DataSetInfo &)Definition DataSetFactory.cxx:149; TMVA::DataSetFactory::EvtStatsPerClassstd::vector< EventStats > EvtStatsPerClassDefinition DataSetFactory.h:155; TMVA::DataSetFactory::fVerboseLevelTString fVerboseLevelVerboseLevel.Definition DataSetFactory.h:215; TMVA::DataSetFactory::fTargetFormulasstd::vector< TTreeFormula * > fTargetFormulastargetsDefinition DataSetFactory.h:230; TMVA::DataSetFactory::CheckTTreeFormulaBool_t CheckTTreeFormula(TTreeFormula *ttf, const TString &expression, Bool_t &hasDollar)checks a TTreeFormula for problemsDefinition DataSetFactory.cxx:251; TMVA::DataSetFactory::fCutFormulasstd::vector< TTreeFormula * > fCutFormulascutsDefinition DataSetFactory.h:231; TMVA::DataSetFactory::ResetBranchAndEventAddressesvoid ResetBranchAndEventAddresses(TTree *); TMVA::DataSetFactory::fCorrelationsBool_t fCorrelationsWhether to print correlations or not.Definition DataSetFactory.h:218; TMVA::DataSetFactory::fLoggerMsgLogger * fLogger! message loggerDefinition DataSetFactory.h:235; TMVA::DataSetFactory::ValuePerClassOfTreeTypestd::map< Types::ETreeType, ValuePerClass > ValuePerClassOfTreeTypeDefinition DataSetFactory.h:124; TMVA::DataSetFactory::RenormEventsvoid RenormEvents(DataSetInfo &dsi, EventVectorOfClassesOfTreeType &eventsmap, const EvtStatsPerClass &eventCounts, const TString &normMode)renormalisation of the TRAINING event weightsDefinition DataSetFactory.cxx:1488; TMVA::DataSetFactory::fComputeCorrelationsBool_t fComputeCorrelationsWhether to force computation of correlations or not.Definition DataSetFactory.h:219; TMVA::DataSetFactory::ResetCurrentTreevoid ResetCurrentTree()Definition DataSetFactory.h:204; TMVA::DataSetFactory::CalcCorrelationMatrixTMatrixD * CalcCorrelationMatrix(DataSet *, const UInt_t classNumber)computes correlation matrix for variables ""theVars"" in tree; ""theType"" defines the required event ""ty...Definition DataSetFactory.cxx:548; TMVA::DataSetFactory::CalcCovarianceMatrixTMat",MatchSource.WIKI,doc/master/DataSetFactory_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DataSetFactory_8h_source.html
https://root.cern/doc/master/demos_8C.html:2895,Modifiability,config,configurable,2895,"mple of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; AuthorRene Brun ; Definition in file demos.C. tutorialsdemos.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxyg",MatchSource.WIKI,doc/master/demos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demos_8C.html
https://root.cern/doc/master/demos_8C.html:2933,Security,access,access,2933,"mple of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; AuthorRene Brun ; Definition in file demos.C. tutorialsdemos.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxyg",MatchSource.WIKI,doc/master/demos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demos_8C.html
https://root.cern/doc/master/demos_8C.html:2422,Testability,benchmark,benchmarks,2422,"Options"");; bar->AddButton(""fillrandom"", "".x hist/fillrandom.C"", ""Histograms with Random Numbers from a Function"");; bar->AddButton(""fit1"", "".x fit/fit1.C"", ""A Simple Fitting Example"");; bar->AddButton(""multifit"", "".x fit/multifit.C"", ""Fitting in Subranges of Histograms"");; bar->AddButton(""h1ReadAndDraw"", "".x hist/h1ReadAndDraw.C"", ""Drawing Options for 1D Histograms"");; bar->AddButton(""graph"", "".x graphs/graph.C"", ""Example of a Simple Graph"");; bar->AddButton(""gerrors"", "".x graphs/gerrors.C"", ""Example of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() ",MatchSource.WIKI,doc/master/demos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demos_8C.html
https://root.cern/doc/master/demos_8C.html:2446,Testability,benchmark,benchmarks,2446,".x hist/fillrandom.C"", ""Histograms with Random Numbers from a Function"");; bar->AddButton(""fit1"", "".x fit/fit1.C"", ""A Simple Fitting Example"");; bar->AddButton(""multifit"", "".x fit/multifit.C"", ""Fitting in Subranges of Histograms"");; bar->AddButton(""h1ReadAndDraw"", "".x hist/h1ReadAndDraw.C"", ""Drawing Options for 1D Histograms"");; bar->AddButton(""graph"", "".x graphs/graph.C"", ""Example of a Simple Graph"");; bar->AddButton(""gerrors"", "".x graphs/gerrors.C"", ""Example of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::F",MatchSource.WIKI,doc/master/demos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demos_8C.html
https://root.cern/doc/master/demos_8C.html:2475,Testability,test,tests,2475,"from a Function"");; bar->AddButton(""fit1"", "".x fit/fit1.C"", ""A Simple Fitting Example"");; bar->AddButton(""multifit"", "".x fit/multifit.C"", ""Fitting in Subranges of Histograms"");; bar->AddButton(""h1ReadAndDraw"", "".x hist/h1ReadAndDraw.C"", ""Drawing Options for 1D Histograms"");; bar->AddButton(""graph"", "".x graphs/graph.C"", ""Example of a Simple Graph"");; bar->AddButton(""gerrors"", "".x graphs/gerrors.C"", ""Example of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static me",MatchSource.WIKI,doc/master/demos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demos_8C.html
https://root.cern/doc/master/demos_8C.html:2497,Testability,benchmark,benchmark,2497,"from a Function"");; bar->AddButton(""fit1"", "".x fit/fit1.C"", ""A Simple Fitting Example"");; bar->AddButton(""multifit"", "".x fit/multifit.C"", ""Fitting in Subranges of Histograms"");; bar->AddButton(""h1ReadAndDraw"", "".x hist/h1ReadAndDraw.C"", ""Drawing Options for 1D Histograms"");; bar->AddButton(""graph"", "".x graphs/graph.C"", ""Example of a Simple Graph"");; bar->AddButton(""gerrors"", "".x graphs/gerrors.C"", ""Example of a Graph with Error Bars"");; bar->AddButton(""tornado"", "".x graphics/tornado.C"", ""Examples of 3-D PolyMarkers"");; bar->AddButton(""geometry"", "".x geom/rootgeom.C"", ""Example of TGeoManager drawing"");; bar->AddButton(""file"", "".x io/file.C"", ""The ROOT File Format"");; bar->AddButton(""fildir"", "".x io/fildir.C"", ""The ROOT File, Directories and Keys"");; bar->AddButton(""tree"", "".x tree/tree.C"", ""The Tree Data Structure"");; bar->AddButton(""ntuple1"", "".x tree/ntuple1.C"", ""Ntuples and Selections"");; bar->AddButton(""benchmarks"", "".x legacy/benchmarks.C"", ""Runs several tests and produces an benchmark report"");; bar->AddButton(""rootmarks"", "".x legacy/rootmarks.C"", ""Prints an Estimated ROOTMARKS for Your Machine"");; bar->SetButtonWidth(90);; bar->Show();; gROOT->SaveContext();; }; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::SetButtonWidthvoid SetButtonWidth(UInt_t width)Sets the width in pixels for control bar button.Definition TControlBar.cxx:277; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static me",MatchSource.WIKI,doc/master/demos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demos_8C.html
https://root.cern/doc/master/demo_8py.html:4195,Availability,alive,alive,4195,"root/file.py') + '"" );', 'The ROOT File Format' ); bar.AddButton( 'fildir', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/fildir.py') + '"" );', 'The ROOT File, Directories and Keys' ); bar.AddButton( 'tree', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/tree.py') + '"" );', 'The Tree Data Structure' ); bar.AddButton( 'ntuple1', r'TPython::Exec( ""' + to_run.format('ntuple1.py') + '"" );', 'Ntuples and Selections' ); bar.AddButton( 'rootmarks', r'TPython::Exec( ""' + to_run.format('../legacy/pyroot/rootmarks.py') +'"" );', 'Prints an Estimated ROOTMARKS for Your Machine' ); bar.AddSeparator() # not implemented; bar.AddButton( 'make ntuple', r'TPython::Exec( ""' + to_run.format('mrt.py') + '"" );', 'Convert a text file to an ntuple' ); ; bar.Show(); ; ROOT.gROOT.SaveContext(); ; ; ## wait for input to keep the GUI (which lives on a ROOT event dispatcher) alive; if __name__ == '__main__':; rep = ''; while not rep in [ 'q', 'Q' ]:; rep = input( 'enter ""q"" to quit: ' ); if 1 < len(rep):; rep = rep[0]; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t A",MatchSource.WIKI,doc/master/demo_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/demo_8py.html
https://root.cern/doc/master/deprecated.html:4750,Energy Efficiency,reduce,reduce,4750,"emoved in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FormatFrameForLikelihood (RooPlot *frame, std::string xTitle=std::string(""#sigma / #sigma_{SM}""), std::string yTitle=std::string(""-log likelihood"")) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::Measurement::SetExportOnly (bool ExportOnly) R__DEPRECATED(6; Will be removed in ROOT 6.36. ExportOnly() == true is the default since ROOT 6.34 and it can't be disabled anymore in 6.36. ; Member RooStats::MarkovChain::GetAsDataHist (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet), and then obtaining its binned clone. ; Will be removed in ROOT 6.36. . Member RooStats::MarkovChain::GetAsDataSet (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. ; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet) . Member RooTemplateProxy< T >::lvptr (const LValue_t *) const; This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. ; Member RooTemplateProxy< T >::R__DEPRECATED (6, 36, ""Use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ow",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:5304,Energy Efficiency,reduce,reduce,5304," default since ROOT 6.34 and it can't be disabled anymore in 6.36. ; Member RooStats::MarkovChain::GetAsDataHist (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet), and then obtaining its binned clone. ; Will be removed in ROOT 6.36. . Member RooStats::MarkovChain::GetAsDataSet (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. ; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet) . Member RooTemplateProxy< T >::lvptr (const LValue_t *) const; This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. ; Member RooTemplateProxy< T >::R__DEPRECATED (6, 36, ""Use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ownership with RooTemplateProxy::putOwnedArg()."") RooTemplateProxy(const char *theName; Kept for backwards compatibility and will be removed in ROOT 6.36. Either use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool), and transfer the ownership with RooTemplateProxy::putOwnedArg(), or use RooTemplateProxy(const char*, const char*, RooAbsArg*, std::unique_ptr<T>, bool, bool) if you want the proxy to own the argument. depending if you want to transfer ownership or not. ; Member TFitter::Chisquare (Int_t npar, Double_t ",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:517,Integrability,depend,dependentOverlaps,517,". ROOT: Deprecated List. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Deprecated List. Member ClassDefT (name, id); ; Member ClassImp (name); ; Module proof ; We keep PROOF for those who still need it for legacy use cases. PROOF is not developed anymore and receiving only limited support. ROOT has since a few years moved to RDataFrame and related products as multi-core/multi-processing engines. ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset; Use observableOverlaps() ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const; Use recursiveCheckObservables() ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const; Use checkObservables() ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList; Use observableOverlaps() ; Member RooAbsCategory::defineType (const char *label); Use defineState(const std::string& label) ; Member RooAbsCategory::defineType (const char *label, int index); Use defineState(const std::string& label, value_type index) ; Member RooAbsCategory::defineTypeUnchecked (const char *label, value_type index); Use defineStateUnchecked(const std::string& label, value_type index) ; Member RooAbsCategory::lookupType (const RooCatType &type, bool printError=false) const; RooCatType is not used, any more. This function will create one and let it leak. Use lookupIndex() (preferred) or lookupName() instead. ; Member RooAbsCategory::lookupType (value_type index, bool printError=false) const; RooCatType is not used, any more. This function will create one and let it leak. Use lookupIndex() (preferred) or lookupName() instead. ; Member RooAbsCategory::lookupType (const char *label, bool printError=false) const; RooCatType is not used, ",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:994,Integrability,depend,dependentOverlaps,994,"eveloped anymore and receiving only limited support. ROOT has since a few years moved to RDataFrame and related products as multi-core/multi-processing engines. ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset; Use observableOverlaps() ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const; Use recursiveCheckObservables() ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const; Use checkObservables() ; Member RooAbsArg::R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList; Use observableOverlaps() ; Member RooAbsCategory::defineType (const char *label); Use defineState(const std::string& label) ; Member RooAbsCategory::defineType (const char *label, int index); Use defineState(const std::string& label, value_type index) ; Member RooAbsCategory::defineTypeUnchecked (const char *label, value_type index); Use defineStateUnchecked(const std::string& label, value_type index) ; Member RooAbsCategory::lookupType (const RooCatType &type, bool printError=false) const; RooCatType is not used, any more. This function will create one and let it leak. Use lookupIndex() (preferred) or lookupName() instead. ; Member RooAbsCategory::lookupType (value_type index, bool printError=false) const; RooCatType is not used, any more. This function will create one and let it leak. Use lookupIndex() (preferred) or lookupName() instead. ; Member RooAbsCategory::lookupType (const char *label, bool printError=false) const; RooCatType is not used, any more. This function will create one and let it leak. Use lookupIndex() (preferred) or lookupName() instead. ; Member RooAbsCategory::typeIterator () const; Use begin() and end() instead. ; Class RooAbsCategoryLegacyIterator ; Legacy class to iterate through legacy Roo",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:6217,Integrability,depend,depending,6217,"Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet) . Member RooTemplateProxy< T >::lvptr (const LValue_t *) const; This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or RooAbsCategoryLValue (+derived types), as arg() will always return the correct type. ; Member RooTemplateProxy< T >::R__DEPRECATED (6, 36, ""Use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool) and transfer the ownership with RooTemplateProxy::putOwnedArg()."") RooTemplateProxy(const char *theName; Kept for backwards compatibility and will be removed in ROOT 6.36. Either use RooTemplateProxy(const char*, const char*, RooAbsArg*, bool, bool), and transfer the ownership with RooTemplateProxy::putOwnedArg(), or use RooTemplateProxy(const char*, const char*, RooAbsArg*, std::unique_ptr<T>, bool, bool) if you want the proxy to own the argument. depending if you want to transfer ownership or not. ; Member TFitter::Chisquare (Int_t npar, Double_t *params) const override; Use ROOT::Fit::Chisquare class instead. ; Class TGeoTrack ; Use of TGeoTrack is deprecated. For the event display please switch to TEve (using TEveTracks or TEvePointSet to display tracks specifically) or to REve. ; Class THtml ; We keep THtml for those who still need it for legacy use cases. ROOT has since several years moved to doxygen as documentation generator. THtml is not developed nor supported anymore; please migrate to doxygen instead. ; Member THttpCallArg::SetPostData (void *data, Long_t length, Bool_t make_copy=kFALSE); Use signature with std::string ; Member THttpServer::ReadFileContent (const char *filename, Int_t &len); ; Member TPython::Eval (const char *expr) R__DEPRECATED(6; Use TPython::Exec() with an std::any output parameter instead. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:3130,Safety,safe,safer,3130,"ex() (preferred) or lookupName() instead. ; Member RooAbsCategory::typeIterator () const; Use begin() and end() instead. ; Class RooAbsCategoryLegacyIterator ; Legacy class to iterate through legacy RooAbsCategory states. Use RooAbsCategory::begin(), RooAbsCategory::end() or range-based for loops instead. Member RooAbsData::statOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Classing parameter formatting options, provided for backward compatibility ; Member RooCategoryProxy ; Use RooTemplateProxy<RooAbsCategory> or more appropriate template parameters. ; Member RooDataHist::binVolume () const; Use binVolume(std::size_t) const. ; Member RooDataHist::calcTreeIndex () const; Use calcTreeIndex(const RooArgSet&,bool) const. ; Member RooDataHist::set (double wgt, double wgtErr=-1); Use set(std::size_t,double,double) ; Member RooDataHist::weight () const override; Use the safer weight(std::size_t) const. ; Member RooDataHist::weightSquared () const override; Use the safer weightSquared(std::size_t) const. ; Member RooRealProxy ; Use RooTemplateProxy<RooAbsReal> or more appropriate template parameters. ; Member RooStats::HistFactory::FitModel (RooWorkspace *, std::string data_name=""obsData"") R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FitModelAndPlot (const std::string &measurementName, const std::string &fileNamePrefix, RooWorkspace &, std::string, std::string, TFile &, std::ostream &) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FormatFrameForLikelihood (RooPlot *frame, std::string xTitle=std::string(""#sigma / #sigma_{SM}""), std::string yTitle=std::string(""-log likelihood"")) R__DEPRECATED(6; W",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:3226,Safety,safe,safer,3226,"yLegacyIterator ; Legacy class to iterate through legacy RooAbsCategory states. Use RooAbsCategory::begin(), RooAbsCategory::end() or range-based for loops instead. Member RooAbsData::statOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}); Classing parameter formatting options, provided for backward compatibility ; Member RooCategoryProxy ; Use RooTemplateProxy<RooAbsCategory> or more appropriate template parameters. ; Member RooDataHist::binVolume () const; Use binVolume(std::size_t) const. ; Member RooDataHist::calcTreeIndex () const; Use calcTreeIndex(const RooArgSet&,bool) const. ; Member RooDataHist::set (double wgt, double wgtErr=-1); Use set(std::size_t,double,double) ; Member RooDataHist::weight () const override; Use the safer weight(std::size_t) const. ; Member RooDataHist::weightSquared () const override; Use the safer weightSquared(std::size_t) const. ; Member RooRealProxy ; Use RooTemplateProxy<RooAbsReal> or more appropriate template parameters. ; Member RooStats::HistFactory::FitModel (RooWorkspace *, std::string data_name=""obsData"") R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FitModelAndPlot (const std::string &measurementName, const std::string &fileNamePrefix, RooWorkspace &, std::string, std::string, TFile &, std::ostream &) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FormatFrameForLikelihood (RooPlot *frame, std::string xTitle=std::string(""#sigma / #sigma_{SM}""), std::string yTitle=std::string(""-log likelihood"")) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::Measurement::S",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/deprecated.html:4035,Testability,log,log,4035,"Member RooDataHist::set (double wgt, double wgtErr=-1); Use set(std::size_t,double,double) ; Member RooDataHist::weight () const override; Use the safer weight(std::size_t) const. ; Member RooDataHist::weightSquared () const override; Use the safer weightSquared(std::size_t) const. ; Member RooRealProxy ; Use RooTemplateProxy<RooAbsReal> or more appropriate template parameters. ; Member RooStats::HistFactory::FitModel (RooWorkspace *, std::string data_name=""obsData"") R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FitModelAndPlot (const std::string &measurementName, const std::string &fileNamePrefix, RooWorkspace &, std::string, std::string, TFile &, std::ostream &) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::FormatFrameForLikelihood (RooPlot *frame, std::string xTitle=std::string(""#sigma / #sigma_{SM}""), std::string yTitle=std::string(""-log likelihood"")) R__DEPRECATED(6; Will be removed in ROOT 6.36. Please write your own plotting code inspired by the hf001 tutorial. ; Member RooStats::HistFactory::Measurement::SetExportOnly (bool ExportOnly) R__DEPRECATED(6; Will be removed in ROOT 6.36. ExportOnly() == true is the default since ROOT 6.34 and it can't be disabled anymore in 6.36. ; Member RooStats::MarkovChain::GetAsDataHist (const RooCmdArg &arg1, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}) const R__DEPRECATED(6; Will be removed in ROOT 6.36. Please implement this functionality by calling RooAbsData::reduce on the Markov Chain's RooDataSet* (obtained using MarkovChain::GetAsConstDataSet), and then obtaining its binned clone. ; Will be removed in ROOT 6.36. . Member RooStats::MarkovChain::GetAsDataSet (const RooCmdArg &arg1, const ",MatchSource.WIKI,doc/master/deprecated.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/deprecated.html
https://root.cern/doc/master/df000__simple_8C.html:1021,Integrability,interface,interface,1021,". ROOT: tutorials/dataframe/df000_simple.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df000_simple.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Simple RDataFrame example in C++. ; This tutorial shows a minimal example of RDataFrame. It starts without input data, generates a new column x with random numbers, and finally draws a histogram for x.; ; void df000_simple(); {; // Create a data frame with 100 rows; ROOT::RDataFrame rdf(100);; ; // Define a new column `x` that contains random numbers; auto rdf_x = rdf.Define(""x"", [](){ return gRandom->Rndm(); });; ; // Create a histogram from `x`; auto h = rdf_x.Histo1D(""x"");; ; // At the end of this function, the histogram pointed to by `h` will be deleted.; // Draw a copy of the histogram object instead:; h->DrawClone();; }; h#define h(i)Definition RSha256.hxx:106; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; df000_simpleDefinition df000_simple.py:1; ; DateSeptember 2021 ; AuthorEnric Tejedor (CERN) ; Definition in file df000_simple.C. tutorialsdataframedf000_simple.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df000__simple_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df000__simple_8C.html
https://root.cern/doc/master/df000__simple_8py.html:770,Integrability,interface,interface,770,". ROOT: tutorials/dataframe/df000_simple.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df000_simple.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Simple RDataFrame example in Python. ; This tutorial shows a minimal example of RDataFrame. It starts without input data, generates a new column x with random numbers, and finally draws a histogram for x.; ; import ROOT; ; # Create a data frame with 100 rows; rdf = ROOT.RDataFrame(100); ; # Define a new column `x` that contains random numbers; rdf_x = rdf.Define(""x"", ""gRandom->Rndm()""); ; # Create a histogram from `x` and draw it; h = rdf_x.Histo1D(""x""); h.Draw(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateSeptember 2021 ; AuthorEnric Tejedor (CERN) ; Definition in file df000_simple.py. tutorialsdataframedf000_simple.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df000__simple_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df000__simple_8py.html
https://root.cern/doc/master/df001__introduction_8C.html:4898,Deployability,pipeline,pipelines,4898,"tr());; std::cout << ""The type of b1Vec is "" << b1VecCl->GetName() << std::endl;; ; // ### `Histo1D` action; // The `Histo1D` action allows to fill an histogram. It returns a TH1D filled; // with values of the column that passed the filters. For the most common; // types, the type of the values stored in the column is automatically; // guessed.; auto hist = d.Filter(cutb1).Histo1D();; std::cout << ""Filled h "" << hist->GetEntries() << "" times, mean: "" << hist->GetMean() << std::endl;; ; // ### `Foreach` action; // The most generic action of all: an operation is applied to all entries.; // In this case we fill a histogram. In some sense this is a violation of a; // purely functional paradigm - C++ allows to do that.; TH1F h(""h"", ""h"", 12, -1, 11);; d.Filter([](int b2) { return b2 % 2 == 0; }, {""b2""}).Foreach([&h](double b1) { h.Fill(b1); });; ; std::cout << ""Filled h with "" << h.GetEntries() << "" entries"" << std::endl;; ; // ## Express your chain of operations with clarity!; // We are discussing an example here but it is not hard to imagine much more; // complex pipelines of actions acting on data. Those might require code; // which is well organised, for example allowing to conditionally add filters; // or again to clearly separate filters and actions without the need of; // writing the entire pipeline on one line. This can be easily achieved.; // We'll show this by re-working the `Count` example:; auto cutb1_result = d.Filter(cutb1);; auto cutb1b2_result = d.Filter(cutb1b2, {""b2"", ""b1""});; auto cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2, {""b2"", ""b1""});; // Now we want to count:; auto evts_cutb1_result = cutb1_result.Count();; auto evts_cutb1b2_result = cutb1b2_result.Count();; auto evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count();; ; std::cout << ""Events passing cutb1: "" << *evts_cutb1_result << std::endl; << ""Events passing cutb1b2: "" << *evts_cutb1b2_result << std::endl; << ""Events passing both: "" << *evts_cutb1_cutb1b2_result << std::endl;; ; // ## ",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:5135,Deployability,pipeline,pipeline,5135,"assed the filters. For the most common; // types, the type of the values stored in the column is automatically; // guessed.; auto hist = d.Filter(cutb1).Histo1D();; std::cout << ""Filled h "" << hist->GetEntries() << "" times, mean: "" << hist->GetMean() << std::endl;; ; // ### `Foreach` action; // The most generic action of all: an operation is applied to all entries.; // In this case we fill a histogram. In some sense this is a violation of a; // purely functional paradigm - C++ allows to do that.; TH1F h(""h"", ""h"", 12, -1, 11);; d.Filter([](int b2) { return b2 % 2 == 0; }, {""b2""}).Foreach([&h](double b1) { h.Fill(b1); });; ; std::cout << ""Filled h with "" << h.GetEntries() << "" entries"" << std::endl;; ; // ## Express your chain of operations with clarity!; // We are discussing an example here but it is not hard to imagine much more; // complex pipelines of actions acting on data. Those might require code; // which is well organised, for example allowing to conditionally add filters; // or again to clearly separate filters and actions without the need of; // writing the entire pipeline on one line. This can be easily achieved.; // We'll show this by re-working the `Count` example:; auto cutb1_result = d.Filter(cutb1);; auto cutb1b2_result = d.Filter(cutb1b2, {""b2"", ""b1""});; auto cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2, {""b2"", ""b1""});; // Now we want to count:; auto evts_cutb1_result = cutb1_result.Count();; auto evts_cutb1b2_result = cutb1b2_result.Count();; auto evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count();; ; std::cout << ""Events passing cutb1: "" << *evts_cutb1_result << std::endl; << ""Events passing cutb1b2: "" << *evts_cutb1b2_result << std::endl; << ""Events passing both: "" << *evts_cutb1_cutb1b2_result << std::endl;; ; // ## Calculating quantities starting from existing columns; // Often, operations need to be carried out on quantities calculated starting; // from the ones present in the columns. We'll create in this example a third; // column",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:1585,Integrability,depend,depending,1585,"ine(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << *entries1 << "" entries passed all filters"" << std::endl;; ; // Filters can be expressed as strings. The content must be C++ code. The; // name of the variables must be the name of the branches. The code is; // just-in-time compiled.; auto entries",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:1781,Integrability,wrap,wrapped,1781,"entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << *entries1 << "" entries passed all filters"" << std::endl;; ; // Filters can be expressed as strings. The content must be C++ code. The; // name of the variables must be the name of the branches. The code is; // just-in-time compiled.; auto entries2 = d.Filter(""b1 < 5."").Count();; std::cout << *entries2 << "" entries passed the string filter"" << std::endl;; ; // ### `Min`",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:7913,Integrability,interface,interface,7913,"; // code. The name of the variables must be the name of the branches. The code; // is just-in-time compiled.; auto entries_sum2 = d.Define(""sum2"", ""b1 + b2"").Filter(""sum2 > 4.2"").Count();; std::cout << *entries_sum2 << std::endl;; ; // It is possible at any moment to read the entry number and the processing; // slot number. The latter may change when implicit multithreading is active.; // The special columns which provide the entry number and the slot index are; // called ""rdfentry_"" and ""rdfslot_"" respectively. Their types are an unsigned; // 64 bit integer and an unsigned integer.; auto printEntrySlot = [](ULong64_t iEntry, unsigned int slot) {; std::cout << ""Entry: "" << iEntry << "" Slot: "" << slot << std::endl;; };; d.Foreach(printEntrySlot, {""rdfentry_"", ""rdfslot_""});; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; h#define h(i)Definition RSha256.hxx:106; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; double; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Create a new collection with the elements passing the filter expressed by the predicate.Definition RVec.hxx:2182; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; df001_introductionDefinition df001_introduction.py:1; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; 2 entries passed all filters; 5 entries passed the string filter; The mean is always included between the min and the max: 1 <= 2 <= 3; Selected b1 entries; 0 1 2 3 4 ; The type of b1Vec is vector<double>; Filled h 5 times, mean: 2; Filled h with 5 entries; Events passing cutb1: 5; Events passing cutb1b2: 2; Events passing both: 2; 8; 8; Entry: 0 Slot: 0; Entry: 1 Slot: 0; Entry: 2 Slot: 0; Entry: 3 Slot: 0; Entry: 4 Slot: 0; Entry: 5 Slot: 0; Entry: 6 ",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:2550,Modifiability,variab,variables,2550,"ctions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << *entries1 << "" entries passed all filters"" << std::endl;; ; // Filters can be expressed as strings. The content must be C++ code. The; // name of the variables must be the name of the branches. The code is; // just-in-time compiled.; auto entries2 = d.Filter(""b1 < 5."").Count();; std::cout << *entries2 << "" entries passed the string filter"" << std::endl;; ; // ### `Min`, `Max` and `Mean` actions; // These actions allow to retrieve statistical information about the entries; // passing the cuts, if any.; auto b1b2_cut = d.Filter(cutb1b2, {""b2"", ""b1""});; auto minVal = b1b2_cut.Min();; auto maxVal = b1b2_cut.Max();; auto meanVal = b1b2_cut.Mean();; auto nonDefmeanVal = b1b2_cut.Mean(""b2""); // <- Column is not the default; std::cout << ""The mean is always included between the min and the max: "" << *minVal << "" <= "" << *meanVal; << "" <= "" << *maxVal << std::endl;; ; // ### `Take` action; // The `Take` action allows to retrieve all values of the variable stored in a; // particular column that passed filters we specified. The values are stored; // in a vector by default, but other collections can be chosen.; auto b1_cut = d.Filter(cutb1);; auto b1Vec =",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:3352,Modifiability,variab,variable,3352,"specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << *entries1 << "" entries passed all filters"" << std::endl;; ; // Filters can be expressed as strings. The content must be C++ code. The; // name of the variables must be the name of the branches. The code is; // just-in-time compiled.; auto entries2 = d.Filter(""b1 < 5."").Count();; std::cout << *entries2 << "" entries passed the string filter"" << std::endl;; ; // ### `Min`, `Max` and `Mean` actions; // These actions allow to retrieve statistical information about the entries; // passing the cuts, if any.; auto b1b2_cut = d.Filter(cutb1b2, {""b2"", ""b1""});; auto minVal = b1b2_cut.Min();; auto maxVal = b1b2_cut.Max();; auto meanVal = b1b2_cut.Mean();; auto nonDefmeanVal = b1b2_cut.Mean(""b2""); // <- Column is not the default; std::cout << ""The mean is always included between the min and the max: "" << *minVal << "" <= "" << *meanVal; << "" <= "" << *maxVal << std::endl;; ; // ### `Take` action; // The `Take` action allows to retrieve all values of the variable stored in a; // particular column that passed filters we specified. The values are stored; // in a vector by default, but other collections can be chosen.; auto b1_cut = d.Filter(cutb1);; auto b1Vec = b1_cut.Take<double>();; auto b1List = b1_cut.Take<double, std::list<double>>();; ; std::cout << ""Selected b1 entries"" << std::endl;; for (auto b1_entry : *b1List); std::cout << b1_entry << "" "";; std::cout << std::endl;; auto b1VecCl = ROOT::GetClass(b1Vec.GetPtr());; std::cout << ""The type of b1Vec is "" << b1VecCl->GetName() << std::endl;; ; // ### `Histo1D` action; // The `Histo1D` action allows to fill an histogram. It returns a TH1D filled; // with values of the column that passed the filters. For the most common; // types, the type of the values stored in the column is automatically; // guessed.; auto hist = d.Filter(cutb1).Histo1D();; std::cout << ""Filled h "" << hist->GetEntries(",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:6930,Modifiability,variab,variables,6930,"ted starting; // from the ones present in the columns. We'll create in this example a third; // column, the values of which are the sum of the *b1* and *b2* ones, entry by; // entry. The way in which the new quantity is defined is via a callable.; // It is important to note two aspects at this point:; // - The value is created on the fly only if the entry passed the existing; // filters.; // - The newly created column behaves as the one present on the file on disk.; // - The operation creates a new value, without modifying anything. De facto,; // this is like having a general container at disposal able to accommodate; // any value of any type.; // Let's dive in an example:; auto entries_sum = d.Define(""sum"", [](double b1, int b2) { return b2 + b1; }, {""b1"", ""b2""}); .Filter([](double sum) { return sum > 4.2; }, {""sum""}); .Count();; std::cout << *entries_sum << std::endl;; ; // Additional columns can be expressed as strings. The content must be C++; // code. The name of the variables must be the name of the branches. The code; // is just-in-time compiled.; auto entries_sum2 = d.Define(""sum2"", ""b1 + b2"").Filter(""sum2 > 4.2"").Count();; std::cout << *entries_sum2 << std::endl;; ; // It is possible at any moment to read the entry number and the processing; // slot number. The latter may change when implicit multithreading is active.; // The special columns which provide the entry number and the slot index are; // called ""rdfentry_"" and ""rdfslot_"" respectively. Their types are an unsigned; // 64 bit integer and an unsigned integer.; auto printEntrySlot = [](ULong64_t iEntry, unsigned int slot) {; std::cout << ""Entry: "" << iEntry << "" Slot: "" << slot << std::endl;; };; d.Foreach(printEntrySlot, {""rdfentry_"", ""rdfslot_""});; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; h#define h(i)Definition RSha256.hxx:106; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:1452,Performance,perform,performed,1452,"wing a functional-chain like approach.; ; // ## Preparation; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(10);; d.Define(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << ",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:1685,Security,access,accessed,1685,"ine(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = [](int b2, double b1) { return b2 % 2 && b1 < 4.; };; ; // ### `Count` action; // The `Count` allows to retrieve the number of the entries that passed the; // filters. Here, we show how the automatic selection of the column kicks; // in in case the user specifies none.; auto entries1 = d.Filter(cutb1) // <- no column name specified here!; .Filter(cutb1b2, {""b2"", ""b1""}); .Count();; ; std::cout << *entries1 << "" entries passed all filters"" << std::endl;; ; // Filters can be expressed as strings. The content must be C++ code. The; // name of the variables must be the name of the branches. The code is; // just-in-time compiled.; auto entries",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:500,Testability,test,test,500,". ROOT: tutorials/dataframe/df001_introduction.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df001_introduction.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Basic RDataFrame usage. ; This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; // ## Preparation; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(10);; d.Define(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = ",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:467,Usability,simpl,simple,467,". ROOT: tutorials/dataframe/df001_introduction.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df001_introduction.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Basic RDataFrame usage. ; This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; // ## Preparation; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(10);; d.Define(""b1"", [](ULong64_t entry) -> double { return entry; }, {""rdfentry_""}); .Define(""b2"", [](ULong64_t entry) -> int { return entry * entry; }, {""rdfentry_""}); .Snapshot(treeName, fileName);; }; ; int df001_introduction(); {; ; // We prepare an input tree to run on; auto fileName = ""df001_introduction.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; // We select a default column, a *branch* to adopt ROOT jargon, which will; // be looked at if none is specified by the user when dealing with filters; // and actions.; ROOT::RDataFrame d(treeName, fileName, {""b1""});; ; // ## Operations on the dataframe; // We now review some *actions* which can be performed on the data frame.; // Actions can be divided into instant actions (e. g. Foreach()) and lazy; // actions (e. g. Count()), depending on whether they trigger the event; // loop immediately or only when one of the results is accessed for the; // first time. Actions that return ""something"" either return their result; // wrapped in a RResultPtr or in a RDataFrame.; // But first of all, let us define our cut-flow with two lambda; // functions. We can use free functions too.; auto cutb1 = [](double b1) { return b1 < 5.; };; auto cutb1b2 = ",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8C.html:5055,Usability,clear,clearly,5055,"assed the filters. For the most common; // types, the type of the values stored in the column is automatically; // guessed.; auto hist = d.Filter(cutb1).Histo1D();; std::cout << ""Filled h "" << hist->GetEntries() << "" times, mean: "" << hist->GetMean() << std::endl;; ; // ### `Foreach` action; // The most generic action of all: an operation is applied to all entries.; // In this case we fill a histogram. In some sense this is a violation of a; // purely functional paradigm - C++ allows to do that.; TH1F h(""h"", ""h"", 12, -1, 11);; d.Filter([](int b2) { return b2 % 2 == 0; }, {""b2""}).Foreach([&h](double b1) { h.Fill(b1); });; ; std::cout << ""Filled h with "" << h.GetEntries() << "" entries"" << std::endl;; ; // ## Express your chain of operations with clarity!; // We are discussing an example here but it is not hard to imagine much more; // complex pipelines of actions acting on data. Those might require code; // which is well organised, for example allowing to conditionally add filters; // or again to clearly separate filters and actions without the need of; // writing the entire pipeline on one line. This can be easily achieved.; // We'll show this by re-working the `Count` example:; auto cutb1_result = d.Filter(cutb1);; auto cutb1b2_result = d.Filter(cutb1b2, {""b2"", ""b1""});; auto cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2, {""b2"", ""b1""});; // Now we want to count:; auto evts_cutb1_result = cutb1_result.Count();; auto evts_cutb1b2_result = cutb1b2_result.Count();; auto evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count();; ; std::cout << ""Events passing cutb1: "" << *evts_cutb1_result << std::endl; << ""Events passing cutb1b2: "" << *evts_cutb1b2_result << std::endl; << ""Events passing both: "" << *evts_cutb1_cutb1b2_result << std::endl;; ; // ## Calculating quantities starting from existing columns; // Often, operations need to be carried out on quantities calculated starting; // from the ones present in the columns. We'll create in this example a third; // column",MatchSource.WIKI,doc/master/df001__introduction_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8C.html
https://root.cern/doc/master/df001__introduction_8py.html:3246,Deployability,pipeline,pipelines,3246,"ter(""b1 < 5."").Count();; print('{} entries passed all filters'.format(entries2.GetValue())); ; # `Min`, `Max` and `Mean` actions; # These actions allow to retrieve statistical information about the entries; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1'); maxVal = b1b2_cut.Max('b1'); meanVal = b1b2_cut.Mean('b1'); nonDefmeanVal = b1b2_cut.Mean(""b2""); print('The mean is always included between the min and the max: {0} <= {1} <= {2}'.format(minVal.GetValue(), meanVal.GetValue(), maxVal.GetValue())); ; # `Histo1D` action; # The `Histo1D` action allows to fill an histogram. It returns a TH1F filled; # with values of the column that passed the filters. For the most common; # types, the type of the values stored in the column is automatically; # guessed.; hist = d.Filter(cutb1).Histo1D('b1'); print('Filled h {0} times, mean: {1}'.format(hist.GetEntries(), hist.GetMean())); ; # Express your chain of operations with clarity!; # We are discussing an example here but it is not hard to imagine much more; # complex pipelines of actions acting on data. Those might require code; # which is well organised, for example allowing to conditionally add filters; # or again to clearly separate filters and actions without the need of; # writing the entire pipeline on one line. This can be easily achieved.; # We'll show this re-working the `Count` example:; cutb1_result = d.Filter(cutb1);; cutb1b2_result = d.Filter(cutb1b2);; cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2); ; # Now we want to count:; evts_cutb1_result = cutb1_result.Count(); evts_cutb1b2_result = cutb1b2_result.Count(); evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count(); ; print('Events passing cutb1: {}'.format(evts_cutb1_result.GetValue())); print('Events passing cutb1b2: {}'.format(evts_cutb1b2_result.GetValue())); print('Events passing both: {}'.format(evts_cutb1_cutb1b2_result.GetValue())); ; # Calculating quantities starting from existing columns; # Often, operations n",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:3480,Deployability,pipeline,pipeline,3480,"es; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1'); maxVal = b1b2_cut.Max('b1'); meanVal = b1b2_cut.Mean('b1'); nonDefmeanVal = b1b2_cut.Mean(""b2""); print('The mean is always included between the min and the max: {0} <= {1} <= {2}'.format(minVal.GetValue(), meanVal.GetValue(), maxVal.GetValue())); ; # `Histo1D` action; # The `Histo1D` action allows to fill an histogram. It returns a TH1F filled; # with values of the column that passed the filters. For the most common; # types, the type of the values stored in the column is automatically; # guessed.; hist = d.Filter(cutb1).Histo1D('b1'); print('Filled h {0} times, mean: {1}'.format(hist.GetEntries(), hist.GetMean())); ; # Express your chain of operations with clarity!; # We are discussing an example here but it is not hard to imagine much more; # complex pipelines of actions acting on data. Those might require code; # which is well organised, for example allowing to conditionally add filters; # or again to clearly separate filters and actions without the need of; # writing the entire pipeline on one line. This can be easily achieved.; # We'll show this re-working the `Count` example:; cutb1_result = d.Filter(cutb1);; cutb1b2_result = d.Filter(cutb1b2);; cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2); ; # Now we want to count:; evts_cutb1_result = cutb1_result.Count(); evts_cutb1b2_result = cutb1b2_result.Count(); evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count(); ; print('Events passing cutb1: {}'.format(evts_cutb1_result.GetValue())); print('Events passing cutb1b2: {}'.format(evts_cutb1b2_result.GetValue())); print('Events passing both: {}'.format(evts_cutb1_cutb1b2_result.GetValue())); ; # Calculating quantities starting from existing columns; # Often, operations need to be carried out on quantities calculated starting; # from the ones present in the columns. We'll create in this example a third; # column, the values of which are the sum of the *b1* and *b2* ones, ",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:1296,Integrability,depend,depending,1296,"lass, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; import ROOT; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; # in in case the user specifies none.; entries1 = d.Filter(cutb1) \; .Filter(cutb1b2) \; .Count();; ; print('{} entries passed all filters'.format(entries1.GetValue())); ; entries2 = d.Filter(""b1 < 5."").Count();; print('{} entries passed all filters'.format(entries2.GetValue())); ; # `Min`, `Max` and `Mean` actions; # These actions allow to retrieve stati",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:1492,Integrability,wrap,wrapped,1492,"T; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; # in in case the user specifies none.; entries1 = d.Filter(cutb1) \; .Filter(cutb1b2) \; .Count();; ; print('{} entries passed all filters'.format(entries1.GetValue())); ; entries2 = d.Filter(""b1 < 5."").Count();; print('{} entries passed all filters'.format(entries2.GetValue())); ; # `Min`, `Max` and `Mean` actions; # These actions allow to retrieve statistical information about the entries; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1');",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:5910,Integrability,interface,interface,5910,"lable.; # It is important to note two aspects at this point:; # - The value is created on the fly only if the entry passed the existing; # filters.; # - The newly created column behaves as the one present on the file on disk.; # - The operation creates a new value, without modifying anything. De facto,; # this is like having a general container at disposal able to accommodate; # any value of any type.; # Let's dive in an example:; entries_sum = d.Define('sum', 'b2 + b1') \; .Filter('sum > 4.2') \; .Count(); print(entries_sum.GetValue()); ; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; 2 entries passed all filters; 5 entries passed all filters; The mean is always included between the min and the max: 1.0 <= 2.0 <= 3.0; Filled h 5.0 times, mean: 2.0; Events passing cutb1: 5; Events passing cutb1b2: 2; Events passing both: 2; 8; DateMay 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df001_introduction.py. tutorialsdataframedf001_introduction.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:1698,Modifiability,variab,variables,1698,"c_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; # in in case the user specifies none.; entries1 = d.Filter(cutb1) \; .Filter(cutb1b2) \; .Count();; ; print('{} entries passed all filters'.format(entries1.GetValue())); ; entries2 = d.Filter(""b1 < 5."").Count();; print('{} entries passed all filters'.format(entries2.GetValue())); ; # `Min`, `Max` and `Mean` actions; # These actions allow to retrieve statistical information about the entries; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1'); maxVal = b1b2_cut.Max('b1'); meanVal = b1b2_cut.Mean('b1'); nonDefmeanVal = b1b2_cut.Mean(""b2""); print('The mean is always included between the min and the max: {0} <= {1} <= {2}'.format(minVal.GetValue(), meanVal.GetValue(), m",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:1165,Performance,perform,performed,1165,"rching...; No Matches. Namespaces ; df001_introduction.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Basic usage of RDataFrame from python. ; This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; import ROOT; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; # in in case the user specifies none.; entries1 = d.Filter(cutb1) \; .Filter(cutb1b2) \; .Count();; ; print('{} entries passe",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:1396,Security,access,accessed,1396,"lass, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; import ROOT; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; # in in case the user specifies none.; entries1 = d.Filter(cutb1) \; .Filter(cutb1b2) \; .Count();; ; print('{} entries passed all filters'.format(entries1.GetValue())); ; entries2 = d.Filter(""b1 < 5."").Count();; print('{} entries passed all filters'.format(entries2.GetValue())); ; # `Min`, `Max` and `Mean` actions; # These actions allow to retrieve stati",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:560,Testability,test,test,560,". ROOT: tutorials/dataframe/df001_introduction.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df001_introduction.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Basic usage of RDataFrame from python. ; This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; import ROOT; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; #",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:527,Usability,simpl,simple,527,". ROOT: tutorials/dataframe/df001_introduction.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df001_introduction.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Basic usage of RDataFrame from python. ; This tutorial illustrates the basic features of the RDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach.; ; import ROOT; ; def fill_tree(treeName, fileName):; """"""A simple helper function to fill a test tree: this makes the example stand-alone.""""""; df = ROOT.RDataFrame(10); df.Define(""b1"", ""static_cast<double>(rdfentry_)"")\; .Define(""b2"", ""static_cast<int>(rdfentry_ * rdfentry_)"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df001_introduction_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operations on the dataframe; # We now review some *actions* which can be performed on the data frame.; # Actions can be divided into instant actions (e. g. Foreach()) and lazy; # actions (e. g. Count()), depending on whether they trigger the event ; # loop immediately or only when one of the results is accessed for the ; # first time. Actions that return ""something"" either return their result ; # wrapped in a RResultPtr or in a RDataFrame.; # But first of all, let us we define now our cut-flow with two strings.; # Filters can be expressed as strings. The content must be C++ code. The; # name of the variables must be the name of the branches. The code is; # just-in-time compiled.; cutb1 = 'b1 < 5.'; cutb1b2 = 'b2 % 2 && b1 < 4.'; ; # `Count` action; # The `Count` allows to retrieve the number of the entries that passed the; # filters. Here we show how the automatic selection of the column kicks; #",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df001__introduction_8py.html:3401,Usability,clear,clearly,3401,"es; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1'); maxVal = b1b2_cut.Max('b1'); meanVal = b1b2_cut.Mean('b1'); nonDefmeanVal = b1b2_cut.Mean(""b2""); print('The mean is always included between the min and the max: {0} <= {1} <= {2}'.format(minVal.GetValue(), meanVal.GetValue(), maxVal.GetValue())); ; # `Histo1D` action; # The `Histo1D` action allows to fill an histogram. It returns a TH1F filled; # with values of the column that passed the filters. For the most common; # types, the type of the values stored in the column is automatically; # guessed.; hist = d.Filter(cutb1).Histo1D('b1'); print('Filled h {0} times, mean: {1}'.format(hist.GetEntries(), hist.GetMean())); ; # Express your chain of operations with clarity!; # We are discussing an example here but it is not hard to imagine much more; # complex pipelines of actions acting on data. Those might require code; # which is well organised, for example allowing to conditionally add filters; # or again to clearly separate filters and actions without the need of; # writing the entire pipeline on one line. This can be easily achieved.; # We'll show this re-working the `Count` example:; cutb1_result = d.Filter(cutb1);; cutb1b2_result = d.Filter(cutb1b2);; cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2); ; # Now we want to count:; evts_cutb1_result = cutb1_result.Count(); evts_cutb1b2_result = cutb1b2_result.Count(); evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count(); ; print('Events passing cutb1: {}'.format(evts_cutb1_result.GetValue())); print('Events passing cutb1b2: {}'.format(evts_cutb1b2_result.GetValue())); print('Events passing both: {}'.format(evts_cutb1_cutb1b2_result.GetValue())); ; # Calculating quantities starting from existing columns; # Often, operations need to be carried out on quantities calculated starting; # from the ones present in the columns. We'll create in this example a third; # column, the values of which are the sum of the *b1* and *b2* ones, ",MatchSource.WIKI,doc/master/df001__introduction_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html
https://root.cern/doc/master/df002__dataModel_8C.html:1210,Energy Efficiency,energy,energy,1210,"frame tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using FourVectorRVec = ROOT::VecOps::RVec<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; ; int df002_dataModel(); {; ; // We prepare an input tree to run on; auto fileName = ""df002_dataModel.root"";; auto treeName = ""myTree"";; fill_tree(fileName, treeName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; ROOT::RDataFrame d(treeName, fileName, {""tracks""});; ; // ## Operating on branches which are collections of objects; // Here we deal with the simplest of the cuts: we decide to accept the event; // only if the number of tracks is greater than 8.; auto n_cut = [](const FourVectorRVec &tracks) { return tracks.size() > 8; };; auto nentries = d.Filter(n_cut, {""tracks""}).Count();; ; std::cout << *nentries ",MatchSource.WIKI,doc/master/df002__dataModel_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8C.html
https://root.cern/doc/master/df002__dataModel_8C.html:4232,Integrability,interface,interface,4232,"N->DrawCopy();; ; auto c2 = new TCanvas();; trPts->DrawCopy();; ; auto c3 = new TCanvas();; trWPts->DrawCopy();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; R#define R(a, b, c, d, e, f, g, h, i)Definition RSha256.hxx:110; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; nentriesint nentriesDefinition THbookFile.cxx:91; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; R; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom3Random number generator class based on M.Definition TRandom3.h:27; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::Mapauto Map(Args &&... args)Create new collection applying a callable to the elements of the input collection.Definition RVec.hxx:2150; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Create a new collection with the elements passing the filter expressed by the predicate.Definition RVec.hxx:2182; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; ROOT::Math::RhoEtaPhiVectorDisplacementVector3D< CylindricalEta3D< double >, DefaultCoordinateSystemTag > RhoEtaPhiVector3D Vector based on the eta based cylindrical ",MatchSource.WIKI,doc/master/df002__dataModel_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8C.html
https://root.cern/doc/master/df002__dataModel_8C.html:657,Testability,test,test,657,". ROOT: tutorials/dataframe/df002_dataModel.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df002_dataModel.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using FourVectorRVec = ROOT::VecOps::RVec<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; ; int df002_dataModel(); {; ; // We prepare an input tree to run on; auto fileName = ""df002_dataModel.root"";; auto treeName = ""myTree"";; fill_tree(fileName, treeName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; ROOT::RDataFrame d(treeName, fileName, {""tracks""});; ; // ## Operating on branches which are collections of objects; // Here we deal with the simplest of the cuts: we decide to accept the event; // only if the num",MatchSource.WIKI,doc/master/df002__dataModel_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8C.html
https://root.cern/doc/master/df002__dataModel_8C.html:624,Usability,simpl,simple,624,". ROOT: tutorials/dataframe/df002_dataModel.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df002_dataModel.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using FourVectorRVec = ROOT::VecOps::RVec<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; ; int df002_dataModel(); {; ; // We prepare an input tree to run on; auto fileName = ""df002_dataModel.root"";; auto treeName = ""myTree"";; fill_tree(fileName, treeName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; ROOT::RDataFrame d(treeName, fileName, {""tracks""});; ; // ## Operating on branches which are collections of objects; // Here we deal with the simplest of the cuts: we decide to accept the event; // only if the num",MatchSource.WIKI,doc/master/df002__dataModel_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8C.html
https://root.cern/doc/master/df002__dataModel_8C.html:1930,Usability,simpl,simplest,1930,"(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; ; int df002_dataModel(); {; ; // We prepare an input tree to run on; auto fileName = ""df002_dataModel.root"";; auto treeName = ""myTree"";; fill_tree(fileName, treeName);; ; // We read the tree from the file and create a RDataFrame, a class that; // allows us to interact with the data contained in the tree.; ROOT::RDataFrame d(treeName, fileName, {""tracks""});; ; // ## Operating on branches which are collections of objects; // Here we deal with the simplest of the cuts: we decide to accept the event; // only if the number of tracks is greater than 8.; auto n_cut = [](const FourVectorRVec &tracks) { return tracks.size() > 8; };; auto nentries = d.Filter(n_cut, {""tracks""}).Count();; ; std::cout << *nentries << "" passed all filters"" << std::endl;; ; // Another possibility consists in creating a new column containing the; // quantity we are interested in.; // In this example, we will cut on the number of tracks and plot their; // transverse momentum.; auto getPt = [](const FourVectorRVec &tracks) {; return ROOT::VecOps::Map(tracks, [](const FourVector& v){return v.Pt();});; };; ; // We do the same for the weights.; auto getPtWeights = [](const FourVectorRVec &tracks) {; return ROOT::VecOps::Map(tracks, [](const FourVector& v){ return 1. / v.Pt();});; };; ; auto augmented_d = d.Define(""tracks_n"", [](const FourVectorRVec &tracks) { return (int)tracks.size(); }); .Filter([](int tracks_n) { return tracks_n > 2; }, {""t",MatchSource.WIKI,doc/master/df002__dataModel_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8C.html
https://root.cern/doc/master/df002__dataModel_8py.html:1291,Energy Efficiency,energy,energy,1291,"lat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; fill_tree_code = '''; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''; ; # We prepare an input tree to run on; fileName = ""df002_dataModel_py.root""; treeName = ""myTree""; ROOT.gInterpreter.Declare(fill_tree_code); ROOT.fill_tree(fileName, treeName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operating on branches which are collections of objects; # Here we deal with the simplest of the cuts: we decide to accept the event; # only if the number of tracks is greater than 8.; n_cut = 'tracks.size() > 8'; nentries = d.Filter(n_cut).Count();; ; print(""%s events passed all filters"" % nentries.GetValue()); ; # Another possibility consists i",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df002__dataModel_8py.html:3702,Integrability,interface,interface,3702,"lest of the cuts: we decide to accept the event; # only if the number of tracks is greater than 8.; n_cut = 'tracks.size() > 8'; nentries = d.Filter(n_cut).Count();; ; print(""%s events passed all filters"" % nentries.GetValue()); ; # Another possibility consists in creating a new column containing the; # quantity we are interested in.; # In this example, we will cut on the number of tracks and plot their; # transverse momentum.; ; getPt_code ='''; using namespace ROOT::VecOps;; ROOT::RVecD getPt(const RVec<FourVector> &tracks); {; auto pt = [](const FourVector &v) { return v.pt(); };; return Map(tracks, pt);; }; '''; ROOT.gInterpreter.Declare(getPt_code); ; getPtWeights_code ='''; using namespace ROOT::VecOps;; ROOT::RVecD getPtWeights(const RVec<FourVector> &tracks); {; auto ptWeight = [](const FourVector &v) { return 1. / v.Pt(); };; return Map(tracks, ptWeight);; };; '''; ROOT.gInterpreter.Declare(getPtWeights_code); ; augmented_d = d.Define('tracks_n', '(int)tracks.size()') \; .Filter('tracks_n > 2') \; .Define('tracks_pts', 'getPt( tracks )') \; .Define(""tracks_pts_weights"", 'getPtWeights( tracks )' ); ; # The histogram is initialised with a tuple containing the parameters of the; # histogram; trN = augmented_d.Histo1D(("""", """", 40, -.5, 39.5), ""tracks_n""); trPts = augmented_d.Histo1D(""tracks_pts""); trWPts = augmented_d.Histo1D(""tracks_pts"", ""tracks_pts_weights""); ; c1 = ROOT.TCanvas(); trN.Draw(); c1.SaveAs(""df002_trN.png""); ; c2 = ROOT.TCanvas(); trPts.Draw(); c2.SaveAs(""df002_trPts.png""); ; c3 = ROOT.TCanvas(); trWPts.Draw(); c2.SaveAs(""df002_trWPts.png""); ; print(""Saved figures to df002_*.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateMay 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df002_dataModel.py. tutorialsdataframedf002_dataModel.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df002__dataModel_8py.html:484,Testability,test,test,484,". ROOT: tutorials/dataframe/df002_dataModel.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df002_dataModel.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; fill_tree_code = '''; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''; ; # We prepare an input tree to run on; fileName = ""df002_dataModel_py.root""; treeName = ""myTree""; ROOT.gInterpreter.Declare(fill_tree_code); ROOT.fill_tree(fileName, treeName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operating on branches which are collections of objects; # Here we deal with",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df002__dataModel_8py.html:738,Testability,test,test,738,". ROOT: tutorials/dataframe/df002_dataModel.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df002_dataModel.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; fill_tree_code = '''; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''; ; # We prepare an input tree to run on; fileName = ""df002_dataModel_py.root""; treeName = ""myTree""; ROOT.gInterpreter.Declare(fill_tree_code); ROOT.fill_tree(fileName, treeName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operating on branches which are collections of objects; # Here we deal with",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df002__dataModel_8py.html:451,Usability,simpl,simple,451,". ROOT: tutorials/dataframe/df002_dataModel.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df002_dataModel.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; fill_tree_code = '''; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''; ; # We prepare an input tree to run on; fileName = ""df002_dataModel_py.root""; treeName = ""myTree""; ROOT.gInterpreter.Declare(fill_tree_code); ROOT.fill_tree(fileName, treeName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operating on branches which are collections of objects; # Here we deal with",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df002__dataModel_8py.html:705,Usability,simpl,simple,705,". ROOT: tutorials/dataframe/df002_dataModel.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df002_dataModel.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how to work with non-flat data models, e.g. ; vectors of tracks.; This tutorial shows the possibility to use data models which are more complex than flat ntuples with RDataFrame.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; fill_tree_code = '''; using FourVector = ROOT::Math::XYZTVector;; using FourVectorVec = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *filename, const char *treeName); {; const double M = 0.13957; // set pi+ mass; TRandom3 R(1);; ; auto genTracks = [&](){; FourVectorVec tracks;; const auto nPart = R.Poisson(15);; tracks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''; ; # We prepare an input tree to run on; fileName = ""df002_dataModel_py.root""; treeName = ""myTree""; ROOT.gInterpreter.Declare(fill_tree_code); ROOT.fill_tree(fileName, treeName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operating on branches which are collections of objects; # Here we deal with",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df002__dataModel_8py.html:2006,Usability,simpl,simplest,2006,"acks.reserve(nPart);; for (int j = 0; j < nPart; ++j) {; const auto px = R.Gaus(0, 10);; const auto py = R.Gaus(0, 10);; const auto pt = sqrt(px * px + py * py);; const auto eta = R.Uniform(-3, 3);; const auto phi = R.Uniform(0.0, 2 * TMath::Pi());; CylFourVector vcyl(pt, eta, phi);; // set energy; auto E = sqrt(vcyl.R() * vcyl.R() + M * M);; // fill track vector; tracks.emplace_back(vcyl.X(), vcyl.Y(), vcyl.Z(), E);; }; return tracks;; };; ; ROOT::RDataFrame d(64);; d.Define(""tracks"", genTracks).Snapshot<FourVectorVec>(treeName, filename, {""tracks""});; }; '''; ; # We prepare an input tree to run on; fileName = ""df002_dataModel_py.root""; treeName = ""myTree""; ROOT.gInterpreter.Declare(fill_tree_code); ROOT.fill_tree(fileName, treeName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # Operating on branches which are collections of objects; # Here we deal with the simplest of the cuts: we decide to accept the event; # only if the number of tracks is greater than 8.; n_cut = 'tracks.size() > 8'; nentries = d.Filter(n_cut).Count();; ; print(""%s events passed all filters"" % nentries.GetValue()); ; # Another possibility consists in creating a new column containing the; # quantity we are interested in.; # In this example, we will cut on the number of tracks and plot their; # transverse momentum.; ; getPt_code ='''; using namespace ROOT::VecOps;; ROOT::RVecD getPt(const RVec<FourVector> &tracks); {; auto pt = [](const FourVector &v) { return v.pt(); };; return Map(tracks, pt);; }; '''; ROOT.gInterpreter.Declare(getPt_code); ; getPtWeights_code ='''; using namespace ROOT::VecOps;; ROOT::RVecD getPtWeights(const RVec<FourVector> &tracks); {; auto ptWeight = [](const FourVector &v) { return 1. / v.Pt(); };; return Map(tracks, ptWeight);; };; '''; ROOT.gInterpreter.Declare(getPtWeights_code); ; augmented_d = d.Define('tracks_n', '(int)tracks.size()",MatchSource.WIKI,doc/master/df002__dataModel_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df002__dataModel_8py.html
https://root.cern/doc/master/df003__profiles_8C.html:1769,Integrability,interface,interface,1769," const char *fileName); {; ROOT::RDataFrame d(25000);; d.Define(""px"", []() { return gRandom->Gaus(); }); .Define(""py"", []() { return gRandom->Gaus(); }); .Define(""pz"", [](double px, double py) { return sqrt(px * px + py * py); }, {""px"", ""py""}); .Snapshot(treeName, fileName);; }; ; void df003_profiles(); {; // We prepare an input tree to run on; auto fileName = ""df003_profiles.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // Create the profiles; auto hprof1d = d.Profile1D({""hprof1d"", ""Profile of py versus px"", 64, -4, 4}, ""px"", ""py"");; auto hprof2d =; d.Profile2D({""hprof2d"", ""Profile of pz versus px and py"", 40, -4, 4, 40, -4, 4, 0, 20}, ""px"", ""py"", ""pz"");; ; // And Draw; auto c1 = new TCanvas(""c1"", ""Profile histogram example"", 200, 10, 700, 500);; hprof1d->DrawClone();; auto c2 = new TCanvas(""c2"", ""Profile2D histogram example"", 200, 10, 700, 500);; hprof2d->DrawClone(""BOX"");; }; d#define d(i)Definition RSha256.hxx:102; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; df003_profilesDefinition df003_profiles.py:1; DateFebruary 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df003_profiles.C. tutorialsdataframedf003_profiles.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df003__profiles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df003__profiles_8C.html
https://root.cern/doc/master/df003__profiles_8C.html:501,Testability,test,test,501,". ROOT: tutorials/dataframe/df003_profiles.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df003_profiles.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use TProfiles with RDataFrame. ; This tutorial illustrates how to use TProfiles in combination with the RDataFrame. See the documentation of TProfile and TProfile2D to better understand the analogy of this code with the example one. ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(25000);; d.Define(""px"", []() { return gRandom->Gaus(); }); .Define(""py"", []() { return gRandom->Gaus(); }); .Define(""pz"", [](double px, double py) { return sqrt(px * px + py * py); }, {""px"", ""py""}); .Snapshot(treeName, fileName);; }; ; void df003_profiles(); {; // We prepare an input tree to run on; auto fileName = ""df003_profiles.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // Create the profiles; auto hprof1d = d.Profile1D({""hprof1d"", ""Profile of py versus px"", 64, -4, 4}, ""px"", ""py"");; auto hprof2d =; d.Profile2D({""hprof2d"", ""Profile of pz versus px and py"", 40, -4, 4, 40, -4, 4, 0, 20}, ""px"", ""py"", ""pz"");; ; // And Draw; auto c1 = new TCanvas(""c1"", ""Profile histogram example"", 200, 10, 700, 500);; hprof1d->DrawClone();; auto c2 = new TCanvas(""c2"", ""Profile2D histogram example"", 200, 10, 700, 500);; hprof2d->DrawClone(""BOX"");; }; d#define d(i)Definition RSha256.hxx:102; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the ",MatchSource.WIKI,doc/master/df003__profiles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df003__profiles_8C.html
https://root.cern/doc/master/df003__profiles_8C.html:468,Usability,simpl,simple,468,". ROOT: tutorials/dataframe/df003_profiles.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df003_profiles.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use TProfiles with RDataFrame. ; This tutorial illustrates how to use TProfiles in combination with the RDataFrame. See the documentation of TProfile and TProfile2D to better understand the analogy of this code with the example one. ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(25000);; d.Define(""px"", []() { return gRandom->Gaus(); }); .Define(""py"", []() { return gRandom->Gaus(); }); .Define(""pz"", [](double px, double py) { return sqrt(px * px + py * py); }, {""px"", ""py""}); .Snapshot(treeName, fileName);; }; ; void df003_profiles(); {; // We prepare an input tree to run on; auto fileName = ""df003_profiles.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // Create the profiles; auto hprof1d = d.Profile1D({""hprof1d"", ""Profile of py versus px"", 64, -4, 4}, ""px"", ""py"");; auto hprof2d =; d.Profile2D({""hprof2d"", ""Profile of pz versus px and py"", 40, -4, 4, 40, -4, 4, 0, 20}, ""px"", ""py"", ""pz"");; ; // And Draw; auto c1 = new TCanvas(""c1"", ""Profile histogram example"", 200, 10, 700, 500);; hprof1d->DrawClone();; auto c2 = new TCanvas(""c2"", ""Profile2D histogram example"", 200, 10, 700, 500);; hprof2d->DrawClone(""BOX"");; }; d#define d(i)Definition RSha256.hxx:102; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the ",MatchSource.WIKI,doc/master/df003__profiles_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df003__profiles_8C.html
https://root.cern/doc/master/df003__profiles_8py.html:1603,Integrability,interface,interface,1603,". ROOT: tutorials/dataframe/df003_profiles.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df003_profiles.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use TProfiles with RDataFrame. ; This tutorial illustrates how to use TProfiles in combination with the RDataFrame. See the documentation of TProfile and TProfile2D to better understand the analogy of this code with the example one.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example; # stand-alone.; def fill_tree(treeName, fileName):; d = ROOT.RDataFrame(25000); d.Define(""px"", ""gRandom->Gaus()"")\; .Define(""py"", ""gRandom->Gaus()"")\; .Define(""pz"", ""sqrt(px * px + py * py)"")\; .Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df003_profiles_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame.; d = ROOT.RDataFrame(treeName, fileName); ; # Create the profiles; hprof1d = d.Profile1D((""hprof1d"", ""Profile of pz versus px"", 64, -4, 4), ""px"", ""py""); hprof2d = d.Profile2D((""hprof2d"", ""Profile of pz versus px and py"", 40, -4, 4, 40, -4, 4, 0, 20), ""px"", ""py"", ""pz""); ; # And Draw; c1 = ROOT.TCanvas(""c1"", ""Profile histogram example"", 200, 10, 700, 500); hprof1d.Draw(); c1.SaveAs(""df003_c1.png""); ; c2 = ROOT.TCanvas(""c2"", ""Profile2D histogram example"", 200, 10, 700, 500); hprof2d.Draw(); c2.SaveAs(""df003_c2.png""); ; print(""Saved figures to df003_*.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateFebruary 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df003_profiles.py. tutorialsdataframedf003_profiles.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df003__profiles_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df003__profiles_8py.html
https://root.cern/doc/master/df003__profiles_8py.html:531,Testability,test,test,531,". ROOT: tutorials/dataframe/df003_profiles.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df003_profiles.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use TProfiles with RDataFrame. ; This tutorial illustrates how to use TProfiles in combination with the RDataFrame. See the documentation of TProfile and TProfile2D to better understand the analogy of this code with the example one.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example; # stand-alone.; def fill_tree(treeName, fileName):; d = ROOT.RDataFrame(25000); d.Define(""px"", ""gRandom->Gaus()"")\; .Define(""py"", ""gRandom->Gaus()"")\; .Define(""pz"", ""sqrt(px * px + py * py)"")\; .Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df003_profiles_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame.; d = ROOT.RDataFrame(treeName, fileName); ; # Create the profiles; hprof1d = d.Profile1D((""hprof1d"", ""Profile of pz versus px"", 64, -4, 4), ""px"", ""py""); hprof2d = d.Profile2D((""hprof2d"", ""Profile of pz versus px and py"", 40, -4, 4, 40, -4, 4, 0, 20), ""px"", ""py"", ""pz""); ; # And Draw; c1 = ROOT.TCanvas(""c1"", ""Profile histogram example"", 200, 10, 700, 500); hprof1d.Draw(); c1.SaveAs(""df003_c1.png""); ; c2 = ROOT.TCanvas(""c2"", ""Profile2D histogram example"", 200, 10, 700, 500); hprof2d.Draw(); c2.SaveAs(""df003_c2.png""); ; print(""Saved figures to df003_*.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateFebruary 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df003_profiles.py. tutorialsdataframedf003_profiles.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df003__profiles_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df003__profiles_8py.html
https://root.cern/doc/master/df003__profiles_8py.html:498,Usability,simpl,simple,498,". ROOT: tutorials/dataframe/df003_profiles.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df003_profiles.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use TProfiles with RDataFrame. ; This tutorial illustrates how to use TProfiles in combination with the RDataFrame. See the documentation of TProfile and TProfile2D to better understand the analogy of this code with the example one.; ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example; # stand-alone.; def fill_tree(treeName, fileName):; d = ROOT.RDataFrame(25000); d.Define(""px"", ""gRandom->Gaus()"")\; .Define(""py"", ""gRandom->Gaus()"")\; .Define(""pz"", ""sqrt(px * px + py * py)"")\; .Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df003_profiles_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame.; d = ROOT.RDataFrame(treeName, fileName); ; # Create the profiles; hprof1d = d.Profile1D((""hprof1d"", ""Profile of pz versus px"", 64, -4, 4), ""px"", ""py""); hprof2d = d.Profile2D((""hprof2d"", ""Profile of pz versus px and py"", 40, -4, 4, 40, -4, 4, 0, 20), ""px"", ""py"", ""pz""); ; # And Draw; c1 = ROOT.TCanvas(""c1"", ""Profile histogram example"", 200, 10, 700, 500); hprof1d.Draw(); c1.SaveAs(""df003_c1.png""); ; c2 = ROOT.TCanvas(""c2"", ""Profile2D histogram example"", 200, 10, 700, 500); hprof2d.Draw(); c2.SaveAs(""df003_c2.png""); ; print(""Saved figures to df003_*.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateFebruary 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df003_profiles.py. tutorialsdataframedf003_profiles.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df003__profiles_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df003__profiles_8py.html
https://root.cern/doc/master/df004__cutFlowReport_8C.html:3491,Integrability,interface,interface,3491,"is not only possible to print the information about cuts, but also to; // retrieve it to then use it programmatically.; std::cout << ""All stats:"" << std::endl;; auto allCutsReport = d.Report();; allCutsReport->Print();; ; // We can now loop on the cuts; std::cout << ""Name\tAll\tPass\tEfficiency"" << std::endl;; for (auto &&cutInfo : allCutsReport) {; std::cout << cutInfo.GetName() << ""\t"" << cutInfo.GetAll() << ""\t"" << cutInfo.GetPass() << ""\t""; << cutInfo.GetEff() << "" %"" << std::endl;; }; ; // Or get information about them individually; auto cutName = ""Cut1"";; auto cut = allCutsReport->At(""Cut1"");; std::cout << cutName << "" efficiency is "" << cut.GetEff() << "" %"" << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; ROOT::Math::RhoEtaPhiVectorDisplacementVector3D< CylindricalEta3D< double >, DefaultCoordinateSystemTag > RhoEtaPhiVector3D Vector based on the eta based cylindrical coordinates rho, eta, phi in double precision.Definition Vector3Dfwd.h:62; ROOT::Math::XYZTVectorLorentzVector< PxPyPzE4D< double > > XYZTVectorLorentzVector based on x,y,x,t (or px,py,pz,E) coordinates in double precision with metric (-,...Definition Vector4Dfwd.h:46; df004_cutFlowReportDefinition df004_cutFlowReport.py:1; ; Cut3 stats:; Cut2 : pass=25 all=50 -- eff=50.00 % cumulative eff=50.00 %; Cut3 : pass=23 all=25 -- eff=92.00 % cumulative eff=46.00 %; All stats:; Cut1 : pass=24 all=50 -- eff=48.00 % cumulative eff=48.00 %; Cut2 : pass=25 all=50 -- eff=50.00 % cumulative eff=50.00 %; Cut3 : pass=23 all=25 -- eff=92.00 % cumulative eff=46.00 %; Name All Pass Efficiency; Cut1 50 24 48 %; Cu",MatchSource.WIKI,doc/master/df004__cutFlowReport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8C.html
https://root.cern/doc/master/df004__cutFlowReport_8C.html:561,Testability,test,test,561,". ROOT: tutorials/dataframe/df004_cutFlowReport.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df004_cutFlowReport.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Display cut/Filter efficiencies with RDataFrame. ; This tutorial shows how to get information about the efficiency of the filters applied; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectors = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(50);; int i(0);; d.Define(""b1"", [&i]() { return (double)i; }); .Define(""b2"",; [&i]() {; auto j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; void df004_cutFlowReport(); {; ; // We prepare an input tree to run on; auto fileName = ""df004_cutFlowReport.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName, {""b1"", ""b2""});; ; // ## Define cuts and create the report; // Here we define two simple cuts; auto cut1 = [](double b1) { return b1 > 25.; };; auto cut2 = [](int b2) { return 0 == b2 % 2; };; ; // An optional string parameter name can be passed to the Filter method to create a named filter.; // Named filters work as usual, but also keep track of how many entries they accept and reject.; auto filtered1 = d.Filter(cut1, {""b1""}, ""Cut1"");; auto filtered2 = d.Filter(cut2, {""b2""}, ""Cut2"");; ; auto augmented1 = filtered2.Define(""b3"", [](double b1, int b2) { return b1 / b2; });; auto cut3 = [](double x) { return x < .5; };; auto filtered3 = augmented1.Filter(cut3, {""b3""}, ""Cut3"");; ; // Statistics are retrieved through a call to the Report method:; // when Report is called on the main RDataFrame object, it retrieves stats; // for all named filters declared up to ",MatchSource.WIKI,doc/master/df004__cutFlowReport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8C.html
https://root.cern/doc/master/df004__cutFlowReport_8C.html:528,Usability,simpl,simple,528,". ROOT: tutorials/dataframe/df004_cutFlowReport.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df004_cutFlowReport.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Display cut/Filter efficiencies with RDataFrame. ; This tutorial shows how to get information about the efficiency of the filters applied; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectors = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(50);; int i(0);; d.Define(""b1"", [&i]() { return (double)i; }); .Define(""b2"",; [&i]() {; auto j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; void df004_cutFlowReport(); {; ; // We prepare an input tree to run on; auto fileName = ""df004_cutFlowReport.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName, {""b1"", ""b2""});; ; // ## Define cuts and create the report; // Here we define two simple cuts; auto cut1 = [](double b1) { return b1 > 25.; };; auto cut2 = [](int b2) { return 0 == b2 % 2; };; ; // An optional string parameter name can be passed to the Filter method to create a named filter.; // Named filters work as usual, but also keep track of how many entries they accept and reject.; auto filtered1 = d.Filter(cut1, {""b1""}, ""Cut1"");; auto filtered2 = d.Filter(cut2, {""b2""}, ""Cut2"");; ; auto augmented1 = filtered2.Define(""b3"", [](double b1, int b2) { return b1 / b2; });; auto cut3 = [](double x) { return x < .5; };; auto filtered3 = augmented1.Filter(cut3, {""b3""}, ""Cut3"");; ; // Statistics are retrieved through a call to the Report method:; // when Report is called on the main RDataFrame object, it retrieves stats; // for all named filters declared up to ",MatchSource.WIKI,doc/master/df004__cutFlowReport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8C.html
https://root.cern/doc/master/df004__cutFlowReport_8C.html:1215,Usability,simpl,simple,1215,"; Searching...; No Matches. df004_cutFlowReport.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Display cut/Filter efficiencies with RDataFrame. ; This tutorial shows how to get information about the efficiency of the filters applied; ; using FourVector = ROOT::Math::XYZTVector;; using FourVectors = std::vector<FourVector>;; using CylFourVector = ROOT::Math::RhoEtaPhiVector;; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(50);; int i(0);; d.Define(""b1"", [&i]() { return (double)i; }); .Define(""b2"",; [&i]() {; auto j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; void df004_cutFlowReport(); {; ; // We prepare an input tree to run on; auto fileName = ""df004_cutFlowReport.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName, {""b1"", ""b2""});; ; // ## Define cuts and create the report; // Here we define two simple cuts; auto cut1 = [](double b1) { return b1 > 25.; };; auto cut2 = [](int b2) { return 0 == b2 % 2; };; ; // An optional string parameter name can be passed to the Filter method to create a named filter.; // Named filters work as usual, but also keep track of how many entries they accept and reject.; auto filtered1 = d.Filter(cut1, {""b1""}, ""Cut1"");; auto filtered2 = d.Filter(cut2, {""b2""}, ""Cut2"");; ; auto augmented1 = filtered2.Define(""b3"", [](double b1, int b2) { return b1 / b2; });; auto cut3 = [](double x) { return x < .5; };; auto filtered3 = augmented1.Filter(cut3, {""b3""}, ""Cut3"");; ; // Statistics are retrieved through a call to the Report method:; // when Report is called on the main RDataFrame object, it retrieves stats; // for all named filters declared up to that point.; // When called on a stored chain state (i.e. a chain/graph node), it; // retrieves stats for all named fi",MatchSource.WIKI,doc/master/df004__cutFlowReport_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8C.html
https://root.cern/doc/master/df004__cutFlowReport_8py.html:2065,Integrability,interface,interface,2065," # We prepare an input tree to run on; fileName = 'df004_cutFlowReport_py.root'; treeName = 'myTree'; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame, a class that; # allows us to interact with the data contained in the tree.; d = ROOT.RDataFrame(treeName, fileName); ; # ## Define cuts and create the report; # An optional string parameter name can be passed to the Filter method to create a named filter.; # Named filters work as usual, but also keep track of how many entries they accept and reject.; filtered1 = d.Filter('b1 > 25', 'Cut1'); filtered2 = d.Filter('0 == b2 % 2', 'Cut2'); ; augmented1 = filtered2.Define('b3', 'b1 / b2'); filtered3 = augmented1.Filter('b3 < .5','Cut3'); ; # Statistics are retrieved through a call to the Report method:; # when Report is called on the main RDataFrame object, it retrieves stats for; # all named filters declared up to that point. When called on a stored chain; # state (i.e. a chain/graph node), it retrieves stats for all named filters in; # the section of the chain between the main RDataFrame and that node (included).; # Stats are printed in the same order as named filters that have been added to the; # graph, and refer to the latest event-loop that has been running using the relevant; # RDataFrame.; print('Cut3 stats:'); filtered3.Report(); print('All stats:'); allCutsReport = d.Report(); allCutsReport.Print(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; Cut1 : pass=24 all=50 -- eff=48.00 % cumulative eff=48.00 %; Cut2 : pass=25 all=50 -- eff=50.00 % cumulative eff=50.00 %; Cut3 : pass=23 all=25 -- eff=92.00 % cumulative eff=46.00 %; Cut3 stats:; All stats:; DateMay 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df004_cutFlowReport.py. tutorialsdataframedf004_cutFlowReport.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df004__cutFlowReport_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df004__cutFlowReport_8py.html
https://root.cern/doc/master/df005__fillAnyObject_8C.html:1624,Integrability,interface,interface,1624," helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; auto i = 0.;; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df005_fillAnyObject(); {; ; // We prepare an input tree to run on; auto fileName = ""df005_fillAnyObject.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Filling any object; // We now fill some objects which are instances of classes which expose a; // `Fill` method with some input arguments.; auto th1d = d.Fill<double>(TH1D(""th1d"", ""th1d"", 64, 0, 128), {""b1""});; auto th1i = d.Fill<float>(TH1I(""th1i"", ""th1i"", 64, 0, 128), {""b2""});; auto th2d = d.Fill<double, float>(TH2D(""th2d"", ""th2d"", 64, 0, 128, 64, 0, 1024), {""b1"", ""b2""});; ; auto c1 = new TCanvas();; th1d->DrawClone();; ; auto c2 = new TCanvas();; th1i->DrawClone();; ; auto c3 = new TCanvas();; th2d->DrawClone(""COLZ"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; double; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; . DateMarch 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df005_fillAnyObject.C. tutorialsdataframedf005_fillAnyObject.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df005__fillAnyObject_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df005__fillAnyObject_8C.html
https://root.cern/doc/master/df005__fillAnyObject_8C.html:333,Security,expose,exposes,333,". ROOT: tutorials/dataframe/df005_fillAnyObject.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df005_fillAnyObject.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Using the generic Fill action. ; This tutorial shows how to fill any object the class of which exposes a Fill method.; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; auto i = 0.;; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df005_fillAnyObject(); {; ; // We prepare an input tree to run on; auto fileName = ""df005_fillAnyObject.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Filling any object; // We now fill some objects which are instances of classes which expose a; // `Fill` method with some input arguments.; auto th1d = d.Fill<double>(TH1D(""th1d"", ""th1d"", 64, 0, 128), {""b1""});; auto th1i = d.Fill<float>(TH1I(""th1i"", ""th1i"", 64, 0, 128), {""b2""});; auto th2d = d.Fill<double, float>(TH2D(""th2d"", ""th2d"", 64, 0, 128, 64, 0, 1024), {""b1"", ""b2""});; ; auto c1 = new TCanvas();; th1d->DrawClone();; ; auto c2 = new TCanvas();; th1i->DrawClone();; ; auto c3 = new TCanvas();; th2d->DrawClone(""COLZ"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH2D2-D histogram with a double per channel (see TH1 documentation)Defi",MatchSource.WIKI,doc/master/df005__fillAnyObject_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df005__fillAnyObject_8C.html
https://root.cern/doc/master/df005__fillAnyObject_8C.html:1062,Security,expose,expose,1062,"taframe/df005_fillAnyObject.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df005_fillAnyObject.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Using the generic Fill action. ; This tutorial shows how to fill any object the class of which exposes a Fill method.; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; auto i = 0.;; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df005_fillAnyObject(); {; ; // We prepare an input tree to run on; auto fileName = ""df005_fillAnyObject.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Filling any object; // We now fill some objects which are instances of classes which expose a; // `Fill` method with some input arguments.; auto th1d = d.Fill<double>(TH1D(""th1d"", ""th1d"", 64, 0, 128), {""b1""});; auto th1i = d.Fill<float>(TH1I(""th1i"", ""th1i"", 64, 0, 128), {""b2""});; auto th2d = d.Fill<double, float>(TH2D(""th2d"", ""th2d"", 64, 0, 128, 64, 0, 1024), {""b1"", ""b2""});; ; auto c1 = new TCanvas();; th1d->DrawClone();; ; auto c2 = new TCanvas();; th1i->DrawClone();; ; auto c3 = new TCanvas();; th2d->DrawClone(""COLZ"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; do",MatchSource.WIKI,doc/master/df005__fillAnyObject_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df005__fillAnyObject_8C.html
https://root.cern/doc/master/df005__fillAnyObject_8C.html:397,Testability,test,test,397,". ROOT: tutorials/dataframe/df005_fillAnyObject.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df005_fillAnyObject.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Using the generic Fill action. ; This tutorial shows how to fill any object the class of which exposes a Fill method.; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; auto i = 0.;; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df005_fillAnyObject(); {; ; // We prepare an input tree to run on; auto fileName = ""df005_fillAnyObject.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Filling any object; // We now fill some objects which are instances of classes which expose a; // `Fill` method with some input arguments.; auto th1d = d.Fill<double>(TH1D(""th1d"", ""th1d"", 64, 0, 128), {""b1""});; auto th1i = d.Fill<float>(TH1I(""th1i"", ""th1i"", 64, 0, 128), {""b2""});; auto th2d = d.Fill<double, float>(TH2D(""th2d"", ""th2d"", 64, 0, 128, 64, 0, 1024), {""b1"", ""b2""});; ; auto c1 = new TCanvas();; th1d->DrawClone();; ; auto c2 = new TCanvas();; th1i->DrawClone();; ; auto c3 = new TCanvas();; th2d->DrawClone(""COLZ"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH2D2-D histogram with a double per channel (see TH1 documentation)Defi",MatchSource.WIKI,doc/master/df005__fillAnyObject_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df005__fillAnyObject_8C.html
https://root.cern/doc/master/df005__fillAnyObject_8C.html:364,Usability,simpl,simple,364,". ROOT: tutorials/dataframe/df005_fillAnyObject.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df005_fillAnyObject.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Using the generic Fill action. ; This tutorial shows how to fill any object the class of which exposes a Fill method.; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; auto i = 0.;; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df005_fillAnyObject(); {; ; // We prepare an input tree to run on; auto fileName = ""df005_fillAnyObject.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Filling any object; // We now fill some objects which are instances of classes which expose a; // `Fill` method with some input arguments.; auto th1d = d.Fill<double>(TH1D(""th1d"", ""th1d"", 64, 0, 128), {""b1""});; auto th1i = d.Fill<float>(TH1I(""th1i"", ""th1i"", 64, 0, 128), {""b2""});; auto th2d = d.Fill<double, float>(TH2D(""th2d"", ""th2d"", 64, 0, 128, 64, 0, 1024), {""b1"", ""b2""});; ; auto c1 = new TCanvas();; th1d->DrawClone();; ; auto c2 = new TCanvas();; th1i->DrawClone();; ; auto c3 = new TCanvas();; th2d->DrawClone(""COLZ"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH2D2-D histogram with a double per channel (see TH1 documentation)Defi",MatchSource.WIKI,doc/master/df005__fillAnyObject_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df005__fillAnyObject_8C.html
https://root.cern/doc/master/df006__ranges_8C.html:1846,Integrability,depend,depends,1846,"tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Usage of ranges; // Now we'll count some entries using ranges; auto c_all = d.Count();; ; // This is how you can express a range of the first 30 entries; auto d_0_30 = d.Range(30);; auto c_0_30 = d_0_30.Count();; ; // This is how you pick all entries from 15 onwards; auto d_15_end = d.Range(15, 0);; auto c_15_end = d_15_end.Count();; ; // We can use a stride too, in this case we pick an event every 3 entries; auto d_15_end_3 = d.Range(15, 0, 3);; auto c_15_end_3 = d_15_end_3.Count();; ; // The Range here acts first on the (whole) RDataFrame graph:; // Not only actions (like Count) but also filters and new columns can be added to it.; auto d_0_50 = d.Range(50);; auto c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count();; ; // An important thing to notice is that the counts of a filter are relative to the; // number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; // the Range will act on the entries passing the filter only.; auto c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count();; ; // Ok, time to wrap up: let's print all counts!; cout << ""Usage of ranges:\n""; << "" - All entries: "" << *c_all << endl; << "" - Entries from 0 to 30: "" << *c_0_30 << endl; << "" - Entries from 15 onwards: "" << *c_15_end << endl; << "" - Entries from 15 onwards in steps of 3: "" << *c_15_end_3 << endl; << "" - Entries from 0 to 50, odd only: "" << *c_0_50_odd_b1 << endl; << "" - First three entries of all even entries: "" << *c_0_3_after_even_b1 << endl;; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df006_rangesDefinition df006_ranges.py:1; ; Usage of ranges:; - All entries: 100; - Entries from 0 to 30: 30; - Entries from 15 onwards: 85; - Entries from 15 onwards in steps of 3: 29; - Entries from 0 to 50, odd only:",MatchSource.WIKI,doc/master/df006__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8C.html
https://root.cern/doc/master/df006__ranges_8C.html:2021,Integrability,wrap,wrap,2021,"o c_0_30 = d_0_30.Count();; ; // This is how you pick all entries from 15 onwards; auto d_15_end = d.Range(15, 0);; auto c_15_end = d_15_end.Count();; ; // We can use a stride too, in this case we pick an event every 3 entries; auto d_15_end_3 = d.Range(15, 0, 3);; auto c_15_end_3 = d_15_end_3.Count();; ; // The Range here acts first on the (whole) RDataFrame graph:; // Not only actions (like Count) but also filters and new columns can be added to it.; auto d_0_50 = d.Range(50);; auto c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count();; ; // An important thing to notice is that the counts of a filter are relative to the; // number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; // the Range will act on the entries passing the filter only.; auto c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count();; ; // Ok, time to wrap up: let's print all counts!; cout << ""Usage of ranges:\n""; << "" - All entries: "" << *c_all << endl; << "" - Entries from 0 to 30: "" << *c_0_30 << endl; << "" - Entries from 15 onwards: "" << *c_15_end << endl; << "" - Entries from 15 onwards in steps of 3: "" << *c_15_end_3 << endl; << "" - Entries from 0 to 50, odd only: "" << *c_0_50_odd_b1 << endl; << "" - First three entries of all even entries: "" << *c_0_3_after_even_b1 << endl;; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df006_rangesDefinition df006_ranges.py:1; ; Usage of ranges:; - All entries: 100; - Entries from 0 to 30: 30; - Entries from 15 onwards: 85; - Entries from 15 onwards in steps of 3: 29; - Entries from 0 to 50, odd only: 25; - First three entries of all even entries: 3; (int) 0; DateMarch 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df006_ranges.C. tutorialsdataframedf006_ranges.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df006__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8C.html
https://root.cern/doc/master/df006__ranges_8C.html:2576,Integrability,interface,interface,2576,"o c_0_30 = d_0_30.Count();; ; // This is how you pick all entries from 15 onwards; auto d_15_end = d.Range(15, 0);; auto c_15_end = d_15_end.Count();; ; // We can use a stride too, in this case we pick an event every 3 entries; auto d_15_end_3 = d.Range(15, 0, 3);; auto c_15_end_3 = d_15_end_3.Count();; ; // The Range here acts first on the (whole) RDataFrame graph:; // Not only actions (like Count) but also filters and new columns can be added to it.; auto d_0_50 = d.Range(50);; auto c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count();; ; // An important thing to notice is that the counts of a filter are relative to the; // number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; // the Range will act on the entries passing the filter only.; auto c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count();; ; // Ok, time to wrap up: let's print all counts!; cout << ""Usage of ranges:\n""; << "" - All entries: "" << *c_all << endl; << "" - Entries from 0 to 30: "" << *c_0_30 << endl; << "" - Entries from 15 onwards: "" << *c_15_end << endl; << "" - Entries from 15 onwards in steps of 3: "" << *c_15_end_3 << endl; << "" - Entries from 0 to 50, odd only: "" << *c_0_50_odd_b1 << endl; << "" - First three entries of all even entries: "" << *c_0_3_after_even_b1 << endl;; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df006_rangesDefinition df006_ranges.py:1; ; Usage of ranges:; - All entries: 100; - Entries from 0 to 30: 30; - Entries from 15 onwards: 85; - Entries from 15 onwards in steps of 3: 29; - Entries from 0 to 50, odd only: 25; - First three entries of all even entries: 3; (int) 0; DateMarch 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df006_ranges.C. tutorialsdataframedf006_ranges.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df006__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8C.html
https://root.cern/doc/master/df006__ranges_8C.html:407,Testability,test,test,407,". ROOT: tutorials/dataframe/df006_ranges.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df006_ranges.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use Range to limit the amount of data processed. ; This tutorial shows how to express the concept of ranges when working with the RDataFrame.; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; int i(0);; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df006_ranges(); {; ; // We prepare an input tree to run on; auto fileName = ""df006_ranges.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Usage of ranges; // Now we'll count some entries using ranges; auto c_all = d.Count();; ; // This is how you can express a range of the first 30 entries; auto d_0_30 = d.Range(30);; auto c_0_30 = d_0_30.Count();; ; // This is how you pick all entries from 15 onwards; auto d_15_end = d.Range(15, 0);; auto c_15_end = d_15_end.Count();; ; // We can use a stride too, in this case we pick an event every 3 entries; auto d_15_end_3 = d.Range(15, 0, 3);; auto c_15_end_3 = d_15_end_3.Count();; ; // The Range here acts first on the (whole) RDataFrame graph:; // Not only actions (like Count) but also filters and new columns can be added to it.; auto d_0_50 = d.Range(50);; auto c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count();; ; // An important thing to notice is that the counts of a filter are relative to the; // number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; // the Range will act on the entries passing the filter only.; auto c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count()",MatchSource.WIKI,doc/master/df006__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8C.html
https://root.cern/doc/master/df006__ranges_8C.html:374,Usability,simpl,simple,374,". ROOT: tutorials/dataframe/df006_ranges.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df006_ranges.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use Range to limit the amount of data processed. ; This tutorial shows how to express the concept of ranges when working with the RDataFrame.; ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(100);; int i(0);; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df006_ranges(); {; ; // We prepare an input tree to run on; auto fileName = ""df006_ranges.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame.; ROOT::RDataFrame d(treeName, fileName);; ; // ## Usage of ranges; // Now we'll count some entries using ranges; auto c_all = d.Count();; ; // This is how you can express a range of the first 30 entries; auto d_0_30 = d.Range(30);; auto c_0_30 = d_0_30.Count();; ; // This is how you pick all entries from 15 onwards; auto d_15_end = d.Range(15, 0);; auto c_15_end = d_15_end.Count();; ; // We can use a stride too, in this case we pick an event every 3 entries; auto d_15_end_3 = d.Range(15, 0, 3);; auto c_15_end_3 = d_15_end_3.Count();; ; // The Range here acts first on the (whole) RDataFrame graph:; // Not only actions (like Count) but also filters and new columns can be added to it.; auto d_0_50 = d.Range(50);; auto c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count();; ; // An important thing to notice is that the counts of a filter are relative to the; // number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; // the Range will act on the entries passing the filter only.; auto c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count()",MatchSource.WIKI,doc/master/df006__ranges_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8C.html
https://root.cern/doc/master/df006__ranges_8py.html:1631,Integrability,depend,depends,1631,"e = ""myTree""; ; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame.; d = ROOT.RDataFrame(treeName, fileName); ; # ## Usage of ranges; # Now we'll count some entries using ranges; c_all = d.Count(); ; # This is how you can express a range of the first 30 entries; d_0_30 = d.Range(30) ; c_0_30 = d_0_30.Count(); ; # This is how you pick all entries from 15 onwards; d_15_end = d.Range(15, 0); c_15_end = d_15_end.Count(); ; # We can use a stride too, in this case we pick an event every 3 entries; d_15_end_3 = d.Range(15, 0, 3); c_15_end_3 = d_15_end_3.Count(); ; # The Range here acts first on the (whole) RDataFrame graph:; # Not only actions (like Count) but also filters and new columns can be added to it.; d_0_50 = d.Range(50); c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count(); ; # An important thing to notice is that the counts of a filter are relative to the; # number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; # the Range will act on the entries passing the filter only.; c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count(); ; # Ok, time to wrap up: let's print all counts!; print(""Usage of ranges:""); print("" - All entries:"", c_all.GetValue()); print("" - Entries from 0 to 30:"", c_0_30.GetValue()); print("" - Entries from 15 onwards:"", c_15_end.GetValue()); print("" - Entries from 15 onwards in steps of 3:"", c_15_end_3.GetValue()); print("" - Entries from 0 to 50, odd only:"", c_0_50_odd_b1.GetValue()); print("" - First three entries of all even entries:"", c_0_3_after_even_b1.GetValue()); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; RangeTa Range(0, 0, 1, 1); Usage of ranges:; - All entries: 100; - Entries from 0 to 30: 30; - Entries from 15 onwards: 85; - Entries from 15 onwards in steps of 3: 29; - Entries from 0 to 50, odd only: 25; - First three entries of all even entries: 3; DateMarch 2017 ; ",MatchSource.WIKI,doc/master/df006__ranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8py.html
https://root.cern/doc/master/df006__ranges_8py.html:1798,Integrability,wrap,wrap,1798,"; # Now we'll count some entries using ranges; c_all = d.Count(); ; # This is how you can express a range of the first 30 entries; d_0_30 = d.Range(30) ; c_0_30 = d_0_30.Count(); ; # This is how you pick all entries from 15 onwards; d_15_end = d.Range(15, 0); c_15_end = d_15_end.Count(); ; # We can use a stride too, in this case we pick an event every 3 entries; d_15_end_3 = d.Range(15, 0, 3); c_15_end_3 = d_15_end_3.Count(); ; # The Range here acts first on the (whole) RDataFrame graph:; # Not only actions (like Count) but also filters and new columns can be added to it.; d_0_50 = d.Range(50); c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count(); ; # An important thing to notice is that the counts of a filter are relative to the; # number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; # the Range will act on the entries passing the filter only.; c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count(); ; # Ok, time to wrap up: let's print all counts!; print(""Usage of ranges:""); print("" - All entries:"", c_all.GetValue()); print("" - Entries from 0 to 30:"", c_0_30.GetValue()); print("" - Entries from 15 onwards:"", c_15_end.GetValue()); print("" - Entries from 15 onwards in steps of 3:"", c_15_end_3.GetValue()); print("" - Entries from 0 to 50, odd only:"", c_0_50_odd_b1.GetValue()); print("" - First three entries of all even entries:"", c_0_3_after_even_b1.GetValue()); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; RangeTa Range(0, 0, 1, 1); Usage of ranges:; - All entries: 100; - Entries from 0 to 30: 30; - Entries from 15 onwards: 85; - Entries from 15 onwards in steps of 3: 29; - Entries from 0 to 50, odd only: 25; - First three entries of all even entries: 3; DateMarch 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df006_ranges.py. tutorialsdataframedf006_ranges.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA",MatchSource.WIKI,doc/master/df006__ranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8py.html
https://root.cern/doc/master/df006__ranges_8py.html:2310,Integrability,interface,interface,2310,"sing ranges; c_all = d.Count(); ; # This is how you can express a range of the first 30 entries; d_0_30 = d.Range(30) ; c_0_30 = d_0_30.Count(); ; # This is how you pick all entries from 15 onwards; d_15_end = d.Range(15, 0); c_15_end = d_15_end.Count(); ; # We can use a stride too, in this case we pick an event every 3 entries; d_15_end_3 = d.Range(15, 0, 3); c_15_end_3 = d_15_end_3.Count(); ; # The Range here acts first on the (whole) RDataFrame graph:; # Not only actions (like Count) but also filters and new columns can be added to it.; d_0_50 = d.Range(50); c_0_50_odd_b1 = d_0_50.Filter(""1 == b1 % 2"").Count(); ; # An important thing to notice is that the counts of a filter are relative to the; # number of entries a filter ""sees"". Therefore, if a Range depends on a filter,; # the Range will act on the entries passing the filter only.; c_0_3_after_even_b1 = d.Filter(""0 == b1 % 2"").Range(0, 3).Count(); ; # Ok, time to wrap up: let's print all counts!; print(""Usage of ranges:""); print("" - All entries:"", c_all.GetValue()); print("" - Entries from 0 to 30:"", c_0_30.GetValue()); print("" - Entries from 15 onwards:"", c_15_end.GetValue()); print("" - Entries from 15 onwards in steps of 3:"", c_15_end_3.GetValue()); print("" - Entries from 0 to 50, odd only:"", c_0_50_odd_b1.GetValue()); print("" - First three entries of all even entries:"", c_0_3_after_even_b1.GetValue()); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; RangeTa Range(0, 0, 1, 1); Usage of ranges:; - All entries: 100; - Entries from 0 to 30: 30; - Entries from 15 onwards: 85; - Entries from 15 onwards in steps of 3: 29; - Entries from 0 to 50, odd only: 25; - First three entries of all even entries: 3; DateMarch 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df006_ranges.py. tutorialsdataframedf006_ranges.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df006__ranges_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df006__ranges_8py.html
https://root.cern/doc/master/df007__snapshot_8C.html:2543,Availability,avail,available,2543,"riables.; // The user can explicitly specify the types of the columns as template; // arguments of the Snapshot method, otherwise they will be automatically; // inferred.; d2.Snapshot(treeName, outFileName, {""b1"", ""b1_square"", ""b2_vector""});; ; // Open the new file and list the columns of the tree; TFile f1(outFileName);; auto t = f1.Get<TTree>(treeName);; std::cout << ""These are the columns b1, b1_square and b2_vector:"" << std::endl;; for (auto branch : *t->GetListOfBranches()) {; std::cout << ""Branch: "" << branch->GetName() << std::endl;; }; f1.Close();; ; // We are not forced to write the full set of column names. We can also; // specify a regular expression for that. In case nothing is specified, all; // columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns);; ; // Open the new file and list the columns of the tree; TFile f2(outFileNameAllColumns);; t = f2.Get<TTree>(treeName);; std::cout << ""These are all the columns available to this dataframe:"" << std::endl;; for (auto branch : *t->GetListOfBranches()) {; std::cout << ""Branch: "" << branch->GetName() << std::endl;; }; f2.Close();; ; // We can also get a fresh RDataFrame out of the snapshot and restart the; // analysis chain from it. The default columns are the ones selected.; // Notice also how we can decide to be more explicit with the types of the; // columns.; auto snapshot_df = d2.Snapshot<int>(treeName, outFileName, {""b1_square""});; auto h = snapshot_df->Histo1D();; auto c = new TCanvas();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNamed::GetNameconst char * ",MatchSource.WIKI,doc/master/df007__snapshot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8C.html
https://root.cern/doc/master/df007__snapshot_8C.html:3301,Integrability,interface,interface,3301,") {; std::cout << ""Branch: "" << branch->GetName() << std::endl;; }; f1.Close();; ; // We are not forced to write the full set of column names. We can also; // specify a regular expression for that. In case nothing is specified, all; // columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns);; ; // Open the new file and list the columns of the tree; TFile f2(outFileNameAllColumns);; t = f2.Get<TTree>(treeName);; std::cout << ""These are all the columns available to this dataframe:"" << std::endl;; for (auto branch : *t->GetListOfBranches()) {; std::cout << ""Branch: "" << branch->GetName() << std::endl;; }; f2.Close();; ; // We can also get a fresh RDataFrame out of the snapshot and restart the; // analysis chain from it. The default columns are the ones selected.; // Notice also how we can decide to be more explicit with the types of the; // columns.; auto snapshot_df = d2.Snapshot<int>(treeName, outFileName, {""b1_square""});; auto h = snapshot_df->Histo1D();; auto c = new TCanvas();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; f1TF1 * f1Definition legend1.C:11; df007_snapshotDefinition df007_snapshot.py:1; v@ vDefinition rootcling_impl.cxx:3699; DateApril 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df007_snapshot.C. tutorialsdataframedf007_snapshot.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df007__snapshot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8C.html
https://root.cern/doc/master/df007__snapshot_8C.html:1531,Modifiability,variab,variables,1531,"{; ROOT::RDataFrame d(10000);; int i(0);; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df007_snapshot(); {; // We prepare an input tree to run on; auto fileName = ""df007_snapshot.root"";; auto outFileName = ""df007_snapshot_output.root"";; auto outFileNameAllColumns = ""df007_snapshot_output_allColumns.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName);; ; // ## Select entries; // We now select some entries in the dataset; auto d_cut = d.Filter(""b1 % 2 == 0"");; // ## Enrich the dataset; // Build some temporary columns: we'll write them out; auto d2 = d_cut.Define(""b1_square"", ""b1 * b1""); .Define(""b2_vector"",; [](float b2) {; std::vector<float> v;; for (int i = 0; i < 3; i++); v.push_back(b2 * i);; return v;; },; {""b2""});; ; // ## Write it to disk in ROOT format; // We now write to disk a new dataset with one of the variables originally; // present in the tree and the new variables.; // The user can explicitly specify the types of the columns as template; // arguments of the Snapshot method, otherwise they will be automatically; // inferred.; d2.Snapshot(treeName, outFileName, {""b1"", ""b1_square"", ""b2_vector""});; ; // Open the new file and list the columns of the tree; TFile f1(outFileName);; auto t = f1.Get<TTree>(treeName);; std::cout << ""These are the columns b1, b1_square and b2_vector:"" << std::endl;; for (auto branch : *t->GetListOfBranches()) {; std::cout << ""Branch: "" << branch->GetName() << std::endl;; }; f1.Close();; ; // We are not forced to write the full set of column names. We can also; // specify a regular expression for that. In case nothing is specified, all; // columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns);; ; // Open the new file and list the columns of the tree; TFile f2(outFileNameAllColumns);; t = f2.Get<TTree>(tree",MatchSource.WIKI,doc/master/df007__snapshot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8C.html
https://root.cern/doc/master/df007__snapshot_8C.html:1588,Modifiability,variab,variables,1588,"{; ROOT::RDataFrame d(10000);; int i(0);; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df007_snapshot(); {; // We prepare an input tree to run on; auto fileName = ""df007_snapshot.root"";; auto outFileName = ""df007_snapshot_output.root"";; auto outFileNameAllColumns = ""df007_snapshot_output_allColumns.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName);; ; // ## Select entries; // We now select some entries in the dataset; auto d_cut = d.Filter(""b1 % 2 == 0"");; // ## Enrich the dataset; // Build some temporary columns: we'll write them out; auto d2 = d_cut.Define(""b1_square"", ""b1 * b1""); .Define(""b2_vector"",; [](float b2) {; std::vector<float> v;; for (int i = 0; i < 3; i++); v.push_back(b2 * i);; return v;; },; {""b2""});; ; // ## Write it to disk in ROOT format; // We now write to disk a new dataset with one of the variables originally; // present in the tree and the new variables.; // The user can explicitly specify the types of the columns as template; // arguments of the Snapshot method, otherwise they will be automatically; // inferred.; d2.Snapshot(treeName, outFileName, {""b1"", ""b1_square"", ""b2_vector""});; ; // Open the new file and list the columns of the tree; TFile f1(outFileName);; auto t = f1.Get<TTree>(treeName);; std::cout << ""These are the columns b1, b1_square and b2_vector:"" << std::endl;; for (auto branch : *t->GetListOfBranches()) {; std::cout << ""Branch: "" << branch->GetName() << std::endl;; }; f1.Close();; ; // We are not forced to write the full set of column names. We can also; // specify a regular expression for that. In case nothing is specified, all; // columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns);; ; // Open the new file and list the columns of the tree; TFile f2(outFileNameAllColumns);; t = f2.Get<TTree>(tree",MatchSource.WIKI,doc/master/df007__snapshot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8C.html
https://root.cern/doc/master/df007__snapshot_8C.html:382,Testability,test,test,382,". ROOT: tutorials/dataframe/df007_snapshot.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df007_snapshot.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Write ROOT data with RDataFrame. ; This tutorial shows how to write out datasets in ROOT format using RDataFrame. ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(10000);; int i(0);; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df007_snapshot(); {; // We prepare an input tree to run on; auto fileName = ""df007_snapshot.root"";; auto outFileName = ""df007_snapshot_output.root"";; auto outFileNameAllColumns = ""df007_snapshot_output_allColumns.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName);; ; // ## Select entries; // We now select some entries in the dataset; auto d_cut = d.Filter(""b1 % 2 == 0"");; // ## Enrich the dataset; // Build some temporary columns: we'll write them out; auto d2 = d_cut.Define(""b1_square"", ""b1 * b1""); .Define(""b2_vector"",; [](float b2) {; std::vector<float> v;; for (int i = 0; i < 3; i++); v.push_back(b2 * i);; return v;; },; {""b2""});; ; // ## Write it to disk in ROOT format; // We now write to disk a new dataset with one of the variables originally; // present in the tree and the new variables.; // The user can explicitly specify the types of the columns as template; // arguments of the Snapshot method, otherwise they will be automatically; // inferred.; d2.Snapshot(treeName, outFileName, {""b1"", ""b1_square"", ""b2_vector""});; ; // Open the new file and list the columns of the tree; TFile f1(outFileName);; auto t = f1.Get<TTree>(treeName);; std::cout << ""These are the columns b1, b1_square an",MatchSource.WIKI,doc/master/df007__snapshot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8C.html
https://root.cern/doc/master/df007__snapshot_8C.html:349,Usability,simpl,simple,349,". ROOT: tutorials/dataframe/df007_snapshot.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df007_snapshot.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Write ROOT data with RDataFrame. ; This tutorial shows how to write out datasets in ROOT format using RDataFrame. ; // A simple helper function to fill a test tree: this makes the example; // stand-alone.; void fill_tree(const char *treeName, const char *fileName); {; ROOT::RDataFrame d(10000);; int i(0);; d.Define(""b1"", [&i]() { return i; }); .Define(""b2"",; [&i]() {; float j = i * i;; ++i;; return j;; }); .Snapshot(treeName, fileName);; }; ; int df007_snapshot(); {; // We prepare an input tree to run on; auto fileName = ""df007_snapshot.root"";; auto outFileName = ""df007_snapshot_output.root"";; auto outFileNameAllColumns = ""df007_snapshot_output_allColumns.root"";; auto treeName = ""myTree"";; fill_tree(treeName, fileName);; ; // We read the tree from the file and create a RDataFrame; ROOT::RDataFrame d(treeName, fileName);; ; // ## Select entries; // We now select some entries in the dataset; auto d_cut = d.Filter(""b1 % 2 == 0"");; // ## Enrich the dataset; // Build some temporary columns: we'll write them out; auto d2 = d_cut.Define(""b1_square"", ""b1 * b1""); .Define(""b2_vector"",; [](float b2) {; std::vector<float> v;; for (int i = 0; i < 3; i++); v.push_back(b2 * i);; return v;; },; {""b2""});; ; // ## Write it to disk in ROOT format; // We now write to disk a new dataset with one of the variables originally; // present in the tree and the new variables.; // The user can explicitly specify the types of the columns as template; // arguments of the Snapshot method, otherwise they will be automatically; // inferred.; d2.Snapshot(treeName, outFileName, {""b1"", ""b1_square"", ""b2_vector""});; ; // Open the new file and list the columns of the tree; TFile f1(outFileName);; auto t = f1.Get<TTree>(treeName);; std::cout << ""These are the columns b1, b1_square an",MatchSource.WIKI,doc/master/df007__snapshot_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8C.html
https://root.cern/doc/master/df007__snapshot_8py.html:2470,Availability,avail,available,2470,"v.push_back(b2*i);; return v;; }; '''; ROOT.gInterpreter.Declare(getVector_code); ; d2 = d_cut.Define(""b1_square"", ""b1 * b1"") \; .Define(""b2_vector"", ""getVector( b2 )""); ; # ## Write it to disk in ROOT format; # We now write to disk a new dataset with one of the variables originally; # present in the tree and the new variables.; # The user can explicitly specify the types of the columns as template; # arguments of the Snapshot method, otherwise they will be automatically; # inferred.; d2.Snapshot(treeName, outFileName, \; [""b1"", ""b1_square"", ""b2_vector""]); # Open the new file and list the columns of the tree; f1 = ROOT.TFile(outFileName); t = f1[treeName]; print(""These are the columns b1, b1_square and b2_vector:""); for branch in t.GetListOfBranches():; print(""Branch: %s"" %branch.GetName()); ; f1.Close(); ; # We are not forced to write the full set of column names. We can also; # specify a regular expression for that. In case nothing is specified, all; # columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns); ; # Open the new file and list the columns of the tree; f2 = ROOT.TFile(outFileNameAllColumns); t = f2[treeName]; print(""These are all the columns available to this dataframe:""); for branch in t.GetListOfBranches():; print(""Branch: %s"" %branch.GetName()); ; f2.Close(); ; # We can also get a fresh RDataFrame out of the snapshot and restart the; # analysis chain from it.; ; snapshot_df = d2.Snapshot(treeName, outFileName, [""b1_square""]);; h = snapshot_df.Histo1D(""b1_square""); ; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df007_snapshot.png""); ; print(""Saved figure to df007_snapshot.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateApril 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df007_snapshot.py. tutorialsdataframedf007_snapshot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df007__snapshot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8py.html
https://root.cern/doc/master/df007__snapshot_8py.html:2975,Integrability,interface,interface,2975,"v.push_back(b2*i);; return v;; }; '''; ROOT.gInterpreter.Declare(getVector_code); ; d2 = d_cut.Define(""b1_square"", ""b1 * b1"") \; .Define(""b2_vector"", ""getVector( b2 )""); ; # ## Write it to disk in ROOT format; # We now write to disk a new dataset with one of the variables originally; # present in the tree and the new variables.; # The user can explicitly specify the types of the columns as template; # arguments of the Snapshot method, otherwise they will be automatically; # inferred.; d2.Snapshot(treeName, outFileName, \; [""b1"", ""b1_square"", ""b2_vector""]); # Open the new file and list the columns of the tree; f1 = ROOT.TFile(outFileName); t = f1[treeName]; print(""These are the columns b1, b1_square and b2_vector:""); for branch in t.GetListOfBranches():; print(""Branch: %s"" %branch.GetName()); ; f1.Close(); ; # We are not forced to write the full set of column names. We can also; # specify a regular expression for that. In case nothing is specified, all; # columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns); ; # Open the new file and list the columns of the tree; f2 = ROOT.TFile(outFileNameAllColumns); t = f2[treeName]; print(""These are all the columns available to this dataframe:""); for branch in t.GetListOfBranches():; print(""Branch: %s"" %branch.GetName()); ; f2.Close(); ; # We can also get a fresh RDataFrame out of the snapshot and restart the; # analysis chain from it.; ; snapshot_df = d2.Snapshot(treeName, outFileName, [""b1_square""]);; h = snapshot_df.Histo1D(""b1_square""); ; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df007_snapshot.png""); ; print(""Saved figure to df007_snapshot.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateApril 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df007_snapshot.py. tutorialsdataframedf007_snapshot.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df007__snapshot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8py.html
https://root.cern/doc/master/df007__snapshot_8py.html:1544,Modifiability,variab,variables,1544,"Frame(10000); df.Define(""b1"", ""(int) rdfentry_"")\; .Define(""b2"", ""(float) rdfentry_ * rdfentry_"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df007_snapshot_py.root""; outFileName = ""df007_snapshot_output_py.root""; outFileNameAllColumns = ""df007_snapshot_output_allColumns_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame; d = ROOT.RDataFrame(treeName, fileName); ; # ## Select entries; # We now select some entries in the dataset; d_cut = d.Filter(""b1 % 2 == 0""); # ## Enrich the dataset; # Build some temporary columns: we'll write them out; ; getVector_code ='''; std::vector<float> getVector (float b2); {; std::vector<float> v;; for (int i = 0; i < 3; i++) v.push_back(b2*i);; return v;; }; '''; ROOT.gInterpreter.Declare(getVector_code); ; d2 = d_cut.Define(""b1_square"", ""b1 * b1"") \; .Define(""b2_vector"", ""getVector( b2 )""); ; # ## Write it to disk in ROOT format; # We now write to disk a new dataset with one of the variables originally; # present in the tree and the new variables.; # The user can explicitly specify the types of the columns as template; # arguments of the Snapshot method, otherwise they will be automatically; # inferred.; d2.Snapshot(treeName, outFileName, \; [""b1"", ""b1_square"", ""b2_vector""]); # Open the new file and list the columns of the tree; f1 = ROOT.TFile(outFileName); t = f1[treeName]; print(""These are the columns b1, b1_square and b2_vector:""); for branch in t.GetListOfBranches():; print(""Branch: %s"" %branch.GetName()); ; f1.Close(); ; # We are not forced to write the full set of column names. We can also; # specify a regular expression for that. In case nothing is specified, all; # columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns); ; # Open the new file and list the columns of the tree; f2 = ROOT.TFile(outFileNameAllColumns); t = f2[treeName]; print(""These are all the columns available to this dataframe:""); for branc",MatchSource.WIKI,doc/master/df007__snapshot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8py.html
https://root.cern/doc/master/df007__snapshot_8py.html:1600,Modifiability,variab,variables,1600,"Frame(10000); df.Define(""b1"", ""(int) rdfentry_"")\; .Define(""b2"", ""(float) rdfentry_ * rdfentry_"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df007_snapshot_py.root""; outFileName = ""df007_snapshot_output_py.root""; outFileNameAllColumns = ""df007_snapshot_output_allColumns_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame; d = ROOT.RDataFrame(treeName, fileName); ; # ## Select entries; # We now select some entries in the dataset; d_cut = d.Filter(""b1 % 2 == 0""); # ## Enrich the dataset; # Build some temporary columns: we'll write them out; ; getVector_code ='''; std::vector<float> getVector (float b2); {; std::vector<float> v;; for (int i = 0; i < 3; i++) v.push_back(b2*i);; return v;; }; '''; ROOT.gInterpreter.Declare(getVector_code); ; d2 = d_cut.Define(""b1_square"", ""b1 * b1"") \; .Define(""b2_vector"", ""getVector( b2 )""); ; # ## Write it to disk in ROOT format; # We now write to disk a new dataset with one of the variables originally; # present in the tree and the new variables.; # The user can explicitly specify the types of the columns as template; # arguments of the Snapshot method, otherwise they will be automatically; # inferred.; d2.Snapshot(treeName, outFileName, \; [""b1"", ""b1_square"", ""b2_vector""]); # Open the new file and list the columns of the tree; f1 = ROOT.TFile(outFileName); t = f1[treeName]; print(""These are the columns b1, b1_square and b2_vector:""); for branch in t.GetListOfBranches():; print(""Branch: %s"" %branch.GetName()); ; f1.Close(); ; # We are not forced to write the full set of column names. We can also; # specify a regular expression for that. In case nothing is specified, all; # columns are persistified.; d2.Snapshot(treeName, outFileNameAllColumns); ; # Open the new file and list the columns of the tree; f2 = ROOT.TFile(outFileNameAllColumns); t = f2[treeName]; print(""These are all the columns available to this dataframe:""); for branc",MatchSource.WIKI,doc/master/df007__snapshot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8py.html
https://root.cern/doc/master/df007__snapshot_8py.html:411,Testability,test,test,411,". ROOT: tutorials/dataframe/df007_snapshot.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df007_snapshot.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Write ROOT data with RDataFrame. ; This tutorial shows how to write out datasets in ROOT format using RDataFrame. ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; def fill_tree(treeName, fileName):; df = ROOT.RDataFrame(10000); df.Define(""b1"", ""(int) rdfentry_"")\; .Define(""b2"", ""(float) rdfentry_ * rdfentry_"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df007_snapshot_py.root""; outFileName = ""df007_snapshot_output_py.root""; outFileNameAllColumns = ""df007_snapshot_output_allColumns_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame; d = ROOT.RDataFrame(treeName, fileName); ; # ## Select entries; # We now select some entries in the dataset; d_cut = d.Filter(""b1 % 2 == 0""); # ## Enrich the dataset; # Build some temporary columns: we'll write them out; ; getVector_code ='''; std::vector<float> getVector (float b2); {; std::vector<float> v;; for (int i = 0; i < 3; i++) v.push_back(b2*i);; return v;; }; '''; ROOT.gInterpreter.Declare(getVector_code); ; d2 = d_cut.Define(""b1_square"", ""b1 * b1"") \; .Define(""b2_vector"", ""getVector( b2 )""); ; # ## Write it to disk in ROOT format; # We now write to disk a new dataset with one of the variables originally; # present in the tree and the new variables.; # The user can explicitly specify the types of the columns as template; # arguments of the Snapshot method, otherwise they will be automatically; # inferred.; d2.Snapshot(treeName, outFileName, \; [""b1"", ""b1_square"", ""b2_vector""]); # Open the new file and list the columns of the tree; f1 = ROOT.TFile(outFileName); t = f1[treeName]; print(""These are the columns b1, b1_square and b2_vecto",MatchSource.WIKI,doc/master/df007__snapshot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8py.html
https://root.cern/doc/master/df007__snapshot_8py.html:378,Usability,simpl,simple,378,". ROOT: tutorials/dataframe/df007_snapshot.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df007_snapshot.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Write ROOT data with RDataFrame. ; This tutorial shows how to write out datasets in ROOT format using RDataFrame. ; import ROOT; ; # A simple helper function to fill a test tree: this makes the example stand-alone.; def fill_tree(treeName, fileName):; df = ROOT.RDataFrame(10000); df.Define(""b1"", ""(int) rdfentry_"")\; .Define(""b2"", ""(float) rdfentry_ * rdfentry_"").Snapshot(treeName, fileName); ; # We prepare an input tree to run on; fileName = ""df007_snapshot_py.root""; outFileName = ""df007_snapshot_output_py.root""; outFileNameAllColumns = ""df007_snapshot_output_allColumns_py.root""; treeName = ""myTree""; fill_tree(treeName, fileName); ; # We read the tree from the file and create a RDataFrame; d = ROOT.RDataFrame(treeName, fileName); ; # ## Select entries; # We now select some entries in the dataset; d_cut = d.Filter(""b1 % 2 == 0""); # ## Enrich the dataset; # Build some temporary columns: we'll write them out; ; getVector_code ='''; std::vector<float> getVector (float b2); {; std::vector<float> v;; for (int i = 0; i < 3; i++) v.push_back(b2*i);; return v;; }; '''; ROOT.gInterpreter.Declare(getVector_code); ; d2 = d_cut.Define(""b1_square"", ""b1 * b1"") \; .Define(""b2_vector"", ""getVector( b2 )""); ; # ## Write it to disk in ROOT format; # We now write to disk a new dataset with one of the variables originally; # present in the tree and the new variables.; # The user can explicitly specify the types of the columns as template; # arguments of the Snapshot method, otherwise they will be automatically; # inferred.; d2.Snapshot(treeName, outFileName, \; [""b1"", ""b1_square"", ""b2_vector""]); # Open the new file and list the columns of the tree; f1 = ROOT.TFile(outFileName); t = f1[treeName]; print(""These are the columns b1, b1_square and b2_vecto",MatchSource.WIKI,doc/master/df007__snapshot_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df007__snapshot_8py.html
https://root.cern/doc/master/df008__createDataSetFromScratch_8C.html:865,Integrability,interface,interface,865,". ROOT: tutorials/dataframe/df008_createDataSetFromScratch.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df008_createDataSetFromScratch.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Create data from scratch with RDataFrame. ; This tutorial shows how to create a dataset from scratch with RDataFrame; ; void df008_createDataSetFromScratch(); {; // We create an empty data frame of 100 entries; ROOT::RDataFrame df(100);; ; // We now fill it with random numbers; gRandom->SetSeed(1);; auto df_1 = df.Define(""rnd"", []() { return gRandom->Gaus(); });; ; // And we write out the dataset on disk; df_1.Snapshot(""randomNumbers"", ""df008_createDataSetFromScratch.root"");; }; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; df008_createDataSetFromScratchDefinition df008_createDataSetFromScratch.py:1; DateJune 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df008_createDataSetFromScratch.C. tutorialsdataframedf008_createDataSetFromScratch.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df008__createDataSetFromScratch_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df008__createDataSetFromScratch_8C.html
https://root.cern/doc/master/df008__createDataSetFromScratch_8py.html:772,Integrability,interface,interface,772,". ROOT: tutorials/dataframe/df008_createDataSetFromScratch.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df008_createDataSetFromScratch.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Create data from scratch with RDataFrame. ; This tutorial shows how to create a dataset from scratch with RDataFrame; ; import ROOT; ; # We create an empty data frame of 100 entries; df = ROOT.RDataFrame(100); ; # We now fill it with random numbers; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""rnd"", ""gRandom->Gaus()""); ; # And we write out the dataset on disk; df_1.Snapshot(""randomNumbers"", ""df008_createDataSetFromScratch_py.root""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateJune 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df008_createDataSetFromScratch.py. tutorialsdataframedf008_createDataSetFromScratch.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df008__createDataSetFromScratch_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df008__createDataSetFromScratch_8py.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:444,Integrability,interface,interfaces,444,". ROOT: tutorials/dataframe/df009_FromScratchVSTTree.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df009_FromScratchVSTTree.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Compare creation of a ROOT dataset with RDataFrame and TTree. ; This tutorial illustrates how much simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces.; ; // ##This is the classic way of creating a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""t",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:2265,Integrability,interface,interface,2265,":Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""treeName"", ""df009_FromScratchVSTTree_df.root"");; }; ; void df009_FromScratchVSTTree(); {; ; classicWay();; RDFWay();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; DateAugust 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df009_FromScratchVSTTree.C. tutorialsdataframedf009_FromScratchVSTTree.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:614,Modifiability,variab,variables,614,". ROOT: tutorials/dataframe/df009_FromScratchVSTTree.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df009_FromScratchVSTTree.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Compare creation of a ROOT dataset with RDataFrame and TTree. ; This tutorial illustrates how much simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces.; ; // ##This is the classic way of creating a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""t",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:694,Modifiability,variab,variables,694,". ROOT: tutorials/dataframe/df009_FromScratchVSTTree.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df009_FromScratchVSTTree.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Compare creation of a ROOT dataset with RDataFrame and TTree. ; This tutorial illustrates how much simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces.; ; // ##This is the classic way of creating a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""t",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:761,Modifiability,variab,variables,761,". ROOT: tutorials/dataframe/df009_FromScratchVSTTree.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df009_FromScratchVSTTree.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Compare creation of a ROOT dataset with RDataFrame and TTree. ; This tutorial illustrates how much simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces.; ; // ##This is the classic way of creating a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""t",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:819,Modifiability,variab,variables,819,". ROOT: tutorials/dataframe/df009_FromScratchVSTTree.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df009_FromScratchVSTTree.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Compare creation of a ROOT dataset with RDataFrame and TTree. ; This tutorial illustrates how much simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces.; ; // ##This is the classic way of creating a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""t",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:1427,Modifiability,variab,variables,1427,"ing a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""treeName"", ""df009_FromScratchVSTTree_df.root"");; }; ; void df009_FromScratchVSTTree(); {; ; classicWay();; RDFWay();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TTreeA TTree repre",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html:347,Usability,simpl,simpler,347,". ROOT: tutorials/dataframe/df009_FromScratchVSTTree.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df009_FromScratchVSTTree.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Compare creation of a ROOT dataset with RDataFrame and TTree. ; This tutorial illustrates how much simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces.; ; // ##This is the classic way of creating a ROOT dataset; // The steps are:; // - Create a file; // - Create a tree associated to the file; // - Define the variables to write in the entries; // - Define the branches associated to those variables; // - Write the event loop to set the right value to the variables; // - Call TTree::Fill to save the value of the variables; // - Write the TTree; // - Close the file; void classicWay(); {; TFile f(""df009_FromScratchVSTTree_classic.root"", ""RECREATE"");; TTree t(""treeName"", ""treeName"");; double b1;; int b2;; t.Branch(""b1"", &b1);; t.Branch(""b2"", &b2);; for (int i = 0; i < 10; ++i) {; b1 = i;; b2 = i * i;; t.Fill();; }; t.Write();; f.Close();; }; ; // ##This is the RDF way of creating a ROOT dataset; // Few lines are needed to achieve the same result.; // Parallel creation of the TTree is not supported in the; // classic method.; // In this case the steps are:; // - Create an empty RDataFrame; // - If needed, define variables for the functions used to fill the branches; // - Create new columns expressing their content with lambdas, functors, functions or strings; // - Invoke the Snapshot action; //; // Parallelism is not the only advantage. Starting from an existing dataset,; // filtering it, enriching it with new columns, leaving aside some other columns, and; // writing a new dataset become very easy to do.; void RDFWay(); {; ROOT::RDataFrame df(10);; auto b = 0.;; df.Define(""b1"", [&b]() { return b++; }); .Define(""b2"", ""(int) b1 * b1"") // This can even be a string; .Snapshot(""t",MatchSource.WIKI,doc/master/df009__FromScratchVSTTree_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df009__FromScratchVSTTree_8C.html
https://root.cern/doc/master/df010__trivialDataSource_8C.html:630,Availability,avail,available,630,". ROOT: tutorials/dataframe/df010_trivialDataSource.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df010_trivialDataSource.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the ""trivial data source"", an example data source implementation. ; This tutorial illustrates how use the RDataFrame in combination with a RDataSource. In this case we use a RTrivialDS, which is nothing more than a simple generator: it does not interface to any existing dataset. The RTrivialDS has a single column, col0, which has value n for entry n. The code for RTrivialDS is available at these links (header and source):; https://github.com/root-project/root/blob/master/tree/dataframe/src/RTrivialDS.cxx; https://github.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RTrivialDS.hxx. Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; int df010_trivialDataSource(); {; auto nEvents = 128U;; auto d_s = ROOT::RDF::MakeTrivialDataFrame(nEvents);; ; /// Now we have a regular RDataFrame: the ingestion of data is delegated to; /// the RDataSource. At this point everything works as before.; auto h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D({""h_s"", ""h_s"", 128, 0, .6}, ""x"");; ; /// Now we redo the same with a RDF from scratch and we draw the two histograms; ROOT::RDataFrame d(nEvents);; ; /// This lambda redoes what the RTrivialDS provides; auto g = []() {; static ULong64_t i = 0;; return i++;; };; auto h = d.Define(""col0"", g).Define(""x"", ""1./(1. + col0)"").Histo1D({""h"", ""h"", 128, 0, .6}, ""x"");; ; auto c_s = new TCanvas();; c_s->SetLogy();; h_s->DrawClone();; ; auto c = new TCanvas();; c->SetLogy();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha25",MatchSource.WIKI,doc/master/df010__trivialDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8C.html
https://root.cern/doc/master/df010__trivialDataSource_8C.html:495,Integrability,interface,interface,495,". ROOT: tutorials/dataframe/df010_trivialDataSource.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df010_trivialDataSource.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the ""trivial data source"", an example data source implementation. ; This tutorial illustrates how use the RDataFrame in combination with a RDataSource. In this case we use a RTrivialDS, which is nothing more than a simple generator: it does not interface to any existing dataset. The RTrivialDS has a single column, col0, which has value n for entry n. The code for RTrivialDS is available at these links (header and source):; https://github.com/root-project/root/blob/master/tree/dataframe/src/RTrivialDS.cxx; https://github.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RTrivialDS.hxx. Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; int df010_trivialDataSource(); {; auto nEvents = 128U;; auto d_s = ROOT::RDF::MakeTrivialDataFrame(nEvents);; ; /// Now we have a regular RDataFrame: the ingestion of data is delegated to; /// the RDataSource. At this point everything works as before.; auto h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D({""h_s"", ""h_s"", 128, 0, .6}, ""x"");; ; /// Now we redo the same with a RDF from scratch and we draw the two histograms; ROOT::RDataFrame d(nEvents);; ; /// This lambda redoes what the RTrivialDS provides; auto g = []() {; static ULong64_t i = 0;; return i++;; };; auto h = d.Define(""col0"", g).Define(""x"", ""1./(1. + col0)"").Histo1D({""h"", ""h"", 128, 0, .6}, ""x"");; ; auto c_s = new TCanvas();; c_s->SetLogy();; h_s->DrawClone();; ; auto c = new TCanvas();; c->SetLogy();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha25",MatchSource.WIKI,doc/master/df010__trivialDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8C.html
https://root.cern/doc/master/df010__trivialDataSource_8C.html:2139,Integrability,interface,interface,2139,"b.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RTrivialDS.hxx. Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; int df010_trivialDataSource(); {; auto nEvents = 128U;; auto d_s = ROOT::RDF::MakeTrivialDataFrame(nEvents);; ; /// Now we have a regular RDataFrame: the ingestion of data is delegated to; /// the RDataSource. At this point everything works as before.; auto h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D({""h_s"", ""h_s"", 128, 0, .6}, ""x"");; ; /// Now we redo the same with a RDF from scratch and we draw the two histograms; ROOT::RDataFrame d(nEvents);; ; /// This lambda redoes what the RTrivialDS provides; auto g = []() {; static ULong64_t i = 0;; return i++;; };; auto h = d.Define(""col0"", g).Define(""x"", ""1./(1. + col0)"").Histo1D({""h"", ""h"", 128, 0, .6}, ""x"");; ; auto c_s = new TCanvas();; c_s->SetLogy();; h_s->DrawClone();; ; auto c = new TCanvas();; c->SetLogy();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; ROOT::RDF::MakeTrivialDataFrameRInterface< RDFDetail::RLoopManager > MakeTrivialDataFrame()Make a RDF wrapping a RTrivialDS with infinite entries, for demo purposes.Definition RTrivialDS.cxx:130; df010_trivialDataSourceDefinition df010_trivialDataSource.py:1; DateSeptember 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df010_trivialDataSource.C. tutorialsdataframedf010_trivialDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df010__trivialDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8C.html
https://root.cern/doc/master/df010__trivialDataSource_8C.html:2371,Integrability,wrap,wrapping,2371,"b.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RTrivialDS.hxx. Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; int df010_trivialDataSource(); {; auto nEvents = 128U;; auto d_s = ROOT::RDF::MakeTrivialDataFrame(nEvents);; ; /// Now we have a regular RDataFrame: the ingestion of data is delegated to; /// the RDataSource. At this point everything works as before.; auto h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D({""h_s"", ""h_s"", 128, 0, .6}, ""x"");; ; /// Now we redo the same with a RDF from scratch and we draw the two histograms; ROOT::RDataFrame d(nEvents);; ; /// This lambda redoes what the RTrivialDS provides; auto g = []() {; static ULong64_t i = 0;; return i++;; };; auto h = d.Define(""col0"", g).Define(""x"", ""1./(1. + col0)"").Histo1D({""h"", ""h"", 128, 0, .6}, ""x"");; ; auto c_s = new TCanvas();; c_s->SetLogy();; h_s->DrawClone();; ; auto c = new TCanvas();; c->SetLogy();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; ROOT::RDF::MakeTrivialDataFrameRInterface< RDFDetail::RLoopManager > MakeTrivialDataFrame()Make a RDF wrapping a RTrivialDS with infinite entries, for demo purposes.Definition RTrivialDS.cxx:130; df010_trivialDataSourceDefinition df010_trivialDataSource.py:1; DateSeptember 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df010_trivialDataSource.C. tutorialsdataframedf010_trivialDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df010__trivialDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8C.html
https://root.cern/doc/master/df010__trivialDataSource_8C.html:465,Usability,simpl,simple,465,". ROOT: tutorials/dataframe/df010_trivialDataSource.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df010_trivialDataSource.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the ""trivial data source"", an example data source implementation. ; This tutorial illustrates how use the RDataFrame in combination with a RDataSource. In this case we use a RTrivialDS, which is nothing more than a simple generator: it does not interface to any existing dataset. The RTrivialDS has a single column, col0, which has value n for entry n. The code for RTrivialDS is available at these links (header and source):; https://github.com/root-project/root/blob/master/tree/dataframe/src/RTrivialDS.cxx; https://github.com/root-project/root/blob/master/tree/dataframe/inc/ROOT/RTrivialDS.hxx. Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; int df010_trivialDataSource(); {; auto nEvents = 128U;; auto d_s = ROOT::RDF::MakeTrivialDataFrame(nEvents);; ; /// Now we have a regular RDataFrame: the ingestion of data is delegated to; /// the RDataSource. At this point everything works as before.; auto h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D({""h_s"", ""h_s"", 128, 0, .6}, ""x"");; ; /// Now we redo the same with a RDF from scratch and we draw the two histograms; ROOT::RDataFrame d(nEvents);; ; /// This lambda redoes what the RTrivialDS provides; auto g = []() {; static ULong64_t i = 0;; return i++;; };; auto h = d.Define(""col0"", g).Define(""x"", ""1./(1. + col0)"").Histo1D({""h"", ""h"", 128, 0, .6}, ""x"");; ; auto c_s = new TCanvas();; c_s->SetLogy();; h_s->DrawClone();; ; auto c = new TCanvas();; c->SetLogy();; h->DrawClone();; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha25",MatchSource.WIKI,doc/master/df010__trivialDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8C.html
https://root.cern/doc/master/df010__trivialDataSource_8py.html:510,Integrability,interface,interface,510,". ROOT: tutorials/dataframe/df010_trivialDataSource.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df010_trivialDataSource.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the ""trivial data source"", an example data source implementation. ; This tutorial illustrates how use the RDataFrame in combination with a RDataSource. In this case we use a RTrivialDS, which is nothing more than a simple generator: it does not interface to any existing dataset. The RTrivialDS has a single column, col0, which has value n for entry n.; Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; import ROOT; ; # Create the data frame; MakeTrivialDataFrame = ROOT.RDF.MakeTrivialDataFrame; ; nEvents = 128; ; d_s = MakeTrivialDataFrame(nEvents); ; # Now we have a regular RDataFrame: the ingestion of data is delegated to; # the RDataSource. At this point everything works as before.; h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D((""h_s"", ""h_s"", 128, 0, .6), ""x""); ; c = ROOT.TCanvas(); c.SetLogy(); h_s.Draw(); c.SaveAs(""df010_trivialDataSource.png""); ; print(""Saved figure to df010_trivialDataSource.png""); DateSeptember 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df010_trivialDataSource.py. tutorialsdataframedf010_trivialDataSource.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df010__trivialDataSource_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8py.html
https://root.cern/doc/master/df010__trivialDataSource_8py.html:480,Usability,simpl,simple,480,". ROOT: tutorials/dataframe/df010_trivialDataSource.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df010_trivialDataSource.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the ""trivial data source"", an example data source implementation. ; This tutorial illustrates how use the RDataFrame in combination with a RDataSource. In this case we use a RTrivialDS, which is nothing more than a simple generator: it does not interface to any existing dataset. The RTrivialDS has a single column, col0, which has value n for entry n.; Note that RTrivialDS is only a demo data source implementation and superior alternatives typically exist for production use (e.g. constructing an empty RDataFrame as RDataFrame(nEntries)).; ; import ROOT; ; # Create the data frame; MakeTrivialDataFrame = ROOT.RDF.MakeTrivialDataFrame; ; nEvents = 128; ; d_s = MakeTrivialDataFrame(nEvents); ; # Now we have a regular RDataFrame: the ingestion of data is delegated to; # the RDataSource. At this point everything works as before.; h_s = d_s.Define(""x"", ""1./(1. + col0)"").Histo1D((""h_s"", ""h_s"", 128, 0, .6), ""x""); ; c = ROOT.TCanvas(); c.SetLogy(); h_s.Draw(); c.SaveAs(""df010_trivialDataSource.png""); ; print(""Saved figure to df010_trivialDataSource.png""); DateSeptember 2017 ; AuthorDanilo Piparo (CERN) ; Definition in file df010_trivialDataSource.py. tutorialsdataframedf010_trivialDataSource.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df010__trivialDataSource_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df010__trivialDataSource_8py.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html:1199,Availability,failure,failures,1199,"enceTutorials  Dataframe tutorials. Detailed Description; Use just-in-time-compiled Filters and Defines for quick prototyping. ; This tutorial illustrates how to save some typing when using RDataFrame by invoking functions that perform jit-compiling at runtime.; ; void df012_DefinesAndFiltersAsStrings(); {; // We will inefficiently calculate an approximation of pi by generating; // some data, and doing very simple filtering and analysis on it.; ; // We start by creating an empty dataframe where we will insert 10 million; // random points in a square of side 2.0 (that is, with an inscribed circle; // of radius 1.0).; ; size_t npoints = 10000000;; ROOT::RDataFrame df(npoints);; ; // Define what we want inside the dataframe. We do not need to define p as an array,; // but we do it here to demonstrate how to use jitting with RDataFrame.; ; // NOTE: Although it's possible to use ""for (auto&& x : p)"" below, it will; // shadow the name of the data column ""x"", and may cause compilation failures; // if the local variable and the data column are of different types, or the; // local x variable is declared in the global scope of the lambda function.; ; auto pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""p"", ""std::array<double, 2> v{x, y}; return v;""); .Define(""r"", ""double r2 = 0.0; for (auto&& x : p) r2 += x*x; return sqrt(r2);"");; ; // Now we have a dataframe with columns x, y, p (which is a point based on x; // and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; // need to know how many of our data points fall inside the unit circle compared; // with the total number of points. The ratio of the areas is; //; // A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; //; // Therefore, we can approximate pi with four times the number of points inside the; // unit circle over the total number of points in our dataframe:; ; auto incircle = *(pidf.Filter(""r <= 1.0"").Count());; ; double p",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html:2384,Integrability,interface,interface,2384,"000000;; ROOT::RDataFrame df(npoints);; ; // Define what we want inside the dataframe. We do not need to define p as an array,; // but we do it here to demonstrate how to use jitting with RDataFrame.; ; // NOTE: Although it's possible to use ""for (auto&& x : p)"" below, it will; // shadow the name of the data column ""x"", and may cause compilation failures; // if the local variable and the data column are of different types, or the; // local x variable is declared in the global scope of the lambda function.; ; auto pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""p"", ""std::array<double, 2> v{x, y}; return v;""); .Define(""r"", ""double r2 = 0.0; for (auto&& x : p) r2 += x*x; return sqrt(r2);"");; ; // Now we have a dataframe with columns x, y, p (which is a point based on x; // and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; // need to know how many of our data points fall inside the unit circle compared; // with the total number of points. The ratio of the areas is; //; // A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; //; // Therefore, we can approximate pi with four times the number of points inside the; // unit circle over the total number of points in our dataframe:; ; auto incircle = *(pidf.Filter(""r <= 1.0"").Count());; ; double pi_approx = 4.0 * incircle / npoints;; ; std::cout << ""pi is approximately equal to "" << pi_approx << std::endl;; }; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df012_DefinesAndFiltersAsStringsDefinition df012_DefinesAndFiltersAsStrings.py:1; ; pi is approximately equal to 3.14146; DateOctober 2017 ; AuthorGuilherme Amadio (CERN) ; Definition in file df012_DefinesAndFiltersAsStrings.C. tutorialsdataframedf012_DefinesAndFiltersAsStrings.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html:1225,Modifiability,variab,variable,1225,"enceTutorials  Dataframe tutorials. Detailed Description; Use just-in-time-compiled Filters and Defines for quick prototyping. ; This tutorial illustrates how to save some typing when using RDataFrame by invoking functions that perform jit-compiling at runtime.; ; void df012_DefinesAndFiltersAsStrings(); {; // We will inefficiently calculate an approximation of pi by generating; // some data, and doing very simple filtering and analysis on it.; ; // We start by creating an empty dataframe where we will insert 10 million; // random points in a square of side 2.0 (that is, with an inscribed circle; // of radius 1.0).; ; size_t npoints = 10000000;; ROOT::RDataFrame df(npoints);; ; // Define what we want inside the dataframe. We do not need to define p as an array,; // but we do it here to demonstrate how to use jitting with RDataFrame.; ; // NOTE: Although it's possible to use ""for (auto&& x : p)"" below, it will; // shadow the name of the data column ""x"", and may cause compilation failures; // if the local variable and the data column are of different types, or the; // local x variable is declared in the global scope of the lambda function.; ; auto pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""p"", ""std::array<double, 2> v{x, y}; return v;""); .Define(""r"", ""double r2 = 0.0; for (auto&& x : p) r2 += x*x; return sqrt(r2);"");; ; // Now we have a dataframe with columns x, y, p (which is a point based on x; // and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; // need to know how many of our data points fall inside the unit circle compared; // with the total number of points. The ratio of the areas is; //; // A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; //; // Therefore, we can approximate pi with four times the number of points inside the; // unit circle over the total number of points in our dataframe:; ; auto incircle = *(pidf.Filter(""r <= 1.0"").Count());; ; double p",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html:1297,Modifiability,variab,variable,1297,"enceTutorials  Dataframe tutorials. Detailed Description; Use just-in-time-compiled Filters and Defines for quick prototyping. ; This tutorial illustrates how to save some typing when using RDataFrame by invoking functions that perform jit-compiling at runtime.; ; void df012_DefinesAndFiltersAsStrings(); {; // We will inefficiently calculate an approximation of pi by generating; // some data, and doing very simple filtering and analysis on it.; ; // We start by creating an empty dataframe where we will insert 10 million; // random points in a square of side 2.0 (that is, with an inscribed circle; // of radius 1.0).; ; size_t npoints = 10000000;; ROOT::RDataFrame df(npoints);; ; // Define what we want inside the dataframe. We do not need to define p as an array,; // but we do it here to demonstrate how to use jitting with RDataFrame.; ; // NOTE: Although it's possible to use ""for (auto&& x : p)"" below, it will; // shadow the name of the data column ""x"", and may cause compilation failures; // if the local variable and the data column are of different types, or the; // local x variable is declared in the global scope of the lambda function.; ; auto pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""p"", ""std::array<double, 2> v{x, y}; return v;""); .Define(""r"", ""double r2 = 0.0; for (auto&& x : p) r2 += x*x; return sqrt(r2);"");; ; // Now we have a dataframe with columns x, y, p (which is a point based on x; // and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; // need to know how many of our data points fall inside the unit circle compared; // with the total number of points. The ratio of the areas is; //; // A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; //; // Therefore, we can approximate pi with four times the number of points inside the; // unit circle over the total number of points in our dataframe:; ; auto incircle = *(pidf.Filter(""r <= 1.0"").Count());; ; double p",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html:434,Performance,perform,perform,434,". ROOT: tutorials/dataframe/df012_DefinesAndFiltersAsStrings.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df012_DefinesAndFiltersAsStrings.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use just-in-time-compiled Filters and Defines for quick prototyping. ; This tutorial illustrates how to save some typing when using RDataFrame by invoking functions that perform jit-compiling at runtime.; ; void df012_DefinesAndFiltersAsStrings(); {; // We will inefficiently calculate an approximation of pi by generating; // some data, and doing very simple filtering and analysis on it.; ; // We start by creating an empty dataframe where we will insert 10 million; // random points in a square of side 2.0 (that is, with an inscribed circle; // of radius 1.0).; ; size_t npoints = 10000000;; ROOT::RDataFrame df(npoints);; ; // Define what we want inside the dataframe. We do not need to define p as an array,; // but we do it here to demonstrate how to use jitting with RDataFrame.; ; // NOTE: Although it's possible to use ""for (auto&& x : p)"" below, it will; // shadow the name of the data column ""x"", and may cause compilation failures; // if the local variable and the data column are of different types, or the; // local x variable is declared in the global scope of the lambda function.; ; auto pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""p"", ""std::array<double, 2> v{x, y}; return v;""); .Define(""r"", ""double r2 = 0.0; for (auto&& x : p) r2 += x*x; return sqrt(r2);"");; ; // Now we have a dataframe with columns x, y, p (which is a point based on x; // and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; // need to know how many of our data points fall inside the unit circle compared; // with the total number of points. The ratio of the areas is; //; // A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; //; // Therefor",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html:617,Usability,simpl,simple,617,". ROOT: tutorials/dataframe/df012_DefinesAndFiltersAsStrings.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df012_DefinesAndFiltersAsStrings.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use just-in-time-compiled Filters and Defines for quick prototyping. ; This tutorial illustrates how to save some typing when using RDataFrame by invoking functions that perform jit-compiling at runtime.; ; void df012_DefinesAndFiltersAsStrings(); {; // We will inefficiently calculate an approximation of pi by generating; // some data, and doing very simple filtering and analysis on it.; ; // We start by creating an empty dataframe where we will insert 10 million; // random points in a square of side 2.0 (that is, with an inscribed circle; // of radius 1.0).; ; size_t npoints = 10000000;; ROOT::RDataFrame df(npoints);; ; // Define what we want inside the dataframe. We do not need to define p as an array,; // but we do it here to demonstrate how to use jitting with RDataFrame.; ; // NOTE: Although it's possible to use ""for (auto&& x : p)"" below, it will; // shadow the name of the data column ""x"", and may cause compilation failures; // if the local variable and the data column are of different types, or the; // local x variable is declared in the global scope of the lambda function.; ; auto pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)""); .Define(""p"", ""std::array<double, 2> v{x, y}; return v;""); .Define(""r"", ""double r2 = 0.0; for (auto&& x : p) r2 += x*x; return sqrt(r2);"");; ; // Now we have a dataframe with columns x, y, p (which is a point based on x; // and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; // need to know how many of our data points fall inside the unit circle compared; // with the total number of points. The ratio of the areas is; //; // A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; //; // Therefor",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8C.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8py.html:2003,Integrability,interface,interface,2003,"it-compiling features of RDataFrame to define data using C++ code in a Python script.; ; import ROOT; ; ## We will inefficiently calculate an approximation of pi by generating; ## some data and doing very simple filtering and analysis on it.; ; ## We start by creating an empty dataframe where we will insert 10 million; ## random points in a square of side 2.0 (that is, with an inscribed unit; ## circle).; ; npoints = 10000000; df = ROOT.RDataFrame(npoints); ; ## Define what data we want inside the dataframe. We do not need to define p; ## as an array, but we do it here to demonstrate how to use jitting with RDataFrame.; ; pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)"") \; .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)"") \; .Define(""p"", ""std::array<double, 2> v{x, y}; return v;"") \; .Define(""r"", ""double r2 = 0.0; for (auto&& w : p) r2 += w*w; return sqrt(r2);""); ; ## Now we have a dataframe with columns x, y, p (which is a point based on x; ## and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; ## need to know how many of our data points fall inside the circle of radius; ## one compared with the total number of points. The ratio of the areas is; ##; ## A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; ##; ## Therefore, we can approximate pi with four times the number of points inside; ## the unit circle over the total number of points:; ; incircle = pidf.Filter(""r <= 1.0"").Count().GetValue(); ; pi_approx = 4.0 * incircle / npoints; ; print(""pi is approximately equal to %g"" % (pi_approx)); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; pi is approximately equal to 3.14146; DateOctober 2017 ; AuthorGuilherme Amadio (CERN) ; Definition in file df012_DefinesAndFiltersAsStrings.py. tutorialsdataframedf012_DefinesAndFiltersAsStrings.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8py.html
https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8py.html:593,Usability,simpl,simple,593,". ROOT: tutorials/dataframe/df012_DefinesAndFiltersAsStrings.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df012_DefinesAndFiltersAsStrings.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use just-in-time-compiled Filters and Defines for quick prototyping. ; This tutorial illustrates how to use jit-compiling features of RDataFrame to define data using C++ code in a Python script.; ; import ROOT; ; ## We will inefficiently calculate an approximation of pi by generating; ## some data and doing very simple filtering and analysis on it.; ; ## We start by creating an empty dataframe where we will insert 10 million; ## random points in a square of side 2.0 (that is, with an inscribed unit; ## circle).; ; npoints = 10000000; df = ROOT.RDataFrame(npoints); ; ## Define what data we want inside the dataframe. We do not need to define p; ## as an array, but we do it here to demonstrate how to use jitting with RDataFrame.; ; pidf = df.Define(""x"", ""gRandom->Uniform(-1.0, 1.0)"") \; .Define(""y"", ""gRandom->Uniform(-1.0, 1.0)"") \; .Define(""p"", ""std::array<double, 2> v{x, y}; return v;"") \; .Define(""r"", ""double r2 = 0.0; for (auto&& w : p) r2 += w*w; return sqrt(r2);""); ; ## Now we have a dataframe with columns x, y, p (which is a point based on x; ## and y), and the radius r = sqrt(x*x + y*y). In order to approximate pi, we; ## need to know how many of our data points fall inside the circle of radius; ## one compared with the total number of points. The ratio of the areas is; ##; ## A_circle / A_square = pi r*r / l * l, where r = 1.0, and l = 2.0; ##; ## Therefore, we can approximate pi with four times the number of points inside; ## the unit circle over the total number of points:; ; incircle = pidf.Filter(""r <= 1.0"").Count().GetValue(); ; pi_approx = 4.0 * incircle / npoints; ; print(""pi is approximately equal to %g"" % (pi_approx)); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-leve",MatchSource.WIKI,doc/master/df012__DefinesAndFiltersAsStrings_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df012__DefinesAndFiltersAsStrings_8py.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:259,Deployability,update,update,259,". ROOT: tutorials/dataframe/df013_InspectAnalysis.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df013_InspectAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use callbacks to update a plot and a progress bar during the event loop. ; Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot. This tutorial is not meant to run in batch mode.; ; using namespace ROOT; // RDataFrame lives in here; ; void df013_InspectAnalysis(); {; ROOT::EnableImplicitMT();; const auto poolSize = ROOT::GetThreadPoolSize();; const auto nSlots = 0 == poolSize ? 1 : poolSize;; ; // ## Setup a simple RDataFrame; // We start by creating a RDataFrame with a good number of empty events; const auto nEvents = nSlots * 10000ull;; RDataFrame d(nEvents);; ; // `heavyWork` is a lambda that fakes some interesting computation and just returns a normally distributed double; TRandom r;; auto heavyWork = [&r]() {; for (volatile int i = 0; i < 1000000; ++i); ;; return r.Gaus();; };; ; // Let's define a column ""x"" produced by invoking `heavyWork` for each event; // `df` stores a modified data-frame that contains ""x""; auto df = d.Define(""x"", heavyWork);; ; // Now we register a histogram-filling action with the RDataFrame.; // `h` can be used just like a pointer to TH1D but it is actually a TResultProxy<TH1D>, a smart object that triggers; // an event-loop to fill the pointee histogram if needed.; auto h = df.Histo1D<double>({""browserHisto"", """", 100, -2., 2.}, ""x"");; ; // ## Use the callback mechanism to draw the histogram on a TBrowser while it is being filled; // So far we have registered a column ""x"" to a data-frame with `nEvents` events and we registered the filling of a; // histogram with the values of column ""x"".; // In the following we will register three functions for execution during the event-loop:; // - one is to be executed on",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:3745,Deployability,update,updated,3745,"e per specified number of events during the event-loop, on ""partial"" versions of the result objects; // contained in the `TResultProxy`. In this case, the partial result is going to be a histogram filled with an; // increasing number of events.; // Instead of requesting the callback to be executed every N entries, this time we use the special value `kOnce` to; // request that it is executed once right before starting the event-loop.; // The callback is a C++11 lambda that registers the partial result object in `dfDirectory`.; h.OnPartialResult(h.kOnce, [dfDirectory](TH1D &h_) { dfDirectory->Add(&h_); });; // Note that we called `OnPartialResult` with a dot, `.`, since this is a method of `TResultProxy` itself.; // We do not want to call `OnPartialResult` on the pointee histogram!); ; // Multiple callbacks can be registered on the same `TResultProxy` (they are executed one after the other in the; // same order as they were registered). We now request that the partial result is drawn and the TBrowser's TPad is; // updated every 50 events.; h.OnPartialResult(50, [&browserPad](TH1D &hist) {; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; hist.Draw();; browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callbac",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5517,Deployability,release,releases,5517,"that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first; // time. Let's run!; std::cout << ""Analysis running..."" << std::endl;; h->Draw(); // the final, complete result will be drawn after the event-loop has completed.; std::cout << ""\nDone!"" << std::endl;; ; // Finally, some book-keeping: in the TMemFile that we are using as TBrowser directory, we substitute the partial",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4985,Integrability,synchroniz,synchronization,4985,"browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the prog",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:7301,Integrability,interface,interface,7301,"t << ""\nDone!"" << std::endl;; ; // Finally, some book-keeping: in the TMemFile that we are using as TBrowser directory, we substitute the partial; // result with a clone of the final result (the ""original"" final result will be deleted at the end of the macro).; dfDirectory->Clear();; auto clone = static_cast<TH1D *>(h->Clone());; clone->SetDirectory(nullptr);; dfDirectory->Add(clone);; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; clone->Draw();; browserPad->Update();; }; d#define d(i)Definition RSha256.hxx:102; h#define h(i)Definition RSha256.hxx:106; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory.Definition TMemFile.h:19; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb..",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:2549,Modifiability,variab,variable,2549,"aFrame.; // `h` can be used just like a pointer to TH1D but it is actually a TResultProxy<TH1D>, a smart object that triggers; // an event-loop to fill the pointee histogram if needed.; auto h = df.Histo1D<double>({""browserHisto"", """", 100, -2., 2.}, ""x"");; ; // ## Use the callback mechanism to draw the histogram on a TBrowser while it is being filled; // So far we have registered a column ""x"" to a data-frame with `nEvents` events and we registered the filling of a; // histogram with the values of column ""x"".; // In the following we will register three functions for execution during the event-loop:; // - one is to be executed once just before the loop and adds a partially-filled histogram to a TBrowser; // - the next is executed every 50 events and draws the partial histogram on the TBrowser's TPad; // - another callback is responsible of updating a simple progress bar from multiple threads; ; // First off we create a TBrowser that contains a ""RDFResults"" directory; auto dfDirectory = new TMemFile(""RDFResults"", ""RECREATE"");; auto browser = new TBrowser(""b"", dfDirectory);; // The global pad should now be set to the TBrowser's canvas, let's store its value in a local variable; auto browserPad = gPad;; ; // A useful feature of `TResultProxy` is its `OnPartialResult` method: it allows us to register a callback that is; // executed once per specified number of events during the event-loop, on ""partial"" versions of the result objects; // contained in the `TResultProxy`. In this case, the partial result is going to be a histogram filled with an; // increasing number of events.; // Instead of requesting the callback to be executed every N entries, this time we use the special value `kOnce` to; // request that it is executed once right before starting the event-loop.; // The callback is a C++11 lambda that registers the partial result object in `dfDirectory`.; h.OnPartialResult(h.kOnce, [dfDirectory](TH1D &h_) { dfDirectory->Add(&h_); });; // Note that we called `OnPartialRes",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4537,Performance,concurren,concurrent,4537," `TResultProxy` (they are executed one after the other in the; // same order as they were registered). We now request that the partial result is drawn and the TBrowser's TPad is; // updated every 50 events.; h.OnPartialResult(50, [&browserPad](TH1D &hist) {; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; hist.Draw();; browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_b",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5121,Performance,concurren,concurrent,5121,"ly, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first;",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:8414,Performance,multi-thread,multi-threading,8414,"nt const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory.Definition TMemFile.h:19; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; lTLine lDefinition textangle.C:4; DateSeptember 2017 ; AuthorEnrico Guiraud (CERN) ; Definition in file df013_InspectAnalysis.C. tutorialsdataframedf013_InspectAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4573,Safety,safe,safety,4573," `TResultProxy` (they are executed one after the other in the; // same order as they were registered). We now request that the partial result is drawn and the TBrowser's TPad is; // updated every 50 events.; h.OnPartialResult(50, [&browserPad](TH1D &hist) {; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; hist.Draw();; browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_b",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5115,Safety,avoid,avoid,5115,"ly, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first;",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:6064,Security,access,accessing,6064,"want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first; // time. Let's run!; std::cout << ""Analysis running..."" << std::endl;; h->Draw(); // the final, complete result will be drawn after the event-loop has completed.; std::cout << ""\nDone!"" << std::endl;; ; // Finally, some book-keeping: in the TMemFile that we are using as TBrowser directory, we substitute the partial; // result with a clone of the final result (the ""original"" final result will be deleted at the end of the macro).; dfDirectory->Clear();; auto clone = static_cast<TH1D *>(h->Clone());; clone->SetDirectory(nullptr);; dfDirectory->Add(clone);; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; clone->Draw();; browserPad->Update();; }; d#define d(i)Definition RSha256.hxx:102; h#d",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:279,Usability,progress bar,progress bar,279,". ROOT: tutorials/dataframe/df013_InspectAnalysis.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df013_InspectAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use callbacks to update a plot and a progress bar during the event loop. ; Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot. This tutorial is not meant to run in batch mode.; ; using namespace ROOT; // RDataFrame lives in here; ; void df013_InspectAnalysis(); {; ROOT::EnableImplicitMT();; const auto poolSize = ROOT::GetThreadPoolSize();; const auto nSlots = 0 == poolSize ? 1 : poolSize;; ; // ## Setup a simple RDataFrame; // We start by creating a RDataFrame with a good number of empty events; const auto nEvents = nSlots * 10000ull;; RDataFrame d(nEvents);; ; // `heavyWork` is a lambda that fakes some interesting computation and just returns a normally distributed double; TRandom r;; auto heavyWork = [&r]() {; for (volatile int i = 0; i < 1000000; ++i); ;; return r.Gaus();; };; ; // Let's define a column ""x"" produced by invoking `heavyWork` for each event; // `df` stores a modified data-frame that contains ""x""; auto df = d.Define(""x"", heavyWork);; ; // Now we register a histogram-filling action with the RDataFrame.; // `h` can be used just like a pointer to TH1D but it is actually a TResultProxy<TH1D>, a smart object that triggers; // an event-loop to fill the pointee histogram if needed.; auto h = df.Histo1D<double>({""browserHisto"", """", 100, -2., 2.}, ""x"");; ; // ## Use the callback mechanism to draw the histogram on a TBrowser while it is being filled; // So far we have registered a column ""x"" to a data-frame with `nEvents` events and we registered the filling of a; // histogram with the values of column ""x"".; // In the following we will register three functions for execution during the event-loop:; // - one is to be executed on",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:750,Usability,simpl,simple,750,". ROOT: tutorials/dataframe/df013_InspectAnalysis.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df013_InspectAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use callbacks to update a plot and a progress bar during the event loop. ; Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot. This tutorial is not meant to run in batch mode.; ; using namespace ROOT; // RDataFrame lives in here; ; void df013_InspectAnalysis(); {; ROOT::EnableImplicitMT();; const auto poolSize = ROOT::GetThreadPoolSize();; const auto nSlots = 0 == poolSize ? 1 : poolSize;; ; // ## Setup a simple RDataFrame; // We start by creating a RDataFrame with a good number of empty events; const auto nEvents = nSlots * 10000ull;; RDataFrame d(nEvents);; ; // `heavyWork` is a lambda that fakes some interesting computation and just returns a normally distributed double; TRandom r;; auto heavyWork = [&r]() {; for (volatile int i = 0; i < 1000000; ++i); ;; return r.Gaus();; };; ; // Let's define a column ""x"" produced by invoking `heavyWork` for each event; // `df` stores a modified data-frame that contains ""x""; auto df = d.Define(""x"", heavyWork);; ; // Now we register a histogram-filling action with the RDataFrame.; // `h` can be used just like a pointer to TH1D but it is actually a TResultProxy<TH1D>, a smart object that triggers; // an event-loop to fill the pointee histogram if needed.; auto h = df.Histo1D<double>({""browserHisto"", """", 100, -2., 2.}, ""x"");; ; // ## Use the callback mechanism to draw the histogram on a TBrowser while it is being filled; // So far we have registered a column ""x"" to a data-frame with `nEvents` events and we registered the filling of a; // histogram with the values of column ""x"".; // In the following we will register three functions for execution during the event-loop:; // - one is to be executed on",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:2227,Usability,simpl,simple,2227,"aFrame.; // `h` can be used just like a pointer to TH1D but it is actually a TResultProxy<TH1D>, a smart object that triggers; // an event-loop to fill the pointee histogram if needed.; auto h = df.Histo1D<double>({""browserHisto"", """", 100, -2., 2.}, ""x"");; ; // ## Use the callback mechanism to draw the histogram on a TBrowser while it is being filled; // So far we have registered a column ""x"" to a data-frame with `nEvents` events and we registered the filling of a; // histogram with the values of column ""x"".; // In the following we will register three functions for execution during the event-loop:; // - one is to be executed once just before the loop and adds a partially-filled histogram to a TBrowser; // - the next is executed every 50 events and draws the partial histogram on the TBrowser's TPad; // - another callback is responsible of updating a simple progress bar from multiple threads; ; // First off we create a TBrowser that contains a ""RDFResults"" directory; auto dfDirectory = new TMemFile(""RDFResults"", ""RECREATE"");; auto browser = new TBrowser(""b"", dfDirectory);; // The global pad should now be set to the TBrowser's canvas, let's store its value in a local variable; auto browserPad = gPad;; ; // A useful feature of `TResultProxy` is its `OnPartialResult` method: it allows us to register a callback that is; // executed once per specified number of events during the event-loop, on ""partial"" versions of the result objects; // contained in the `TResultProxy`. In this case, the partial result is going to be a histogram filled with an; // increasing number of events.; // Instead of requesting the callback to be executed every N entries, this time we use the special value `kOnce` to; // request that it is executed once right before starting the event-loop.; // The callback is a C++11 lambda that registers the partial result object in `dfDirectory`.; h.OnPartialResult(h.kOnce, [dfDirectory](TH1D &h_) { dfDirectory->Add(&h_); });; // Note that we called `OnPartialRes",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:2234,Usability,progress bar,progress bar,2234,"aFrame.; // `h` can be used just like a pointer to TH1D but it is actually a TResultProxy<TH1D>, a smart object that triggers; // an event-loop to fill the pointee histogram if needed.; auto h = df.Histo1D<double>({""browserHisto"", """", 100, -2., 2.}, ""x"");; ; // ## Use the callback mechanism to draw the histogram on a TBrowser while it is being filled; // So far we have registered a column ""x"" to a data-frame with `nEvents` events and we registered the filling of a; // histogram with the values of column ""x"".; // In the following we will register three functions for execution during the event-loop:; // - one is to be executed once just before the loop and adds a partially-filled histogram to a TBrowser; // - the next is executed every 50 events and draws the partial histogram on the TBrowser's TPad; // - another callback is responsible of updating a simple progress bar from multiple threads; ; // First off we create a TBrowser that contains a ""RDFResults"" directory; auto dfDirectory = new TMemFile(""RDFResults"", ""RECREATE"");; auto browser = new TBrowser(""b"", dfDirectory);; // The global pad should now be set to the TBrowser's canvas, let's store its value in a local variable; auto browserPad = gPad;; ; // A useful feature of `TResultProxy` is its `OnPartialResult` method: it allows us to register a callback that is; // executed once per specified number of events during the event-loop, on ""partial"" versions of the result objects; // contained in the `TResultProxy`. In this case, the partial result is going to be a histogram filled with an; // increasing number of events.; // Instead of requesting the callback to be executed every N entries, this time we use the special value `kOnce` to; // request that it is executed once right before starting the event-loop.; // The callback is a C++11 lambda that registers the partial result object in `dfDirectory`.; h.OnPartialResult(h.kOnce, [dfDirectory](TH1D &h_) { dfDirectory->Add(&h_); });; // Note that we called `OnPartialRes",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4147,Usability,progress bar,progress bar,4147," value `kOnce` to; // request that it is executed once right before starting the event-loop.; // The callback is a C++11 lambda that registers the partial result object in `dfDirectory`.; h.OnPartialResult(h.kOnce, [dfDirectory](TH1D &h_) { dfDirectory->Add(&h_); });; // Note that we called `OnPartialResult` with a dot, `.`, since this is a method of `TResultProxy` itself.; // We do not want to call `OnPartialResult` on the pointee histogram!); ; // Multiple callbacks can be registered on the same `TResultProxy` (they are executed one after the other in the; // same order as they were registered). We now request that the partial result is drawn and the TBrowser's TPad is; // updated every 50 events.; h.OnPartialResult(50, [&browserPad](TH1D &hist) {; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; hist.Draw();; browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:4855,Usability,progress bar,progress bar,4855,"browserPad->Update();; // This call tells ROOT to process all pending GUI events; // It allows users to use the TBrowser as usual while the event-loop is running; gSystem->ProcessEvents();; });; ; // Finally, we would like to print a progress bar on the terminal to show how the event-loop is progressing.; // To take into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the prog",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5176,Usability,progress bar,progress bars,5176,"ake into account _all_ events we use `OnPartialResultSlot`: when Implicit Multi-Threading is enabled, in fact,; // `OnPartialResult` invokes the callback only in one of the worker threads, and always returns that worker threads'; // partial result. This is useful because it means we don't have to worry about concurrent execution and; // thread-safety of the callbacks if we are happy with just one threads' partial result.; // `OnPartialResultSlot`, on the other hand, invokes the callback in each one of the worker threads, every time a; // thread finishes processing a batch of `everyN` events. This is what we want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first; // time. Let's run!; std::cout << ""Analysis running..."" << std::endl;; h->Draw(); // the final, complete res",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5604,Usability,progress bar,progress bar,5604,"want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first; // time. Let's run!; std::cout << ""Analysis running..."" << std::endl;; h->Draw(); // the final, complete result will be drawn after the event-loop has completed.; std::cout << ""\nDone!"" << std::endl;; ; // Finally, some book-keeping: in the TMemFile that we are using as TBrowser directory, we substitute the partial; // result with a clone of the final result (the ""original"" final result will be deleted at the end of the macro).; dfDirectory->Clear();; auto clone = static_cast<TH1D *>(h->Clone());; clone->SetDirectory(nullptr);; dfDirectory->Add(clone);; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; clone->Draw();; browserPad->Update();; }; d#define d(i)Definition RSha256.hxx:102; h#d",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df013__InspectAnalysis_8C.html:5909,Usability,progress bar,progress bar,5909,"want for the progress bar, but we need to; // take care that two threads will not print to terminal at the same time: we need a std::mutex for synchronization.; std::string progressBar;; std::mutex barMutex; // Only one thread at a time can lock a mutex. Let's use this to avoid concurrent printing.; // Magic numbers that yield good progress bars for nSlots = 1,2,4,8; const auto everyN = nSlots == 8 ? 1000 : 100ull * nSlots;; const auto barWidth = nEvents / everyN;; h.OnPartialResultSlot(everyN, [&barWidth, &progressBar, &barMutex](unsigned int /*slot*/, TH1D & /*partialHist*/) {; std::lock_guard<std::mutex> l(barMutex); // lock_guard locks the mutex at construction, releases it at destruction; progressBar.push_back('#');; // re-print the line with the progress bar; std::cout << ""\r["" << std::left << std::setw(barWidth) << progressBar << ']' << std::flush;; });; ; // ## Running the analysis; // So far we told RDataFrame what we want to happen during the event-loop, but we have not actually run any of those; // actions: the TBrowser is still empty, the progress bar has not been printed even once, and we haven't produced; // a single data-point!; // As usual with RDataFrame, the event-loop is triggered by accessing the contents of a TResultProxy for the first; // time. Let's run!; std::cout << ""Analysis running..."" << std::endl;; h->Draw(); // the final, complete result will be drawn after the event-loop has completed.; std::cout << ""\nDone!"" << std::endl;; ; // Finally, some book-keeping: in the TMemFile that we are using as TBrowser directory, we substitute the partial; // result with a clone of the final result (the ""original"" final result will be deleted at the end of the macro).; dfDirectory->Clear();; auto clone = static_cast<TH1D *>(h->Clone());; clone->SetDirectory(nullptr);; dfDirectory->Add(clone);; if (!browserPad); return; // in case root -b was invoked; browserPad->cd();; clone->Draw();; browserPad->Update();; }; d#define d(i)Definition RSha256.hxx:102; h#d",MatchSource.WIKI,doc/master/df013__InspectAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df013__InspectAnalysis_8C.html
https://root.cern/doc/master/df014__CSVDataSource_8C.html:3551,Security,access,access,3551,"; auto fullSpectrum =; filteredEvents.Histo1D({""Spectrum"", ""Subset of CMS Run 2010B;#mu#mu mass [GeV];Events"", 1024, 2, 110}, ""m"");; ; // Next we will create the histogram for the J/psi particle, applying first; // the corresponding cut.; double jpsiLow = 2.95;; double jpsiHigh = 3.25;; auto jpsiCut = [jpsiLow, jpsiHigh](double m) { return m < jpsiHigh && m > jpsiLow; };; auto jpsi =; filteredEvents.Filter(jpsiCut, {""m""}); .Histo1D({""jpsi"", ""Subset of CMS Run 2010B: J/#psi window;#mu#mu mass [GeV];Events"", 128, jpsiLow, jpsiHigh},; ""m"");; ; // Finally we draw the two histograms side by side.; auto dualCanvas = new TCanvas(""DualCanvas"", ""DualCanvas"", 800, 512);; dualCanvas->Divide(2, 1);; auto leftPad = dualCanvas->cd(1);; leftPad->SetLogx();; leftPad->SetLogy();; fullSpectrum->DrawClone(""Hist"");; dualCanvas->cd(2);; jpsi->SetMarkerStyle(20);; jpsi->DrawClone(""HistP"");; ; return 0;; }; c#define c(i)Definition RSha256.hxx:101; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDF::FromCSVRDataFrame FromCSV(std::string_view fileName, bool readHeaders=true, char delimiter=',', Long64_t linesChunkSize=-1LL, std::unordered_map< std::string, char > &&colTypes={})Factory method to create a CSV RDataFrame.Definition RCsvDS.cxx:558; df014_CSVDataSourceDefinition df014_CSVDataSource.py:1; mTMarker mDefinition textangle.C:8; . DateOctober 2017 ; AuthorEnric Tejedor (CERN) ; Definition in file df014_CSVDataSource.C. tutorialsdataframedf014_CSVDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df014__CSVDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df014__CSVDataSource_8C.html
https://root.cern/doc/master/df014__CSVDataSource_8C.html:3585,Security,access,access,3585,"; auto fullSpectrum =; filteredEvents.Histo1D({""Spectrum"", ""Subset of CMS Run 2010B;#mu#mu mass [GeV];Events"", 1024, 2, 110}, ""m"");; ; // Next we will create the histogram for the J/psi particle, applying first; // the corresponding cut.; double jpsiLow = 2.95;; double jpsiHigh = 3.25;; auto jpsiCut = [jpsiLow, jpsiHigh](double m) { return m < jpsiHigh && m > jpsiLow; };; auto jpsi =; filteredEvents.Filter(jpsiCut, {""m""}); .Histo1D({""jpsi"", ""Subset of CMS Run 2010B: J/#psi window;#mu#mu mass [GeV];Events"", 128, jpsiLow, jpsiHigh},; ""m"");; ; // Finally we draw the two histograms side by side.; auto dualCanvas = new TCanvas(""DualCanvas"", ""DualCanvas"", 800, 512);; dualCanvas->Divide(2, 1);; auto leftPad = dualCanvas->cd(1);; leftPad->SetLogx();; leftPad->SetLogy();; fullSpectrum->DrawClone(""Hist"");; dualCanvas->cd(2);; jpsi->SetMarkerStyle(20);; jpsi->DrawClone(""HistP"");; ; return 0;; }; c#define c(i)Definition RSha256.hxx:101; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDF::FromCSVRDataFrame FromCSV(std::string_view fileName, bool readHeaders=true, char delimiter=',', Long64_t linesChunkSize=-1LL, std::unordered_map< std::string, char > &&colTypes={})Factory method to create a CSV RDataFrame.Definition RCsvDS.cxx:558; df014_CSVDataSourceDefinition df014_CSVDataSource.py:1; mTMarker mDefinition textangle.C:8; . DateOctober 2017 ; AuthorEnric Tejedor (CERN) ; Definition in file df014_CSVDataSource.C. tutorialsdataframedf014_CSVDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df014__CSVDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df014__CSVDataSource_8C.html
https://root.cern/doc/master/df014__CSVDataSource_8C_source.html:3978,Security,access,access,3978,"el than before.; 53 auto fullSpectrum =; 54 filteredEvents.Histo1D({""Spectrum"", ""Subset of CMS Run 2010B;#mu#mu mass [GeV];Events"", 1024, 2, 110}, ""m"");; 55 ; 56 // Next we will create the histogram for the J/psi particle, applying first; 57 // the corresponding cut.; 58 double jpsiLow = 2.95;; 59 double jpsiHigh = 3.25;; 60 auto jpsiCut = [jpsiLow, jpsiHigh](double m) { return m < jpsiHigh && m > jpsiLow; };; 61 auto jpsi =; 62 filteredEvents.Filter(jpsiCut, {""m""}); 63 .Histo1D({""jpsi"", ""Subset of CMS Run 2010B: J/#psi window;#mu#mu mass [GeV];Events"", 128, jpsiLow, jpsiHigh},; 64 ""m"");; 65 ; 66 // Finally we draw the two histograms side by side.; 67 auto dualCanvas = new TCanvas(""DualCanvas"", ""DualCanvas"", 800, 512);; 68 dualCanvas->Divide(2, 1);; 69 auto leftPad = dualCanvas->cd(1);; 70 leftPad->SetLogx();; 71 leftPad->SetLogy();; 72 fullSpectrum->DrawClone(""Hist"");; 73 dualCanvas->cd(2);; 74 jpsi->SetMarkerStyle(20);; 75 jpsi->DrawClone(""HistP"");; 76 ; 77 return 0;; 78}; c#define c(i)Definition RSha256.hxx:101; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDF::FromCSVRDataFrame FromCSV(std::string_view fileName, bool readHeaders=true, char delimiter=',', Long64_t linesChunkSize=-1LL, std::unordered_map< std::string, char > &&colTypes={})Factory method to create a CSV RDataFrame.Definition RCsvDS.cxx:558; df014_CSVDataSourceDefinition df014_CSVDataSource.py:1; mTMarker mDefinition textangle.C:8. tutorialsdataframedf014_CSVDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df014__CSVDataSource_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df014__CSVDataSource_8C_source.html
https://root.cern/doc/master/df014__CSVDataSource_8C_source.html:4012,Security,access,access,4012,"el than before.; 53 auto fullSpectrum =; 54 filteredEvents.Histo1D({""Spectrum"", ""Subset of CMS Run 2010B;#mu#mu mass [GeV];Events"", 1024, 2, 110}, ""m"");; 55 ; 56 // Next we will create the histogram for the J/psi particle, applying first; 57 // the corresponding cut.; 58 double jpsiLow = 2.95;; 59 double jpsiHigh = 3.25;; 60 auto jpsiCut = [jpsiLow, jpsiHigh](double m) { return m < jpsiHigh && m > jpsiLow; };; 61 auto jpsi =; 62 filteredEvents.Filter(jpsiCut, {""m""}); 63 .Histo1D({""jpsi"", ""Subset of CMS Run 2010B: J/#psi window;#mu#mu mass [GeV];Events"", 128, jpsiLow, jpsiHigh},; 64 ""m"");; 65 ; 66 // Finally we draw the two histograms side by side.; 67 auto dualCanvas = new TCanvas(""DualCanvas"", ""DualCanvas"", 800, 512);; 68 dualCanvas->Divide(2, 1);; 69 auto leftPad = dualCanvas->cd(1);; 70 leftPad->SetLogx();; 71 leftPad->SetLogy();; 72 fullSpectrum->DrawClone(""Hist"");; 73 dualCanvas->cd(2);; 74 jpsi->SetMarkerStyle(20);; 75 jpsi->DrawClone(""HistP"");; 76 ; 77 return 0;; 78}; c#define c(i)Definition RSha256.hxx:101; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDF::FromCSVRDataFrame FromCSV(std::string_view fileName, bool readHeaders=true, char delimiter=',', Long64_t linesChunkSize=-1LL, std::unordered_map< std::string, char > &&colTypes={})Factory method to create a CSV RDataFrame.Definition RCsvDS.cxx:558; df014_CSVDataSourceDefinition df014_CSVDataSource.py:1; mTMarker mDefinition textangle.C:8. tutorialsdataframedf014_CSVDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df014__CSVDataSource_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df014__CSVDataSource_8C_source.html
https://root.cern/doc/master/df015__LazyDataSource_8C.html:2514,Security,access,access,2514,"; ; // Let's first create a RDF that will read from the CSV file.; // See the tutorial (https://root.cern/doc/master/df014__CSVDataSource_8C.html) on CSV data sources for more details!; auto fileNameUrl = ""http://root.cern/files/tutorials/df014_CsvDataSource_MuRun2010B.csv"";; auto fileName = ""df015_CsvDataSource_MuRun2010B.csv"";; if(gSystem->AccessPathName(fileName)); TFile::Cp(fileNameUrl, fileName);; ; auto csv_rdf = FromCSV(fileName);; ; // Now we take out two columns: px and py of the first muon in the muon pair; std::string px1Name = ""px1"";; auto px1 = csv_rdf.Take<double>(px1Name);; std::string py1Name = ""py1"";; auto py1 = csv_rdf.Take<double>(py1Name);; ; // Now we create a new dataframe built on top of the columns above. Note that up to now, no event loop; // has been carried out!; auto df = MakeLazyDataFrame(std::make_pair(px1Name, px1), std::make_pair(py1Name, py1));; ; // We build a histogram of the transverse momentum of the muons.; auto ptFormula = [](double px, double py) { return sqrt(px * px + py * py); };; auto pt_h = df.Define(""pt"", ptFormula, {""px1"", ""py1""}); .Histo1D<double>({""pt"", ""Muon p_{T};p_{T} [GeV/c];"", 128, 0, 128}, ""pt"");; ; auto can = new TCanvas();; can->SetLogy();; pt_h->DrawCopy();; ; return 0;; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDFDefinition RArrowDS.hxx:28; . DateFebruary 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df015_LazyDataSource.C. tutorialsdataframedf015_LazyDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df015__LazyDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df015__LazyDataSource_8C.html
https://root.cern/doc/master/df015__LazyDataSource_8C.html:2548,Security,access,access,2548,"; ; // Let's first create a RDF that will read from the CSV file.; // See the tutorial (https://root.cern/doc/master/df014__CSVDataSource_8C.html) on CSV data sources for more details!; auto fileNameUrl = ""http://root.cern/files/tutorials/df014_CsvDataSource_MuRun2010B.csv"";; auto fileName = ""df015_CsvDataSource_MuRun2010B.csv"";; if(gSystem->AccessPathName(fileName)); TFile::Cp(fileNameUrl, fileName);; ; auto csv_rdf = FromCSV(fileName);; ; // Now we take out two columns: px and py of the first muon in the muon pair; std::string px1Name = ""px1"";; auto px1 = csv_rdf.Take<double>(px1Name);; std::string py1Name = ""py1"";; auto py1 = csv_rdf.Take<double>(py1Name);; ; // Now we create a new dataframe built on top of the columns above. Note that up to now, no event loop; // has been carried out!; auto df = MakeLazyDataFrame(std::make_pair(px1Name, px1), std::make_pair(py1Name, py1));; ; // We build a histogram of the transverse momentum of the muons.; auto ptFormula = [](double px, double py) { return sqrt(px * px + py * py); };; auto pt_h = df.Define(""pt"", ptFormula, {""px1"", ""py1""}); .Histo1D<double>({""pt"", ""Muon p_{T};p_{T} [GeV/c];"", 128, 0, 128}, ""pt"");; ; auto can = new TCanvas();; can->SetLogy();; pt_h->DrawCopy();; ; return 0;; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDFDefinition RArrowDS.hxx:28; . DateFebruary 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df015_LazyDataSource.C. tutorialsdataframedf015_LazyDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df015__LazyDataSource_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df015__LazyDataSource_8C.html
https://root.cern/doc/master/df016__vecOps_8C.html:2759,Integrability,interface,interface,2759,".5 && r < 1 && x*y < 0""); .Define(""yFig"", ""y[rInFig]""); .Define(""xFig"", ""x[rInFig]""); .Histo2D({""fig"", ""Two quarters of a ring"", 64, -1.1, 1.1, 64, -1.1, 1.1}, ""xFig"", ""yFig"");; ; auto cring = new TCanvas();; ring_h->DrawCopy(""Colz"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; double; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; df016_vecOpsDefinition df016_vecOps.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateFebruary 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df016_vecOps.C. tutorialsdataframedf016_vecOps.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df016__vecOps_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df016__vecOps_8C.html
https://root.cern/doc/master/df016__vecOps_8C.html:1394,Performance,perform,performed,1394,"ata analysis.; ; using namespace ROOT;; ; int df016_vecOps(); {; // We re-create a set of points in a square.; // This is a technical detail, just to create a dataset to play with!; auto unifGen = [](double) { return gRandom->Uniform(-1.0, 1.0); };; auto vGen = [&](int len) {; RVecD v(len);; std::transform(v.begin(), v.end(), v.begin(), unifGen);; return v;; };; RDataFrame d(1024);; auto d0 = d.Define(""len"", []() { return (int)gRandom->Uniform(0, 16); }); .Define(""x"", vGen, {""len""}); .Define(""y"", vGen, {""len""});; ; // Now we have in our hands d, a RDataFrame with two columns, x and y, which; // hold collections of coordinates. The sizes of these collections vary.; // Let's now define radii from the x and y coordinates. We'll do it treating ; // the collections stored in the columns without looping on the individual elements.; auto d1 = d0.Define(""r"", ""sqrt(x*x + y*y)"");; ; // Now we want to plot 2 quarters of a ring with radii .5 and 1.; // Note how the cuts are performed on RVecs, comparing them with integers and; // among themselves.; auto ring_h = d1.Define(""rInFig"", ""r > .5 && r < 1 && x*y < 0""); .Define(""yFig"", ""y[rInFig]""); .Define(""xFig"", ""x[rInFig]""); .Histo2D({""fig"", ""Two quarters of a ring"", 64, -1.1, 1.1, 64, -1.1, 1.1}, ""xFig"", ""yFig"");; ; auto cring = new TCanvas();; ring_h->DrawCopy(""Colz"");; ; return 0;; }; d#define d(i)Definition RSha256.hxx:102; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap",MatchSource.WIKI,doc/master/df016__vecOps_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df016__vecOps_8C.html
https://root.cern/doc/master/df016__vecOps_8py.html:1717,Integrability,interface,interface,1717,"frame/df016_vecOps.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df016_vecOps.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Process collections in RDataFrame with the help of RVec. ; This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis. ; import ROOT; ; df = ROOT.RDataFrame(1024); coordDefineCode = '''ROOT::RVecD {0}(len);; std::transform({0}.begin(), {0}.end(), {0}.begin(), [](double){{return gRandom->Uniform(-1.0, 1.0);}});; return {0};'''; d = df.Define(""len"", ""gRandom->Uniform(0, 16)"")\; .Define(""x"", coordDefineCode.format(""x""))\; .Define(""y"", coordDefineCode.format(""y"")); ; # Now we have in our hands d, a RDataFrame with two columns, x and y, which; # hold collections of coordinates. The sizes of these collections vary.; # Let's now define radii radii from the x and y coordinates. We'll do it treating ; # the collections stored in the columns without looping on the individual elements.; d1 = d.Define(""r"", ""sqrt(x*x + y*y)""); ; # Now we want to plot 2 quarters of a ring with radii .5 and 1.; # Note how the cuts are performed on RVecs, comparing them with integers and; # among themselves.; ring_h = d1.Define(""rInFig"", ""r > .5 && r < 1 && x*y < 0"")\; .Define(""yFig"", ""y[rInFig]"")\; .Define(""xFig"", ""x[rInFig]"")\; .Histo2D((""fig"", ""Two quarters of a ring"", 64, -1.1, 1.1, 64, -1.1, 1.1), ""xFig"", ""yFig""); ; cring = ROOT.TCanvas(); ring_h.Draw(""Colz""); cring.SaveAs(""df016_ring.png""); ; print(""Saved figure to df016_ring.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateFebruary 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df016_vecOps.py. tutorialsdataframedf016_vecOps.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df016__vecOps_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df016__vecOps_8py.html
https://root.cern/doc/master/df016__vecOps_8py.html:1244,Performance,perform,performed,1244,"frame/df016_vecOps.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df016_vecOps.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Process collections in RDataFrame with the help of RVec. ; This tutorial shows the potential of the VecOps approach for treating collections stored in datasets, a situation very common in HEP data analysis. ; import ROOT; ; df = ROOT.RDataFrame(1024); coordDefineCode = '''ROOT::RVecD {0}(len);; std::transform({0}.begin(), {0}.end(), {0}.begin(), [](double){{return gRandom->Uniform(-1.0, 1.0);}});; return {0};'''; d = df.Define(""len"", ""gRandom->Uniform(0, 16)"")\; .Define(""x"", coordDefineCode.format(""x""))\; .Define(""y"", coordDefineCode.format(""y"")); ; # Now we have in our hands d, a RDataFrame with two columns, x and y, which; # hold collections of coordinates. The sizes of these collections vary.; # Let's now define radii radii from the x and y coordinates. We'll do it treating ; # the collections stored in the columns without looping on the individual elements.; d1 = d.Define(""r"", ""sqrt(x*x + y*y)""); ; # Now we want to plot 2 quarters of a ring with radii .5 and 1.; # Note how the cuts are performed on RVecs, comparing them with integers and; # among themselves.; ring_h = d1.Define(""rInFig"", ""r > .5 && r < 1 && x*y < 0"")\; .Define(""yFig"", ""y[rInFig]"")\; .Define(""xFig"", ""x[rInFig]"")\; .Histo2D((""fig"", ""Two quarters of a ring"", 64, -1.1, 1.1, 64, -1.1, 1.1), ""xFig"", ""yFig""); ; cring = ROOT.TCanvas(); ring_h.Draw(""Colz""); cring.SaveAs(""df016_ring.png""); ; print(""Saved figure to df016_ring.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; DateFebruary 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df016_vecOps.py. tutorialsdataframedf016_vecOps.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df016__vecOps_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df016__vecOps_8py.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:348,Availability,down,down,348,". ROOT: tutorials/dataframe/df017_vecOpsHEP.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df017_vecOpsHEP.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use RVecs to plot the transverse momentum of selected particles. ; This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis. In this case we have a dataset containing the kinematic properties of particles stored in individual arrays. We want to plot the transverse momentum of these particles if the energy is greater than 100 MeV.; ; auto filename = gROOT->GetTutorialDir() + ""/dataframe/df017_vecOpsHEP.root"";; auto treename = ""myDataset"";; ; using namespace ROOT;; ; ; void WithTTreeReader(); {; TFile f(filename);; TTreeReader tr(treename, &f);; TTreeReaderArray<double> px(tr, ""px"");; TTreeReaderArray<double> py(tr, ""py"");; TTreeReaderArray<double> E(tr, ""E"");; ; TH1F h(""pt"", ""pt"", 16, 0, 4);; ; while (tr.Next()) {; for (auto i=0U;i < px.GetSize(); ++i) {; if (E[i] > 100) h.Fill(sqrt(px[i]*px[i] + py[i]*py[i]));; }; }; h.DrawCopy();; }; ; void WithRDataFrame(); {; RDataFrame f(treename, filename.Data());; auto CalcPt = [](RVecD &px, RVecD &py, RVecD &E) {; RVecD v;; for (auto i=0U;i < px.size(); ++i) {; if (E[i] > 100) {; v.emplace_back(sqrt(px[i]*px[i] + py[i]*py[i]));; }; }; return v;; };; f.Define(""pt"", CalcPt, {""px"", ""py"", ""E""}); .Histo1D<RVecD>({""pt"", ""pt"", 16, 0, 4}, ""pt"")->DrawCopy();; }; ; void WithRDataFrameVecOps(); {; RDataFrame f(treename, filename.Data());; auto CalcPt = [](RVecD &px, RVecD &py, RVecD &E) {; auto pt = sqrt(px*px + py*py);; return pt[E>100];; };; f.Define(""good_pt"", CalcPt, {""px"", ""py"", ""E""}); .Histo1D<RVecD>({""pt"", ""pt"", 16, 0, 4}, ""good_pt"")->DrawCopy();; }; ; void WithRDataFrameVecOpsJit(); {; RDataFrame f(treename, filename.Data());; f.Define(""good_pt"", ""sqrt(px*px + py*py)[E>100]""); .Histo1D({""pt"", ""pt"", 16, 0, 4}, ""good_pt"")->DrawCopy();; }; ; void df",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:3937,Availability,robust,robust,3937,"GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; df017_vecOpsHEPDefinition df017_vecOpsHEP.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateMarch 2018 ; AuthorsDanilo Piparo (CERN), Andre Vieira Silva ; Definition in file df017_vecOpsHEP.C. tutorialsdataframedf017_vecOpsHEP.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:589,Energy Efficiency,energy,energy,589,". ROOT: tutorials/dataframe/df017_vecOpsHEP.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df017_vecOpsHEP.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use RVecs to plot the transverse momentum of selected particles. ; This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis. In this case we have a dataset containing the kinematic properties of particles stored in individual arrays. We want to plot the transverse momentum of these particles if the energy is greater than 100 MeV.; ; auto filename = gROOT->GetTutorialDir() + ""/dataframe/df017_vecOpsHEP.root"";; auto treename = ""myDataset"";; ; using namespace ROOT;; ; ; void WithTTreeReader(); {; TFile f(filename);; TTreeReader tr(treename, &f);; TTreeReaderArray<double> px(tr, ""px"");; TTreeReaderArray<double> py(tr, ""py"");; TTreeReaderArray<double> E(tr, ""E"");; ; TH1F h(""pt"", ""pt"", 16, 0, 4);; ; while (tr.Next()) {; for (auto i=0U;i < px.GetSize(); ++i) {; if (E[i] > 100) h.Fill(sqrt(px[i]*px[i] + py[i]*py[i]));; }; }; h.DrawCopy();; }; ; void WithRDataFrame(); {; RDataFrame f(treename, filename.Data());; auto CalcPt = [](RVecD &px, RVecD &py, RVecD &E) {; RVecD v;; for (auto i=0U;i < px.size(); ++i) {; if (E[i] > 100) {; v.emplace_back(sqrt(px[i]*px[i] + py[i]*py[i]));; }; }; return v;; };; f.Define(""pt"", CalcPt, {""px"", ""py"", ""E""}); .Histo1D<RVecD>({""pt"", ""pt"", 16, 0, 4}, ""pt"")->DrawCopy();; }; ; void WithRDataFrameVecOps(); {; RDataFrame f(treename, filename.Data());; auto CalcPt = [](RVecD &px, RVecD &py, RVecD &E) {; auto pt = sqrt(px*px + py*py);; return pt[E>100];; };; f.Define(""good_pt"", CalcPt, {""px"", ""py"", ""E""}); .Histo1D<RVecD>({""pt"", ""pt"", 16, 0, 4}, ""good_pt"")->DrawCopy();; }; ; void WithRDataFrameVecOpsJit(); {; RDataFrame f(treename, filename.Data());; f.Define(""good_pt"", ""sqrt(px*px + py*py)[E>100]""); .Histo1D({""pt"", ""pt"", 16, 0, 4}, ""good_pt"")->DrawCopy();; }; ; void df",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:3416,Integrability,interface,interface,3416," h(i)Definition RSha256.hxx:106; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstex",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:3815,Integrability,interface,interface,3815,"GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; df017_vecOpsHEPDefinition df017_vecOpsHEP.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateMarch 2018 ; AuthorsDanilo Piparo (CERN), Andre Vieira Silva ; Definition in file df017_vecOpsHEP.C. tutorialsdataframedf017_vecOpsHEP.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:3953,Integrability,interface,interface,3953,"GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; df017_vecOpsHEPDefinition df017_vecOpsHEP.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateMarch 2018 ; AuthorsDanilo Piparo (CERN), Andre Vieira Silva ; Definition in file df017_vecOpsHEP.C. tutorialsdataframedf017_vecOpsHEP.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:4436,Testability,log,log,4436,"GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; df017_vecOpsHEPDefinition df017_vecOpsHEP.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateMarch 2018 ; AuthorsDanilo Piparo (CERN), Andre Vieira Silva ; Definition in file df017_vecOpsHEP.C. tutorialsdataframedf017_vecOpsHEP.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8C.html:3929,Usability,simpl,simple,3929,"GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; gROOT#define gROOTDefinition TROOT.h:406; ROOT::Detail::VecOps::RVecImpl::emplace_backreference emplace_back(ArgTypes &&...Args)Definition RVec.hxx:920; ROOT::Internal::VecOps::SmallVectorTemplateCommon::sizesize_t size() constDefinition RVec.hxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< double >; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderArrayAn interface for reading collections stored in ROOT columnar datasets.Definition TTreeReaderArray.h:75; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::Econstexpr Double_t E()Base of natural log: .Definition TMath.h:93; df017_vecOpsHEPDefinition df017_vecOpsHEP.py:1; v@ vDefinition rootcling_impl.cxx:3699; . DateMarch 2018 ; AuthorsDanilo Piparo (CERN), Andre Vieira Silva ; Definition in file df017_vecOpsHEP.C. tutorialsdataframedf017_vecOpsHEP.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df017__vecOpsHEP_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8C.html
https://root.cern/doc/master/df017__vecOpsHEP_8py.html:363,Availability,down,down,363,. ROOT: tutorials/dataframe/df017_vecOpsHEP.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df017_vecOpsHEP.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use RVecs to plot the transverse momentum of selected particles. ; This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis. In this case we have a dataset containing the kinematic properties of particles stored in individual arrays. We want to plot the transverse momentum of these particles if the energy is greater than 100 MeV. ; Definition in file df017_vecOpsHEP.py. tutorialsdataframedf017_vecOpsHEP.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ,MatchSource.WIKI,doc/master/df017__vecOpsHEP_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8py.html
https://root.cern/doc/master/df017__vecOpsHEP_8py.html:604,Energy Efficiency,energy,energy,604,. ROOT: tutorials/dataframe/df017_vecOpsHEP.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df017_vecOpsHEP.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use RVecs to plot the transverse momentum of selected particles. ; This tutorial shows how VecOps can be used to slim down the programming model typically adopted in HEP for analysis. In this case we have a dataset containing the kinematic properties of particles stored in individual arrays. We want to plot the transverse momentum of these particles if the energy is greater than 100 MeV. ; Definition in file df017_vecOpsHEP.py. tutorialsdataframedf017_vecOpsHEP.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ,MatchSource.WIKI,doc/master/df017__vecOpsHEP_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df017__vecOpsHEP_8py.html
https://root.cern/doc/master/df018__customActions_8C.html:4487,Availability,robust,robust,4487," max values; ; // We book the action: it will be treated during the event loop.; auto myTHnT = dd.Book<double, double, float, int>(std::move(helper), {""x0"", ""x1"", ""x2"", ""x3""});; ; myTHnT->Print();; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::TSeqUTSeq< unsigned int > TSeqUDefinition TSeq.hxx:204; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; ; THnT<float> (*0x55999709c0e0): ""myThN"" ""A THn with 4 dimension",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df018__customActions_8C.html:445,Integrability,interface,interface,445,". ROOT: tutorials/dataframe/df018_customActions.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df018_customActions.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Implement a custom action to fill THns. ; This tutorial shows how to implement a custom action. As an example, we build a helper for filling THns.; ; // This is a custom action which respects a well defined interface. It supports parallelism,; // in the sense that it behaves correctly if implicit multi threading is enabled.; // We template it on:; // - The type of the internal THnT(s); // - The dimension of the internal THnT(s); // Note the plural: in presence of a MT execution, internally more than a single THnT is created.; template <typename T, unsigned int NDIM>; class THnHelper : public ROOT::Detail::RDF::RActionImpl<THnHelper<T, NDIM>> {; public:; /// This is a handy, expressive shortcut.; using THn_t = THnT<T>;; /// This type is a requirement for every helper.; using Result_t = THn_t;; ; private:; std::vector<std::shared_ptr<THn_t>> fHistos; // one per data processing slot; ; public:; /// This constructor takes all the parameters necessary to build the THnTs. In addition, it requires the names of; /// the columns which will be used.; THnHelper(std::string_view name, std::string_view title, std::array<int, NDIM> nbins, std::array<double, NDIM> xmins,; std::array<double, NDIM> xmax); {; const auto nSlots = ROOT::IsImplicitMTEnabled() ? ROOT::GetThreadPoolSize() : 1;; for (auto i : ROOT::TSeqU(nSlots)) {; fHistos.emplace_back(std::make_shared<THn_t>(std::string(name).c_str(), std::string(title).c_str(),; NDIM, nbins.data(), xmins.data(), xmax.data()));; (void)i;; }; }; THnHelper(THnHelper &&) = default;; THnHelper(const THnHelper &) = delete;; std::shared_ptr<THn_t> GetResultPtr() const { return fHistos[0]; }; void Initialize() {}; void InitTask(TTreeReader *, unsigned int) {}; /// This is a method executed at every entry; templa",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df018__customActions_8C.html:4176,Integrability,interface,interface,4176,"nF).Define(""x3"", genI);; ; // Our Helper type: templated on the internal THnT type, the size, the types of the columns; // we'll use to fill.; using Helper_t = THnHelper<float, 4>;; ; Helper_t helper{""myThN"", // Name; ""A THn with 4 dimensions"", // Title; {4, 4, 8, 2}, // NBins; {-10., -10, -4., -6.}, // Axes min values; {10., 10, 5., 7.}}; // Axes max values; ; // We book the action: it will be treated during the event loop.; auto myTHnT = dd.Book<double, double, float, int>(std::move(helper), {""x0"", ""x1"", ""x2"", ""x3""});; ; myTHnT->Print();; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROO",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df018__customActions_8C.html:4503,Integrability,interface,interface,4503," max values; ; // We book the action: it will be treated during the event loop.; auto myTHnT = dd.Book<double, double, float, int>(std::move(helper), {""x0"", ""x1"", ""x2"", ""x3""});; ; myTHnT->Print();; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::TSeqUTSeq< unsigned int > TSeqUDefinition TSeq.hxx:204; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; ; THnT<float> (*0x55999709c0e0): ""myThN"" ""A THn with 4 dimension",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df018__customActions_8C.html:4927,Performance,multi-thread,multi-threading,4927,"a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::TSeqUTSeq< unsigned int > TSeqUDefinition TSeq.hxx:204; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; ; THnT<float> (*0x55999709c0e0): ""myThN"" ""A THn with 4 dimensions""; 4 dimensions, 128 entries in 1440 filled bins; DateApril 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN) ; Definition in file df018_customActions.C. tutorialsdataframedf018_customActions.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df018__customActions_8C.html:5116,Performance,multi-thread,multi-threading,5116,"a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::TSeqUTSeq< unsigned int > TSeqUDefinition TSeq.hxx:204; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; ; THnT<float> (*0x55999709c0e0): ""myThN"" ""A THn with 4 dimensions""; 4 dimensions, 128 entries in 1440 filled bins; DateApril 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN) ; Definition in file df018_customActions.C. tutorialsdataframedf018_customActions.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df018__customActions_8C.html:4479,Usability,simpl,simple,4479," max values; ; // We book the action: it will be treated during the event loop.; auto myTHnT = dd.Book<double, double, float, int>(std::move(helper), {""x0"", ""x1"", ""x2"", ""x3""});; ; myTHnT->Print();; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; namechar name[80]Definition TGX11.cxx:110; xmaxfloat xmaxDefinition THbookFile.cxx:95; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; THnTTemplated implementation of the abstract base THn.Definition THn.h:219; TRandom::Uniformvirtual Double_t Uniform(Double_t x1=1)Returns a uniform deviate on the interval (0, x1).Definition TRandom.cxx:682; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; double; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; ROOT::TSeqUTSeq< unsigned int > TSeqUDefinition TSeq.hxx:204; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; ; THnT<float> (*0x55999709c0e0): ""myThN"" ""A THn with 4 dimension",MatchSource.WIKI,doc/master/df018__customActions_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df018__customActions_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:893,Availability,checkpoint,checkpointing,893,". ROOT: tutorials/dataframe/df019_Cache.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:2281,Integrability,interface,interface,2281,"s particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df019_CacheDefinition df019_Cache.py:1; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.C. tutorialsdataframedf019_Cache.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:341,Performance,cache,cached,341,". ROOT: tutorials/dataframe/df019_Cache.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:511,Performance,perform,performed,511,". ROOT: tutorials/dataframe/df019_Cache.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:534,Performance,cache,cached,534,". ROOT: tutorials/dataframe/df019_Cache.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:766,Performance,perform,performed,766,". ROOT: tutorials/dataframe/df019_Cache.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:974,Performance,cache,cached,974,"rials/dataframe/df019_Cache.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event l",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:1481,Performance,cache,cache,1481,"emory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df019_CacheDefinition df019_Cache.py:1; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Defi",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:1766,Performance,cache,cached,1766,"s particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df019_CacheDefinition df019_Cache.py:1; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.C. tutorialsdataframedf019_Cache.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:2023,Performance,cache,cached,2023,"s particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df019_CacheDefinition df019_Cache.py:1; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.C. tutorialsdataframedf019_Cache.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8C.html:1286,Usability,simpl,simple,1286,"orial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface ",MatchSource.WIKI,doc/master/df019__Cache_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html
https://root.cern/doc/master/df019__Cache_8py.html:908,Availability,checkpoint,checkpointing,908,". ROOT: tutorials/dataframe/df019_Cache.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:1902,Integrability,interface,interface,1902," tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.py. tutorialsdataframedf019_Cache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:356,Performance,cache,cached,356,". ROOT: tutorials/dataframe/df019_Cache.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:526,Performance,perform,performed,526,". ROOT: tutorials/dataframe/df019_Cache.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:549,Performance,cache,cached,549,". ROOT: tutorials/dataframe/df019_Cache.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:781,Performance,perform,performed,781,". ROOT: tutorials/dataframe/df019_Cache.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:989,Performance,cache,cached,989,"/df019_Cache.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df019_Cache.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN)",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:1413,Performance,cache,cache,1413," tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.py. tutorialsdataframedf019_Cache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:1617,Performance,cache,cached,1617," tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.py. tutorialsdataframedf019_Cache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:1648,Security,access,accessing,1648," tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.py. tutorialsdataframedf019_Cache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df019__Cache_8py.html:1302,Usability,simpl,simple,1302," tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; import ROOT; import os; ; # We create a data frame on top of the hsimple example.; hsimplePath = os.path.join(str(ROOT.gROOT.GetTutorialDir().Data()), ""hsimple.root""); df = ROOT.RDataFrame(""ntuple"", hsimplePath); ; # We apply a simple cut and define a new column.; df_cut = df.Filter(""py > 0.f"")\; .Define(""px_plus_py"", ""px + py""); ; # We cache the content of the dataset. Nothing has happened yet: the work to accomplish; # has been described.; df_cached = df_cut.Cache(); ; h = df_cached.Histo1D(""px_plus_py""); ; # Now the event loop on the cached dataset is triggered by accessing the histogram.; # This event triggers the loop on the `df` data frame lazily.; c = ROOT.TCanvas(); h.Draw(); c.SaveAs(""df019_Cache.png""); ; print(""Saved figure to df019_Cache.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.py. tutorialsdataframedf019_Cache.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df019__Cache_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df019__Cache_8py.html
https://root.cern/doc/master/df020__helpers_8C.html:1905,Availability,down,down,1905,"tOne` are callables that we can use in `Filters`:; auto c1 = df.Filter(isOne, {""one""}).Count();; auto c2 = df.Filter(isNotOne, {""two""}).Count();; // Both counts are equal to the total number of entries, as both Filters always pass.; R__ASSERT(*c1 == nEntries);; R__ASSERT(*c2 == nEntries);; ; // *** PassAsVec ***; // Consider the following function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f` that expects a collection as argument and returns a new callable that takes single arguments instead, passes; // them down to `f` and returns what `f` returns.; // PassAsVec requires that number of arguments and their type is specified as template argument.; // Here's an example usage (remember, PassAsVec(f) returns a new callable!):; auto c3 = df.Filter(ROOT::RDF::PassAsVec<2, int>(checkOneTwo), {""one"", ""two""}).Count();; R__ASSERT(*c3 == nEntries);; }; a#define a(i)Definition RSha256.hxx:99; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; ROOT::RDF::Notauto Not(F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)))Given a callable with signature bool(T1, T2, ...) return a ",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df020__helpers_8C.html:2121,Availability,down,down,2121,"tOne` are callables that we can use in `Filters`:; auto c1 = df.Filter(isOne, {""one""}).Count();; auto c2 = df.Filter(isNotOne, {""two""}).Count();; // Both counts are equal to the total number of entries, as both Filters always pass.; R__ASSERT(*c1 == nEntries);; R__ASSERT(*c2 == nEntries);; ; // *** PassAsVec ***; // Consider the following function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f` that expects a collection as argument and returns a new callable that takes single arguments instead, passes; // them down to `f` and returns what `f` returns.; // PassAsVec requires that number of arguments and their type is specified as template argument.; // Here's an example usage (remember, PassAsVec(f) returns a new callable!):; auto c3 = df.Filter(ROOT::RDF::PassAsVec<2, int>(checkOneTwo), {""one"", ""two""}).Count();; R__ASSERT(*c3 == nEntries);; }; a#define a(i)Definition RSha256.hxx:99; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; ROOT::RDF::Notauto Not(F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)))Given a callable with signature bool(T1, T2, ...) return a ",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df020__helpers_8C.html:2569,Availability,error,error,2569,"wing function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f` that expects a collection as argument and returns a new callable that takes single arguments instead, passes; // them down to `f` and returns what `f` returns.; // PassAsVec requires that number of arguments and their type is specified as template argument.; // Here's an example usage (remember, PassAsVec(f) returns a new callable!):; auto c3 = df.Filter(ROOT::RDF::PassAsVec<2, int>(checkOneTwo), {""one"", ""two""}).Count();; R__ASSERT(*c3 == nEntries);; }; a#define a(i)Definition RSha256.hxx:99; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; ROOT::RDF::Notauto Not(F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)))Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns ...Definition RDFHelpers.hxx:83; v@ vDefinition rootcling_impl.cxx:3699; DateJuly 2018 ; AuthorEnrico Guiraud (CERN) ; Definition in file df020_helpers.C. tutorialsdataframedf020_helpers.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df020__helpers_8C.html:2676,Integrability,interface,interface,2676,"wing function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f` that expects a collection as argument and returns a new callable that takes single arguments instead, passes; // them down to `f` and returns what `f` returns.; // PassAsVec requires that number of arguments and their type is specified as template argument.; // Here's an example usage (remember, PassAsVec(f) returns a new callable!):; auto c3 = df.Filter(ROOT::RDF::PassAsVec<2, int>(checkOneTwo), {""one"", ""two""}).Count();; R__ASSERT(*c3 == nEntries);; }; a#define a(i)Definition RSha256.hxx:99; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; c3return c3Definition legend3.C:15; ROOT::RDF::Notauto Not(F &&f) -> decltype(RDFInternal::NotHelper(Args(), std::forward< F >(f)))Given a callable with signature bool(T1, T2, ...) return a callable with same signature that returns ...Definition RDFHelpers.hxx:83; v@ vDefinition rootcling_impl.cxx:3699; DateJuly 2018 ; AuthorEnrico Guiraud (CERN) ; Definition in file df020_helpers.C. tutorialsdataframedf020_helpers.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df020__helpers_8C.html:775,Performance,perform,performed,775,". ROOT: tutorials/dataframe/df020_helpers.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df020_helpers.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ; ; void df020_helpers(); {; // First of all, we create a dataframe with 3 entries and define two simple columns; const auto nEntries = 3;; ROOT::RDataFrame _df(nEntries);; auto df = _df.Define(""one"", [] { return 1; }).Define(""two"", [] { return 2; });; ; // *** Not ***; // This helper takes a callable `f` (which must return a `bool`) and produces a new callable which takes the same; // arguments as `f` but returns its negated result. `Not` is useful to invert the check performed by a given Filter.; // Here we define a simple lambda that checks whether a value is equal to 1, and invert it with Not:; auto isOne = [] (int a) { return a == 1; };; auto isNotOne = ROOT::RDF::Not(isOne);; ; // Both `isOne` and `isNotOne` are callables that we can use in `Filters`:; auto c1 = df.Filter(isOne, {""one""}).Count();; auto c2 = df.Filter(isNotOne, {""two""}).Count();; // Both counts are equal to the total number of entries, as both Filters always pass.; R__ASSERT(*c1 == nEntries);; R__ASSERT(*c2 == nEntries);; ; // *** PassAsVec ***; // Consider the following function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df020__helpers_8C.html:399,Usability,simpl,simple,399,". ROOT: tutorials/dataframe/df020_helpers.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df020_helpers.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ; ; void df020_helpers(); {; // First of all, we create a dataframe with 3 entries and define two simple columns; const auto nEntries = 3;; ROOT::RDataFrame _df(nEntries);; auto df = _df.Define(""one"", [] { return 1; }).Define(""two"", [] { return 2; });; ; // *** Not ***; // This helper takes a callable `f` (which must return a `bool`) and produces a new callable which takes the same; // arguments as `f` but returns its negated result. `Not` is useful to invert the check performed by a given Filter.; // Here we define a simple lambda that checks whether a value is equal to 1, and invert it with Not:; auto isOne = [] (int a) { return a == 1; };; auto isNotOne = ROOT::RDF::Not(isOne);; ; // Both `isOne` and `isNotOne` are callables that we can use in `Filters`:; auto c1 = df.Filter(isOne, {""one""}).Count();; auto c2 = df.Filter(isNotOne, {""two""}).Count();; // Both counts are equal to the total number of entries, as both Filters always pass.; R__ASSERT(*c1 == nEntries);; R__ASSERT(*c2 == nEntries);; ; // *** PassAsVec ***; // Consider the following function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df020__helpers_8C.html:825,Usability,simpl,simple,825,". ROOT: tutorials/dataframe/df020_helpers.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df020_helpers.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ; ; void df020_helpers(); {; // First of all, we create a dataframe with 3 entries and define two simple columns; const auto nEntries = 3;; ROOT::RDataFrame _df(nEntries);; auto df = _df.Define(""one"", [] { return 1; }).Define(""two"", [] { return 2; });; ; // *** Not ***; // This helper takes a callable `f` (which must return a `bool`) and produces a new callable which takes the same; // arguments as `f` but returns its negated result. `Not` is useful to invert the check performed by a given Filter.; // Here we define a simple lambda that checks whether a value is equal to 1, and invert it with Not:; auto isOne = [] (int a) { return a == 1; };; auto isNotOne = ROOT::RDF::Not(isOne);; ; // Both `isOne` and `isNotOne` are callables that we can use in `Filters`:; auto c1 = df.Filter(isOne, {""one""}).Count();; auto c2 = df.Filter(isNotOne, {""two""}).Count();; // Both counts are equal to the total number of entries, as both Filters always pass.; R__ASSERT(*c1 == nEntries);; R__ASSERT(*c2 == nEntries);; ; // *** PassAsVec ***; // Consider the following function, which checks if a vector consists of two elements equal to 1 and 2:; auto checkOneTwo = [] (const std::vector<int> &v) { return v.size() == 2 && v[0] == 1 && v[1] == 2; };; // The following line, although it looks reasonable, would _not_ run correctly:; // df.Filter(checkOneTwo, {""one"", ""two""});; // The reason is that `Filter(..., {""one"", ""two""})` expects a callable that takes exactly two integers, while; // `checkOneTwo` actually takes a vector of integers (i.e. it does not have the right signature).; // PassAsVec helps passing down the single values ""one"", ""two"" to `checkOneTwo` as a collection: it takes a callable; // `f",MatchSource.WIKI,doc/master/df020__helpers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df020__helpers_8C.html
https://root.cern/doc/master/df021__createTGraph_8C.html:868,Integrability,interface,interface,868,". ROOT: tutorials/dataframe/df021_createTGraph.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df021_createTGraph.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Fill a TGraph using RDataFrame. ; ; ; ; void df021_createTGraph(); {; ROOT::EnableImplicitMT(2);; ; ROOT::RDataFrame d(160);; ; // Create a trivial parabola; auto dd = d.Alias(""x"", ""rdfentry_"").Define(""y"", ""x*x"");; ; auto graph = dd.Graph(""x"", ""y"");; ; // This tutorial is ran with multithreading enabled. The order in which points are inserted is not known, so to have a meaningful representation points are sorted.; graph->Sort();; auto c = new TCanvas();; graph->DrawClone(""APL"");; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; df021_createTGraphDefinition df021_createTGraph.py:1; graphDefinition graph.py:1; . DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df021_createTGraph.C. tutorialsdataframedf021_createTGraph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df021__createTGraph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df021__createTGraph_8C.html
https://root.cern/doc/master/df021__createTGraph_8C.html:1085,Performance,multi-thread,multi-threading,1085,". ROOT: tutorials/dataframe/df021_createTGraph.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df021_createTGraph.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Fill a TGraph using RDataFrame. ; ; ; ; void df021_createTGraph(); {; ROOT::EnableImplicitMT(2);; ; ROOT::RDataFrame d(160);; ; // Create a trivial parabola; auto dd = d.Alias(""x"", ""rdfentry_"").Define(""y"", ""x*x"");; ; auto graph = dd.Graph(""x"", ""y"");; ; // This tutorial is ran with multithreading enabled. The order in which points are inserted is not known, so to have a meaningful representation points are sorted.; graph->Sort();; auto c = new TCanvas();; graph->DrawClone(""APL"");; }; d#define d(i)Definition RSha256.hxx:102; c#define c(i)Definition RSha256.hxx:101; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TCanvasThe Canvas class.Definition TCanvas.h:23; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; df021_createTGraphDefinition df021_createTGraph.py:1; graphDefinition graph.py:1; . DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df021_createTGraph.C. tutorialsdataframedf021_createTGraph.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df021__createTGraph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df021__createTGraph_8C.html
https://root.cern/doc/master/df021__createTGraph_8py.html:839,Integrability,interface,interface,839,". ROOT: tutorials/dataframe/df021_createTGraph.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df021_createTGraph.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Fill a TGraph using RDataFrame. ; ; import ROOT; ; ROOT.ROOT.EnableImplicitMT(2); d = ROOT.RDataFrame(160); ; # Create a trivial parabola; dd = d.Alias(""x"", ""rdfentry_"").Define(""y"", ""x*x""); ; graph = dd.Graph(""x"", ""y""); ; # This tutorial is ran with multithreading enabled. The order in which points are inserted is not known, so to have a meaningful representation points are sorted.; c = ROOT.TCanvas(); graph.Sort(); graph.Draw(""APL""); c.SaveAs(""df021_createTGraph.png""); ; print(""Saved figure to df021_createTGraph.png""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; . DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df021_createTGraph.py. tutorialsdataframedf021_createTGraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df021__createTGraph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df021__createTGraph_8py.html
https://root.cern/doc/master/df022__useKahan_8C.html:3032,Availability,robust,robust,3032,"0000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000",MatchSource.WIKI,doc/master/df022__useKahan_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html
https://root.cern/doc/master/df022__useKahan_8C.html:2930,Integrability,interface,interface,2930," implicit parallelism; ROOT::EnableImplicitMT(2);; ; ROOT::RDataFrame d(20);; auto dd = d.Define(""x"", ""(rdfentry_ %2 == 0) ? 0.00000001 : 100000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvagl",MatchSource.WIKI,doc/master/df022__useKahan_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html
https://root.cern/doc/master/df022__useKahan_8C.html:3048,Integrability,interface,interface,3048,"0000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000",MatchSource.WIKI,doc/master/df022__useKahan_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html
https://root.cern/doc/master/df022__useKahan_8C.html:3471,Performance,multi-thread,multi-threading,3471,"1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000011920929 Classical: 1000000000.00000011920929; DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df022_useKahan.C. tutorialsdataframedf022_useKahan.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df022__useKahan_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html
https://root.cern/doc/master/df022__useKahan_8C.html:3660,Performance,multi-thread,multi-threading,3660,"1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000011920929 Classical: 1000000000.00000011920929; DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df022_useKahan.C. tutorialsdataframedf022_useKahan.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df022__useKahan_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html
https://root.cern/doc/master/df022__useKahan_8C.html:3024,Usability,simpl,simple,3024,"0000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000",MatchSource.WIKI,doc/master/df022__useKahan_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html
https://root.cern/doc/master/df023__aggregate_8C.html:2145,Integrability,interface,interface,2145,"ction. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ; 120; DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df023_aggregate.C. tutorialsdataframedf023_aggregate.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df023__aggregate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html
https://root.cern/doc/master/df023__aggregate_8C.html:815,Modifiability,variab,variable,815,". ROOT: tutorials/dataframe/df023_aggregate.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df023_aggregate.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the Aggregate action to specify arbitrary data aggregations. ; This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column. This operation may be performed using a Reduce action, however aggregate is used for the sake of the tutorial; ; void df023_aggregate(); {; ; // Column to be aggregated; const std::string columnName = ""x"";; ; ROOT::EnableImplicitMT(2);; auto rdf = ROOT::RDataFrame(5);; auto d = rdf.Define(columnName, ""rdfentry_ + 1."");; ; // Aggregator function. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int",MatchSource.WIKI,doc/master/df023__aggregate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html
https://root.cern/doc/master/df023__aggregate_8C.html:428,Performance,perform,performed,428,". ROOT: tutorials/dataframe/df023_aggregate.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df023_aggregate.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the Aggregate action to specify arbitrary data aggregations. ; This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column. This operation may be performed using a Reduce action, however aggregate is used for the sake of the tutorial; ; void df023_aggregate(); {; ; // Column to be aggregated; const std::string columnName = ""x"";; ; ROOT::EnableImplicitMT(2);; auto rdf = ROOT::RDataFrame(5);; auto d = rdf.Define(columnName, ""rdfentry_ + 1."");; ; // Aggregator function. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int",MatchSource.WIKI,doc/master/df023__aggregate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html
https://root.cern/doc/master/df023__aggregate_8C.html:1173,Performance,perform,performs,1173,"aframe tutorials. Detailed Description; Use the Aggregate action to specify arbitrary data aggregations. ; This tutorial shows how to use the Aggregate action to evaluate the product of all the elements of a column. This operation may be performed using a Reduce action, however aggregate is used for the sake of the tutorial; ; void df023_aggregate(); {; ; // Column to be aggregated; const std::string columnName = ""x"";; ; ROOT::EnableImplicitMT(2);; auto rdf = ROOT::RDataFrame(5);; auto d = rdf.Define(columnName, ""rdfentry_ + 1."");; ; // Aggregator function. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree",MatchSource.WIKI,doc/master/df023__aggregate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html
https://root.cern/doc/master/df023__aggregate_8C.html:2352,Performance,multi-thread,multi-threading,2352,"ction. It receives an accumulator (acc) and a column value (x). The variable acc is shared among the; // calls, so the function has to specify how the value has to be aggregated in the accumulator.; auto aggregator = [](double acc, double x) { return acc * x; };; ; // If multithread is enabled, the aggregator function will be called by more threads and will produce a vector of; // partial accumulators. The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; auto size = accumulators.size();; for (int i = 1; i < size; ++i) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, columnName, initValue);; ; std::cout << *result << std::endl;; }; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; xDouble_t x[n]Definition legend1.C:17; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ; 120; DateJuly 2018 ; AuthorsEnrico Guiraud, Danilo Piparo (CERN), Massimo Tumolo (Politecnico di Torino) ; Definition in file df023_aggregate.C. tutorialsdataframedf023_aggregate.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df023__aggregate_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df023__aggregate_8C.html
https://root.cern/doc/master/df024__Display_8C.html:1566,Integrability,interface,interface,1566,"ector<int>({x++, x++, x++, x++});; }) // A column with four-elements collection; .Define(""w"", [&w]() { return w *= 1.8; }) // A column with doubles; .Define(""z"", [&z]() {; z *= 1.1;; return std::vector<std::vector<double>>({{z, ++z}, {z, ++z}, {z, ++z}});; }); // A column of matrices; ; // Preparing the RResultPtr<RDisplay> object with all columns and default number of entries; auto d1 = d.Display("""");; // Preparing the RResultPtr<RDisplay> object with two columns and default number of entries; auto d2 = d.Display({""x"", ""y""});; ; // Printing the short representations, the event loop will run; std::cout << ""The following is the representation of all columns with the default nr of entries"" << std::endl;; d1->Print();; std::cout << ""\n\nThe following is the representation of two columns with the default nr of entries"" << std::endl;; d2->Print();; }; d#define d(i)Definition RSha256.hxx:102; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; df024_DisplayDefinition df024_Display.py:1; ; The following is the representation of all columns with the default nr of entries; +-----+-----------+----+-------------+--------------------------+; | Row | w | x | y | z | ; +-----+-----------+----+-------------+--------------------------+; | 0 | 1.800000 | 1 | 100 | { 1.1000000, 2.1000000 } | ; | | | 2 | | { 2.1000000, 3.1000000 } | ; | | | 3 | | { 3.1000000, 4.1000000 } | ; | | | 4 | | | ; +-----+-----------+----+-------------+--------------------------+; | 1 | 3.240000 | 5 | 10000 | { 4.5100000, 5.5100000 } | ; | | | 6 | | { 5.5100000, 6.5100000 } | ; | | | 7 | | { 6.5100000, 7.5100000 } | ; | | | 8 | | | ; +-----+-----------+----+-------------+--------------------------+; | 2 | 5.832000 | 9 | 1000000 | { 8.2610000, 9.2610000 } | ; | | | 10 | | { 9.2610000, 10.261000 } ",MatchSource.WIKI,doc/master/df024__Display_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df024__Display_8C.html
https://root.cern/doc/master/df025__RNode_8C.html:1795,Integrability,interface,interface,1795,"ect and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; f1TF1 * f1Definition legend1.C:11; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; ; Entries passing the selection: 4; DateJune 2020 ; AuthorsDanilo Piparo, Enrico Guiraud (CERN) ; Definition in file df025_RNode.C. tutorialsdataframedf025_RNode.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df025__RNode_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html
https://root.cern/doc/master/df025__RNode_8C.html:2155,Integrability,interface,interface,2155,"ect and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; f1TF1 * f1Definition legend1.C:11; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; ; Entries passing the selection: 4; DateJune 2020 ; AuthorsDanilo Piparo, Enrico Guiraud (CERN) ; Definition in file df025_RNode.C. tutorialsdataframedf025_RNode.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df025__RNode_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html
https://root.cern/doc/master/df025__RNode_8C.html:348,Performance,perform,performance,348,". ROOT: tutorials/dataframe/df025_RNode.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df025_RNode.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Manipulate RDF objects in functions, loops and conditional branches. ; Each RDataFrame object has its own type. It helps with performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}",MatchSource.WIKI,doc/master/df025__RNode_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html
https://root.cern/doc/master/df025__RNode_8C.html:405,Usability,simpl,simple,405,". ROOT: tutorials/dataframe/df025_RNode.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df025_RNode.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Manipulate RDF objects in functions, loops and conditional branches. ; Each RDataFrame object has its own type. It helps with performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}",MatchSource.WIKI,doc/master/df025__RNode_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html
https://root.cern/doc/master/df025__RNode_8C.html:1080,Usability,simpl,simple,1080,"...; Searching...; No Matches. df025_RNode.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Manipulate RDF objects in functions, loops and conditional branches. ; Each RDataFrame object has its own type. It helps with performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFram",MatchSource.WIKI,doc/master/df025__RNode_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html
https://root.cern/doc/master/df025__RNode_8C.html:1310,Usability,simpl,simple,1310,"h performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; f1TF1 * f1Definition legend1.C:11; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefin",MatchSource.WIKI,doc/master/df025__RNode_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html
https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:2665,Deployability,install,install,2665,"ed by PyROOT; # in the Python world. However, be aware that objects other than fundamental types,; # such as complex C++ objects and not int or float, are costly to read-out.; ROOT.gInterpreter.Declare(""""""; // Inject the C++ class CustomObject in the C++ runtime.; class CustomObject {; public:; int x = 42;; };; // Create a function that returns such an object. This is called to fill the dataframe.; CustomObject fill_object() { return CustomObject(); }; """"""); ; df3 = df.Define(""custom_object"", ""fill_object()""); npy5 = df3.AsNumpy(); print(""Read-out of C++ objects:\n{}\n"".format(npy5[""custom_object""])); print(""Access to all methods and data members of the C++ object:\nObject: {}\nAccess data member: custom_object.x = {}\n"".format(; repr(npy5[""custom_object""][0]), npy5[""custom_object""][0].x)); ; # Note that you can pass the object returned by AsNumpy directly to pandas.DataFrame; # including any complex C++ object that may be read-out.; try:; import pandas; except:; print(""Please install the pandas package to run this section of the tutorial.""); exit(1); ; df = pandas.DataFrame(npy5); print(""Content of the ROOT.RDataFrame as pandas.DataFrame:\n{}\n"".format(df)); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProx",MatchSource.WIKI,doc/master/df026__AsNumpyArrays_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html
https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:1007,Energy Efficiency,reduce,reduce,1007,". ROOT: tutorials/dataframe/df026_AsNumpyArrays.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df026_AsNumpyArrays.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Read data from RDataFrame into Numpy arrays. ; ; import ROOT; from sys import exit; ; # Let's create a simple dataframe with ten rows and two columns; df = ROOT.RDataFrame(10) \; .Define(""x"", ""(int)rdfentry_"") \; .Define(""y"", ""1.f/(1.f+rdfentry_)""); ; # Next, we want to access the data from Python as Numpy arrays. To do so, the; # content of the dataframe is converted using the AsNumpy method. The returned; # object is a dictionary with the column names as keys and 1D numpy arrays with; # the content as values.; npy = df.AsNumpy(); print(""Read-out of the full RDataFrame:\n{}\n"".format(npy)); ; # Since reading out data to memory is expensive, always try to read-out only what; # is needed for your analysis. You can use all RDataFrame features to reduce your; # dataset, e.g., the Filter transformation. Furthermore, you can can pass to the; # AsNumpy method a whitelist of column names with the option `columns` or a blacklist; # with column names with the option `exclude`.; df2 = df.Filter(""x>5""); npy2 = df2.AsNumpy(); print(""Read-out of the filtered RDataFrame:\n{}\n"".format(npy2)); ; npy3 = df2.AsNumpy(columns=[""x""]); print(""Read-out of the filtered RDataFrame with the columns option:\n{}\n"".format(npy3)); ; npy4 = df2.AsNumpy(exclude=[""x""]); print(""Read-out of the filtered RDataFrame with the exclude option:\n{}\n"".format(npy4)); ; # You can read-out all objects from ROOT files since these are wrapped by PyROOT; # in the Python world. However, be aware that objects other than fundamental types,; # such as complex C++ objects and not int or float, are costly to read-out.; ROOT.gInterpreter.Declare(""""""; // Inject the C++ class CustomObject in the C++ runtime.; class CustomObject {; public:; int x = 42;; };; // Create a fu",MatchSource.WIKI,doc/master/df026__AsNumpyArrays_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html
https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:1668,Integrability,wrap,wrapped,1668,". The returned; # object is a dictionary with the column names as keys and 1D numpy arrays with; # the content as values.; npy = df.AsNumpy(); print(""Read-out of the full RDataFrame:\n{}\n"".format(npy)); ; # Since reading out data to memory is expensive, always try to read-out only what; # is needed for your analysis. You can use all RDataFrame features to reduce your; # dataset, e.g., the Filter transformation. Furthermore, you can can pass to the; # AsNumpy method a whitelist of column names with the option `columns` or a blacklist; # with column names with the option `exclude`.; df2 = df.Filter(""x>5""); npy2 = df2.AsNumpy(); print(""Read-out of the filtered RDataFrame:\n{}\n"".format(npy2)); ; npy3 = df2.AsNumpy(columns=[""x""]); print(""Read-out of the filtered RDataFrame with the columns option:\n{}\n"".format(npy3)); ; npy4 = df2.AsNumpy(exclude=[""x""]); print(""Read-out of the filtered RDataFrame with the exclude option:\n{}\n"".format(npy4)); ; # You can read-out all objects from ROOT files since these are wrapped by PyROOT; # in the Python world. However, be aware that objects other than fundamental types,; # such as complex C++ objects and not int or float, are costly to read-out.; ROOT.gInterpreter.Declare(""""""; // Inject the C++ class CustomObject in the C++ runtime.; class CustomObject {; public:; int x = 42;; };; // Create a function that returns such an object. This is called to fill the dataframe.; CustomObject fill_object() { return CustomObject(); }; """"""); ; df3 = df.Define(""custom_object"", ""fill_object()""); npy5 = df3.AsNumpy(); print(""Read-out of C++ objects:\n{}\n"".format(npy5[""custom_object""])); print(""Access to all methods and data members of the C++ object:\nObject: {}\nAccess data member: custom_object.x = {}\n"".format(; repr(npy5[""custom_object""][0]), npy5[""custom_object""][0].x)); ; # Note that you can pass the object returned by AsNumpy directly to pandas.DataFrame; # including any complex C++ object that may be read-out.; try:; import pandas; except:",MatchSource.WIKI,doc/master/df026__AsNumpyArrays_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html
https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:3747,Integrability,interface,interface,3747,"(1); ; df = pandas.DataFrame(npy5); print(""Content of the ROOT.RDataFrame as pandas.DataFrame:\n{}\n"".format(df)); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; Read-out of the full RDataFrame:; {'x': ndarray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=int32), 'y': ndarray([1. , 0.5 , 0.33333334, 0.25 , 0.2 ,; 0.16666667, 0.14285715, 0.125 , 0.11111111, 0.1 ],; dtype=float32)}; ; Read-out of the filtered RDataFrame:; {'x': ndarray([6, 7, 8, 9], dtype=int32), 'y': ndarray([0.14285715, 0.125 , 0.11111111, 0.1 ], dtype=float32)}; ; Read-out of the filtered RDataFrame with the columns option:; {'x': ndarray([6, 7, 8, 9], dtype=int32)}; ; Read-out of the filtered RDataFrame with the exclude option:; {'y': ndarray([0.14285715, 0.125 , 0.11111111, 0.1 ], dtype=float32)}; ; Read-out of C++ objects:; [<cppyy.gbl.CustomObject object at 0xe484480>; <cppyy.gbl.CustomObject object at 0xe484484>; <cppyy.gbl.CustomObject object at 0xe484488>; <cppyy.gbl.CustomObject object at 0xe48448c>; <cppyy.gbl.CustomObject object at 0xe484490>; <cppyy.gbl.CustomObject object at 0xe4844",MatchSource.WIKI,doc/master/df026__AsNumpyArrays_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html
https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:524,Security,access,access,524,". ROOT: tutorials/dataframe/df026_AsNumpyArrays.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df026_AsNumpyArrays.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Read data from RDataFrame into Numpy arrays. ; ; import ROOT; from sys import exit; ; # Let's create a simple dataframe with ten rows and two columns; df = ROOT.RDataFrame(10) \; .Define(""x"", ""(int)rdfentry_"") \; .Define(""y"", ""1.f/(1.f+rdfentry_)""); ; # Next, we want to access the data from Python as Numpy arrays. To do so, the; # content of the dataframe is converted using the AsNumpy method. The returned; # object is a dictionary with the column names as keys and 1D numpy arrays with; # the content as values.; npy = df.AsNumpy(); print(""Read-out of the full RDataFrame:\n{}\n"".format(npy)); ; # Since reading out data to memory is expensive, always try to read-out only what; # is needed for your analysis. You can use all RDataFrame features to reduce your; # dataset, e.g., the Filter transformation. Furthermore, you can can pass to the; # AsNumpy method a whitelist of column names with the option `columns` or a blacklist; # with column names with the option `exclude`.; df2 = df.Filter(""x>5""); npy2 = df2.AsNumpy(); print(""Read-out of the filtered RDataFrame:\n{}\n"".format(npy2)); ; npy3 = df2.AsNumpy(columns=[""x""]); print(""Read-out of the filtered RDataFrame with the columns option:\n{}\n"".format(npy3)); ; npy4 = df2.AsNumpy(exclude=[""x""]); print(""Read-out of the filtered RDataFrame with the exclude option:\n{}\n"".format(npy4)); ; # You can read-out all objects from ROOT files since these are wrapped by PyROOT; # in the Python world. However, be aware that objects other than fundamental types,; # such as complex C++ objects and not int or float, are costly to read-out.; ROOT.gInterpreter.Declare(""""""; // Inject the C++ class CustomObject in the C++ runtime.; class CustomObject {; public:; int x = 42;; };; // Create a fun",MatchSource.WIKI,doc/master/df026__AsNumpyArrays_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html
https://root.cern/doc/master/df026__AsNumpyArrays_8py.html:356,Usability,simpl,simple,356,". ROOT: tutorials/dataframe/df026_AsNumpyArrays.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df026_AsNumpyArrays.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Read data from RDataFrame into Numpy arrays. ; ; import ROOT; from sys import exit; ; # Let's create a simple dataframe with ten rows and two columns; df = ROOT.RDataFrame(10) \; .Define(""x"", ""(int)rdfentry_"") \; .Define(""y"", ""1.f/(1.f+rdfentry_)""); ; # Next, we want to access the data from Python as Numpy arrays. To do so, the; # content of the dataframe is converted using the AsNumpy method. The returned; # object is a dictionary with the column names as keys and 1D numpy arrays with; # the content as values.; npy = df.AsNumpy(); print(""Read-out of the full RDataFrame:\n{}\n"".format(npy)); ; # Since reading out data to memory is expensive, always try to read-out only what; # is needed for your analysis. You can use all RDataFrame features to reduce your; # dataset, e.g., the Filter transformation. Furthermore, you can can pass to the; # AsNumpy method a whitelist of column names with the option `columns` or a blacklist; # with column names with the option `exclude`.; df2 = df.Filter(""x>5""); npy2 = df2.AsNumpy(); print(""Read-out of the filtered RDataFrame:\n{}\n"".format(npy2)); ; npy3 = df2.AsNumpy(columns=[""x""]); print(""Read-out of the filtered RDataFrame with the columns option:\n{}\n"".format(npy3)); ; npy4 = df2.AsNumpy(exclude=[""x""]); print(""Read-out of the filtered RDataFrame with the exclude option:\n{}\n"".format(npy4)); ; # You can read-out all objects from ROOT files since these are wrapped by PyROOT; # in the Python world. However, be aware that objects other than fundamental types,; # such as complex C++ objects and not int or float, are costly to read-out.; ROOT.gInterpreter.Declare(""""""; // Inject the C++ class CustomObject in the C++ runtime.; class CustomObject {; public:; int x = 42;; };; // Create a fun",MatchSource.WIKI,doc/master/df026__AsNumpyArrays_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df026__AsNumpyArrays_8py.html
https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html:280,Availability,down,downloads,280,". ROOT: tutorials/dataframe/df027_SQliteDependencyOverVersion.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; This tutorial uses the Reduce method which allows to extract the minimum time stored in the SQlite3 database. The next step is to create a TH1F Histogram, which will be filled with the values stored in two different columns from the database. This procedure is simplified with a lambda expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; ; ; void df027_SQliteDependencyOverVersion (); {; auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; ; std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; ; double minTime = TDatime(minTimeStr.c_str()).Convert();; double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; ; auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; ; auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; ; auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; ; auto h618 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.18"");}, {""Version""}); .Histo1D({""h618"", ""Download time for version 6.18"", 64, minTime, maxTime}, {""datime""});; ; auto customize_histo = [](TH1D &histo) {; auto *xaxis = histo.GetXaxis();; xaxis->SetTimeDisplay(1);; ",MatchSource.WIKI,doc/master/df027__SQliteDependencyOverVersion_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html
https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html:874,Security,access,accesslog,874,". ROOT: tutorials/dataframe/df027_SQliteDependencyOverVersion.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; This tutorial uses the Reduce method which allows to extract the minimum time stored in the SQlite3 database. The next step is to create a TH1F Histogram, which will be filled with the values stored in two different columns from the database. This procedure is simplified with a lambda expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; ; ; void df027_SQliteDependencyOverVersion (); {; auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; ; std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; ; double minTime = TDatime(minTimeStr.c_str()).Convert();; double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; ; auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; ; auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; ; auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; ; auto h618 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.18"");}, {""Version""}); .Histo1D({""h618"", ""Download time for version 6.18"", 64, minTime, maxTime}, {""datime""});; ; auto customize_histo = [](TH1D &histo) {; auto *xaxis = histo.GetXaxis();; xaxis->SetTimeDisplay(1);; ",MatchSource.WIKI,doc/master/df027__SQliteDependencyOverVersion_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html
https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html:605,Usability,simpl,simplified,605,". ROOT: tutorials/dataframe/df027_SQliteDependencyOverVersion.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; This tutorial uses the Reduce method which allows to extract the minimum time stored in the SQlite3 database. The next step is to create a TH1F Histogram, which will be filled with the values stored in two different columns from the database. This procedure is simplified with a lambda expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; ; ; void df027_SQliteDependencyOverVersion (); {; auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; ; std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; ; double minTime = TDatime(minTimeStr.c_str()).Convert();; double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; ; auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; ; auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; ; auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; ; auto h618 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.18"");}, {""Version""}); .Histo1D({""h618"", ""Download time for version 6.18"", 64, minTime, maxTime}, {""datime""});; ; auto customize_histo = [](TH1D &histo) {; auto *xaxis = histo.GetXaxis();; xaxis->SetTimeDisplay(1);; ",MatchSource.WIKI,doc/master/df027__SQliteDependencyOverVersion_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C.html
https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html:318,Availability,down,downloads,318,". ROOT: tutorials/dataframe/df027_SQliteDependencyOverVersion.C Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_dataframe; 3/// \notebook -js; 4/// Plot the ROOT downloads based on the version reading a remote sqlite3 file.; 5///; 6/// This tutorial uses the Reduce method which allows to extract the minimum time; 7/// stored in the SQlite3 database.; 8/// The next step is to create a TH1F Histogram, which will be filled with the values stored in; 9/// two different columns from the database. This procedure is simplified with a lambda; 10/// expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; 11///; 12/// \macro_code; 13/// \macro_image; 14///; 15/// \date August 2018; 16/// \authors Alexandra-Maria Dobrescu, Sergey Linev; 17 ; 18 ; 19void df027_SQliteDependencyOverVersion (); 20{; 21 auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; 22 ; 23 auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; 24 ; 25 std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; 26 ; 27 double minTime = TDatime(minTimeStr.c_str()).Convert();; 28 double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; 29 ; 30 auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; 31 ; 32 auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); 33 .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; 34 ; 35 auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); 36 .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; 37 ; 38 auto h618 = rdf.",MatchSource.WIKI,doc/master/df027__SQliteDependencyOverVersion_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html
https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html:1093,Security,access,accesslog,1093,"ce Guide ; . . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_dataframe; 3/// \notebook -js; 4/// Plot the ROOT downloads based on the version reading a remote sqlite3 file.; 5///; 6/// This tutorial uses the Reduce method which allows to extract the minimum time; 7/// stored in the SQlite3 database.; 8/// The next step is to create a TH1F Histogram, which will be filled with the values stored in; 9/// two different columns from the database. This procedure is simplified with a lambda; 10/// expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; 11///; 12/// \macro_code; 13/// \macro_image; 14///; 15/// \date August 2018; 16/// \authors Alexandra-Maria Dobrescu, Sergey Linev; 17 ; 18 ; 19void df027_SQliteDependencyOverVersion (); 20{; 21 auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; 22 ; 23 auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; 24 ; 25 std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; 26 ; 27 double minTime = TDatime(minTimeStr.c_str()).Convert();; 28 double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; 29 ; 30 auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; 31 ; 32 auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); 33 .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; 34 ; 35 auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); 36 .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; 37 ; 38 auto h618 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.18"");}, {""Version""}); 39 .Histo1D({""h618"", ""Downl",MatchSource.WIKI,doc/master/df027__SQliteDependencyOverVersion_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html
https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html:671,Usability,simpl,simplified,671,". ROOT: tutorials/dataframe/df027_SQliteDependencyOverVersion.C Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_dataframe; 3/// \notebook -js; 4/// Plot the ROOT downloads based on the version reading a remote sqlite3 file.; 5///; 6/// This tutorial uses the Reduce method which allows to extract the minimum time; 7/// stored in the SQlite3 database.; 8/// The next step is to create a TH1F Histogram, which will be filled with the values stored in; 9/// two different columns from the database. This procedure is simplified with a lambda; 10/// expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; 11///; 12/// \macro_code; 13/// \macro_image; 14///; 15/// \date August 2018; 16/// \authors Alexandra-Maria Dobrescu, Sergey Linev; 17 ; 18 ; 19void df027_SQliteDependencyOverVersion (); 20{; 21 auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; 22 ; 23 auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; 24 ; 25 std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; 26 ; 27 double minTime = TDatime(minTimeStr.c_str()).Convert();; 28 double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; 29 ; 30 auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; 31 ; 32 auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); 33 .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; 34 ; 35 auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); 36 .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; 37 ; 38 auto h618 = rdf.",MatchSource.WIKI,doc/master/df027__SQliteDependencyOverVersion_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html
https://root.cern/doc/master/df028__SQliteIPLocation_8C.html:270,Availability,down,downloads,270,". ROOT: tutorials/dataframe/df028_SQliteIPLocation.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df028_SQliteIPLocation.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the location of ROOT downloads reading a remote sqlite3 file. ; The world map is held by a TH2Poly histogram which, after filling, will show the world wide dispersion of ROOT's users. To histogram filling, is done thanks to a lambda expression having as input parameters the two columns of the database: ""IPLongitude' - for the longitude, and the; ""IPLatitude"" - for the latitude.; The data related to the latitude and the longitude has been provided from the; log files storing the users IP.; This product includes GeoLite2 data created by MaxMind, available from; <a href=""http://www.maxmind.com"">http://www.maxmind.com.; ; void df028_SQliteIPLocation() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto f = TFile::Open(""http://root.cern/files/WM.root"");; auto worldMap = f->Get<TH2Poly>(""WMUSA"");; ; auto fillIPLocation = [&worldMap] ( const std::string &sLongitude, const std::string &sLatitude ) {; if (!( sLongitude == """" ) && !( sLatitude == """" )) {; auto latitude = std::stof(sLatitude);; auto longitude = std::stof(sLongitude);; worldMap->Fill(longitude, latitude);; }; };; ; rdf.Foreach( fillIPLocation, { ""IPLongitude"", ""IPLatitude"" } );; ; auto worldMapCanvas = new TCanvas();; worldMapCanvas->SetLogz();; worldMap->SetTitle(""ROOT Downloads per Location (GitHub excluded);Longitude;Latitude"");; worldMap->DrawClone(""colz"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH2Poly2D Hist",MatchSource.WIKI,doc/master/df028__SQliteIPLocation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df028__SQliteIPLocation_8C.html
https://root.cern/doc/master/df028__SQliteIPLocation_8C.html:799,Availability,avail,available,799,". ROOT: tutorials/dataframe/df028_SQliteIPLocation.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df028_SQliteIPLocation.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the location of ROOT downloads reading a remote sqlite3 file. ; The world map is held by a TH2Poly histogram which, after filling, will show the world wide dispersion of ROOT's users. To histogram filling, is done thanks to a lambda expression having as input parameters the two columns of the database: ""IPLongitude' - for the longitude, and the; ""IPLatitude"" - for the latitude.; The data related to the latitude and the longitude has been provided from the; log files storing the users IP.; This product includes GeoLite2 data created by MaxMind, available from; <a href=""http://www.maxmind.com"">http://www.maxmind.com.; ; void df028_SQliteIPLocation() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto f = TFile::Open(""http://root.cern/files/WM.root"");; auto worldMap = f->Get<TH2Poly>(""WMUSA"");; ; auto fillIPLocation = [&worldMap] ( const std::string &sLongitude, const std::string &sLatitude ) {; if (!( sLongitude == """" ) && !( sLatitude == """" )) {; auto latitude = std::stof(sLatitude);; auto longitude = std::stof(sLongitude);; worldMap->Fill(longitude, latitude);; }; };; ; rdf.Foreach( fillIPLocation, { ""IPLongitude"", ""IPLatitude"" } );; ; auto worldMapCanvas = new TCanvas();; worldMapCanvas->SetLogz();; worldMap->SetTitle(""ROOT Downloads per Location (GitHub excluded);Longitude;Latitude"");; worldMap->DrawClone(""colz"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH2Poly2D Hist",MatchSource.WIKI,doc/master/df028__SQliteIPLocation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df028__SQliteIPLocation_8C.html
https://root.cern/doc/master/df028__SQliteIPLocation_8C.html:1011,Security,access,accesslog,1011,"ame/df028_SQliteIPLocation.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df028_SQliteIPLocation.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the location of ROOT downloads reading a remote sqlite3 file. ; The world map is held by a TH2Poly histogram which, after filling, will show the world wide dispersion of ROOT's users. To histogram filling, is done thanks to a lambda expression having as input parameters the two columns of the database: ""IPLongitude' - for the longitude, and the; ""IPLatitude"" - for the latitude.; The data related to the latitude and the longitude has been provided from the; log files storing the users IP.; This product includes GeoLite2 data created by MaxMind, available from; <a href=""http://www.maxmind.com"">http://www.maxmind.com.; ; void df028_SQliteIPLocation() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto f = TFile::Open(""http://root.cern/files/WM.root"");; auto worldMap = f->Get<TH2Poly>(""WMUSA"");; ; auto fillIPLocation = [&worldMap] ( const std::string &sLongitude, const std::string &sLatitude ) {; if (!( sLongitude == """" ) && !( sLatitude == """" )) {; auto latitude = std::stof(sLatitude);; auto longitude = std::stof(sLongitude);; worldMap->Fill(longitude, latitude);; }; };; ; rdf.Foreach( fillIPLocation, { ""IPLongitude"", ""IPLatitude"" } );; ; auto worldMapCanvas = new TCanvas();; worldMapCanvas->SetLogz();; worldMap->SetTitle(""ROOT Downloads per Location (GitHub excluded);Longitude;Latitude"");; worldMap->DrawClone(""colz"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH2Poly2D Histogram with Polygonal Bin",MatchSource.WIKI,doc/master/df028__SQliteIPLocation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df028__SQliteIPLocation_8C.html
https://root.cern/doc/master/df028__SQliteIPLocation_8C.html:710,Testability,log,log,710,". ROOT: tutorials/dataframe/df028_SQliteIPLocation.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df028_SQliteIPLocation.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Plot the location of ROOT downloads reading a remote sqlite3 file. ; The world map is held by a TH2Poly histogram which, after filling, will show the world wide dispersion of ROOT's users. To histogram filling, is done thanks to a lambda expression having as input parameters the two columns of the database: ""IPLongitude' - for the longitude, and the; ""IPLatitude"" - for the latitude.; The data related to the latitude and the longitude has been provided from the; log files storing the users IP.; This product includes GeoLite2 data created by MaxMind, available from; <a href=""http://www.maxmind.com"">http://www.maxmind.com.; ; void df028_SQliteIPLocation() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto f = TFile::Open(""http://root.cern/files/WM.root"");; auto worldMap = f->Get<TH2Poly>(""WMUSA"");; ; auto fillIPLocation = [&worldMap] ( const std::string &sLongitude, const std::string &sLatitude ) {; if (!( sLongitude == """" ) && !( sLatitude == """" )) {; auto latitude = std::stof(sLatitude);; auto longitude = std::stof(sLongitude);; worldMap->Fill(longitude, latitude);; }; };; ; rdf.Foreach( fillIPLocation, { ""IPLongitude"", ""IPLatitude"" } );; ; auto worldMapCanvas = new TCanvas();; worldMapCanvas->SetLogz();; worldMap->SetTitle(""ROOT Downloads per Location (GitHub excluded);Longitude;Latitude"");; worldMap->DrawClone(""colz"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH2Poly2D Hist",MatchSource.WIKI,doc/master/df028__SQliteIPLocation_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df028__SQliteIPLocation_8C.html
https://root.cern/doc/master/df029__SQlitePlatformDistribution_8C.html:306,Availability,down,downloads,306,". ROOT: tutorials/dataframe/df029_SQlitePlatformDistribution.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df029_SQlitePlatformDistribution.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use RDataFrame to display data about ROOT downloads. ; In order to display the Platform Distribution of ROOT, we choose to create two TH1F histograms: one that includes all types of platforms, other filtering and classifying them. This procedure is using a lambda expression taking as parameter the values stored in the ""Platform"" column from the database. At the end, the histograms are filled with their specific demand regarding the platform's type.; ; void df029_SQlitePlatformDistribution() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; TH1F hRootPlatform(""hrootPlatform"", ""Platform Distribution"", 7, 0, -1);; TH1F hShortRootPlatform(""hShortRootPlatform"", ""Short Platform Distribution"", 7, 0, -1);; ; auto fillRootPlatform = [&hRootPlatform, &hShortRootPlatform] ( const std::string &platform ) {; TString Platform = platform;; TString Platform_0(Platform(0,5));; TString Platform_1(Platform(0,6));; TString Platform_2(Platform(0,8));; ; if ( Platform.Contains(""win32"") ){; hShortRootPlatform.Fill(Platform_0,1);; } else if ( Platform.Contains(""Linux"") ){; hShortRootPlatform.Fill(Platform_0,1);; } else if ( Platform.Contains(""source"") ){; hShortRootPlatform.Fill(Platform_1,1);; } else if ( Platform.Contains(""macosx64"") ){; hShortRootPlatform.Fill(Platform_2,1);; } else if ( Platform.Contains(""IRIX64"") ){; hShortRootPlatform.Fill(Platform_1,1);; }; ; hRootPlatform.Fill(Platform,1);; };; ; rdf.Foreach( fillRootPlatform, { ""Platform"" } );; ; auto c1 = new TCanvas();; c1->SetLogy(1);; hRootPlatform.GetXaxis()->LabelsOption(""a"");; hRootPlatform.LabelsDeflate(""X"");; hRootPlatform.DrawClone();; ; auto c2 = new TCanvas();; hShortRootPlatform.GetXaxis(",MatchSource.WIKI,doc/master/df029__SQlitePlatformDistribution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df029__SQlitePlatformDistribution_8C.html
https://root.cern/doc/master/df029__SQlitePlatformDistribution_8C.html:866,Security,access,accesslog,866,"ference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df029_SQlitePlatformDistribution.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use RDataFrame to display data about ROOT downloads. ; In order to display the Platform Distribution of ROOT, we choose to create two TH1F histograms: one that includes all types of platforms, other filtering and classifying them. This procedure is using a lambda expression taking as parameter the values stored in the ""Platform"" column from the database. At the end, the histograms are filled with their specific demand regarding the platform's type.; ; void df029_SQlitePlatformDistribution() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; TH1F hRootPlatform(""hrootPlatform"", ""Platform Distribution"", 7, 0, -1);; TH1F hShortRootPlatform(""hShortRootPlatform"", ""Short Platform Distribution"", 7, 0, -1);; ; auto fillRootPlatform = [&hRootPlatform, &hShortRootPlatform] ( const std::string &platform ) {; TString Platform = platform;; TString Platform_0(Platform(0,5));; TString Platform_1(Platform(0,6));; TString Platform_2(Platform(0,8));; ; if ( Platform.Contains(""win32"") ){; hShortRootPlatform.Fill(Platform_0,1);; } else if ( Platform.Contains(""Linux"") ){; hShortRootPlatform.Fill(Platform_0,1);; } else if ( Platform.Contains(""source"") ){; hShortRootPlatform.Fill(Platform_1,1);; } else if ( Platform.Contains(""macosx64"") ){; hShortRootPlatform.Fill(Platform_2,1);; } else if ( Platform.Contains(""IRIX64"") ){; hShortRootPlatform.Fill(Platform_1,1);; }; ; hRootPlatform.Fill(Platform,1);; };; ; rdf.Foreach( fillRootPlatform, { ""Platform"" } );; ; auto c1 = new TCanvas();; c1->SetLogy(1);; hRootPlatform.GetXaxis()->LabelsOption(""a"");; hRootPlatform.LabelsDeflate(""X"");; hRootPlatform.DrawClone();; ; auto c2 = new TCanvas();; hShortRootPlatform.GetXaxis()->LabelsOption(""a"");; hShortRootPlatform.LabelsDeflate(""X"");; hShort",MatchSource.WIKI,doc/master/df029__SQlitePlatformDistribution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df029__SQlitePlatformDistribution_8C.html
https://root.cern/doc/master/df030__SQliteVersionsOfROOT_8C.html:322,Availability,down,downloads,322,". ROOT: tutorials/dataframe/df030_SQliteVersionsOfROOT.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df030_SQliteVersionsOfROOT.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; Plot the downloads of different ROOT versions reading a remote sqlite3 file with RSqliteDS. Then a TH1F histogram is created and filled using a lambda expression which receives the recorded values in the ""version"" column of the sqlite3 database. The histogram shows the usage of the ROOT development version.; ; void df030_SQliteVersionsOfROOT() {; ; auto rdf =; ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT Version FROM accesslog;"");; ; TH1F hVersionOfRoot(""hVersionOfRoot"", ""Development Versions of ROOT"", 8, 0, -1);; ; auto fillVersionHisto = [&hVersionOfRoot] (const std::string &version) {; TString copyVersion = version;; TString shortVersion(copyVersion(0,4));; hVersionOfRoot.Fill(shortVersion, 1);; };; ; rdf.Foreach( fillVersionHisto, { ""Version"" } );; ; auto VersionOfRootHistogram = new TCanvas();; ; gStyle->SetOptStat(0);; hVersionOfRoot.GetXaxis()->LabelsOption(""a"");; hVersionOfRoot.LabelsDeflate(""X"");; hVersionOfRoot.DrawClone("""");; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; ROOT::RDF::FromSqliteRDataFrame FromSqlite(std::string_view fileName, std::string_view query)Factory method to create a SQlite RDataFrame.Definition RSqliteDS.cxx:538; . DateAugust 2018 ; AuthorAlexandra-Maria Dobrescu ; Definition in file df030_SQli",MatchSource.WIKI,doc/master/df030__SQliteVersionsOfROOT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df030__SQliteVersionsOfROOT_8C.html
https://root.cern/doc/master/df030__SQliteVersionsOfROOT_8C.html:344,Availability,down,downloads,344,". ROOT: tutorials/dataframe/df030_SQliteVersionsOfROOT.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df030_SQliteVersionsOfROOT.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; Plot the downloads of different ROOT versions reading a remote sqlite3 file with RSqliteDS. Then a TH1F histogram is created and filled using a lambda expression which receives the recorded values in the ""version"" column of the sqlite3 database. The histogram shows the usage of the ROOT development version.; ; void df030_SQliteVersionsOfROOT() {; ; auto rdf =; ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT Version FROM accesslog;"");; ; TH1F hVersionOfRoot(""hVersionOfRoot"", ""Development Versions of ROOT"", 8, 0, -1);; ; auto fillVersionHisto = [&hVersionOfRoot] (const std::string &version) {; TString copyVersion = version;; TString shortVersion(copyVersion(0,4));; hVersionOfRoot.Fill(shortVersion, 1);; };; ; rdf.Foreach( fillVersionHisto, { ""Version"" } );; ; auto VersionOfRootHistogram = new TCanvas();; ; gStyle->SetOptStat(0);; hVersionOfRoot.GetXaxis()->LabelsOption(""a"");; hVersionOfRoot.LabelsDeflate(""X"");; hVersionOfRoot.DrawClone("""");; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; ROOT::RDF::FromSqliteRDataFrame FromSqlite(std::string_view fileName, std::string_view query)Factory method to create a SQlite RDataFrame.Definition RSqliteDS.cxx:538; . DateAugust 2018 ; AuthorAlexandra-Maria Dobrescu ; Definition in file df030_SQli",MatchSource.WIKI,doc/master/df030__SQliteVersionsOfROOT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df030__SQliteVersionsOfROOT_8C.html
https://root.cern/doc/master/df030__SQliteVersionsOfROOT_8C.html:794,Security,access,accesslog,794,". ROOT: tutorials/dataframe/df030_SQliteVersionsOfROOT.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df030_SQliteVersionsOfROOT.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; Plot the downloads of different ROOT versions reading a remote sqlite3 file with RSqliteDS. Then a TH1F histogram is created and filled using a lambda expression which receives the recorded values in the ""version"" column of the sqlite3 database. The histogram shows the usage of the ROOT development version.; ; void df030_SQliteVersionsOfROOT() {; ; auto rdf =; ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT Version FROM accesslog;"");; ; TH1F hVersionOfRoot(""hVersionOfRoot"", ""Development Versions of ROOT"", 8, 0, -1);; ; auto fillVersionHisto = [&hVersionOfRoot] (const std::string &version) {; TString copyVersion = version;; TString shortVersion(copyVersion(0,4));; hVersionOfRoot.Fill(shortVersion, 1);; };; ; rdf.Foreach( fillVersionHisto, { ""Version"" } );; ; auto VersionOfRootHistogram = new TCanvas();; ; gStyle->SetOptStat(0);; hVersionOfRoot.GetXaxis()->LabelsOption(""a"");; hVersionOfRoot.LabelsDeflate(""X"");; hVersionOfRoot.DrawClone("""");; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; ROOT::RDF::FromSqliteRDataFrame FromSqlite(std::string_view fileName, std::string_view query)Factory method to create a SQlite RDataFrame.Definition RSqliteDS.cxx:538; . DateAugust 2018 ; AuthorAlexandra-Maria Dobrescu ; Definition in file df030_SQli",MatchSource.WIKI,doc/master/df030__SQliteVersionsOfROOT_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df030__SQliteVersionsOfROOT_8C.html
https://root.cern/doc/master/df031__Stats_8C.html:1461,Integrability,interface,interface,1461,"No Matches. df031_Stats.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the Stats action to extract the statistics of a column. ; Extract the statistics relative to RDataFrame columns and store them in TStatistic instances.; ; void df031_Stats() {; ; // Create a data frame and add two columns: one for the values and one for the weight.; ROOT::RDataFrame r(256);; auto rr = r.Define(""v"", [](ULong64_t e){return e;}, {""rdfentry_""}); .Define(""w"", [](ULong64_t e){return 1./(e+1);}, {""v""});; ; // Now extract the statistics, weighted, unweighted - with and without explicit types.; auto stats_eu = rr.Stats<ULong64_t>(""v"");; auto stats_ew = rr.Stats<ULong64_t, double>(""v"", ""w"");; auto stats_iu = rr.Stats(""v"");; auto stats_iw = rr.Stats(""v"", ""w"");; ; // Now print them: they are all identical of course!; stats_eu->Print();; stats_ew->Print();; stats_iu->Print();; stats_iw->Print();; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df031_StatsDefinition df031_Stats.py:1; ; OBJ: TStatistic Mean = 127.5 +- 4.628 RMS = 74.045 Count = 256 Min = 0 Max = 255; OBJ: TStatistic Mean = 40.8 +- 12.86 RMS = 60.318 Count = 256 Min = 0 Max = 255; OBJ: TStatistic Mean = 127.5 +- 4.628 RMS = 74.045 Count = 256 Min = 0 Max = 255; OBJ: TStatistic Mean = 40.8 +- 12.86 RMS = 60.318 Count = 256 Min = 0 Max = 255; DateApril 2019 ; AuthorDanilo Piparo (CERN) ; Definition in file df031_Stats.C. tutorialsdataframedf031_Stats.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df031__Stats_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df031__Stats_8C.html
https://root.cern/doc/master/df031__Stats_8py.html:856,Integrability,interface,interface,856,". ROOT: tutorials/dataframe/df031_Stats.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df031_Stats.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Use the Stats action to extract the statistics of a column. ; Extract the statistics relative to RDataFrame columns and store them in TStatistic instances.; ; import ROOT; ; # Create a data frame and add two columns: one for the values and one for the weight.; r = ROOT.RDataFrame(256);; rr = r.Define(""v"", ""rdfentry_"")\; .Define(""w"", ""return 1./(v+1)""); ; # Now extract the statistics, weighted, unweighted; stats_iu = rr.Stats(""v""); stats_iw = rr.Stats(""v"", ""w""); ; # Now print them: they are all identical of course!; stats_iu.Print(); stats_iw.Print(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; OBJ: TStatistic Mean = 127.5 +- 4.628 RMS = 74.045 Count = 256 Min = 0 Max = 255; OBJ: TStatistic Mean = 40.8 +- 12.86 RMS = 60.318 Count = 256 Min = 0 Max = 255; DateApril 2019 ; AuthorDanilo Piparo (CERN) ; Definition in file df031_Stats.py. tutorialsdataframedf031_Stats.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df031__Stats_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df031__Stats_8py.html
https://root.cern/doc/master/df033__Describe_8py.html:2399,Integrability,interface,interface,2399,"nt(shortFormat=True); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; Printvoid Print(GNN_Data &d, std::string txt="""")Definition TMVA_SOFIE_GNN_Application.C:59; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; RangeTa Range(0, 0, 1, 1); Dataframe from TChain Events in file root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root; ; Property Value; -------- -----; Columns in total 6; Columns from defines 0; Event loops run 0; ; Column Type Origin; ------ ---- ------; Muon_charge ROOT::VecOps::RVec<Int_t> Dataset; Muon_eta ROOT::VecOps::RVec<Float_t> Dataset; Muon_mass ROOT::VecOps::RVec<Float_t> Dataset; Muon_phi ROOT::VecOps::RVec<Float_t> Dataset; Muon_pt ROOT::VecOps::RVec<Float_t> Dataset; nMuon UInt_t Dataset; ; Approximate mass of the Z boson: 91.44 GeV; ; Dataframe from TChain Events in file root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root; ; Property Value; -------- -----; Columns in total 7; Columns from defines 1; Event loops run 1; ; Column Type Origin; ------ ---- ----",MatchSource.WIKI,doc/master/df033__Describe_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df033__Describe_8py.html
https://root.cern/doc/master/df034__SaveGraph_8C.html:2487,Integrability,interface,interface,2487,"h_1_2_def < 2"", ""Filter_1_2"").Count();; ; ROOT::RDF::RResultPtr<double> branch2_1 = branch2.Filter(""Branch_2_def < 2"", ""Filter_2""); .Define(""Branch_2_1_def"", ""1""); .Define(""Branch_2_2_def"", ""1""); .Filter(""1 == Branch_2_1_def % 2"", ""Filter_2_1""); .Max(""Branch_2_1_def"");; ; ROOT::RDF::RResultPtr<unsigned long long> branch2_2 = branch2.Count();; ; std::cout << ROOT::RDF::SaveGraph(branch1_1);; ROOT::RDF::SaveGraph(rd1, /*output_file=*/""rdf_savegraph_tutorial.dot"");; // SaveGraph produces content in the standard DOT file format; // (https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29): it can be converted to e.g. an image file; // using standard tools such as the `dot` CLI program.; gSystem->Exec(""dot -Tpng rdf_savegraph_tutorial.dot -o rdf_savegraph_tutorial.png"");; }; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDF::RResultPtrSmart pointer for the return type of actions.Definition RResultPtr.hxx:119; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; ROOT::RDF::SaveGraphstd::string SaveGraph(NodeType node)Create a graphviz representation of the dataframe computation graph, return it as a string.Definition RDFHelpers.hxx:120; df034_SaveGraphDefinition df034_SaveGraph.py:1; ; digraph {; 8 [label=""Mean"", style=""filled"", fillcolor=""#e47c7e"", shape=""box""];; 6 [label=""Filter_1_1"", style=""filled"", fillcolor=""#0f9d58"", shape=""hexagon""];; 7 [label=""Define\nBranch_1_1_def"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 3 [label=""Filter_1"", style=""filled"", fillcolor=""#0f9d58"", shape=""hexagon""];; 4 [label=""Define\nBranch_1_def"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 5 [label=""Define\nRoot_def2"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 1 [label=""Main_Filter"", style=""filled"", fillcolor=""#0f9d58"", shape=""hexagon""];;",MatchSource.WIKI,doc/master/df034__SaveGraph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df034__SaveGraph_8C.html
https://root.cern/doc/master/df034__SaveGraph_8py.html:1832,Integrability,interface,interface,1832,"ed as second argument, the graph is saved to that file, otherwise it is returned as a string.; ; import ROOT; ; rd1 = ROOT.RDataFrame(2); ; rd2 = rd1.Define(""Root_def1"", ""1"") \; .Filter(""Root_def1 < 2"", ""Main_Filter"") \; .Define(""Root_def2"", ""1""); ; branch1 = rd2.Define(""Branch_1_def"", ""1""); branch2 = rd2.Define(""Branch_2_def"", ""1""); ; branch1_1 = branch1.Filter(""Branch_1_def < 2"", ""Filter_1"") \; .Define(""Branch_1_1_def"", ""1"") \; .Filter(""1 == Branch_1_1_def % 2"", ""Filter_1_1"") \; .Mean(""Branch_1_1_def"");; ; branch1_2 = branch1.Define(""Branch_1_2_def"", ""1"") \; .Filter(""Branch_1_2_def < 2"", ""Filter_1_2"") \; .Count(); ; branch2_1 = branch2.Filter(""Branch_2_def < 2"", ""Filter_2"") \; .Define(""Branch_2_1_def"", ""1"") \; .Define(""Branch_2_2_def"", ""1"") \; .Filter(""1 == Branch_2_1_def % 2"", ""Filter_2_1"") \; .Max(""Branch_2_1_def""); ; branch2_2 = branch2.Count(); ; print(ROOT.RDF.SaveGraph(branch1_1)); ROOT.RDF.SaveGraph(rd1, ""exampleGraph.dot""); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::SaveGraphstd::string SaveGraph(NodeType node)Create a graphviz representation of the dataframe computation graph, return it as a string.Definition RDFHelpers.hxx:120; digraph {; 8 [label=""Mean"", style=""filled"", fillcolor=""#e47c7e"", shape=""box""];; 6 [label=""Filter_1_1"", style=""filled"", fillcolor=""#0f9d58"", shape=""hexagon""];; 7 [label=""Define\nBranch_1_1_def"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 3 [label=""Filter_1"", style=""filled"", fillcolor=""#0f9d58"", shape=""hexagon""];; 4 [label=""Define\nBranch_1_def"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 5 [label=""Define\nRoot_def2"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 1 [label=""Main_Filter"", style=""filled"", fillcolor=""#0f9d58"", shape=""hexagon""];; 2 [label=""Define\nRoot_def1"", style=""filled"", fillcolor=""#4285f4"", shape=""ellipse""];; 0 [label=""Empty source\nEntries: 2"", style=""filled"", fillcolor=",MatchSource.WIKI,doc/master/df034__SaveGraph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df034__SaveGraph_8py.html
https://root.cern/doc/master/df036__missingBranches_8C.html:3585,Integrability,interface,interface,3585,"(""y"", defaultValue); .Display<int, int>({""x"", ""y""}, /*nRows*/ 15);; ; // Example 2: provide a default value for branch y, but skip events where; // branch x is missing; auto display2 =; df.DefaultValueFor(""y"", defaultValue).FilterAvailable(""x"").Display<int, int>({""x"", ""y""}, /*nRows*/ 15);; ; // Example 3: only keep events where branch y is missing and display values for branch x; auto display3 = df.FilterMissing(""y"").Display<int>({""x""}, /*nRows*/ 15);; ; std::cout << ""Example 1: provide a default value for all missing branches\n"";; display1->Print();; ; std::cout << ""Example 2: provide a default value for branch y, but skip events where branch x is missing\n"";; display2->Print();; ; std::cout << ""Example 3: only keep events where branch y is missing and display values for branch x\n"";; display3->Print();; }; RDataFrame.hxx; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; TChain.h; TFile.h; TTree.h; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TChain::Addvirtual Int_t Add(TChain *chain)Add all files referenced by the passed chain to this chain.Definition TChain.cxx:219; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; df036_missingBranchesDefinition df036_missingBranches.py:1; ; Example 1: provide a default value for all missing branches; +-----+-------------+-------------+; | Row | x | y | ; +-----+-------------+-------------+; | 0 | 1 | 2 | ; +-----+-------------+-------------+; | 1 | 2 | 4 | ; +-----+-------------+-------------+; | 2 | 3 | 6 | ; +-----+-------------+-------------+; | 3 | 4 | 8 | ; +-----+-------------+--",MatchSource.WIKI,doc/master/df036__missingBranches_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df036__missingBranches_8C.html
https://root.cern/doc/master/df037__TTreeEventMatching_8C.html:5417,Integrability,interface,interface,5417," a default value for those; auto display2 = df.DefaultValueFor(auxTree2ColIdx, defaultValue); .DefaultValueFor(auxTree2ColZ, defaultValue); .FilterAvailable(auxTree1ColY); .Display<int, int, int, int, int, int>(; {""idx"", auxTree1ColIdx, auxTree2ColIdx, ""x"", auxTree1ColY, auxTree2ColZ});; ; // Example 3: Keep entries from the main tree for which there is no; // corresponding match in entries of the first auxiliary tree; auto display3 = df.FilterMissing(auxTree1ColIdx).Display<int, int>({""idx"", ""x""});; ; std::cout << ""Example 1: provide default values for all columns\n"";; display1->Print();; std::cout << ""Example 2: skip the entry only when the first auxiliary tree does not match\n"";; display2->Print();; std::cout << ""Example 3: keep entries from the main tree for which there is no match in the auxiliary tree\n"";; display3->Print();; }; RDataFrame.hxx; f#define f(i)Definition RSha256.hxx:104; TChain.h; TFile.h; TTreeIndex.h; TTree.h; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMVA_SOFIE_GNN_Parser.datasetlist datasetDefinition TMVA_SOFIE_GNN_Parser.py:190; df037_TTreeEventMatchingDefinition df037_TTreeEventMatching.py:1; ; Example 1: provide default values for all columns; +-----+-----+---------------+---------------+---+-------------+-------------+; | Row | idx | auxdata_1.idx | auxdata_2.idx | x | auxdata_1.y | auxdata_2.z | ; +-----+-----+---------------+---------------+---+-------------+-------------+; | 0 | 1 | 1 | 1 | 1 | 4 | 6 | ; +-----+-----+---------------+---------------+---+-------------+--------",MatchSource.WIKI,doc/master/df037__TTreeEventMatching_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df037__TTreeEventMatching_8C.html
https://root.cern/doc/master/df101__h1Analysis_8C.html:4231,Integrability,interface,interface,4231,"ot-eos/h1/dstarmb.root"");; chain.Add(""root://eospublic.cern.ch//eos/root-eos/h1/dstarp1a.root"");; chain.Add(""root://eospublic.cern.ch//eos/root-eos/h1/dstarp1b.root"");; chain.Add(""root://eospublic.cern.ch//eos/root-eos/h1/dstarp2.root"");; ; ROOT::EnableImplicitMT(4);; ; ROOT::RDataFrame dataFrame(chain);; auto selected = Select(dataFrame);; // Note: The title syntax is ""<Title>;<Label x axis>;<Label y axis>""; auto hdmdARP = selected.Histo1D({""hdmd"", ""Dm_d;m_{K#pi#pi} - m_{K#pi}[GeV/c^{2}]"", 40, 0.13, 0.17}, ""dm_d"");; auto selectedAddedBranch = selected.Define(""h2_y"", ""rpd0_t / 0.029979f * 1.8646f / ptd0_d"");; auto h2ARP = selectedAddedBranch.Histo2D({""h2"", ""ptD0 vs Dm_d"", 30, 0.135, 0.165, 30, -3, 6}, ""dm_d"", ""h2_y"");; ; FitAndPlotHdmd(*hdmdARP);; FitAndPlotH2(*h2ARP);; }; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< int >; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TO",MatchSource.WIKI,doc/master/df101__h1Analysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df101__h1Analysis_8C.html
https://root.cern/doc/master/df101__h1Analysis_8C.html:6561,Performance,multi-thread,multi-threading,6561,"r to create a simple line.Definition TLine.h:22; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::VecOps::powRVec< PromoteTypes< T0, T1 > > pow(const T0 &x, const RVec< T1 > &v)Definition RVec.hxx:1846; ROOT::VecOps::expRVec< PromoteType< T > > exp(const RVec< T > &v)Definition RVec.hxx:1837; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Create a new collection with the elements passing the filter expressed by the predicate.Definition RVec.hxx:2182; fdm5Double_t fdm5(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:14; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; dxbinconst Double_t dxbinDefinition h1analysisProxy.h:10; fdm2Double_t fdm2(Double_t *xx, Double_t *par)Definition h1analysisProxy.h:25; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; c2return c2Definition legend2.C:14; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; . DateDecember 2016 ; AuthorsAxel Naumann, Danilo Piparo (CERN) ; Definition in file df101_h1Analysis.C. tutorialsdataframedf101_h1Analysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df101__h1Analysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df101__h1Analysis_8C.html
https://root.cern/doc/master/df101__h1Analysis_8C.html:2144,Testability,log,loglikelihood,2144,"r(""njets >= 1"");; ; return ret;; };; ; const Double_t dxbin = (0.17 - 0.13) / 40; // Bin-width; ; Double_t fdm5(Double_t *xx, Double_t *par); {; Double_t x = xx[0];; if (x <= 0.13957); return 0;; Double_t xp3 = (x - par[3]) * (x - par[3]);; Double_t res =; dxbin * (par[0] * pow(x - 0.13957, par[1]) + par[2] / 2.5066 / par[4] * exp(-xp3 / 2 / par[4] / par[4]));; return res;; }; ; Double_t fdm2(Double_t *xx, Double_t *par); {; static const Double_t sigma = 0.0012;; Double_t x = xx[0];; if (x <= 0.13957); return 0;; Double_t xp3 = (x - 0.1454) * (x - 0.1454);; Double_t res = dxbin * (par[0] * pow(x - 0.13957, 0.25) + par[1] / 2.5066 / sigma * exp(-xp3 / 2 / sigma / sigma));; return res;; }; ; void FitAndPlotHdmd(TH1 &hdmd); {; // create the canvas for the h1analysis fit; gStyle->SetOptFit();; auto c1 = new TCanvas(""c1"", ""h1analysis analysis"", 10, 10, 800, 600);; ; hdmd.GetXaxis()->SetTitleOffset(1.4);; ; auto hdraw = (TH1 *) hdmd.DrawClone();; ; // fit histogram hdmd with function f5 using the loglikelihood option; auto f5 = new TF1(""f5"", fdm5, 0.139, 0.17, 5);; f5->SetParameters(1000000, .25, 2000, .1454, .001);; hdraw->Fit(""f5"", ""lr"");; }; ; void FitAndPlotH2(TH2 &h2); {; // create the canvas for tau d0; auto c2 = new TCanvas(""c2"", ""tauD0"", 100, 100, 800, 600);; ; c2->SetGrid();; c2->SetBottomMargin(0.15);; ; // Project slices of 2-d histogram h2 along X , then fit each slice; // with function f2 and make a histogram for each fit parameter; // Note that the generated histograms are added to the list of objects; // in the current directory.; auto f2 = new TF1(""f2"", fdm2, 0.139, 0.17, 2);; f2->SetParameters(10000, 10);; h2.FitSlicesX(f2, 0, -1, 1, ""qln"");; ; // See TH2::FitSlicesX documentation why h2_1 name is used; auto h2_1 = (TH1D *)gDirectory->Get(""h2_1"");; h2_1->SetDirectory(nullptr);; h2_1->GetXaxis()->SetTitle(""#tau [ps]"");; h2_1->SetMarkerStyle(21);; h2_1->Draw();; c2->Update();; ; auto line = new TLine(0, 0, 0, c2->GetUymax());; line->Draw();; }; ; void df101_",MatchSource.WIKI,doc/master/df101__h1Analysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df101__h1Analysis_8C.html
https://root.cern/doc/master/df101__h1Analysis_8C.html:4996,Usability,simpl,simple,4996,"; FitAndPlotH2(*h2ARP);; }; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< int >; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TChainA chain is a collection of files containing TTree objects.Definition TChain.h:33; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::VecOps::powRVec< PromoteTypes< T0, T1 > > pow(const T0 &x, const RVec< T1 > &v)Definition RVec.hxx:1846; ROOT::VecOps::expRVec< PromoteType< T > > exp(const RVec< T > &v)Definition RVec.hxx:1837; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Create a new collection with the elements passing the filter expressed by the predicate.Definition RVec.hxx:2182; fdm5Double_t fdm5(Double_t *xx, ",MatchSource.WIKI,doc/master/df101__h1Analysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df101__h1Analysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1518,Energy Efficiency,charge,charge,1518,"vents from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produce plot; gStyle->SetOptStat(0); gStyle->SetTextFont(42);; auto c = new TCanvas(""c"", """", 800, 700);; c->SetLogx(); c->SetLogy();; ; h->GetXaxis()->SetTitleSize(0.04);; h->GetYaxis()->SetTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1683,Energy Efficiency,charge,charge,1683,"resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produce plot; gStyle->SetOptStat(0); gStyle->SetTextFont(42);; auto c = new TCanvas(""c"", """", 800, 700);; c->SetLogx(); c->SetLogy();; ; h->GetXaxis()->SetTitleSize(0.04);; h->GetYaxis()->SetTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.DrawLatex(0.205, 0.775, ""#rho,#omega"");; label.DrawLatex(0.270, 0.740, ""#phi"");; label.DrawLatex(0.400, 0.800, ""J/#psi"");; label.DrawLatex(0.415, 0.670, ""#psi'"");; label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)"");; label.DrawLatex(0.755, 0.680, ""Z""",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:66681,Energy Efficiency,charge,charge,66681,"===============================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================> | [Elapsed time: 0:10m processing file: 1 / 1 processed evts: 59996000 / 61540413 7.50e+06 evt/s 0:00m remaining time (per file being processed)] ; ; ; [Total elapsed time: 0:11m processed files: 1 / 1 processed evts: 61540413 / 61540413] ; Events with exactly two muons: pass=31104343 all=61540413 -- eff=50.54 % cumulative eff=50.54 %; Muons with opposite charge: pass=24067843 all=31104343 -- eff=77.38 % cumulative eff=39.11 %; DateAugust 2018 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df102_NanoAODDimuonAnalysis.C. tutorialsdataframedf102_NanoAODDimuonAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:3340,Integrability,interface,interface,3340,"etTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.DrawLatex(0.205, 0.775, ""#rho,#omega"");; label.DrawLatex(0.270, 0.740, ""#phi"");; label.DrawLatex(0.400, 0.800, ""J/#psi"");; label.DrawLatex(0.415, 0.670, ""#psi'"");; label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)"");; label.DrawLatex(0.755, 0.680, ""Z"");; label.SetTextSize(0.040); label.DrawLatex(0.100, 0.920, ""#bf{CMS Open Data}"");; label.SetTextSize(0.030); label.DrawLatex(0.630, 0.920, ""#sqrt{s} = 8 TeV, L_{int} = 11.6 fb^{-1}"");; ; c->SaveAs(""dimuon_spectrum.pdf"");; ; // Print cut-flow report; report->Print();; }; ; int main(); {; df102_NanoAODDimuonAnalysis();; }; mainint main()Definition Prototype.cxx:12; RDFHelpers.hxx; RDataFrame.hxx; c#define c(i)Definition RSha256.hxx:101; h#define h(i)Definition RSha256.hxx:106; RVec.hxx; TCanvas.h; TH1D.h; TLatex.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mo",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1125,Performance,multi-thread,multi-threading,1125,"tches. df102_NanoAODDimuonAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how NanoAOD files can be processed with RDataFrame. ; This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produc",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:4679,Performance,multi-thread,multi-threading,4679,"vas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TText::SetNDCvirtual void SetNDC(Bool_t isNDC=kTRUE)Set NDC mode on if isNDC = kTRUE, off otherwise.Definition TText.cxx:823; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::VecOpsDefinition TCollectionProxyInfo.h:42; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; df102_NanoAODDimuonAnalysisDefinition df102_NanoAODDimuonAnalysis.py:1; ; |> | [Elapsed time: 0:03m processing file: 1 / 1 processed evts: 1000 / 46836615 2.58e+02 evt/s 50:21:12h remaining time (per file being processed)] ; |====================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================================",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html:1443,Usability,simpl,simplicity,1443,"vents from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TStyle.h""; ; using namespace ROOT::VecOps;; ; void df102_NanoAODDimuonAnalysis(); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // Create dataframe from NanoAOD files; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/""; ""Run2012BC_DoubleMuParked_Muons.root"");; ; // Add ProgressBar; ROOT::RDF::Experimental::AddProgressBar(df);; ; // For simplicity, select only events with exactly two muons and require opposite charge; auto df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons"");; auto df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge"");; ; // Compute invariant mass of the dimuon system; auto df_mass = df_os.Define(""Dimuon_mass"", InvariantMass<float>, {""Muon_pt"", ""Muon_eta"", ""Muon_phi"", ""Muon_mass""});; ; // Make histogram of dimuon mass spectrum. Note how we can set title and axis labels in one go; auto h = df_mass.Histo1D({""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300}, ""Dimuon_mass"");; ; // Request cut-flow report; auto report = df.Report();; ; // Produce plot; gStyle->SetOptStat(0); gStyle->SetTextFont(42);; auto c = new TCanvas(""c"", """", 800, 700);; c->SetLogx(); c->SetLogy();; ; h->GetXaxis()->SetTitleSize(0.04);; h->GetYaxis()->SetTitleSize(0.04);; h->DrawClone();; ; TLatex label; label.SetNDC(true);; label.DrawLatex(0.175, 0.740, ""#eta"");; label.",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8C.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:1229,Energy Efficiency,charge,charge,1229,"sis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how NanoAOD files can be processed with RDataFrame. ; This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; import ROOT; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create dataframe from NanoAOD files; df = ROOT.RDataFrame(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root""); ; # For simplicity, select only events with exactly two muons and require opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.7",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:1383,Energy Efficiency,charge,charge,1383," with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; import ROOT; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create dataframe from NanoAOD files; df = ROOT.RDataFrame(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root""); ; # For simplicity, select only events with exactly two muons and require opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.740, ""#phi""); label.DrawLatex(0.400, 0.800, ""J/#psi""); label.DrawLatex(0.415, 0.670, ""#psi'""); label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)""); label.DrawLatex(0.755, 0.680, ""Z""); label.SetTextSize(0.0",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:2886,Energy Efficiency,charge,charge,2886,"ire opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.740, ""#phi""); label.DrawLatex(0.400, 0.800, ""J/#psi""); label.DrawLatex(0.415, 0.670, ""#psi'""); label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)""); label.DrawLatex(0.755, 0.680, ""Z""); label.SetTextSize(0.040); label.DrawLatex(0.100, 0.920, ""#bf{CMS Open Data}""); label.SetTextSize(0.030); label.DrawLatex(0.630, 0.920, ""#sqrt{s} = 8 TeV, L_{int} = 11.6 fb^{-1}""); ; c.SaveAs(""dimuon_spectrum.pdf""); ; # Print cut-flow report; report.Print(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; Events with exactly two muons: pass=31104343 all=61540413 -- eff=50.54 % cumulative eff=50.54 %; Muons with opposite charge: pass=24067843 all=31104343 -- eff=77.38 % cumulative eff=39.11 %; DateApril 2019 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df102_NanoAODDimuonAnalysis.py. tutorialsdataframedf102_NanoAODDimuonAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:2688,Integrability,interface,interface,2688,"ire opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.740, ""#phi""); label.DrawLatex(0.400, 0.800, ""J/#psi""); label.DrawLatex(0.415, 0.670, ""#psi'""); label.DrawLatex(0.485, 0.700, ""Y(1,2,3S)""); label.DrawLatex(0.755, 0.680, ""Z""); label.SetTextSize(0.040); label.DrawLatex(0.100, 0.920, ""#bf{CMS Open Data}""); label.SetTextSize(0.030); label.DrawLatex(0.630, 0.920, ""#sqrt{s} = 8 TeV, L_{int} = 11.6 fb^{-1}""); ; c.SaveAs(""dimuon_spectrum.pdf""); ; # Print cut-flow report; report.Print(); ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; Events with exactly two muons: pass=31104343 all=61540413 -- eff=50.54 % cumulative eff=50.54 %; Muons with opposite charge: pass=24067843 all=31104343 -- eff=77.38 % cumulative eff=39.11 %; DateApril 2019 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df102_NanoAODDimuonAnalysis.py. tutorialsdataframedf102_NanoAODDimuonAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:907,Performance,multi-thread,multi-threading,907,". ROOT: tutorials/dataframe/df102_NanoAODDimuonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df102_NanoAODDimuonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how NanoAOD files can be processed with RDataFrame. ; This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; import ROOT; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create dataframe from NanoAOD files; df = ROOT.RDataFrame(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root""); ; # For simplicity, select only events with exactly two muons and require opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetY",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html
https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html:1154,Usability,simpl,simplicity,1154,"sis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Show how NanoAOD files can be processed with RDataFrame. ; This tutorial illustrates how NanoAOD files can be processed with ROOT dataframes. The NanoAOD-like input files are filled with 66 mio. events from CMS OpenData containing muon candidates part of 2012 dataset (DOI: 10.7483/OPENDATA.CMS.YLIC.86ZZ and DOI: 10.7483/OPENDATA.CMS.M5AD.Y3V3). The macro matches muon pairs and produces an histogram of the dimuon mass spectrum showing resonances up to the Z mass. Note that the bump at 30 GeV is not a resonance but a trigger effect.; More details about the dataset can be found on the CERN Open Data portal. ; import ROOT; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create dataframe from NanoAOD files; df = ROOT.RDataFrame(""Events"", ""root://eospublic.cern.ch//eos/opendata/cms/derived-data/AOD2NanoAODOutreachTool/Run2012BC_DoubleMuParked_Muons.root""); ; # For simplicity, select only events with exactly two muons and require opposite charge; df_2mu = df.Filter(""nMuon == 2"", ""Events with exactly two muons""); df_os = df_2mu.Filter(""Muon_charge[0] != Muon_charge[1]"", ""Muons with opposite charge""); ; # Compute invariant mass of the dimuon system; df_mass = df_os.Define(""Dimuon_mass"", ""InvariantMass(Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Make histogram of dimuon mass spectrum. Note how we can set titles and axis labels in one go.; h = df_mass.Histo1D((""Dimuon_mass"", ""Dimuon mass;m_{#mu#mu} (GeV);N_{Events}"", 30000, 0.25, 300), ""Dimuon_mass""); ; # Request cut-flow report; report = df_mass.Report(); ; # Produce plot; ROOT.gStyle.SetOptStat(0); ROOT.gStyle.SetTextFont(42); c = ROOT.TCanvas(""c"", """", 800, 700); c.SetLogx(); c.SetLogy(); ; h.SetTitle(""""); h.GetXaxis().SetTitleSize(0.04); h.GetYaxis().SetTitleSize(0.04); h.Draw(); ; label = ROOT.TLatex(); label.SetNDC(True); label.DrawLatex(0.175, 0.740, ""#eta""); label.DrawLatex(0.205, 0.775, ""#rho,#omega""); label.DrawLatex(0.270, 0.7",MatchSource.WIKI,doc/master/df102__NanoAODDimuonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df102__NanoAODDimuonAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:20171,Availability,avail,available,20171,"co; .Define(""weight"", [&] { return luminosity * xsec_SMHiggsToZZTo4L / nevt_SMHiggsToZZTo4L; }); .Histo1D({""h_sig_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto xsec_ZZTo2el2mu = 0.18; // ZZ->2el2mu: Standard Model cross-section; const auto nevt_ZZTo2el2mu = 1497445.0; // ZZ->2el2mu: Number of simulated events; auto df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu);; auto df_h_bkg_2el2mu = df_bkg_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_ZZTo2el2mu * scale_ZZTo4l / nevt_ZZTo2el2mu; }); .Histo1D({""h_bkg_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; auto df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu);; auto df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", [] { return 1.0; }); .Histo1D({""h_data_2el2mu_doublemu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; // RunGraphs allows to run the event loops of the separate RDataFrame graphs; // concurrently. This results in an improved usage of the available resources; // if each separate RDataFrame can not utilize all available resources, e.g.,; // because not enough data is available.; ROOT::RDF::RunGraphs({df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu});; ; // Make plots; plot(df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf"");; plot(df_h_sig_4el, df_h_bkg_4el, df_h_data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf"");; plot(df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf"");; ; // Combine channels for final plot; auto h_data_4l = df_h_data_4mu.GetPtr();; h_data_4l->Add(df_h_data_4el.GetPtr());; h_data_4l->Add(df_h_data_2el2mu.GetPtr());; auto h_sig_4l = df_h_sig_4mu.GetPtr();; h_sig_4l->Add(df_h_sig_4el.GetPtr());; h_sig_4l->Add(df_h_sig_2el2mu.GetPtr());; auto h_bkg_4l = df_h_bkg_4mu.GetPtr();; h_bkg_4l->Add(df_h_bkg_4el.GetPtr());; h_bkg_4l->Add(df_h_bkg_2el2mu.GetPtr());; plot(h_sig_4l, h_bkg_4l, h_da",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:20243,Availability,avail,available,20243,"co; .Define(""weight"", [&] { return luminosity * xsec_SMHiggsToZZTo4L / nevt_SMHiggsToZZTo4L; }); .Histo1D({""h_sig_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto xsec_ZZTo2el2mu = 0.18; // ZZ->2el2mu: Standard Model cross-section; const auto nevt_ZZTo2el2mu = 1497445.0; // ZZ->2el2mu: Number of simulated events; auto df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu);; auto df_h_bkg_2el2mu = df_bkg_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_ZZTo2el2mu * scale_ZZTo4l / nevt_ZZTo2el2mu; }); .Histo1D({""h_bkg_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; auto df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu);; auto df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", [] { return 1.0; }); .Histo1D({""h_data_2el2mu_doublemu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; // RunGraphs allows to run the event loops of the separate RDataFrame graphs; // concurrently. This results in an improved usage of the available resources; // if each separate RDataFrame can not utilize all available resources, e.g.,; // because not enough data is available.; ROOT::RDF::RunGraphs({df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu});; ; // Make plots; plot(df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf"");; plot(df_h_sig_4el, df_h_bkg_4el, df_h_data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf"");; plot(df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf"");; ; // Combine channels for final plot; auto h_data_4l = df_h_data_4mu.GetPtr();; h_data_4l->Add(df_h_data_4el.GetPtr());; h_data_4l->Add(df_h_data_2el2mu.GetPtr());; auto h_sig_4l = df_h_sig_4mu.GetPtr();; h_sig_4l->Add(df_h_sig_4el.GetPtr());; h_sig_4l->Add(df_h_sig_2el2mu.GetPtr());; auto h_bkg_4l = df_h_bkg_4mu.GetPtr();; h_bkg_4l->Add(df_h_bkg_4el.GetPtr());; h_bkg_4l->Add(df_h_bkg_2el2mu.GetPtr());; plot(h_sig_4l, h_bkg_4l, h_da",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:20301,Availability,avail,available,20301," }); .Histo1D({""h_sig_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto xsec_ZZTo2el2mu = 0.18; // ZZ->2el2mu: Standard Model cross-section; const auto nevt_ZZTo2el2mu = 1497445.0; // ZZ->2el2mu: Number of simulated events; auto df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu);; auto df_h_bkg_2el2mu = df_bkg_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_ZZTo2el2mu * scale_ZZTo4l / nevt_ZZTo2el2mu; }); .Histo1D({""h_bkg_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; auto df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu);; auto df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", [] { return 1.0; }); .Histo1D({""h_data_2el2mu_doublemu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; // RunGraphs allows to run the event loops of the separate RDataFrame graphs; // concurrently. This results in an improved usage of the available resources; // if each separate RDataFrame can not utilize all available resources, e.g.,; // because not enough data is available.; ROOT::RDF::RunGraphs({df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu});; ; // Make plots; plot(df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf"");; plot(df_h_sig_4el, df_h_bkg_4el, df_h_data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf"");; plot(df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf"");; ; // Combine channels for final plot; auto h_data_4l = df_h_data_4mu.GetPtr();; h_data_4l->Add(df_h_data_4el.GetPtr());; h_data_4l->Add(df_h_data_2el2mu.GetPtr());; auto h_sig_4l = df_h_sig_4mu.GetPtr();; h_sig_4l->Add(df_h_sig_4el.GetPtr());; h_sig_4l->Add(df_h_sig_2el2mu.GetPtr());; auto h_bkg_4l = df_h_bkg_4mu.GetPtr();; h_bkg_4l->Add(df_h_bkg_4el.GetPtr());; h_bkg_4l->Add(df_h_bkg_2el2mu.GetPtr());; plot(h_sig_4l, h_bkg_4l, h_data_4l, ""m_{4l} (GeV)"", ""higgs_4l.pdf"");; }; ; int main(); {; df103_NanoAODHiggsAnalysis(/*fa",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:23651,Availability,error,errors,23651,"ition TGWin32VirtualXProxy.cxx:232; TH1D.h; TLatex.h; TLegend.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; Vector4Dfwd.h; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< float >; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexNDCTLatex * DrawLatexNDC(Double_t x, Double_t y, const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex.cxx:1957; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::CombinationsRVec< RVec< std::size_t > > Combinations(const std::size_t size1, const std::size_t size2)Return the indices that represent all combinations of the elements of two RVecs.Definition RVec.hxx:2606; ROOT::Math::Vect",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:25403,Availability,down,down,25403,", const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex.cxx:1957; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::CombinationsRVec< RVec< std::size_t > > Combinations(const std::size_t size1, const std::size_t size2)Return the indices that represent all combinations of the elements of two RVecs.Definition RVec.hxx:2606; ROOT::Math::VectorUtil::DeltaRVector1::Scalar DeltaR(const Vector1 &v1, const Vector2 &v2)Find difference in pseudorapidity (Eta) and Phi between two generic vectors The only requirements on ...Definition VectorUtil.h:112; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::VecOpsDefinition TCollectionProxyInfo.h:42; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; df103_NanoAODHiggsAnalysisDefinition df103_NanoAODHiggsAnalysis.py:1; ; DateOctober 2018 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df103_NanoAODHiggsAnalysis.C. tutorialsdataframedf103_NanoAODHiggsAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:16563,Deployability,integrat,integrated,16563,"ulti-threading; ROOT::EnableImplicitMT();; ; // In fast mode, take samples from */cms_opendata_2012_nanoaod_skimmed/*, which has; // the preselections from the selection_* functions already applied.; std::string path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"";; if (run_fast) path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod_skimmed/"";; ; // Create dataframes for signal, background and data samples; ; // Signal: Higgs -> 4 leptons; ROOT::RDataFrame df_sig_4l(""Events"", path + ""SMHiggsToZZTo4L.root"");; ; // Background: ZZ -> 4 leptons; // Note that additional background processes from the original paper with minor contribution were left out for this; // tutorial.; ROOT::RDataFrame df_bkg_4mu(""Events"", path + ""ZZTo4mu.root"");; ROOT::RDataFrame df_bkg_4el(""Events"", path + ""ZZTo4e.root"");; ROOT::RDataFrame df_bkg_2el2mu(""Events"", path + ""ZZTo2e2mu.root"");; ; // CMS data taken in 2012 (11.6 fb^-1 integrated luminosity); ROOT::RDataFrame df_data_doublemu(; ""Events"", {path + ""Run2012B_DoubleMuParked.root"", path + ""Run2012C_DoubleMuParked.root""});; ROOT::RDataFrame df_data_doubleel(; ""Events"", {path + ""Run2012B_DoubleElectron.root"", path + ""Run2012C_DoubleElectron.root""});; ; // Reconstruct Higgs to 4 muons; auto df_sig_4mu_reco = reco_higgs_to_4mu(df_sig_4l);; const auto luminosity = 11580.0; // Integrated luminosity of the data samples; const auto xsec_SMHiggsToZZTo4L = 0.0065; // H->4l: Standard Model cross-section; const auto nevt_SMHiggsToZZTo4L = 299973.0; // H->4l: Number of simulated events; const auto nbins = 36; // Number of bins for the invariant mass spectrum; auto df_h_sig_4mu = df_sig_4mu_reco; .Define(""weight"", [&] { return luminosity * xsec_SMHiggsToZZTo4L / nevt_SMHiggsToZZTo4L; }); .Histo1D({""h_sig_4mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto scale_ZZTo4l = 1.386; // ZZ->4mu: Scale factor for ZZ to four leptons; const auto xsec_ZZTo4mu = 0.077; // ZZ->4mu: Standard Model cross-section; const a",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:6267,Energy Efficiency,charge,charged,6267,"dxy*Electron_dxy + Electron_dz*Electron_dz)"");; auto df_el_sip3d = df_el_ip3d.Define(""Electron_sip3d_el"",; ""Electron_ip3d_el/sqrt(Electron_dxyErr*Electron_dxyErr + ""; ""Electron_dzErr*Electron_dzErr)"");; auto df_el_track = df_el_sip3d.Filter(""All(Electron_sip3d_el<4) && All(abs(Electron_dxy)<0.5) && All(abs(Electron_dz)<1.0)"",; ""Electron track close to primary vertex with small uncertainty"");; auto df_mu_ip3d = df_el_track.Define(""Muon_ip3d_mu"", ""sqrt(Muon_dxy*Muon_dxy + Muon_dz*Muon_dz)"");; auto df_mu_sip3d = df_mu_ip3d.Define(""Muon_sip3d_mu"",; ""Muon_ip3d_mu/sqrt(Muon_dxyErr*Muon_dxyErr + Muon_dzErr*Muon_dzErr)"");; auto df_mu_track = df_mu_sip3d.Filter(""All(Muon_sip3d_mu<4) && All(abs(Muon_dxy)<0.5) && All(abs(Muon_dz)<1.0)"",; ""Muon track close to primary vertex with small uncertainty"");; auto df_2p2n = df_mu_track.Filter(""Sum(Electron_charge)==0 && Sum(Muon_charge)==0"",; ""Two opposite charged electron and muon pairs"");; return df_2p2n;; }; ; // Reconstruct two Z candidates from four leptons of the same kind; RVec<RVec<size_t>> reco_zz_to_4l(cRVecF pt, cRVecF eta, cRVecF phi, cRVecF mass, const ROOT::RVecI & charge); {; RVec<RVec<size_t>> idx(2);; idx[0].reserve(2); idx[1].reserve(2);; ; // Find first lepton pair with invariant mass closest to Z mass; auto idx_cmb = Combinations(pt, 2);; auto best_mass = -1;; size_t best_i1 = 0; size_t best_i2 = 0;; for (size_t i = 0; i < idx_cmb[0].size(); i++) {; const auto i1 = idx_cmb[0][i];; const auto i2 = idx_cmb[1][i];; if (charge[i1] != charge[i2]) {; ROOT::Math::PtEtaPhiMVector p1(pt[i1], eta[i1], phi[i1], mass[i1]);; ROOT::Math::PtEtaPhiMVector p2(pt[i2], eta[i2], phi[i2], mass[i2]);; const auto this_mass = (p1 + p2).M();; if (std::abs(z_mass - this_mass) < std::abs(z_mass - best_mass)) {; best_mass = this_mass;; best_i1 = i1;; best_i2 = i2;; }; }; }; idx[0].emplace_back(best_i1);; idx[0].emplace_back(best_i2);; ; // Reconstruct second Z from remaining lepton pair; for (size_t i = 0; i < 4; i++) {; if (i != best_i1 && i !",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:6494,Energy Efficiency,charge,charge,6494,"dxy*Electron_dxy + Electron_dz*Electron_dz)"");; auto df_el_sip3d = df_el_ip3d.Define(""Electron_sip3d_el"",; ""Electron_ip3d_el/sqrt(Electron_dxyErr*Electron_dxyErr + ""; ""Electron_dzErr*Electron_dzErr)"");; auto df_el_track = df_el_sip3d.Filter(""All(Electron_sip3d_el<4) && All(abs(Electron_dxy)<0.5) && All(abs(Electron_dz)<1.0)"",; ""Electron track close to primary vertex with small uncertainty"");; auto df_mu_ip3d = df_el_track.Define(""Muon_ip3d_mu"", ""sqrt(Muon_dxy*Muon_dxy + Muon_dz*Muon_dz)"");; auto df_mu_sip3d = df_mu_ip3d.Define(""Muon_sip3d_mu"",; ""Muon_ip3d_mu/sqrt(Muon_dxyErr*Muon_dxyErr + Muon_dzErr*Muon_dzErr)"");; auto df_mu_track = df_mu_sip3d.Filter(""All(Muon_sip3d_mu<4) && All(abs(Muon_dxy)<0.5) && All(abs(Muon_dz)<1.0)"",; ""Muon track close to primary vertex with small uncertainty"");; auto df_2p2n = df_mu_track.Filter(""Sum(Electron_charge)==0 && Sum(Muon_charge)==0"",; ""Two opposite charged electron and muon pairs"");; return df_2p2n;; }; ; // Reconstruct two Z candidates from four leptons of the same kind; RVec<RVec<size_t>> reco_zz_to_4l(cRVecF pt, cRVecF eta, cRVecF phi, cRVecF mass, const ROOT::RVecI & charge); {; RVec<RVec<size_t>> idx(2);; idx[0].reserve(2); idx[1].reserve(2);; ; // Find first lepton pair with invariant mass closest to Z mass; auto idx_cmb = Combinations(pt, 2);; auto best_mass = -1;; size_t best_i1 = 0; size_t best_i2 = 0;; for (size_t i = 0; i < idx_cmb[0].size(); i++) {; const auto i1 = idx_cmb[0][i];; const auto i2 = idx_cmb[1][i];; if (charge[i1] != charge[i2]) {; ROOT::Math::PtEtaPhiMVector p1(pt[i1], eta[i1], phi[i1], mass[i1]);; ROOT::Math::PtEtaPhiMVector p2(pt[i2], eta[i2], phi[i2], mass[i2]);; const auto this_mass = (p1 + p2).M();; if (std::abs(z_mass - this_mass) < std::abs(z_mass - best_mass)) {; best_mass = this_mass;; best_i1 = i1;; best_i2 = i2;; }; }; }; idx[0].emplace_back(best_i1);; idx[0].emplace_back(best_i2);; ; // Reconstruct second Z from remaining lepton pair; for (size_t i = 0; i < 4; i++) {; if (i != best_i1 && i !",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:6858,Energy Efficiency,charge,charge,6858,",; ""Muon_ip3d_mu/sqrt(Muon_dxyErr*Muon_dxyErr + Muon_dzErr*Muon_dzErr)"");; auto df_mu_track = df_mu_sip3d.Filter(""All(Muon_sip3d_mu<4) && All(abs(Muon_dxy)<0.5) && All(abs(Muon_dz)<1.0)"",; ""Muon track close to primary vertex with small uncertainty"");; auto df_2p2n = df_mu_track.Filter(""Sum(Electron_charge)==0 && Sum(Muon_charge)==0"",; ""Two opposite charged electron and muon pairs"");; return df_2p2n;; }; ; // Reconstruct two Z candidates from four leptons of the same kind; RVec<RVec<size_t>> reco_zz_to_4l(cRVecF pt, cRVecF eta, cRVecF phi, cRVecF mass, const ROOT::RVecI & charge); {; RVec<RVec<size_t>> idx(2);; idx[0].reserve(2); idx[1].reserve(2);; ; // Find first lepton pair with invariant mass closest to Z mass; auto idx_cmb = Combinations(pt, 2);; auto best_mass = -1;; size_t best_i1 = 0; size_t best_i2 = 0;; for (size_t i = 0; i < idx_cmb[0].size(); i++) {; const auto i1 = idx_cmb[0][i];; const auto i2 = idx_cmb[1][i];; if (charge[i1] != charge[i2]) {; ROOT::Math::PtEtaPhiMVector p1(pt[i1], eta[i1], phi[i1], mass[i1]);; ROOT::Math::PtEtaPhiMVector p2(pt[i2], eta[i2], phi[i2], mass[i2]);; const auto this_mass = (p1 + p2).M();; if (std::abs(z_mass - this_mass) < std::abs(z_mass - best_mass)) {; best_mass = this_mass;; best_i1 = i1;; best_i2 = i2;; }; }; }; idx[0].emplace_back(best_i1);; idx[0].emplace_back(best_i2);; ; // Reconstruct second Z from remaining lepton pair; for (size_t i = 0; i < 4; i++) {; if (i != best_i1 && i != best_i2) {; idx[1].emplace_back(i);; }; }; ; // Return indices of the pairs building two Z bosons; return idx;; }; ; // Compute Z masses from four leptons of the same kind and sort ascending in distance to Z mass; ROOT::RVecF compute_z_masses_4l(const RVec<RVec<size_t>> &idx, cRVecF pt, cRVecF eta, cRVecF phi, cRVecF mass); {; ROOT::RVecF z_masses(2);; for (size_t i = 0; i < 2; i++) {; const auto i1 = idx[i][0]; const auto i2 = idx[i][1];; ROOT::Math::PtEtaPhiMVector p1(pt[i1], eta[i1], phi[i1], mass[i1]);; ROOT::Math::PtEtaPhiMVector p2(pt",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:6872,Energy Efficiency,charge,charge,6872,",; ""Muon_ip3d_mu/sqrt(Muon_dxyErr*Muon_dxyErr + Muon_dzErr*Muon_dzErr)"");; auto df_mu_track = df_mu_sip3d.Filter(""All(Muon_sip3d_mu<4) && All(abs(Muon_dxy)<0.5) && All(abs(Muon_dz)<1.0)"",; ""Muon track close to primary vertex with small uncertainty"");; auto df_2p2n = df_mu_track.Filter(""Sum(Electron_charge)==0 && Sum(Muon_charge)==0"",; ""Two opposite charged electron and muon pairs"");; return df_2p2n;; }; ; // Reconstruct two Z candidates from four leptons of the same kind; RVec<RVec<size_t>> reco_zz_to_4l(cRVecF pt, cRVecF eta, cRVecF phi, cRVecF mass, const ROOT::RVecI & charge); {; RVec<RVec<size_t>> idx(2);; idx[0].reserve(2); idx[1].reserve(2);; ; // Find first lepton pair with invariant mass closest to Z mass; auto idx_cmb = Combinations(pt, 2);; auto best_mass = -1;; size_t best_i1 = 0; size_t best_i2 = 0;; for (size_t i = 0; i < idx_cmb[0].size(); i++) {; const auto i1 = idx_cmb[0][i];; const auto i2 = idx_cmb[1][i];; if (charge[i1] != charge[i2]) {; ROOT::Math::PtEtaPhiMVector p1(pt[i1], eta[i1], phi[i1], mass[i1]);; ROOT::Math::PtEtaPhiMVector p2(pt[i2], eta[i2], phi[i2], mass[i2]);; const auto this_mass = (p1 + p2).M();; if (std::abs(z_mass - this_mass) < std::abs(z_mass - best_mass)) {; best_mass = this_mass;; best_i1 = i1;; best_i2 = i2;; }; }; }; idx[0].emplace_back(best_i1);; idx[0].emplace_back(best_i2);; ; // Reconstruct second Z from remaining lepton pair; for (size_t i = 0; i < 4; i++) {; if (i != best_i1 && i != best_i2) {; idx[1].emplace_back(i);; }; }; ; // Return indices of the pairs building two Z bosons; return idx;; }; ; // Compute Z masses from four leptons of the same kind and sort ascending in distance to Z mass; ROOT::RVecF compute_z_masses_4l(const RVec<RVec<size_t>> &idx, cRVecF pt, cRVecF eta, cRVecF phi, cRVecF mass); {; ROOT::RVecF z_masses(2);; for (size_t i = 0; i < 2; i++) {; const auto i1 = idx[i][0]; const auto i2 = idx[i][1];; ROOT::Math::PtEtaPhiMVector p1(pt[i1], eta[i1], phi[i1], mass[i1]);; ROOT::Math::PtEtaPhiMVector p2(pt",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:16563,Integrability,integrat,integrated,16563,"ulti-threading; ROOT::EnableImplicitMT();; ; // In fast mode, take samples from */cms_opendata_2012_nanoaod_skimmed/*, which has; // the preselections from the selection_* functions already applied.; std::string path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"";; if (run_fast) path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod_skimmed/"";; ; // Create dataframes for signal, background and data samples; ; // Signal: Higgs -> 4 leptons; ROOT::RDataFrame df_sig_4l(""Events"", path + ""SMHiggsToZZTo4L.root"");; ; // Background: ZZ -> 4 leptons; // Note that additional background processes from the original paper with minor contribution were left out for this; // tutorial.; ROOT::RDataFrame df_bkg_4mu(""Events"", path + ""ZZTo4mu.root"");; ROOT::RDataFrame df_bkg_4el(""Events"", path + ""ZZTo4e.root"");; ROOT::RDataFrame df_bkg_2el2mu(""Events"", path + ""ZZTo2e2mu.root"");; ; // CMS data taken in 2012 (11.6 fb^-1 integrated luminosity); ROOT::RDataFrame df_data_doublemu(; ""Events"", {path + ""Run2012B_DoubleMuParked.root"", path + ""Run2012C_DoubleMuParked.root""});; ROOT::RDataFrame df_data_doubleel(; ""Events"", {path + ""Run2012B_DoubleElectron.root"", path + ""Run2012C_DoubleElectron.root""});; ; // Reconstruct Higgs to 4 muons; auto df_sig_4mu_reco = reco_higgs_to_4mu(df_sig_4l);; const auto luminosity = 11580.0; // Integrated luminosity of the data samples; const auto xsec_SMHiggsToZZTo4L = 0.0065; // H->4l: Standard Model cross-section; const auto nevt_SMHiggsToZZTo4L = 299973.0; // H->4l: Number of simulated events; const auto nbins = 36; // Number of bins for the invariant mass spectrum; auto df_h_sig_4mu = df_sig_4mu_reco; .Define(""weight"", [&] { return luminosity * xsec_SMHiggsToZZTo4L / nevt_SMHiggsToZZTo4L; }); .Histo1D({""h_sig_4mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto scale_ZZTo4l = 1.386; // ZZ->4mu: Scale factor for ZZ to four leptons; const auto xsec_ZZTo4mu = 0.077; // ZZ->4mu: Standard Model cross-section; const a",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:22975,Integrability,interface,interface,22975,"roxy.cxx:104; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TH1D.h; TLatex.h; TLegend.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; Vector4Dfwd.h; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< float >; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexNDCTLatex * DrawLatexNDC(Double_t x, Double_t y, const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex.cxx:1957; TLegendThis class displays a legend b",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:1033,Performance,perform,performed,1033,"g...; Searching...; No Matches. df103_NanoAODHiggsAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total size of only 51MB. If the fast mode is disabled, the tutorial runs over the full dataset with a size of 12GB. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""ROOT/RDF/RInterface.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TLegend.h""; #include <Math/Vector4Dfwd.h>; #include <Math/GenVector/LorentzVector.h>; #include <Math/GenVector/PtEtaPhiM4D.h>; #include ""TSt",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:15609,Performance,multi-thread,multi-threading,15609,"atic_cast<TH1 *>(data->Clone());; h_data->SetLineWidth(1);; h_data->SetMarkerStyle(20);; h_data->SetMarkerSize(1.0);; h_data->SetMarkerColor(kBlack);; h_data->SetLineColor(kBlack);; ; // Draw histograms; h_cmb->Draw(""HIST"");; h_bkg->Draw(""HIST SAME"");; h_data->Draw(""PE1 SAME"");; ; // Add legend; auto legend = new TLegend(0.62, 0.70, 0.82, 0.88);; legend->SetFillColor(0);; legend->SetBorderSize(0);; legend->SetTextSize(0.03);; legend->AddEntry(h_data, ""Data"", ""pe"");; legend->AddEntry(h_bkg, ""ZZ"", ""f"");; legend->AddEntry(h_cmb, ""m_{H} = 125 GeV"", ""f"");; legend->Draw();; ; // Add header; TLatex cms_label;; cms_label.SetTextSize(0.04);; cms_label.DrawLatexNDC(0.16, 0.92, ""#bf{CMS Open Data}"");; TLatex header;; header.SetTextSize(0.03);; header.DrawLatexNDC(0.63, 0.92, ""#sqrt{s} = 8 TeV, L_{int} = 11.6 fb^{-1}"");; ; // Save plot; c->SaveAs(filename.c_str());; }; ; void df103_NanoAODHiggsAnalysis(const bool run_fast = true); {; // Enable multi-threading; ROOT::EnableImplicitMT();; ; // In fast mode, take samples from */cms_opendata_2012_nanoaod_skimmed/*, which has; // the preselections from the selection_* functions already applied.; std::string path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/"";; if (run_fast) path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod_skimmed/"";; ; // Create dataframes for signal, background and data samples; ; // Signal: Higgs -> 4 leptons; ROOT::RDataFrame df_sig_4l(""Events"", path + ""SMHiggsToZZTo4L.root"");; ; // Background: ZZ -> 4 leptons; // Note that additional background processes from the original paper with minor contribution were left out for this; // tutorial.; ROOT::RDataFrame df_bkg_4mu(""Events"", path + ""ZZTo4mu.root"");; ROOT::RDataFrame df_bkg_4el(""Events"", path + ""ZZTo4e.root"");; ROOT::RDataFrame df_bkg_2el2mu(""Events"", path + ""ZZTo2e2mu.root"");; ; // CMS data taken in 2012 (11.6 fb^-1 integrated luminosity); ROOT::RDataFrame df_data_doublemu(; ""Events"", {path + ""Run2012B_DoubleMuParke",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:20116,Performance,concurren,concurrently,20116,""");; ; // Reconstruct Higgs to 2 electrons and 2 muons; auto df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l);; auto df_h_sig_2el2mu = df_sig_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_SMHiggsToZZTo4L / nevt_SMHiggsToZZTo4L; }); .Histo1D({""h_sig_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; const auto xsec_ZZTo2el2mu = 0.18; // ZZ->2el2mu: Standard Model cross-section; const auto nevt_ZZTo2el2mu = 1497445.0; // ZZ->2el2mu: Number of simulated events; auto df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu);; auto df_h_bkg_2el2mu = df_bkg_2el2mu_reco; .Define(""weight"", [&] { return luminosity * xsec_ZZTo2el2mu * scale_ZZTo4l / nevt_ZZTo2el2mu; }); .Histo1D({""h_bkg_2el2mu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; auto df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu);; auto df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", [] { return 1.0; }); .Histo1D({""h_data_2el2mu_doublemu"", """", nbins, 70, 180}, ""H_mass"", ""weight"");; ; // RunGraphs allows to run the event loops of the separate RDataFrame graphs; // concurrently. This results in an improved usage of the available resources; // if each separate RDataFrame can not utilize all available resources, e.g.,; // because not enough data is available.; ROOT::RDF::RunGraphs({df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu});; ; // Make plots; plot(df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf"");; plot(df_h_sig_4el, df_h_bkg_4el, df_h_data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf"");; plot(df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf"");; ; // Combine channels for final plot; auto h_data_4l = df_h_data_4mu.GetPtr();; h_data_4l->Add(df_h_data_4el.GetPtr());; h_data_4l->Add(df_h_data_2el2mu.GetPtr());; auto h_sig_4l = df_h_sig_4mu.GetPtr();; h_sig_4l->Add(df_h_sig_4el.GetPtr());; h_sig_4l->Add(df_h_sig_2el2mu.GetPtr",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:25047,Performance,concurren,concurrently,25047,", const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex.cxx:1957; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::CombinationsRVec< RVec< std::size_t > > Combinations(const std::size_t size1, const std::size_t size2)Return the indices that represent all combinations of the elements of two RVecs.Definition RVec.hxx:2606; ROOT::Math::VectorUtil::DeltaRVector1::Scalar DeltaR(const Vector1 &v1, const Vector2 &v2)Find difference in pseudorapidity (Eta) and Phi between two generic vectors The only requirements on ...Definition VectorUtil.h:112; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::VecOpsDefinition TCollectionProxyInfo.h:42; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; df103_NanoAODHiggsAnalysisDefinition df103_NanoAODHiggsAnalysis.py:1; ; DateOctober 2018 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df103_NanoAODHiggsAnalysis.C. tutorialsdataframedf103_NanoAODHiggsAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:25227,Performance,multi-thread,multi-threading,25227,", const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex.cxx:1957; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::CombinationsRVec< RVec< std::size_t > > Combinations(const std::size_t size1, const std::size_t size2)Return the indices that represent all combinations of the elements of two RVecs.Definition RVec.hxx:2606; ROOT::Math::VectorUtil::DeltaRVector1::Scalar DeltaR(const Vector1 &v1, const Vector2 &v2)Find difference in pseudorapidity (Eta) and Phi between two generic vectors The only requirements on ...Definition VectorUtil.h:112; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::VecOpsDefinition TCollectionProxyInfo.h:42; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; df103_NanoAODHiggsAnalysisDefinition df103_NanoAODHiggsAnalysis.py:1; ; DateOctober 2018 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df103_NanoAODHiggsAnalysis.C. tutorialsdataframedf103_NanoAODHiggsAnalysis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:613,Safety,detect,detector,613,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df103_NanoAODHiggsAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total size of only 51MB. If the fast mode is disabled, the tutorial runs over the full dataset with a size of 12GB. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""ROOT/RDF/RInterface.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TLegend.h""; #inclu",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html:353,Usability,simpl,simplified,353,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df103_NanoAODHiggsAnalysis.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total size of only 51MB. If the fast mode is disabled, the tutorial runs over the full dataset with a size of 12GB. ; #include ""ROOT/RDataFrame.hxx""; #include ""ROOT/RDFHelpers.hxx""; #include ""ROOT/RVec.hxx""; #include ""ROOT/RDF/RInterface.hxx""; #include ""TCanvas.h""; #include ""TH1D.h""; #include ""TLatex.h""; #include ""TLegend.h""; #inclu",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8C.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:15024,Availability,avail,available,15024,"el(df_data_doubleel); ; df_h_data_4el = df_data_4el_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # Reconstruct Higgs to 2 electrons and 2 muons; df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l); ; df_h_sig_2el2mu = df_sig_2el2mu_reco.Define(""weight"", ""{}"".format(weight_sig_2el2mu))\; .Histo1D((""h_sig_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu); ; df_h_bkg_2el2mu = df_bkg_2el2mu_reco.Define(""weight"", ""{}"".format(weight_bkg_2el2mu))\; .Histo1D((""h_bkg_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu); ; df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_2el2mu_doublemu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu]); ; # Get histograms (does not rerun the event loop); signal_4mu = df_h_sig_4mu.GetValue(); background_4mu = df_h_bkg_4mu.GetValue(); data_4mu = df_h_data_4mu.GetValue(); ; signal_4el = df_h_sig_4el.GetValue(); background_4el = df_h_bkg_4el.GetValue(); data_4el = df_h_data_4el.GetValue(); ; signal_2el2mu = df_h_sig_2el2mu.GetValue(); background_2el2mu = df_h_bkg_2el2mu.GetValue(); data_2el2mu = df_h_data_2el2mu.GetValue(); ; # Make plots; plot(signal_4mu, background_4mu, data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf""); plot(signal_4el, background_4el, data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf""); plot(signal_2el2mu, background_2el2mu, data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf""); ; # Combined plots; # If this was ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:15095,Availability,avail,available,15095,"el(df_data_doubleel); ; df_h_data_4el = df_data_4el_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # Reconstruct Higgs to 2 electrons and 2 muons; df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l); ; df_h_sig_2el2mu = df_sig_2el2mu_reco.Define(""weight"", ""{}"".format(weight_sig_2el2mu))\; .Histo1D((""h_sig_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu); ; df_h_bkg_2el2mu = df_bkg_2el2mu_reco.Define(""weight"", ""{}"".format(weight_bkg_2el2mu))\; .Histo1D((""h_bkg_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu); ; df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_2el2mu_doublemu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu]); ; # Get histograms (does not rerun the event loop); signal_4mu = df_h_sig_4mu.GetValue(); background_4mu = df_h_bkg_4mu.GetValue(); data_4mu = df_h_data_4mu.GetValue(); ; signal_4el = df_h_sig_4el.GetValue(); background_4el = df_h_bkg_4el.GetValue(); data_4el = df_h_data_4el.GetValue(); ; signal_2el2mu = df_h_sig_2el2mu.GetValue(); background_2el2mu = df_h_bkg_2el2mu.GetValue(); data_2el2mu = df_h_data_2el2mu.GetValue(); ; # Make plots; plot(signal_4mu, background_4mu, data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf""); plot(signal_4el, background_4el, data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf""); plot(signal_2el2mu, background_2el2mu, data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf""); ; # Combined plots; # If this was ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:15152,Availability,avail,available,15152,"((""h_data_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # Reconstruct Higgs to 2 electrons and 2 muons; df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l); ; df_h_sig_2el2mu = df_sig_2el2mu_reco.Define(""weight"", ""{}"".format(weight_sig_2el2mu))\; .Histo1D((""h_sig_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu); ; df_h_bkg_2el2mu = df_bkg_2el2mu_reco.Define(""weight"", ""{}"".format(weight_bkg_2el2mu))\; .Histo1D((""h_bkg_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu); ; df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_2el2mu_doublemu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu]); ; # Get histograms (does not rerun the event loop); signal_4mu = df_h_sig_4mu.GetValue(); background_4mu = df_h_bkg_4mu.GetValue(); data_4mu = df_h_data_4mu.GetValue(); ; signal_4el = df_h_sig_4el.GetValue(); background_4el = df_h_bkg_4el.GetValue(); data_4el = df_h_data_4el.GetValue(); ; signal_2el2mu = df_h_sig_2el2mu.GetValue(); background_2el2mu = df_h_bkg_2el2mu.GetValue(); data_2el2mu = df_h_data_2el2mu.GetValue(); ; # Make plots; plot(signal_4mu, background_4mu, data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf""); plot(signal_4el, background_4el, data_4el, ""m_{4e} (GeV)"", ""higgs_4el.pdf""); plot(signal_2el2mu, background_2el2mu, data_2el2mu, ""m_{2e2#mu} (GeV)"", ""higgs_2el2mu.pdf""); ; # Combined plots; # If this was done before plotting the others, calling the `Add` function; # on the `signal_4mu` histogra",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:11489,Deployability,integrat,integrated,11489,"ggsAnalysis():; # In fast mode, take samples from */cms_opendata_2012_nanoaod_skimmed/*, which has; # the preselections from the selection_* functions already applied.; path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/""; run_fast = True # Run on skimmed data, set to False to run on full dataset; if run_fast: path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod_skimmed/""; ; # Create dataframes for signal, background and data samples; ; # Signal: Higgs -> 4 leptons; df_sig_4l = ROOT.RDataFrame(""Events"", path + ""SMHiggsToZZTo4L.root""); ; # Background: ZZ -> 4 leptons; # Note that additional background processes from the original paper; # with minor contribution were left out for this; # tutorial.; df_bkg_4mu = ROOT.RDataFrame(""Events"", path + ""ZZTo4mu.root""); df_bkg_4el = ROOT.RDataFrame(""Events"", path + ""ZZTo4e.root""); df_bkg_2el2mu = ROOT.RDataFrame(""Events"", path + ""ZZTo2e2mu.root""); ; # CMS data taken in 2012 (11.6 fb^-1 integrated luminosity); df_data_doublemu = ROOT.RDataFrame(""Events"", (path + f for f in [""Run2012B_DoubleMuParked.root"", ""Run2012C_DoubleMuParked.root""])); df_data_doubleel = ROOT.RDataFrame(""Events"", (path + f for f in [""Run2012B_DoubleElectron.root"", ""Run2012C_DoubleElectron.root""])); ; # Number of bins for all histograms; nbins = 36; ; # Weights; luminosity = 11580.0 # Integrated luminosity of the data samples; ; xsec_ZZTo4mu = 0.077 # ZZ->4mu: Standard Model cross-section; nevt_ZZTo4mu = 1499064.0 # ZZ->4mu: Number of simulated events; ; xsec_ZZTo4el = 0.077 # ZZ->4el: Standard Model cross-section; nevt_ZZTo4el = 1499093.0 # ZZ->4el: Number of simulated events; ; xsec_ZZTo2el2mu = 0.18 # ZZ->2el2mu: Standard Model cross-section; nevt_ZZTo2el2mu = 1497445.0 # ZZ->2el2mu: Number of simulated events; ; xsec_SMHiggsToZZTo4L = 0.0065 # H->4l: Standard Model cross-section; nevt_SMHiggsToZZTo4L = 299973.0 # H->4l: Number of simulated events; scale_ZZTo4l = 1.386 # ZZ->4l: Scale factor for ZZ to four leptons;",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:4745,Energy Efficiency,charge,charged,4745," = df_iso.Define(""Electron_ip3d_el"", ""sqrt(Electron_dxy*Electron_dxy + Electron_dz*Electron_dz)""); df_el_sip3d = df_el_ip3d.Define(""Electron_sip3d_el"",; ""Electron_ip3d_el/sqrt(Electron_dxyErr*Electron_dxyErr + ""; ""Electron_dzErr*Electron_dzErr)""); df_el_track = df_el_sip3d.Filter(""All(Electron_sip3d_el<4) && All(abs(Electron_dxy)<0.5) &&""; "" All(abs(Electron_dz)<1.0)"",; ""Electron track close to primary vertex with small uncertainty""); df_mu_ip3d = df_el_track.Define(""Muon_ip3d_mu"", ""sqrt(Muon_dxy*Muon_dxy + Muon_dz*Muon_dz)""); ; df_mu_sip3d = df_mu_ip3d.Define(""Muon_sip3d_mu"",; ""Muon_ip3d_mu/sqrt(Muon_dxyErr*Muon_dxyErr + Muon_dzErr*Muon_dzErr)""); df_mu_track = df_mu_sip3d.Filter(""All(Muon_sip3d_mu<4) && All(abs(Muon_dxy)<0.5) && All(abs(Muon_dz)<1.0)"",; ""Muon track close to primary vertex with small uncertainty""); df_2p2n = df_mu_track.Filter(""Sum(Electron_charge)==0 && Sum(Muon_charge)==0"",; ""Two opposite charged electron and muon pairs""); ; return df_2p2n; ; ; def reco_higgs_to_4mu(df):; """"""Reconstruct Higgs from four muons""""""; # Filter interesting events; df_base = selection_4mu(df); ; # Reconstruct Z systems; df_z_idx = df_base.Define(""Z_idx"", ""reco_zz_to_4l(Muon_pt, Muon_eta, Muon_phi, Muon_mass, Muon_charge)""); ; # Cut on distance between muons building Z systems; df_z_dr = df_z_idx.Filter(""filter_z_dr(Z_idx, Muon_eta, Muon_phi)"", ""Delta R separation of muons building Z system""); ; # Compute masses of Z systems; df_z_mass = df_z_dr.Define(""Z_mass"", ""compute_z_masses_4l(Z_idx, Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; # Cut on mass of Z candidates; df_z_cut = filter_z_candidates(df_z_mass); ; # Reconstruct H mass; df_h_mass = df_z_cut.Define(""H_mass"", ""compute_higgs_mass_4l(Z_idx, Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; return df_h_mass; ; ; def selection_4mu(df):; """"""Select interesting events with four muons""""""; df_ge4m = df.Filter(""nMuon>=4"", ""At least four muons""); ; df_iso = df_ge4m.Filter(""All(abs(Muon_pfRelIso04_all)<0.40)"", ""Require good isolati",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:11489,Integrability,integrat,integrated,11489,"ggsAnalysis():; # In fast mode, take samples from */cms_opendata_2012_nanoaod_skimmed/*, which has; # the preselections from the selection_* functions already applied.; path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/""; run_fast = True # Run on skimmed data, set to False to run on full dataset; if run_fast: path = ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod_skimmed/""; ; # Create dataframes for signal, background and data samples; ; # Signal: Higgs -> 4 leptons; df_sig_4l = ROOT.RDataFrame(""Events"", path + ""SMHiggsToZZTo4L.root""); ; # Background: ZZ -> 4 leptons; # Note that additional background processes from the original paper; # with minor contribution were left out for this; # tutorial.; df_bkg_4mu = ROOT.RDataFrame(""Events"", path + ""ZZTo4mu.root""); df_bkg_4el = ROOT.RDataFrame(""Events"", path + ""ZZTo4e.root""); df_bkg_2el2mu = ROOT.RDataFrame(""Events"", path + ""ZZTo2e2mu.root""); ; # CMS data taken in 2012 (11.6 fb^-1 integrated luminosity); df_data_doublemu = ROOT.RDataFrame(""Events"", (path + f for f in [""Run2012B_DoubleMuParked.root"", ""Run2012C_DoubleMuParked.root""])); df_data_doubleel = ROOT.RDataFrame(""Events"", (path + f for f in [""Run2012B_DoubleElectron.root"", ""Run2012C_DoubleElectron.root""])); ; # Number of bins for all histograms; nbins = 36; ; # Weights; luminosity = 11580.0 # Integrated luminosity of the data samples; ; xsec_ZZTo4mu = 0.077 # ZZ->4mu: Standard Model cross-section; nevt_ZZTo4mu = 1499064.0 # ZZ->4mu: Number of simulated events; ; xsec_ZZTo4el = 0.077 # ZZ->4el: Standard Model cross-section; nevt_ZZTo4el = 1499093.0 # ZZ->4el: Number of simulated events; ; xsec_ZZTo2el2mu = 0.18 # ZZ->2el2mu: Standard Model cross-section; nevt_ZZTo2el2mu = 1497445.0 # ZZ->2el2mu: Number of simulated events; ; xsec_SMHiggsToZZTo4L = 0.0065 # H->4l: Standard Model cross-section; nevt_SMHiggsToZZTo4L = 299973.0 # H->4l: Number of simulated events; scale_ZZTo4l = 1.386 # ZZ->4l: Scale factor for ZZ to four leptons;",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:17746,Integrability,interface,interface,17746,"gnal_4el); h_sig_4l.Add(signal_2el2mu); ; h_bkg_4l = background_4mu; h_bkg_4l.Add(background_4el); h_bkg_4l.Add(background_2el2mu); ; h_data_4l = data_4mu; h_data_4l.Add(data_4el); h_data_4l.Add(data_2el2mu); ; # Plot aggregated histograms; plot(h_sig_4l, h_bkg_4l, h_data_4l, ""m_{4l} (GeV)"", ""higgs_4l.pdf""); ; ; if __name__ == ""__main__"":; df103_NanoAODHiggsAnalysis(); plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; df103_NanoAODHiggsAnalysisDefinition df103_NanoAODHiggsAnalysis.py:1; DateJuly 2019 ; AuthorsStefan Wunsch (KIT, CERN), Vincenzo Eduardo Padulano (UniMiB, CERN) ; Definition in file df103_NanoAODHiggsAnalysis.py. tutorialsdataframedf103_NanoAODHiggsAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:1048,Performance,perform,performed,1048,"g...; No Matches. Namespaces ; df103_NanoAODHiggsAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that make computations on data to define new columns or filter existing ones in a precise way, better suited to be written in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead create nodes of the computational graph (e.g. Filter, Define) remain inside the main Python script.; The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total siz",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:2282,Performance,multi-thread,multi-threading,2282,", kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that make computations on data to define new columns or filter existing ones in a precise way, better suited to be written in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead create nodes of the computational graph (e.g. Filter, Define) remain inside the main Python script.; The tutorial has the fast mode enabled by default, which reads the data from already skimmed datasets with a total size of only 51MB. If the fast mode is disabled, the tutorial runs over the full dataset with a size of 12GB. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Include necessary header; higgs_header_path = os.path.join(os.sep, str(ROOT.gROOT.GetTutorialDir()) + os.sep, ""dataframe"" + os.sep,; ""df103_NanoAODHiggsAnalysis_python.h""); ; ROOT.gInterpreter.Declare('#include ""{}""'.format(higgs_header_path)); ; ; # Python functions; def reco_higgs_to_2el2mu(df):; """"""Reconstruct Higgs from two electrons and two muons""""""; # Filter interesting events; df_base = selection_2el2mu(df); # Compute masses of Z systems; df_z_mass = df_base.Define(""Z_mass"", ""compute_z_masses_2el2mu(Electron_pt, Electron_eta, Electron_phi,""; "" Electron_mass, Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); # Cut on mass of Z candidates; df_z_cut = filter_z_candidates(df_z_mass); # Reconstruct H mass; df_h_mass = df_z_cut.Define(""H_mass"", ""compute_higgs_mass_2el2mu(Electron_pt, Electron_eta, Electron_phi,""; "" Electron_mass, Muon_pt, Muon_eta, Muon_phi, Muon_mass)""); ; return df_h_mass; ; ; def selection_2el2mu(df):; """"""Select i",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:14969,Performance,concurren,concurrently,14969,"reco.Define(""weight"", ""{}"".format(weight_bkg_4el))\; .Histo1D((""h_bkg_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_4el_reco = reco_higgs_to_4el(df_data_doubleel); ; df_h_data_4el = df_data_4el_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # Reconstruct Higgs to 2 electrons and 2 muons; df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l); ; df_h_sig_2el2mu = df_sig_2el2mu_reco.Define(""weight"", ""{}"".format(weight_sig_2el2mu))\; .Histo1D((""h_sig_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu); ; df_h_bkg_2el2mu = df_bkg_2el2mu_reco.Define(""weight"", ""{}"".format(weight_bkg_2el2mu))\; .Histo1D((""h_bkg_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu); ; df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_2el2mu_doublemu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu]); ; # Get histograms (does not rerun the event loop); signal_4mu = df_h_sig_4mu.GetValue(); background_4mu = df_h_bkg_4mu.GetValue(); data_4mu = df_h_data_4mu.GetValue(); ; signal_4el = df_h_sig_4el.GetValue(); background_4el = df_h_bkg_4el.GetValue(); data_4el = df_h_data_4el.GetValue(); ; signal_2el2mu = df_h_sig_2el2mu.GetValue(); background_2el2mu = df_h_bkg_2el2mu.GetValue(); data_2el2mu = df_h_data_2el2mu.GetValue(); ; # Make plots; plot(signal_4mu, background_4mu, data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf""); plot(signal_4el, background_4el, data_4el, ""m_{4e} ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:17954,Performance,concurren,concurrently,17954,"gnal_4el); h_sig_4l.Add(signal_2el2mu); ; h_bkg_4l = background_4mu; h_bkg_4l.Add(background_4el); h_bkg_4l.Add(background_2el2mu); ; h_data_4l = data_4mu; h_data_4l.Add(data_4el); h_data_4l.Add(data_2el2mu); ; # Plot aggregated histograms; plot(h_sig_4l, h_bkg_4l, h_data_4l, ""m_{4l} (GeV)"", ""higgs_4l.pdf""); ; ; if __name__ == ""__main__"":; df103_NanoAODHiggsAnalysis(); plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; df103_NanoAODHiggsAnalysisDefinition df103_NanoAODHiggsAnalysis.py:1; DateJuly 2019 ; AuthorsStefan Wunsch (KIT, CERN), Vincenzo Eduardo Padulano (UniMiB, CERN) ; Definition in file df103_NanoAODHiggsAnalysis.py. tutorialsdataframedf103_NanoAODHiggsAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:628,Safety,detect,detector,628,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df103_NanoAODHiggsAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that make computations on data to define new columns or filter existing ones in a precise way, better suited to be written in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead create nodes of the computational graph (e.g. Filter, Define) remain inside the ma",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:368,Usability,simpl,simplified,368,". ROOT: tutorials/dataframe/df103_NanoAODHiggsAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df103_NanoAODHiggsAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; This tutorial is a simplified but yet complex example of an analysis reconstructing the Higgs boson decaying to two Z bosons from events with four leptons. The data and simulated events are taken from CERN OpenData representing a subset of the data recorded in 2012 with the CMS detector at the LHC. The tutorials follows the Higgs to four leptons analysis published on CERN Open Data portal (10.7483/OPENDATA.CMS.JKB8.RR42). The resulting plots show the invariant mass of the selected four lepton systems in different decay modes (four muons, four electrons and two of each kind) and in a combined plot indicating the decay of the Higgs boson with a mass of about 125 GeV.; The following steps are performed for each sample with data and simulated events in order to reconstruct the Higgs boson from the selected muons and electrons:; Select interesting events with multiple cuts on event properties, e.g., number of leptons, kinematics of the leptons and quality of the tracks.; Reconstruct two Z bosons of which only one on the mass shell from the selected events and apply additional cuts on the reconstructed objects.; Reconstruct the Higgs boson from the remaining Z boson candidates and calculate its invariant mass. Another aim of this version of the tutorial is to show a way to blend C++ and Python code. All the functions that make computations on data to define new columns or filter existing ones in a precise way, better suited to be written in C++, have been moved to a header that is then declared to the ROOT C++ interpreter. The functions that instead create nodes of the computational graph (e.g. Filter, Define) remain inside the ma",MatchSource.WIKI,doc/master/df103__NanoAODHiggsAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:3757,Availability,avail,available,3757,", phi[1], e[1]);; return (p1 + p2).mass() / 1000.0;; }; """"""); ; # Define a new column with the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] for s in [""ggH"", ""VBF"", ""data""]]); ; ggh = hists[""ggH""].GetValue(); vbf = hists[""VBF""].GetValue(); data = hists[""data""].GetValue(); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pads for main plot and data/MC ratio; c = ROOT.TCanvas(""c"", """", 700, 750); ; upper_pad = ROOT.TPad(""upper_pad"", """", 0, 0.35, 1, 1); lower_pad = ROOT.TPad(""lower_pad"", """", 0, 0, 1, 0.35); for p in [upper_pad, lower_pad]:; p.SetLeftMargin(0.14); p.SetRightMargin(0.05); p.SetTickx(False); p.SetTicky(False); upper_pad.SetBottomMargin(0); lower_pad.SetTopMargin(0); lower_pad.SetBottomMargin(0.3); ; upper_pad.Draw(); lower_pad.Draw(); ; # Fit signal + background model to data; fit = ROOT.TF1(""fit"", ""([0]+[1]*x+[2]*x^2+[3]*x^3)+[4]*exp(-0.5*((x-[5])/[6])^2)"", 105, 160); fit.FixParameter(5, 125.0); fit.FixParameter(4, 119.1); fit.FixPa",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:3828,Availability,avail,available,3828,", phi[1], e[1]);; return (p1 + p2).mass() / 1000.0;; }; """"""); ; # Define a new column with the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] for s in [""ggH"", ""VBF"", ""data""]]); ; ggh = hists[""ggH""].GetValue(); vbf = hists[""VBF""].GetValue(); data = hists[""data""].GetValue(); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pads for main plot and data/MC ratio; c = ROOT.TCanvas(""c"", """", 700, 750); ; upper_pad = ROOT.TPad(""upper_pad"", """", 0, 0.35, 1, 1); lower_pad = ROOT.TPad(""lower_pad"", """", 0, 0, 1, 0.35); for p in [upper_pad, lower_pad]:; p.SetLeftMargin(0.14); p.SetRightMargin(0.05); p.SetTickx(False); p.SetTicky(False); upper_pad.SetBottomMargin(0); lower_pad.SetTopMargin(0); lower_pad.SetBottomMargin(0.3); ; upper_pad.Draw(); lower_pad.Draw(); ; # Fit signal + background model to data; fit = ROOT.TF1(""fit"", ""([0]+[1]*x+[2]*x^2+[3]*x^3)+[4]*exp(-0.5*((x-[5])/[6])^2)"", 105, 160); fit.FixParameter(5, 125.0); fit.FixParameter(4, 119.1); fit.FixPa",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:3885,Availability,avail,available,3885,"the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] for s in [""ggH"", ""VBF"", ""data""]]); ; ggh = hists[""ggH""].GetValue(); vbf = hists[""VBF""].GetValue(); data = hists[""data""].GetValue(); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pads for main plot and data/MC ratio; c = ROOT.TCanvas(""c"", """", 700, 750); ; upper_pad = ROOT.TPad(""upper_pad"", """", 0, 0.35, 1, 1); lower_pad = ROOT.TPad(""lower_pad"", """", 0, 0, 1, 0.35); for p in [upper_pad, lower_pad]:; p.SetLeftMargin(0.14); p.SetRightMargin(0.05); p.SetTickx(False); p.SetTicky(False); upper_pad.SetBottomMargin(0); lower_pad.SetTopMargin(0); lower_pad.SetBottomMargin(0.3); ; upper_pad.Draw(); lower_pad.Draw(); ; # Fit signal + background model to data; fit = ROOT.TF1(""fit"", ""([0]+[1]*x+[2]*x^2+[3]*x^3)+[4]*exp(-0.5*((x-[5])/[6])^2)"", 105, 160); fit.FixParameter(5, 125.0); fit.FixParameter(4, 119.1); fit.FixParameter(6, 2.39); fit.SetLineColor(2); fit.SetLineStyle(1); fit.SetLineWidth(2); data.Fit(""",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:325,Deployability,release,release,325,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:429,Deployability,release,release,429,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:473,Deployability,release,release,473,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:578,Energy Efficiency,energy,energy,578,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:8508,Integrability,interface,interface,8508,"78, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); ; # Save the plot; c.SaveAs(""df104_HiggsToTwoPhotons.png""); print(""Saved figure to df104_HiggsToTwoPhotons.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 19.9699; NDf = 26; Edm = 2.09182e-08; NCalls = 161; p0 = 94325 +/- 72.0525 ; p1 = -1777.22 +/- 0.778155 ; p2 = 11.5606 +/- 0.00536059 ; p3 = -0.0256281 +/- 2.66824e-05 ; p4 = 119.1 (fixed); p5 = 125 (fixed); p6 = 2.39 (fixed); Saved figure to df104_HiggsToTwoPhotons.png; DateFebruary 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df104_HiggsToTwoPhotons.py. tutorialsdataframedf104_HiggsToTwoPhotons.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:968,Performance,multi-thread,multi-threading,968,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:2897,Performance,perform,perform,2897,"[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV and not in the transition region between barrel and encap; df[p] = df[p].Define(""goodphotons"", ""photon_isTightID && (photon_pt > 25000) && (abs(photon_eta) < 2.37) && ((abs(photon_eta) < 1.37) || (abs(photon_eta) > 1.52))"")\; .Filter(""Sum(goodphotons) == 2""); ; # Take only isolated photons; df[p] = df[p].Filter(""Sum(photon_ptcone30[goodphotons] / photon_pt[goodphotons] < 0.065) == 2"")\; .Filter(""Sum(photon_etcone20[goodphotons] / photon_pt[goodphotons] < 0.065) == 2""); ; # Compile a function to compute the invariant mass of the diphoton system; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT;; float ComputeInvariantMass(RVecF pt, RVecF eta, RVecF phi, RVecF e) {; ROOT::Math::PtEtaPhiEVector p1(pt[0], eta[0], phi[0], e[0]);; ROOT::Math::PtEtaPhiEVector p2(pt[1], eta[1], phi[1], e[1]);; return (p1 + p2).mass() / 1000.0;; }; """"""); ; # Define a new column with the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] fo",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:3702,Performance,concurren,concurrently,3702,";; float ComputeInvariantMass(RVecF pt, RVecF eta, RVecF phi, RVecF e) {; ROOT::Math::PtEtaPhiEVector p1(pt[0], eta[0], phi[0], e[0]);; ROOT::Math::PtEtaPhiEVector p2(pt[1], eta[1], phi[1], e[1]);; return (p1 + p2).mass() / 1000.0;; }; """"""); ; # Define a new column with the invariant mass and perform final event selection; hists = {}; for p in processes:; # Make four vectors and compute invariant mass; df[p] = df[p].Define(""m_yy"", ""ComputeInvariantMass(photon_pt[goodphotons], photon_eta[goodphotons], photon_phi[goodphotons], photon_E[goodphotons])""); ; # Make additional kinematic cuts and select mass window; df[p] = df[p].Filter(""photon_pt[goodphotons][0] / 1000.0 / m_yy > 0.35"")\; .Filter(""photon_pt[goodphotons][1] / 1000.0 / m_yy > 0.25"")\; .Filter(""m_yy > 105 && m_yy < 160""); ; # Book histogram of the invariant mass with this selection; hists[p] = df[p].Histo1D(; ROOT.RDF.TH1DModel(p, ""Diphoton invariant mass; m_{#gamma#gamma} [GeV];Events"", 30, 105, 160),; ""m_yy"", ""weight""); ; # Run the event loop; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([hists[s] for s in [""ggH"", ""VBF"", ""data""]]); ; ggh = hists[""ggH""].GetValue(); vbf = hists[""VBF""].GetValue(); data = hists[""data""].GetValue(); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pads for main plot and data/MC ratio; c = ROOT.TCanvas(""c"", """", 700, 750); ; upper_pad = ROOT.TPad(""upper_pad"", """", 0, 0.35, 1, 1); lower_pad = ROOT.TPad(""lower_pad"", """", 0, 0, 1, 0.35); for p in [upper_pad, lower_pad]:; p.SetLeftMargin(0.14); p.SetRightMargin(0.05); p.SetTickx(False); p.SetTicky(False); upper_pad.SetBottomMargin(0); lower_pad.SetTopMargin(0); lower_pad.SetBottomMargin(0.3); ; upper_pad.Draw(); lower_pad.Draw(); ; # Fit signal + backg",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:8716,Performance,concurren,concurrently,8716,"78, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); ; # Save the plot; c.SaveAs(""df104_HiggsToTwoPhotons.png""); print(""Saved figure to df104_HiggsToTwoPhotons.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 19.9699; NDf = 26; Edm = 2.09182e-08; NCalls = 161; p0 = 94325 +/- 72.0525 ; p1 = -1777.22 +/- 0.778155 ; p2 = 11.5606 +/- 0.00536059 ; p3 = -0.0256281 +/- 2.66824e-05 ; p4 = 119.1 (fixed); p5 = 125 (fixed); p6 = 2.39 (fixed); Saved figure to df104_HiggsToTwoPhotons.png; DateFebruary 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df104_HiggsToTwoPhotons.py. tutorialsdataframedf104_HiggsToTwoPhotons.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html:537,Safety,detect,detector,537,". ROOT: tutorials/dataframe/df104_HiggsToTwoPhotons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df104_HiggsToTwoPhotons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; This tutorial is the Higgs to two photons analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Although the Higgs to two photons decay is very rare, the contribution of the Higgs can be seen as a narrow peak around 125 GeV because of the excellent reconstruction and identification efficiency of photons at the ATLAS experiment.; The analysis is translated to a RDataFrame workflow processing 1.7 GB of simulated events and data. ; import ROOT; import os; ; # Enable multi-threading; ROOT.ROOT.EnableImplicitMT(); ; # Create a ROOT dataframe for each dataset; path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; df = {}; df[""data""] = ROOT.RDataFrame(""mini"", (os.path.join(path, ""GamGam/Data/data_{}.GamGam.root"".format(x)) for x in (""A"", ""B"", ""C"", ""D""))); df[""ggH""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_343981.ggH125_gamgam.GamGam.root"")); df[""VBF""] = ROOT.RDataFrame(""mini"", os.path.join(path, ""GamGam/MC/mc_345041.VBFH125_gamgam.GamGam.root"")); processes = list(df.keys()); ; # Apply scale factors and MC weight for simulated events and a weight of 1 for the data; for p in [""ggH"", ""VBF""]:; df[p] = df[p].Define(""weight"",; ""scaleFactor_PHOTON * scaleFactor_PhotonTRIGGER * scaleFactor_PILEUP * mcWeight"");; df[""data""] = df[""data""].Define(""weight"", ""1.0""); ; # Select the events for the analysis; for p in processes:; # Apply preselection cut on photon trigger; df[p] = df[p].Filter(""trigP""); ; # Find two good muons with tight ID, pt > 25 GeV an",MatchSource.WIKI,doc/master/df104__HiggsToTwoPhotons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df104__HiggsToTwoPhotons_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:1357,Availability,avail,available,1357,"is of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:3198,Availability,down,down,3198,"rint('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, phi, e / 1000.0);; if (abs(z0 * sin(p.theta())) > 0.5) return false;; if (type == 11 && abs(eta) < 2.46 && (abs(eta) < 1.37 || abs(eta) > 1.52)) {; if (abs(trackd0pv / tracksigd0pv) > 5) return false;; return true;; }; if (type == 13 && abs(eta) < 2.5) {; if (abs(trackd0pv / tracksigd0pv) > 3) return false;; return true;; }; return false;; }; """"""); ; for s in samples:; # Select events with a muon or electron trigger and with a missing transverse energy larger than 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 3",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:5954,Availability,avail,available,5954,"aleFactor_PILEUP * mcWeight * {} / {} * {}"".format(xsecs[s], sumws[s], lumi)); ; # Compute transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram; ROOT.gInterpreter.Declare(""""""; float ComputeTransverseMass(float met_et, float met_phi, float lep_pt, float lep_eta, float lep_phi, float lep_e); {; ROOT::Math::PtEtaPhiEVector met(met_et, 0, met_phi, met_et);; ROOT::Math::PtEtaPhiEVector lep(lep_pt, lep_eta, lep_phi, lep_e);; return (met + lep).Mt() / 1000.0;; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""mt_w"", ""ComputeTransverseMass(met_et, met_phi, lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx])""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(s, ""mt_w"", 24, 60, 180), ""mt_w"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); wjets = merge_histos(""wjets""); zjets = merge_histos(""zjets""); ttbar = merge_histos(""ttbar""); diboson = merge_histos(""diboson""); singletop = merge_histos(""singletop""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas; c = ROOT.TCanvas(""c"", """", 600, 600); c.SetTickx(0); c.SetTicky(0); c.SetLogy(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); for h, color in zip(; [singletop, diboson, ttbar, zjets, wjets],; [(208, 240, 193), (195, 138, 145), (155, 152, 204), (248, 206, 104), (222, 90, 106)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetC",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:6025,Availability,avail,available,6025,"aleFactor_PILEUP * mcWeight * {} / {} * {}"".format(xsecs[s], sumws[s], lumi)); ; # Compute transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram; ROOT.gInterpreter.Declare(""""""; float ComputeTransverseMass(float met_et, float met_phi, float lep_pt, float lep_eta, float lep_phi, float lep_e); {; ROOT::Math::PtEtaPhiEVector met(met_et, 0, met_phi, met_et);; ROOT::Math::PtEtaPhiEVector lep(lep_pt, lep_eta, lep_phi, lep_e);; return (met + lep).Mt() / 1000.0;; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""mt_w"", ""ComputeTransverseMass(met_et, met_phi, lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx])""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(s, ""mt_w"", 24, 60, 180), ""mt_w"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); wjets = merge_histos(""wjets""); zjets = merge_histos(""zjets""); ttbar = merge_histos(""ttbar""); diboson = merge_histos(""diboson""); singletop = merge_histos(""singletop""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas; c = ROOT.TCanvas(""c"", """", 600, 600); c.SetTickx(0); c.SetTicky(0); c.SetLogy(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); for h, color in zip(; [singletop, diboson, ttbar, zjets, wjets],; [(208, 240, 193), (195, 138, 145), (155, 152, 204), (248, 206, 104), (222, 90, 106)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetC",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:6082,Availability,avail,available,6082,"transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram; ROOT.gInterpreter.Declare(""""""; float ComputeTransverseMass(float met_et, float met_phi, float lep_pt, float lep_eta, float lep_phi, float lep_e); {; ROOT::Math::PtEtaPhiEVector met(met_et, 0, met_phi, met_et);; ROOT::Math::PtEtaPhiEVector lep(lep_pt, lep_eta, lep_phi, lep_e);; return (met + lep).Mt() / 1000.0;; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""mt_w"", ""ComputeTransverseMass(met_et, met_phi, lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx])""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(s, ""mt_w"", 24, 60, 180), ""mt_w"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); wjets = merge_histos(""wjets""); zjets = merge_histos(""zjets""); ttbar = merge_histos(""ttbar""); diboson = merge_histos(""diboson""); singletop = merge_histos(""singletop""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas; c = ROOT.TCanvas(""c"", """", 600, 600); c.SetTickx(0); c.SetTicky(0); c.SetLogy(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); for h, color in zip(; [singletop, diboson, ttbar, zjets, wjets],; [(208, 240, 193), (195, 138, 145), (155, 152, 204), (248, 206, 104), (222, 90, 106)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetColor(*color)); stack.Add(h); stack.Draw(""HIST""); stack.GetXaxis().SetLabelSize(0.04); stack",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:306,Deployability,release,release,306,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:423,Deployability,release,release,423,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:467,Deployability,release,release,467,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:575,Energy Efficiency,energy,energy,575,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:909,Energy Efficiency,reduce,reduce,909,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:4107,Energy Efficiency,energy,energy,4107,"_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, phi, e / 1000.0);; if (abs(z0 * sin(p.theta())) > 0.5) return false;; if (type == 11 && abs(eta) < 2.46 && (abs(eta) < 1.37 || abs(eta) > 1.52)) {; if (abs(trackd0pv / tracksigd0pv) > 5) return false;; return true;; }; if (type == 13 && abs(eta) < 2.5) {; if (abs(trackd0pv / tracksigd0pv) > 3) return false;; return true;; }; return false;; }; """"""); ; for s in samples:; # Select events with a muon or electron trigger and with a missing transverse energy larger than 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Find events with exactly one good lepton; df[s] = df[s].Define(""good_lep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(good_lep) == 1""); ; # Apply additional cuts in case the lepton is an electron or muon; df[s] = df[s].Define(""idx"", ""ROOT::VecOps::ArgMax(good_lep)"")\; .Filter(""GoodElectronOrMuon(lep_type[idx], lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx], lep_trackd0pvunbiased[idx], lep_tracksigd0pvunbiased[idx], lep_z0[idx])""); ; # Apply luminosity, scale factors and MC weights for simulated events; for s in samples:; if ""data"" in s:; df[s] = df[s].Define(""weight"", ""1.0""); else:; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * mcWeight * {} / {} * {}"".form",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:5146,Energy Efficiency,energy,energy,5146,"erse energy larger than 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Find events with exactly one good lepton; df[s] = df[s].Define(""good_lep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(good_lep) == 1""); ; # Apply additional cuts in case the lepton is an electron or muon; df[s] = df[s].Define(""idx"", ""ROOT::VecOps::ArgMax(good_lep)"")\; .Filter(""GoodElectronOrMuon(lep_type[idx], lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx], lep_trackd0pvunbiased[idx], lep_tracksigd0pvunbiased[idx], lep_z0[idx])""); ; # Apply luminosity, scale factors and MC weights for simulated events; for s in samples:; if ""data"" in s:; df[s] = df[s].Define(""weight"", ""1.0""); else:; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * mcWeight * {} / {} * {}"".format(xsecs[s], sumws[s], lumi)); ; # Compute transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram; ROOT.gInterpreter.Declare(""""""; float ComputeTransverseMass(float met_et, float met_phi, float lep_pt, float lep_eta, float lep_phi, float lep_e); {; ROOT::Math::PtEtaPhiEVector met(met_et, 0, met_phi, met_et);; ROOT::Math::PtEtaPhiEVector lep(lep_pt, lep_eta, lep_phi, lep_e);; return (met + lep).Mt() / 1000.0;; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""mt_w"", ""ComputeTransverseMass(met_et, met_phi, lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx])""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(s, ""mt_w"", 24, 60, 180), ""mt_w"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:9316,Integrability,interface,interface,9316,"21, 0.80, ""#sqrt{{s}} = 13 TeV, {:.2f} fb^{{-1}}"".format(lumi * args.lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df105_WBosonAnalysis.png""); print(""Saved figure to df105_WBosonAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.01 fb^-1 ...; Saved figure to df105_WBosonAnalysis.png; DateMarch 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df105_WBosonAnalysis.py. tutorialsdataframedf105_WBosonAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:2547,Performance,load,load,2547,"le to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, fl",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:2652,Performance,load,load,2652,"ch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, ph",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:3419,Performance,perform,performing,3419,"atasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/w""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df105_WBosonAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; bool GoodElectronOrMuon(int type, float pt, float eta, float phi, float e, float trackd0pv, float tracksigd0pv, float z0); {; ROOT::Math::PtEtaPhiEVector p(pt / 1000.0, eta, phi, e / 1000.0);; if (abs(z0 * sin(p.theta())) > 0.5) return false;; if (type == 11 && abs(eta) < 2.46 && (abs(eta) < 1.37 || abs(eta) > 1.52)) {; if (abs(trackd0pv / tracksigd0pv) > 5) return false;; return true;; }; if (type == 13 && abs(eta) < 2.5) {; if (abs(trackd0pv / tracksigd0pv) > 3) return false;; return true;; }; return false;; }; """"""); ; for s in samples:; # Select events with a muon or electron trigger and with a missing transverse energy larger than 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Find events with exactly one good lepton; df[s] = df[s].Define(""good_lep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:5899,Performance,concurren,concurrently,5899," for s in samples:; if ""data"" in s:; df[s] = df[s].Define(""weight"", ""1.0""); else:; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * mcWeight * {} / {} * {}"".format(xsecs[s], sumws[s], lumi)); ; # Compute transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram; ROOT.gInterpreter.Declare(""""""; float ComputeTransverseMass(float met_et, float met_phi, float lep_pt, float lep_eta, float lep_phi, float lep_e); {; ROOT::Math::PtEtaPhiEVector met(met_et, 0, met_phi, met_et);; ROOT::Math::PtEtaPhiEVector lep(lep_pt, lep_eta, lep_phi, lep_e);; return (met + lep).Mt() / 1000.0;; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""mt_w"", ""ComputeTransverseMass(met_et, met_phi, lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx])""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(s, ""mt_w"", 24, 60, 180), ""mt_w"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); wjets = merge_histos(""wjets""); zjets = merge_histos(""zjets""); ttbar = merge_histos(""ttbar""); diboson = merge_histos(""diboson""); singletop = merge_histos(""singletop""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas; c = ROOT.TCanvas(""c"", """", 600, 600); c.SetTickx(0); c.SetTicky(0); c.SetLogy(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); for h, color in zip(; [singletop, diboson, tt",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:9529,Performance,concurren,concurrently,9529,"21, 0.80, ""#sqrt{{s}} = 13 TeV, {:.2f} fb^{{-1}}"".format(lumi * args.lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df105_WBosonAnalysis.png""); print(""Saved figure to df105_WBosonAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.01 fb^-1 ...; Saved figure to df105_WBosonAnalysis.png; DateMarch 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df105_WBosonAnalysis.py. tutorialsdataframedf105_WBosonAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:9659,Performance,multi-thread,multi-threading,9659,"21, 0.80, ""#sqrt{{s}} = 13 TeV, {:.2f} fb^{{-1}}"".format(lumi * args.lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df105_WBosonAnalysis.png""); print(""Saved figure to df105_WBosonAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.01 fb^-1 ...; Saved figure to df105_WBosonAnalysis.png; DateMarch 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df105_WBosonAnalysis.py. tutorialsdataframedf105_WBosonAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:534,Safety,detect,detector,534,". ROOT: tutorials/dataframe/df105_WBosonAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df105_WBosonAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(Tr",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:1382,Usability,usab,usable,1382,"is of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,doc/master/df105__WBosonAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:5271,Availability,mask,mask,5271,"ion that is stored in the JSON config file of the RDataFrame; // The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electron or muon trigger; .Filter(""trigE || trigM""); // Select events with exactly four good leptons conserving charge and lepton numbers; // Note that all collections are RVecs and good_lep is the mask for the good leptons.; // The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; // irrespective of the charge.; .Define(""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3""); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); // Apply additional cuts depending on lepton flavour; .Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], ""; ""lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""); // Create new columns with the kinematics of good leptons; .Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""le",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:8138,Availability,avail,available,8138,"higgs"")""); .Histo1D<float>(ROOT::RDF::TH1DModel(""higgs"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; auto df_zz = df_mc.Filter(""sample_category == \""zz\""""); .Histo1D<float>(ROOT::RDF::TH1DModel(""zz"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; auto df_other = df_mc.Filter(""sample_category == \""other\""""); .Histo1D<float>(ROOT::RDF::TH1DModel(""other"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; ; // Book the invariant mass histogram for the data; auto df_h_mass_data = df_analysis.Filter(""reweighting == false""); .Filter(""sample_category == \""data\""""); .Define(""weight_"", []() { return 1; }); .Histo1D<float>(ROOT::RDF::TH1DModel(""data"", ""m4l"", 24, 80, 170), ""m4l"", ""weight_"");; ; // Evaluate the systematic uncertainty; ; // The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; // kinematics such as pT or pseudorapidity.; // Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON; // Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.0; // The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values; // covered by the analysis.; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph(x.size(), x.data(), y.data());; ; // Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis; // The input consists of the input column to be varied and the lambda function to compute the systematic variations.; // The new output columns contain the varied values of the input column.; auto df_with_variations_mc =; df_mc; .Vary(""weight"",; [&graph](double x, const RVecF &pt, const RVec<unsigned int> &type) {; const auto v = Mean(Map(pt[type == 11], [&graph](auto p) { return graph.Eval(p); }));; return RVec<double",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:9186,Availability,down,down,9186,"plots available in https://doi.org/10.48550/arXiv.1908.0; // The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values; // covered by the analysis.; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph(x.size(), x.data(), y.data());; ; // Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis; // The input consists of the input column to be varied and the lambda function to compute the systematic variations.; // The new output columns contain the varied values of the input column.; auto df_with_variations_mc =; df_mc; .Vary(""weight"",; [&graph](double x, const RVecF &pt, const RVec<unsigned int> &type) {; const auto v = Mean(Map(pt[type == 11], [&graph](auto p) { return graph.Eval(p); }));; return RVec<double>{(1 + v) * x, (1 - v) * x};; },; {""weight"", ""goodlep_pt"", ""goodlep_type""}, {""up"", ""down""}); .Histo1D<float>(ROOT::RDF::TH1DModel(""Invariant Mass"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; ; // Create the total MC scale factor histograms: ""nominal"", ""weight:up"" and ""weight:down"".; auto histos_mc = VariationsFor(df_with_variations_mc);; ; // Evaluate the total MC uncertainty based on the variations. Note, in this case the uncertainties are symmetric.; for (unsigned int i = 0; i < histos_mc[""nominal""].GetXaxis()->GetNbins(); i++) {; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)));; }; ; // Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; gROOT->SetStyle(""ATLAS"");; ; // Create canvas with pad; auto c = new TCanvas(""c"", "" "", 600, 600);; auto pad = new TPad(""upper_pad"", """", 0, 0, 1, 1);; pad->SetTickx(0);; pad->SetTicky(0);; pad->Draw();; pad->cd();; ; // Draw stack with MC contributions; //",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:9375,Availability,down,down,9375,"e of pT values; // covered by the analysis.; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph(x.size(), x.data(), y.data());; ; // Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis; // The input consists of the input column to be varied and the lambda function to compute the systematic variations.; // The new output columns contain the varied values of the input column.; auto df_with_variations_mc =; df_mc; .Vary(""weight"",; [&graph](double x, const RVecF &pt, const RVec<unsigned int> &type) {; const auto v = Mean(Map(pt[type == 11], [&graph](auto p) { return graph.Eval(p); }));; return RVec<double>{(1 + v) * x, (1 - v) * x};; },; {""weight"", ""goodlep_pt"", ""goodlep_type""}, {""up"", ""down""}); .Histo1D<float>(ROOT::RDF::TH1DModel(""Invariant Mass"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; ; // Create the total MC scale factor histograms: ""nominal"", ""weight:up"" and ""weight:down"".; auto histos_mc = VariationsFor(df_with_variations_mc);; ; // Evaluate the total MC uncertainty based on the variations. Note, in this case the uncertainties are symmetric.; for (unsigned int i = 0; i < histos_mc[""nominal""].GetXaxis()->GetNbins(); i++) {; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)));; }; ; // Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; gROOT->SetStyle(""ATLAS"");; ; // Create canvas with pad; auto c = new TCanvas(""c"", "" "", 600, 600);; auto pad = new TPad(""upper_pad"", """", 0, 0, 1, 1);; pad->SetTickx(0);; pad->SetTicky(0);; pad->Draw();; pad->cd();; ; // Draw stack with MC contributions; // Draw cloned histograms to preserve graphics when original objects goes out of scope; df_other->SetFillColor(kViolet - 9);; df_zz->SetFillColor(kAzure - 9);",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:11535,Availability,down,down,11535," h_higgs = static_cast<TH1 *>(df_higgs->Clone());; stack->Add(h_higgs);; stack->Draw(""HIST"");; ; // stack histogram can be accessed only after drawing; stack->GetHistogram()->SetTitle("""");; stack->GetHistogram()->GetXaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetXaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetXaxis()->SetTitleOffset(1.3);; stack->GetHistogram()->GetXaxis()->SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]"");; stack->GetHistogram()->GetYaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetYaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetYaxis()->SetTitle(""Events"");; stack->SetMaximum(35);; stack->GetHistogram()->GetYaxis()->ChangeLabel(1, -1, 0);; ; // Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(kBlack);; histos_mc[""nominal""].SetFillStyle(3254);; auto h_nominal = histos_mc[""nominal""].DrawClone(""E2 same"");; histos_mc[""weight:up""].SetLineColor(kGreen + 2);; auto h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST same"");; histos_mc[""weight:down""].SetLineColor(kBlue + 2);; auto h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST same"");; ; // Draw data histogram; df_h_mass_data->SetMarkerStyle(20);; df_h_mass_data->SetMarkerSize(1.);; df_h_mass_data->SetLineWidth(2);; df_h_mass_data->SetLineColor(kBlack);; df_h_mass_data->SetStats(false);; auto h_mass_data = df_h_mass_data->DrawClone(""E sames"");; ; // Add legend; auto legend = new TLegend(0.57, 0.65, 0.94, 0.94);; legend->SetTextFont(42);; legend->SetFillStyle(0);; legend->SetBorderSize(0);; legend->SetTextSize(0.025);; legend->SetTextAlign(32);; legend->AddEntry(h_mass_data, ""Data"", ""lep"");; legend->AddEntry(h_higgs, ""Higgs MC"", ""f"");; legend->AddEntry(h_zz, ""ZZ MC"", ""f"");; legend->AddEntry(h_other, ""Other MC"", ""f"");; legend->AddEntry(h_weight_down, ""Total MC Variations Down"", ""l"");; legend->AddEntry(h_weight_up, ""Total MC Variations Up"", ""l"");; legend->AddEntry(h_nominal, ""Total MC Uncertainty"", ""f"");; legend->Draw();; ; // Add ATLAS label; TLatex",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:11607,Availability,down,down,11607,"(h_higgs);; stack->Draw(""HIST"");; ; // stack histogram can be accessed only after drawing; stack->GetHistogram()->SetTitle("""");; stack->GetHistogram()->GetXaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetXaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetXaxis()->SetTitleOffset(1.3);; stack->GetHistogram()->GetXaxis()->SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]"");; stack->GetHistogram()->GetYaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetYaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetYaxis()->SetTitle(""Events"");; stack->SetMaximum(35);; stack->GetHistogram()->GetYaxis()->ChangeLabel(1, -1, 0);; ; // Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(kBlack);; histos_mc[""nominal""].SetFillStyle(3254);; auto h_nominal = histos_mc[""nominal""].DrawClone(""E2 same"");; histos_mc[""weight:up""].SetLineColor(kGreen + 2);; auto h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST same"");; histos_mc[""weight:down""].SetLineColor(kBlue + 2);; auto h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST same"");; ; // Draw data histogram; df_h_mass_data->SetMarkerStyle(20);; df_h_mass_data->SetMarkerSize(1.);; df_h_mass_data->SetLineWidth(2);; df_h_mass_data->SetLineColor(kBlack);; df_h_mass_data->SetStats(false);; auto h_mass_data = df_h_mass_data->DrawClone(""E sames"");; ; // Add legend; auto legend = new TLegend(0.57, 0.65, 0.94, 0.94);; legend->SetTextFont(42);; legend->SetFillStyle(0);; legend->SetBorderSize(0);; legend->SetTextSize(0.025);; legend->SetTextAlign(32);; legend->AddEntry(h_mass_data, ""Data"", ""lep"");; legend->AddEntry(h_higgs, ""Higgs MC"", ""f"");; legend->AddEntry(h_zz, ""ZZ MC"", ""f"");; legend->AddEntry(h_other, ""Other MC"", ""f"");; legend->AddEntry(h_weight_down, ""Total MC Variations Down"", ""l"");; legend->AddEntry(h_weight_up, ""Total MC Variations Up"", ""l"");; legend->AddEntry(h_nominal, ""Total MC Uncertainty"", ""f"");; legend->Draw();; ; // Add ATLAS label; TLatex atlas_label;; atlas_label.SetTextFont(70);; atlas_label.SetT",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:15870,Availability,error,errors,15870,"ed, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.Definition RInterface.hxx:735; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< float >; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; THStackThe Histogram stack class.Definition THStack.h:40; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexNDCTLatex * DrawLatexNDC(Double_t x, Double_t y, const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex.cxx:1957; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TObject::SaveAsvirtual void SaveAs(const char *filename="""", Option_t *option="""") constSave this object in the file specified by filename.Definition TObject.cxx:692; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::Mapauto Map(Args &&... args)Create new collection applying a callable to the elements of the input collection.Definition RVec.hxx:2150; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Cre",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:307,Deployability,release,release,307,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:419,Deployability,release,release,419,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:463,Deployability,release,release,463,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:14917,Deployability,update,updated,14917,"w_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; TH1D.h; THStack.h; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TLatex.h; TLegend.h; TProfile.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; Vector4D.h; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.Definition RInterface.hxx:735; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< float >; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this +",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:568,Energy Efficiency,energy,energy,568,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:5185,Energy Efficiency,charge,charge,5185,"ion that is stored in the JSON config file of the RDataFrame; // The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electron or muon trigger; .Filter(""trigE || trigM""); // Select events with exactly four good leptons conserving charge and lepton numbers; // Note that all collections are RVecs and good_lep is the mask for the good leptons.; // The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; // irrespective of the charge.; .Define(""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3""); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); // Apply additional cuts depending on lepton flavour; .Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], ""; ""lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""); // Create new columns with the kinematics of good leptons; .Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""le",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:5403,Energy Efficiency,charge,charge,5403,"ough the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electron or muon trigger; .Filter(""trigE || trigM""); // Select events with exactly four good leptons conserving charge and lepton numbers; // Note that all collections are RVecs and good_lep is the mask for the good leptons.; // The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; // irrespective of the charge.; .Define(""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3""); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); // Apply additional cuts depending on lepton flavour; .Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], ""; ""lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""); // Create new columns with the kinematics of good leptons; .Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""lep_phi[good_lep]""); .Define(""goodlep_E"", ""lep_E[good_lep]""); .Define(""goodlep_type"", ""lep_type[good_lep]""); // Select leptons with high transverse momentum;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:5777,Integrability,depend,depending,5777,"e_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electron or muon trigger; .Filter(""trigE || trigM""); // Select events with exactly four good leptons conserving charge and lepton numbers; // Note that all collections are RVecs and good_lep is the mask for the good leptons.; // The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; // irrespective of the charge.; .Define(""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3""); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); // Apply additional cuts depending on lepton flavour; .Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], ""; ""lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""); // Create new columns with the kinematics of good leptons; .Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""lep_phi[good_lep]""); .Define(""goodlep_E"", ""lep_E[good_lep]""); .Define(""goodlep_type"", ""lep_type[good_lep]""); // Select leptons with high transverse momentum; .Filter(""goodlep_pt[0] > 25000 && goodlep_pt[1] > 15000 && goodlep_pt[2] > 10000""); // Compute invariant mass; .Define(""m4l"", ""ComputeInvariantMass(goodlep_pt, goodlep_eta, goodlep_phi, goodlep_E)""); // Reweighting of the samples is different for ""data"" and ""MC""; .DefinePerSample(""reweighting"", [](unsigned int slot, const RSampleInfo &id) { return id.Contains(""mc""); });; ; // Def",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:7902,Integrability,depend,depends,7902,"(""reweighting == true""); .Define(""weight"", (""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * ""; ""scaleFactor_PILEUP * mcWeight * scale * xsecs / sumws * lumi""));; ; // Book histograms for individual MC samples; auto df_higgs = df_mc.Filter(R""(sample_category == ""higgs"")""); .Histo1D<float>(ROOT::RDF::TH1DModel(""higgs"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; auto df_zz = df_mc.Filter(""sample_category == \""zz\""""); .Histo1D<float>(ROOT::RDF::TH1DModel(""zz"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; auto df_other = df_mc.Filter(""sample_category == \""other\""""); .Histo1D<float>(ROOT::RDF::TH1DModel(""other"", ""m4l"", 24, 80, 170), ""m4l"", ""weight"");; ; // Book the invariant mass histogram for the data; auto df_h_mass_data = df_analysis.Filter(""reweighting == false""); .Filter(""sample_category == \""data\""""); .Define(""weight_"", []() { return 1; }); .Histo1D<float>(ROOT::RDF::TH1DModel(""data"", ""m4l"", 24, 80, 170), ""m4l"", ""weight_"");; ; // Evaluate the systematic uncertainty; ; // The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; // kinematics such as pT or pseudorapidity.; // Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON; // Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.0; // The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values; // covered by the analysis.; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph(x.size(), x.data(), y.data());; ; // Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis; // The input consists of the input column to be varied and the lambda function to compute the systematic variations.; // The new output columns c",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:15205,Integrability,interface,interface,15205,"t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TGraph.h; TH1D.h; THStack.h; TInterpreter.h; gInterpreter#define gInterpreterDefinition TInterpreter.h:573; TLatex.h; TLegend.h; TProfile.h; gROOT#define gROOTDefinition TROOT.h:406; TStyle.h; Vector4D.h; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::RDF::RInterface::DefinePerSampleRInterface< Proxied, DS_t > DefinePerSample(std::string_view name, F expression)Define a new column that is updated when the input sample changes.Definition RInterface.hxx:735; ROOT::RDF::RSampleInfoThis type represents a sample identifier, to be used in conjunction with RDataFrame features such as ...Definition RSampleInfo.hxx:35; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::VecOps::RVec< float >; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; THStackThe Histogram stack class.Definition THStack.h:40; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexNDCTLatex * DrawLatexNDC(Double_t x, Double_t y, const char *text)Draw this TLatex with new coordinates in NDC.Definition TLatex",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:4229,Modifiability,config,config,4229,"nableImplicitMT();; ; // Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same; // folder as this tutorial; std::string dataset_spec = gROOT->GetTutorialsDir() + std::string(""/dataframe/df106_HiggsToFourLeptons_spec.json"");; ROOT::RDataFrame df = ROOT::RDF::Experimental::FromSpec(dataset_spec);; ; // Add the ProgressBar feature; ROOT::RDF::Experimental::AddProgressBar(df);; ; #ifndef __CLING__; // If this tutorial is compiled, rather than run as a ROOT macro, the interpreter needs to be fed the signatures; // of all the functions we want to JIT in our analysis, as well as any type used in those signatures.; // clang-format off; gInterpreter->Declare(; ""using ROOT::RVecF;""; ""bool GoodElectronsAndMuons(const ROOT::RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e,""; ""const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0);""; ""float ComputeInvariantMass(const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e);""; );; // clang-format on; #endif; ; // Perform the analysis; // Access metadata information that is stored in the JSON config file of the RDataFrame; // The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electr",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:17729,Performance,multi-thread,multi-threading,17729,"finition TPad.h:28; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::VecOps::Mapauto Map(Args &&... args)Create new collection applying a callable to the elements of the input collection.Definition RVec.hxx:2150; ROOT::VecOps::FilterRVec< T > Filter(const RVec< T > &v, F &&f)Create a new collection with the elements passing the filter expressed by the predicate.Definition RVec.hxx:2182; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; ROOT::RDF::ExperimentalDefinition RDataFrame.hxx:66; ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::VecOpsDefinition TCollectionProxyInfo.h:42; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; df106_HiggsToFourLeptonsDefinition df106_HiggsToFourLeptons.py:1; graphDefinition graph.py:1; v@ vDefinition rootcling_impl.cxx:3699; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; . DateMarch 2020, August 2022, August 2023 ; AuthorsStefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN) ; Definition in file df106_HiggsToFourLeptons.C. tutorialsdataframedf106_HiggsToFourLeptons.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:527,Safety,detect,detector,527,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.C File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; Lepton selection efficiency corrections (""scale factors"") are applied to simulated samples to correct for the differences in the trigger, reconstruction, and identification efficiencies in simulation compared to real data. Systematic uncertainties for those scale factors are evaluated and the Vary function of RDataFrame is used to propagate the variations to the final four leptons mass distribution.; See the corresponding spec json file.; ; #include ""TInterpreter.h""; #include <Math/Vector4D.h>; #include <ROOT/RDFHelpers.hxx>; #include <ROOT/RDataFrame.hxx>; #include <ROOT/RVec.hxx>; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1D.h>; #include <THStack.h>; #include <TLatex.h>; #include <TLegend.h>; #include <TProfile.h>; #include <TStyle.h>; ; using namespace ROOT::VecOps;; using PtEtaPhiEVectorF = ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<float>>;; using ROOT::RVecF;; using ROOT::RDF::RSampleInfo;; using namespace ROOT::RDF::Experimental;; ; // Define functions needed in the analysis; // Select events for the analys",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:4306,Security,access,accessible,4306,"nableImplicitMT();; ; // Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same; // folder as this tutorial; std::string dataset_spec = gROOT->GetTutorialsDir() + std::string(""/dataframe/df106_HiggsToFourLeptons_spec.json"");; ROOT::RDataFrame df = ROOT::RDF::Experimental::FromSpec(dataset_spec);; ; // Add the ProgressBar feature; ROOT::RDF::Experimental::AddProgressBar(df);; ; #ifndef __CLING__; // If this tutorial is compiled, rather than run as a ROOT macro, the interpreter needs to be fed the signatures; // of all the functions we want to JIT in our analysis, as well as any type used in those signatures.; // clang-format off; gInterpreter->Declare(; ""using ROOT::RVecF;""; ""bool GoodElectronsAndMuons(const ROOT::RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e,""; ""const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0);""; ""float ComputeInvariantMass(const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e);""; );; // clang-format on; #endif; ; // Perform the analysis; // Access metadata information that is stored in the JSON config file of the RDataFrame; // The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo`; // class; auto df_analysis =; df.DefinePerSample(""xsecs"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""xsecs""); }); .DefinePerSample(""lumi"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""lumi""); }); .DefinePerSample(""sumws"", [](unsigned int slot, const RSampleInfo &id) { return id.GetD(""sumws""); }); .DefinePerSample(""sample_category"",; [](unsigned int slot, const RSampleInfo &id) { return id.GetS(""sample_category""); }); // Apply an MC correction for the ZZ decay due to missing gg->ZZ process; .DefinePerSample(""scale"",; [](unsigned int slot, const ROOT::RDF::RSampleInfo &id) {; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }); // Select electr",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:10640,Security,access,accessed,10640,"cale factor histograms: ""nominal"", ""weight:up"" and ""weight:down"".; auto histos_mc = VariationsFor(df_with_variations_mc);; ; // Evaluate the total MC uncertainty based on the variations. Note, in this case the uncertainties are symmetric.; for (unsigned int i = 0; i < histos_mc[""nominal""].GetXaxis()->GetNbins(); i++) {; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)));; }; ; // Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; gROOT->SetStyle(""ATLAS"");; ; // Create canvas with pad; auto c = new TCanvas(""c"", "" "", 600, 600);; auto pad = new TPad(""upper_pad"", """", 0, 0, 1, 1);; pad->SetTickx(0);; pad->SetTicky(0);; pad->Draw();; pad->cd();; ; // Draw stack with MC contributions; // Draw cloned histograms to preserve graphics when original objects goes out of scope; df_other->SetFillColor(kViolet - 9);; df_zz->SetFillColor(kAzure - 9);; df_higgs->SetFillColor(kRed + 2);; ; auto stack = new THStack(""stack"", """");; auto h_other = static_cast<TH1 *>(df_other->Clone());; stack->Add(h_other);; auto h_zz = static_cast<TH1 *>(df_zz->Clone());; stack->Add(h_zz);; auto h_higgs = static_cast<TH1 *>(df_higgs->Clone());; stack->Add(h_higgs);; stack->Draw(""HIST"");; ; // stack histogram can be accessed only after drawing; stack->GetHistogram()->SetTitle("""");; stack->GetHistogram()->GetXaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetXaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetXaxis()->SetTitleOffset(1.3);; stack->GetHistogram()->GetXaxis()->SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]"");; stack->GetHistogram()->GetYaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetYaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetYaxis()->SetTitle(""Events"");; stack->SetMaximum(35);; stack->GetHistogram()->GetYaxis()->ChangeLabel(1, -1, 0);; ; // Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(kBlack);; histos_mc[""nominal""]",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:870,Availability,error,errors,870,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:3385,Availability,mask,mask,3385,"){; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }; """"""; ); ; df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); ; # Select events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); {; for (size_t i = 0; i < type.size(); i++) {; ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; if (type[i] == 11) {; if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; } else {; if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; }; }; return true;; }; """"""; ); ; # Select electron or muon trigger; df = df.Filter(""trigE || trigM""); ; # Select events with exactly four good leptons conserving charge and lepton numbers; # Note that all collections are RVecs and good_lep is the mask for the good leptons.; # The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; # irrespective of the charge.; ; df = (; df.Define(; ""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; ); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); ); ; # Apply additional cuts depending on lepton flavour; df = df.Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; ); ; # Create new columns with the kinematics of good leptons; df = (; df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:6897,Availability,avail,available,6897,"InvariantMass(goodlep_pt, goodlep_eta, goodlep_phi, goodlep_E)""); ; # Save data for statistical analysis tutorial (rf618_mixture_models.py) ; df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); ; # Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); histos = []; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; histos.append(; df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; ""m4l"",; ""weight"",; ); ); ; # Evaluate the systematic uncertainty; ; # The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; # kinematics such as pT or pseudorapidity.; # Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; # Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; # The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; ; # Create a VaryHelper to interpolate the available data.; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT::VecOps;; ; class VaryHelper; {; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph;; ; public:; VaryHelper() : graph(x.size(), x.data(), y.data()) {}; RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); {; const auto v = Mean(Map(pt[type == 11], [this](auto p); {return this->graph.Eval(p); }); );; return RVec<double>{(1 + v) * w, (1 - v) * w};; }; };; ; VaryHelper variationsFactory;; """"""; ); ; # Use the Vary method to add the systematic variations to the total MC scale factor (""w",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:7135,Availability,avail,available,7135,", [""m4l"", ""sample_category"", ""weight""]); ; # Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); histos = []; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; histos.append(; df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; ""m4l"",; ""weight"",; ); ); ; # Evaluate the systematic uncertainty; ; # The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; # kinematics such as pT or pseudorapidity.; # Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; # Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; # The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; ; # Create a VaryHelper to interpolate the available data.; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT::VecOps;; ; class VaryHelper; {; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph;; ; public:; VaryHelper() : graph(x.size(), x.data(), y.data()) {}; RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); {; const auto v = Mean(Map(pt[type == 11], [this](auto p); {return this->graph.Eval(p); }); );; return RVec<double>{(1 + v) * w, (1 - v) * w};; }; };; ; VaryHelper variationsFactory;; """"""; ); ; # Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis.; df_variations_mc = (; df.Filter(""isMC == true""); .Vary(""weight"", ""variationsFactory(weight, goodlep_pt, goodlep_type)"", [""up"", ""down""]); .Histo1D(ROOT.RDF.TH1DModel(""Invariant Mass"", ""m4l"", 24, 80, 170), ""m4l"", ""wei",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:8033,Availability,down,down,8033,", using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; ; # Create a VaryHelper to interpolate the available data.; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT::VecOps;; ; class VaryHelper; {; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph;; ; public:; VaryHelper() : graph(x.size(), x.data(), y.data()) {}; RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); {; const auto v = Mean(Map(pt[type == 11], [this](auto p); {return this->graph.Eval(p); }); );; return RVec<double>{(1 + v) * w, (1 - v) * w};; }; };; ; VaryHelper variationsFactory;; """"""; ); ; # Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis.; df_variations_mc = (; df.Filter(""isMC == true""); .Vary(""weight"", ""variationsFactory(weight, goodlep_pt, goodlep_type)"", [""up"", ""down""]); .Histo1D(ROOT.RDF.TH1DModel(""Invariant Mass"", ""m4l"", 24, 80, 170), ""m4l"", ""weight""); ); histos_mc = ROOT.RDF.Experimental.VariationsFor(df_variations_mc); ; # We reached the end of the analysis part. We now evaluate the total MC uncertainty based on the variations.; # No computation graph was triggered yet, we trigger the computation graph for all histograms at once now,; # by calling 'histos_mc[""nominal""].GetXaxis()'.; # Note, in this case the uncertainties are symmetric.; for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; (; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); ); ); ; # Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c1 = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:10398,Availability,down,down,10398,"ata = histos[0].GetValue().Clone(); h_higgs = histos[1].GetValue().Clone(); h_zz = histos[2].GetValue().Clone(); h_other = histos[3].GetValue().Clone(); ; for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(color); stack.Add(h); ; stack.Draw(""HIST""); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.GetXaxis().SetTitleOffset(1.3); stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetYaxis().SetTitle(""Events""); stack.SetMaximum(35); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(ROOT.kBlack); histos_mc[""nominal""].SetFillStyle(3254); h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); ; # Draw data histogram; h_data.SetMarkerStyle(20); h_data.SetMarkerSize(1.2); h_data.SetLineWidth(2); h_data.SetLineColor(ROOT.kBlack); h_data.Draw(""E SAME"") # Draw raw data with errorbars; ; # Add legend; legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); legend.SetTextFont(42); legend.SetFillStyle(0); legend.SetBorderSize(0); legend.SetTextSize(0.025); legend.SetTextAlign(32); legend.AddEntry(h_data, ""Data"", ""lep""); legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); legend.AddEntry(h_zz, ""ZZ MC"", ""f""); legend.AddEntry(h_other, ""Other MC"", ""f""); legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); legend.Draw(); ; text = ROOT.TLatex(); text.SetTextFont(72); text.SetTextSize(0.04); text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); text.SetTextFont(42); text.Draw",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:10469,Availability,down,down,10469,"one(); h_zz = histos[2].GetValue().Clone(); h_other = histos[3].GetValue().Clone(); ; for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(color); stack.Add(h); ; stack.Draw(""HIST""); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.GetXaxis().SetTitleOffset(1.3); stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetYaxis().SetTitle(""Events""); stack.SetMaximum(35); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(ROOT.kBlack); histos_mc[""nominal""].SetFillStyle(3254); h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); ; # Draw data histogram; h_data.SetMarkerStyle(20); h_data.SetMarkerSize(1.2); h_data.SetLineWidth(2); h_data.SetLineColor(ROOT.kBlack); h_data.Draw(""E SAME"") # Draw raw data with errorbars; ; # Add legend; legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); legend.SetTextFont(42); legend.SetFillStyle(0); legend.SetBorderSize(0); legend.SetTextSize(0.025); legend.SetTextAlign(32); legend.AddEntry(h_data, ""Data"", ""lep""); legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); legend.AddEntry(h_zz, ""ZZ MC"", ""f""); legend.AddEntry(h_other, ""Other MC"", ""f""); legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); legend.Draw(); ; text = ROOT.TLatex(); text.SetTextFont(72); text.SetTextSize(0.04); text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); text.SetTextFont(42); text.DrawLatexNDC(0.19 + 0.15, 0.85, ""Open Data""); text.SetTextSize(0.035); te",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:10680,Availability,error,errorbars,10680,"Color(color); stack.Add(h); ; stack.Draw(""HIST""); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.GetXaxis().SetTitleOffset(1.3); stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetYaxis().SetTitle(""Events""); stack.SetMaximum(35); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(ROOT.kBlack); histos_mc[""nominal""].SetFillStyle(3254); h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); ; # Draw data histogram; h_data.SetMarkerStyle(20); h_data.SetMarkerSize(1.2); h_data.SetLineWidth(2); h_data.SetLineColor(ROOT.kBlack); h_data.Draw(""E SAME"") # Draw raw data with errorbars; ; # Add legend; legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); legend.SetTextFont(42); legend.SetFillStyle(0); legend.SetBorderSize(0); legend.SetTextSize(0.025); legend.SetTextAlign(32); legend.AddEntry(h_data, ""Data"", ""lep""); legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); legend.AddEntry(h_zz, ""ZZ MC"", ""f""); legend.AddEntry(h_other, ""Other MC"", ""f""); legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); legend.Draw(); ; text = ROOT.TLatex(); text.SetTextFont(72); text.SetTextSize(0.04); text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); text.SetTextFont(42); text.DrawLatexNDC(0.19 + 0.15, 0.85, ""Open Data""); text.SetTextSize(0.035); text.DrawLatexNDC(0.21, 0.80, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); ; c1.Update(); ; # Save the plot; c1.SaveAs(""df106_HiggsToFourLeptons_python.png""); print(""Saved figure to df106_HiggsToFourLeptons_python.png""); SetFillStyleOption_t Opti",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:322,Deployability,release,release,322,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:434,Deployability,release,release,434,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:478,Deployability,release,release,478,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:583,Energy Efficiency,energy,energy,583,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:3300,Energy Efficiency,charge,charge,3300,"){; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }; """"""; ); ; df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); ; # Select events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); {; for (size_t i = 0; i < type.size(); i++) {; ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; if (type[i] == 11) {; if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; } else {; if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; }; }; return true;; }; """"""; ); ; # Select electron or muon trigger; df = df.Filter(""trigE || trigM""); ; # Select events with exactly four good leptons conserving charge and lepton numbers; # Note that all collections are RVecs and good_lep is the mask for the good leptons.; # The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; # irrespective of the charge.; ; df = (; df.Define(; ""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; ); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); ); ; # Apply additional cuts depending on lepton flavour; df = df.Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; ); ; # Create new columns with the kinematics of good leptons; df = (; df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:3515,Energy Efficiency,charge,charge,3515,"elect events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); {; for (size_t i = 0; i < type.size(); i++) {; ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; if (type[i] == 11) {; if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; } else {; if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; }; }; return true;; }; """"""; ); ; # Select electron or muon trigger; df = df.Filter(""trigE || trigM""); ; # Select events with exactly four good leptons conserving charge and lepton numbers; # Note that all collections are RVecs and good_lep is the mask for the good leptons.; # The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; # irrespective of the charge.; ; df = (; df.Define(; ""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; ); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); ); ; # Apply additional cuts depending on lepton flavour; df = df.Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; ); ; # Create new columns with the kinematics of good leptons; df = (; df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""lep_phi[good_lep]""); .Define(""goodlep_E"", ""lep_E[good_lep]""); .Define(""goodlep_type"", ""lep_type[good_lep]""); ); ; # Selec",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:3910,Integrability,depend,depending,3910,";; if (type[i] == 11) {; if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; } else {; if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; }; }; return true;; }; """"""; ); ; # Select electron or muon trigger; df = df.Filter(""trigE || trigM""); ; # Select events with exactly four good leptons conserving charge and lepton numbers; # Note that all collections are RVecs and good_lep is the mask for the good leptons.; # The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; # irrespective of the charge.; ; df = (; df.Define(; ""good_lep"",; ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; ); .Filter(""Sum(good_lep) == 4""); .Filter(""Sum(lep_charge[good_lep]) == 0""); .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); ); ; # Apply additional cuts depending on lepton flavour; df = df.Filter(; ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; ); ; # Create new columns with the kinematics of good leptons; df = (; df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); .Define(""goodlep_eta"", ""lep_eta[good_lep]""); .Define(""goodlep_phi"", ""lep_phi[good_lep]""); .Define(""goodlep_E"", ""lep_E[good_lep]""); .Define(""goodlep_type"", ""lep_type[good_lep]""); ); ; # Select leptons with high transverse momentum; df = df.Filter(""goodlep_pt[0] > 25000 && goodlep_pt[1] > 15000 && goodlep_pt[2] > 10000""); ; # Reweighting of the samples is different for ""data"" and ""MC"". This is the function to add reweighting for MC samples; ROOT.gInterpreter.Declare(; """"""; double weights(float scaleFactor_1, float scaleFactor_2, float scaleFactor_3, float scaleFactor_4, float scale, float ",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:6654,Integrability,depend,depends,6654,"[0], eta[0], phi[0], e[0]};; ROOT::Math::PtEtaPhiEVector p2{pt[1], eta[1], phi[1], e[1]};; ROOT::Math::PtEtaPhiEVector p3{pt[2], eta[2], phi[2], e[2]};; ROOT::Math::PtEtaPhiEVector p4{pt[3], eta[3], phi[3], e[3]};; return 0.001 * (p1 + p2 + p3 + p4).M();; }; """"""; ); ; df = df.Define(""m4l"", ""ComputeInvariantMass(goodlep_pt, goodlep_eta, goodlep_phi, goodlep_E)""); ; # Save data for statistical analysis tutorial (rf618_mixture_models.py) ; df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); ; # Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); histos = []; for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; histos.append(; df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; ""m4l"",; ""weight"",; ); ); ; # Evaluate the systematic uncertainty; ; # The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; # kinematics such as pT or pseudorapidity.; # Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; # Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; # The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; ; # Create a VaryHelper to interpolate the available data.; ROOT.gInterpreter.Declare(; """"""; using namespace ROOT::VecOps;; ; class VaryHelper; {; const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; TGraph graph;; ; public:; VaryHelper() : graph(x.size(), x.data(), y.data()) {}; RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsig",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:1685,Modifiability,config,config,1685," and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ; # We must further apply an MC correction for the ZZ decay due to missing gg->ZZ processes.; ROOT.gInterpreter.Declare(; """"""; float scale(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }; """"""; ); ; df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); ; # Select events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVec",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:9312,Performance,perform,performed,9312,"nty based on the variations.; # No computation graph was triggered yet, we trigger the computation graph for all histograms at once now,; # by calling 'histos_mc[""nominal""].GetXaxis()'.; # Note, in this case the uncertainties are symmetric.; for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; (; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); ); ); ; # Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c1 = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); ; # Retrieve values of the data and MC histograms in order to plot them.; # Draw cloned histograms to preserve graphics when original objects goes out of scope; # Note: GetValue() action operation is performed after all lazy actions of the RDF were defined first.; h_data = histos[0].GetValue().Clone(); h_higgs = histos[1].GetValue().Clone(); h_zz = histos[2].GetValue().Clone(); h_other = histos[3].GetValue().Clone(); ; for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(color); stack.Add(h); ; stack.Draw(""HIST""); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.GetXaxis().SetTitleOffset(1.3); stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetYaxis().SetTitle(""Events""); stack.SetMaximum(35); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(ROOT.kBlack); histos_mc[""nominal""].SetFillStyle(3254); h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); histos_mc[""weig",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:12514,Performance,multi-thread,multi-threading,12514,"-1}""); ; c1.Update(); ; # Save the plot; c1.SaveAs(""df106_HiggsToFourLeptons_python.png""); print(""Saved figure to df106_HiggsToFourLeptons_python.png""); SetFillStyleOption_t Option_t SetFillStyleDefinition TGWin32VirtualXProxy.cxx:46; SetLineColorOption_t Option_t SetLineColorDefinition TGWin32VirtualXProxy.cxx:54; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; |> | [Elapsed time: 0:13m processing file: 7 / 9 processed evts: 1000 / 556693 7.24e+01 evt/s 2:07:51h remaining time (per file being processed)] ; |=====================================================================================================================================================================================================================================================================> | [Elapsed time: 0:14m processing file: 9 / 9 processed evts: 436000 / 912535 2.17e+05 evt/s 0:02m remaining time (per file being processed)] ; |======================================================================================================================================================================================================================================",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:542,Safety,detect,detector,542,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df106_HiggsToFourLeptons.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads to a narrow invariant mass peak on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html:1762,Security,access,accessible,1762,"k on top a relatively smooth and small background, revealing the Higgs at 125 GeV. Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting. The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; See the corresponding spec json file. ; import ROOT; import os; ; # Enable Multi-threaded mode; ROOT.EnableImplicitMT(); ; # Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; ; # Add the ProgressBar feature; ROOT.RDF.Experimental.AddProgressBar(df); ; # Access metadata information that is stored in the JSON config file of the RDataFrame.; # The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); ; # We must further apply an MC correction for the ZZ decay due to missing gg->ZZ processes.; ROOT.gInterpreter.Declare(; """"""; float scale(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; }; """"""; ); ; df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); ; # Select events for the analysis; ROOT.gInterpreter.Declare(; """"""; using ROOT::RVecF;; using ROOT::RVecI;; bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); {; for (size_t i = 0; i",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:934,Availability,error,errors,934,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:3911,Availability,mask,mask,3911,"0""""""; 51); 52 ; 53df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); 54 ; 55# Select events for the analysis; 56ROOT.gInterpreter.Declare(; 57 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); 61{; 62 for (size_t i = 0; i < type.size(); i++) {; 63 ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; 64 if (type[i] == 11) {; 65 if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:7698,Availability,avail,available,7698,"144# Save data for statistical analysis tutorial (rf618_mixture_models.py) ; 145df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); 146 ; 147# Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); 148histos = []; 149for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; 150 histos.append(; 151 df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; 152 ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; 153 ""m4l"",; 154 ""weight"",; 155 ); 156 ); 157 ; 158# Evaluate the systematic uncertainty; 159 ; 160# The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; 161# kinematics such as pT or pseudorapidity.; 162# Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; 163# Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; 164# The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; 165 ; 166# Create a VaryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}; 179 RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); 180 {; 181 const auto v = Mean(Map(pt[type == 11], [this](auto p); 182 {return this->graph.Eval(p); }); 183 );; 184 return RVec<double>{(1 + v) * w, (1 - v) * w};; 185 }; 186};; 187 ; 188VaryHelper variationsFactory;; 189""""",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:7946,Availability,avail,available,7946,"r the four different samples: data, higgs, zz and other (this is specific to this particular analysis); 148histos = []; 149for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; 150 histos.append(; 151 df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; 152 ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; 153 ""m4l"",; 154 ""weight"",; 155 ); 156 ); 157 ; 158# Evaluate the systematic uncertainty; 159 ; 160# The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; 161# kinematics such as pT or pseudorapidity.; 162# Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; 163# Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; 164# The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; 165 ; 166# Create a VaryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}; 179 RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); 180 {; 181 const auto v = Mean(Map(pt[type == 11], [this](auto p); 182 {return this->graph.Eval(p); }); 183 );; 184 return RVec<double>{(1 + v) * w, (1 - v) * w};; 185 }; 186};; 187 ; 188VaryHelper variationsFactory;; 189""""""; 190); 191 ; 192# Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis.; 193df_variations_mc = (; 194 df.Filter(""isMC == true""); 195 .Vary(""weight"", ""variationsFactory(weight, goodlep_pt, goo",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:8949,Availability,down,down,8949,"aryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}; 179 RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); 180 {; 181 const auto v = Mean(Map(pt[type == 11], [this](auto p); 182 {return this->graph.Eval(p); }); 183 );; 184 return RVec<double>{(1 + v) * w, (1 - v) * w};; 185 }; 186};; 187 ; 188VaryHelper variationsFactory;; 189""""""; 190); 191 ; 192# Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis.; 193df_variations_mc = (; 194 df.Filter(""isMC == true""); 195 .Vary(""weight"", ""variationsFactory(weight, goodlep_pt, goodlep_type)"", [""up"", ""down""]); 196 .Histo1D(ROOT.RDF.TH1DModel(""Invariant Mass"", ""m4l"", 24, 80, 170), ""m4l"", ""weight""); 197); 198histos_mc = ROOT.RDF.Experimental.VariationsFor(df_variations_mc); 199 ; 200# We reached the end of the analysis part. We now evaluate the total MC uncertainty based on the variations.; 201# No computation graph was triggered yet, we trigger the computation graph for all histograms at once now,; 202# by calling 'histos_mc[""nominal""].GetXaxis()'.; 203# Note, in this case the uncertainties are symmetric.; 204for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; 205 (; 206 histos_mc[""nominal""].SetBinError(; 207 i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); 208 ); 209 ); 210 ; 211# Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; 212 ; 213# Set styles; 214ROOT.gROOT.SetStyle(""ATLAS""); 215 ; 216# Create canvas with pad; 217c1 = ROOT.TCanvas(""c"", ",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:11522,Availability,down,down,11522,"istos[2].GetValue().Clone(); 233h_other = histos[3].GetValue().Clone(); 234 ; 235for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; 236 h.SetLineWidth(1); 237 h.SetLineColor(1); 238 h.SetFillColor(color); 239 stack.Add(h); 240 ; 241stack.Draw(""HIST""); 242stack.GetXaxis().SetLabelSize(0.04); 243stack.GetXaxis().SetTitleSize(0.045); 244stack.GetXaxis().SetTitleOffset(1.3); 245stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); 246stack.GetYaxis().SetLabelSize(0.04); 247stack.GetYaxis().SetTitleSize(0.045); 248stack.GetYaxis().SetTitle(""Events""); 249stack.SetMaximum(35); 250stack.GetYaxis().ChangeLabel(1, -1, 0); 251 ; 252# Draw MC scale factor and variations; 253histos_mc[""nominal""].SetFillColor(ROOT.kBlack); 254histos_mc[""nominal""].SetFillStyle(3254); 255h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); 256histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); 257h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); 258histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); 259h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); 260 ; 261# Draw data histogram; 262h_data.SetMarkerStyle(20); 263h_data.SetMarkerSize(1.2); 264h_data.SetLineWidth(2); 265h_data.SetLineColor(ROOT.kBlack); 266h_data.Draw(""E SAME"") # Draw raw data with errorbars; 267 ; 268# Add legend; 269legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); 270legend.SetTextFont(42); 271legend.SetFillStyle(0); 272legend.SetBorderSize(0); 273legend.SetTextSize(0.025); 274legend.SetTextAlign(32); 275legend.AddEntry(h_data, ""Data"", ""lep""); 276legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); 277legend.AddEntry(h_zz, ""ZZ MC"", ""f""); 278legend.AddEntry(h_other, ""Other MC"", ""f""); 279legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); 280legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); 281legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); 282legend.Draw(); 283 ; 284text = ROOT.TLatex(); 285text.SetTextFont(72); 286text.S",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:11596,Availability,down,down,11596,"234 ; 235for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; 236 h.SetLineWidth(1); 237 h.SetLineColor(1); 238 h.SetFillColor(color); 239 stack.Add(h); 240 ; 241stack.Draw(""HIST""); 242stack.GetXaxis().SetLabelSize(0.04); 243stack.GetXaxis().SetTitleSize(0.045); 244stack.GetXaxis().SetTitleOffset(1.3); 245stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); 246stack.GetYaxis().SetLabelSize(0.04); 247stack.GetYaxis().SetTitleSize(0.045); 248stack.GetYaxis().SetTitle(""Events""); 249stack.SetMaximum(35); 250stack.GetYaxis().ChangeLabel(1, -1, 0); 251 ; 252# Draw MC scale factor and variations; 253histos_mc[""nominal""].SetFillColor(ROOT.kBlack); 254histos_mc[""nominal""].SetFillStyle(3254); 255h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); 256histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); 257h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); 258histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); 259h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); 260 ; 261# Draw data histogram; 262h_data.SetMarkerStyle(20); 263h_data.SetMarkerSize(1.2); 264h_data.SetLineWidth(2); 265h_data.SetLineColor(ROOT.kBlack); 266h_data.Draw(""E SAME"") # Draw raw data with errorbars; 267 ; 268# Add legend; 269legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); 270legend.SetTextFont(42); 271legend.SetFillStyle(0); 272legend.SetBorderSize(0); 273legend.SetTextSize(0.025); 274legend.SetTextAlign(32); 275legend.AddEntry(h_data, ""Data"", ""lep""); 276legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); 277legend.AddEntry(h_zz, ""ZZ MC"", ""f""); 278legend.AddEntry(h_other, ""Other MC"", ""f""); 279legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); 280legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); 281legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); 282legend.Draw(); 283 ; 284text = ROOT.TLatex(); 285text.SetTextFont(72); 286text.SetTextSize(0.04); 287text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); 288text.Set",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:11829,Availability,error,errorbars,11829,"(0.04); 243stack.GetXaxis().SetTitleSize(0.045); 244stack.GetXaxis().SetTitleOffset(1.3); 245stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); 246stack.GetYaxis().SetLabelSize(0.04); 247stack.GetYaxis().SetTitleSize(0.045); 248stack.GetYaxis().SetTitle(""Events""); 249stack.SetMaximum(35); 250stack.GetYaxis().ChangeLabel(1, -1, 0); 251 ; 252# Draw MC scale factor and variations; 253histos_mc[""nominal""].SetFillColor(ROOT.kBlack); 254histos_mc[""nominal""].SetFillStyle(3254); 255h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); 256histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); 257h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); 258histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); 259h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); 260 ; 261# Draw data histogram; 262h_data.SetMarkerStyle(20); 263h_data.SetMarkerSize(1.2); 264h_data.SetLineWidth(2); 265h_data.SetLineColor(ROOT.kBlack); 266h_data.Draw(""E SAME"") # Draw raw data with errorbars; 267 ; 268# Add legend; 269legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); 270legend.SetTextFont(42); 271legend.SetFillStyle(0); 272legend.SetBorderSize(0); 273legend.SetTextSize(0.025); 274legend.SetTextAlign(32); 275legend.AddEntry(h_data, ""Data"", ""lep""); 276legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); 277legend.AddEntry(h_zz, ""ZZ MC"", ""f""); 278legend.AddEntry(h_other, ""Other MC"", ""f""); 279legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); 280legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); 281legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); 282legend.Draw(); 283 ; 284text = ROOT.TLatex(); 285text.SetTextFont(72); 286text.SetTextSize(0.04); 287text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); 288text.SetTextFont(42); 289text.DrawLatexNDC(0.19 + 0.15, 0.85, ""Open Data""); 290text.SetTextSize(0.035); 291text.DrawLatexNDC(0.21, 0.80, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); 292 ; 293c1.Update(); 294 ; 295# Save the plot; 296c1.SaveAs(""df106_HiggsToFourLeptons_python.png"")",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:345,Deployability,release,release,345,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:465,Deployability,release,release,465,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:514,Deployability,release,release,514,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:624,Energy Efficiency,energy,energy,624,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:3824,Energy Efficiency,charge,charge,3824,"0""""""; 51); 52 ; 53df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); 54 ; 55# Select events for the analysis; 56ROOT.gInterpreter.Declare(; 57 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); 61{; 62 for (size_t i = 0; i < type.size(); i++) {; 63 ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; 64 if (type[i] == 11) {; 65 if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:4045,Energy Efficiency,charge,charge,4045,"7 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); 61{; 62 for (size_t i = 0; i < type.size(); i++) {; 63 ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; 64 if (type[i] == 11) {; 65 if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); 102 .Define(""goodlep_eta"", ""lep_eta[good_lep]""); 103 .Define(""goodlep_phi"", ""lep_phi[good_lep]""); 104 .Define(""goodlep_E"", ""lep_E[goo",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:4476,Integrability,depend,depending,4476,"rackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep_pt"", ""lep_pt[good_lep]""); 102 .Define(""goodlep_eta"", ""lep_eta[good_lep]""); 103 .Define(""goodlep_phi"", ""lep_phi[good_lep]""); 104 .Define(""goodlep_E"", ""lep_E[good_lep]""); 105 .Define(""goodlep_type"", ""lep_type[good_lep]""); 106); 107 ; 108# Select leptons with high transverse momentum; 109df = df.Filter(""goodlep_pt[0] > 25000 && goodlep_pt[1] > 15000 && goodlep_pt[2] > 10000""); 110 ; 111# Reweighting of the samples is different for ""data"" and ""MC"". This is the function to add reweighting for MC samples; 112ROOT.gInterpreter.Declare(; 113 """"""; 114double weights(float scaleFactor_1, float scaleFact",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:7446,Integrability,depend,depends,7446,"], e[1]};; 135 ROOT::Math::PtEtaPhiEVector p3{pt[2], eta[2], phi[2], e[2]};; 136 ROOT::Math::PtEtaPhiEVector p4{pt[3], eta[3], phi[3], e[3]};; 137 return 0.001 * (p1 + p2 + p3 + p4).M();; 138}; 139""""""; 140); 141 ; 142df = df.Define(""m4l"", ""ComputeInvariantMass(goodlep_pt, goodlep_eta, goodlep_phi, goodlep_E)""); 143 ; 144# Save data for statistical analysis tutorial (rf618_mixture_models.py) ; 145df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); 146 ; 147# Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); 148histos = []; 149for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; 150 histos.append(; 151 df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; 152 ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; 153 ""m4l"",; 154 ""weight"",; 155 ); 156 ); 157 ; 158# Evaluate the systematic uncertainty; 159 ; 160# The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; 161# kinematics such as pT or pseudorapidity.; 162# Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; 163# Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; 164# The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; 165 ; 166# Create a VaryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:2110,Modifiability,config,config,2110,"ame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature; 35ROOT.RDF.Experimental.AddProgressBar(df); 36 ; 37# Access metadata information that is stored in the JSON config file of the RDataFrame.; 38# The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; 39df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); 40df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 41df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); 42df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 43 ; 44# We must further apply an MC correction for the ZZ decay due to missing gg->ZZ processes.; 45ROOT.gInterpreter.Declare(; 46 """"""; 47float scale(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; 48 return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; 49}; 50""""""; 51); 52 ; 53df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); 54 ; 55# Select events for the analysis; 56ROOT.gInterpreter.Declare(; 57 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVe",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:10342,Performance,perform,performed,10342,"utation graph for all histograms at once now,; 202# by calling 'histos_mc[""nominal""].GetXaxis()'.; 203# Note, in this case the uncertainties are symmetric.; 204for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; 205 (; 206 histos_mc[""nominal""].SetBinError(; 207 i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); 208 ); 209 ); 210 ; 211# Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; 212 ; 213# Set styles; 214ROOT.gROOT.SetStyle(""ATLAS""); 215 ; 216# Create canvas with pad; 217c1 = ROOT.TCanvas(""c"", """", 600, 600); 218pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); 219pad.SetTickx(False); 220pad.SetTicky(False); 221pad.Draw(); 222pad.cd(); 223 ; 224# Draw stack with MC contributions; 225stack = ROOT.THStack(); 226 ; 227# Retrieve values of the data and MC histograms in order to plot them.; 228# Draw cloned histograms to preserve graphics when original objects goes out of scope; 229# Note: GetValue() action operation is performed after all lazy actions of the RDF were defined first.; 230h_data = histos[0].GetValue().Clone(); 231h_higgs = histos[1].GetValue().Clone(); 232h_zz = histos[2].GetValue().Clone(); 233h_other = histos[3].GetValue().Clone(); 234 ; 235for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; 236 h.SetLineWidth(1); 237 h.SetLineColor(1); 238 h.SetFillColor(color); 239 stack.Add(h); 240 ; 241stack.Draw(""HIST""); 242stack.GetXaxis().SetLabelSize(0.04); 243stack.GetXaxis().SetTitleSize(0.045); 244stack.GetXaxis().SetTitleOffset(1.3); 245stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); 246stack.GetYaxis().SetLabelSize(0.04); 247stack.GetYaxis().SetTitleSize(0.045); 248stack.GetYaxis().SetTitle(""Events""); 249stack.SetMaximum(35); 250stack.GetYaxis().ChangeLabel(1, -1, 0); 251 ; 252# Draw MC scale factor and variations; 253histos_mc[""nominal""].SetFillColor(ROOT.kBlack); 254histos_mc[""nominal""].SetFi",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:13760,Performance,multi-thread,multi-threading,13760,"_higgs, ""Higgs MC"", ""f""); 277legend.AddEntry(h_zz, ""ZZ MC"", ""f""); 278legend.AddEntry(h_other, ""Other MC"", ""f""); 279legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); 280legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); 281legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); 282legend.Draw(); 283 ; 284text = ROOT.TLatex(); 285text.SetTextFont(72); 286text.SetTextSize(0.04); 287text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); 288text.SetTextFont(42); 289text.DrawLatexNDC(0.19 + 0.15, 0.85, ""Open Data""); 290text.SetTextSize(0.035); 291text.DrawLatexNDC(0.21, 0.80, ""#sqrt{s} = 13 TeV, 10 fb^{-1}""); 292 ; 293c1.Update(); 294 ; 295# Save the plot; 296c1.SaveAs(""df106_HiggsToFourLeptons_python.png""); 297print(""Saved figure to df106_HiggsToFourLeptons_python.png""); SetFillStyleOption_t Option_t SetFillStyleDefinition TGWin32VirtualXProxy.cxx:46; SetLineColorOption_t Option_t SetLineColorDefinition TGWin32VirtualXProxy.cxx:54; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30. tutorialsdataframedf106_HiggsToFourLeptons.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:578,Safety,detect,detector,578,". ROOT: tutorials/dataframe/df106_HiggsToFourLeptons.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. df106_HiggsToFourLeptons.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_dataframe; 3## \notebook -draw; 4## The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame.; 5##; 6## This tutorial is the Higgs to four lepton analysis from the ATLAS Open Data release in 2020; 7## (http://opendata.atlas.cern/release/2020/documentation/). The data was taken with the ATLAS detector; 8## during 2016 at a center-of-mass energy of 13 TeV. The decay of the Standard Model Higgs boson; 9## to two Z bosons and subsequently to four leptons is called the ""golden channel"". The selection leads; 10## to a narrow invariant mass peak on top a relatively smooth and small background, revealing; 11## the Higgs at 125 GeV.; 12## Systematic errors for the MC scale factors are computed and the Vary function of RDataFrame is used for plotting.; 13## The analysis is translated to an RDataFrame workflow processing about 300 MB of simulated events and data.; 14##; 15## See the [corresponding spec json file](https://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature;",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:2189,Security,access,accessible,2189,"ttps://github.com/root-project/root/blob/master/tutorials/dataframe/df106_HiggsToFourLeptons_spec.json).; 16##; 17## \macro_image; 18## \macro_code; 19## \macro_output; 20##; 21## \date March 2020, August 2022, August 2023; 22## \authors Stefan Wunsch (KIT, CERN), Julia Mathe (CERN), Marta Czurylo (CERN); 23 ; 24import ROOT; 25import os; 26 ; 27# Enable Multi-threaded mode; 28ROOT.EnableImplicitMT(); 29 ; 30# Create the RDataFrame from the spec json file. The df106_HiggsToFourLeptons_spec.json is provided in the same folder as this tutorial; 31dataset_spec = os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe"", ""df106_HiggsToFourLeptons_spec.json""); 32df = ROOT.RDF.Experimental.FromSpec(dataset_spec) # Creates a single dataframe for all the samples; 33 ; 34# Add the ProgressBar feature; 35ROOT.RDF.Experimental.AddProgressBar(df); 36 ; 37# Access metadata information that is stored in the JSON config file of the RDataFrame.; 38# The metadata contained in the JSON file is accessible within a `DefinePerSample` call, through the `RSampleInfo` class.; 39df = df.DefinePerSample(""xsecs"", 'rdfsampleinfo_.GetD(""xsecs"")'); 40df = df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 41df = df.DefinePerSample(""sumws"", 'rdfsampleinfo_.GetD(""sumws"")'); 42df = df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 43 ; 44# We must further apply an MC correction for the ZZ decay due to missing gg->ZZ processes.; 45ROOT.gInterpreter.Declare(; 46 """"""; 47float scale(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; 48 return id.Contains(""mc_363490.llll.4lep.root"") ? 1.3f : 1.0f;; 49}; 50""""""; 51); 52 ; 53df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); 54 ; 55# Select events for the analysis; 56ROOT.gInterpreter.Declare(; 57 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &trac",MatchSource.WIKI,doc/master/df106__HiggsToFourLeptons_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:1377,Availability,avail,available,1377,"production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:3230,Availability,down,down,3230,"n data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF = const ROOT::RVecF &;; using cRVecI = const ROOT::RVecI &;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, cRVecF lep_eta, cRVecF lep_phi, cRVecF lep_e, cRVecF trackd0pv, cRVecF tracksigd0pv, cRVecF z0); {; int idx = -1; // Return -1 if no good lepton is found.; for(auto i = 0; i < type.size(); i++) {; if(!goodlep[i]) continue;; if (type[i] == 11 && abs(lep_eta[i]) < 2.47 && (abs(lep_eta[i]) < 1.37 || abs(lep_eta[i]) > 1.52) && abs(trackd0pv[i] / tracksigd0pv[i]) < 5) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // ",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:8403,Availability,avail,available,8403,"tEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected normalization derived from a validation region; for h, color in zip(; [wjets, twtb, singletop],; [(222, 90, 106), (155, 152, 204), (208, 240, 193)]):; h.SetLineWidth(1); h.SetLineColor(1",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:8474,Availability,avail,available,8474,"tEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected normalization derived from a validation region; for h, color in zip(; [wjets, twtb, singletop],; [(222, 90, 106), (155, 152, 204), (208, 240, 193)]):; h.SetLineWidth(1); h.SetLineColor(1",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:8531,Availability,avail,available,8531,"tEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected normalization derived from a validation region; for h, color in zip(; [wjets, twtb, singletop],; [(222, 90, 106), (155, 152, 204), (208, 240, 193)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetColor(*color)); stack.Add(h); stack.Draw(""HIST""); stack.Ge",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:309,Deployability,release,release,309,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:433,Deployability,release,release,433,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:477,Deployability,release,release,477,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:400,Energy Efficiency,adapt,adapted,400,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:585,Energy Efficiency,energy,energy,585,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:930,Energy Efficiency,reduce,reduce,930,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:4717,Energy Efficiency,energy,energy,4717,"&;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, cRVecF lep_eta, cRVecF lep_phi, cRVecF lep_e, cRVecF trackd0pv, cRVecF tracksigd0pv, cRVecF z0); {; int idx = -1; // Return -1 if no good lepton is found.; for(auto i = 0; i < type.size(); i++) {; if(!goodlep[i]) continue;; if (type[i] == 11 && abs(lep_eta[i]) < 2.47 && (abs(lep_eta[i]) < 1.37 || abs(lep_eta[i]) > 1.52) && abs(trackd0pv[i] / tracksigd0pv[i]) < 5) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; if (type[i] == 13 && abs(lep_eta[i]) < 2.5 && abs(trackd0pv[i] / tracksigd0pv[i]) < 3) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; }; return idx;; }; """"""); ; for s in samples:; # Select events with electron or muon trigger and with a missing transverse energy above 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Perform preselection of highly isolated leptons; df[s] = df[s].Define(""goodlep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(goodlep) > 0""); ; # Find a single good lepton, otherwise return -1 as index; df[s] = df[s].Define(""idx_lep"", ""FindGoodLepton(goodlep, lep_type, lep_pt, lep_eta, lep_phi, lep_E, lep_trackd0pvunbiased, lep_tracksigd0pvunbiased, lep_z0)"")\; .Filter(""idx_lep != -1""); ; # Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV; df[s] = df[s].Define(""mtw"", ""sqrt(2 * lep_pt[idx_lep] * met_et * (1 - cos(lep_phi[idx_lep] - met_phi)))"")\; .Filter(""mtw > 60000""); ; # Perform presel",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:5353,Energy Efficiency,energy,energy,5353," const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; }; return idx;; }; """"""); ; for s in samples:; # Select events with electron or muon trigger and with a missing transverse energy above 30 GeV; df[s] = df[s].Filter(""trigE || trigM"")\; .Filter(""met_et > 30000""); ; # Perform preselection of highly isolated leptons; df[s] = df[s].Define(""goodlep"", ""lep_isTightID && lep_pt > 35000 && lep_ptcone30 / lep_pt < 0.1 && lep_etcone20 / lep_pt < 0.1"")\; .Filter(""ROOT::VecOps::Sum(goodlep) > 0""); ; # Find a single good lepton, otherwise return -1 as index; df[s] = df[s].Define(""idx_lep"", ""FindGoodLepton(goodlep, lep_type, lep_pt, lep_eta, lep_phi, lep_E, lep_trackd0pvunbiased, lep_tracksigd0pvunbiased, lep_z0)"")\; .Filter(""idx_lep != -1""); ; # Compute transverse mass of the W boson using the missing transverse energy and the good lepton; # Use only events with a transverse mass of the reconstructed W boson larger than 60 GeV; df[s] = df[s].Define(""mtw"", ""sqrt(2 * lep_pt[idx_lep] * met_et * (1 - cos(lep_phi[idx_lep] - met_phi)))"")\; .Filter(""mtw > 60000""); ; # Perform preselection of jets; df[s] = df[s].Filter(""ROOT::VecOps::Sum(jet_pt > 30000 && abs(jet_eta) < 2.5) > 0""); ; # Select events with two good jets and one b-jet and find the indices in the collections; df[s] = df[s].Define(""goodjet"", ""jet_pt > 60000 || abs(jet_eta) > 2.4 || jet_jvt > 0.59"")\; .Filter(""ROOT::VecOps::Sum(goodjet) == 2"")\; .Define(""goodbjet"", ""goodjet && jet_MV2c10 > 0.8244273"")\; .Filter(""ROOT::VecOps::Sum(goodbjet) == 1"")\; .Define(""idx_tagged"", ""ROOT::VecOps::ArgMax(goodjet && goodbjet)"")\; .Define(""idx_untagged"", ""ROOT::VecOps::ArgMax(goodjet && !goodbjet)""); ; # Select events based on the jet kinematics and the scalar sum of the transverse momentum; # from the lepton, jets and met above 195 GeV; df[s] = df[s].Filter(""abs(jet_eta[i",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:7104,Energy Efficiency,energy,energy,7104,"odjet && goodbjet)"")\; .Define(""idx_untagged"", ""ROOT::VecOps::ArgMax(goodjet && !goodbjet)""); ; # Select events based on the jet kinematics and the scalar sum of the transverse momentum; # from the lepton, jets and met above 195 GeV; df[s] = df[s].Filter(""abs(jet_eta[idx_untagged]) > 1.5 && abs(jet_eta[idx_tagged] - jet_eta[idx_untagged]) > 1.5"")\; .Filter(""lep_pt[idx_lep] + jet_pt[idx_tagged] + jet_pt[idx_untagged] + met_et > 195000""); ; # Compute luminosity, scale factors and MC weights for simulated events; for s in samples:; if ""data"" in s:; df[s] = df[s].Define(""weight"", ""1.0""); else:; # The single top MC weights are either 1 or -1; if ""single"" in s: stop_norm = ""mcWeight / abs(mcWeight)""; else: stop_norm = ""mcWeight""; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * scaleFactor_BTAG * {} * {} / {} * {}"".format(stop_norm, xsecs[s], sumws[s], lumi)); ; # Reconstruct the top mass from the lepton, the missing transverse energy and the b-jet; ; # Just-in-time compile the function to compute the top mass from the constituents; ROOT.gInterpreter.Declare(""""""; float ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:7736,Energy Efficiency,energy,energy,7736," ""single"" in s: stop_norm = ""mcWeight / abs(mcWeight)""; else: stop_norm = ""mcWeight""; df[s] = df[s].Define(""weight"", ""scaleFactor_ELE * scaleFactor_MUON * scaleFactor_LepTRIGGER * scaleFactor_PILEUP * scaleFactor_BTAG * {} * {} / {} * {}"".format(stop_norm, xsecs[s], sumws[s], lumi)); ; # Reconstruct the top mass from the lepton, the missing transverse energy and the b-jet; ; # Just-in-time compile the function to compute the top mass from the constituents; ROOT.gInterpreter.Declare(""""""; float ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTi",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:11728,Integrability,interface,interface,11728,", ""#sqrt{{s}} = 13 TeV, {:.1f} fb^{{-1}}"".format(lumi * lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df107_SingleTopAnalysis.png""); print(""Saved figure to df107_SingleTopAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.5 fb^-1 ...; Saved figure to df107_SingleTopAnalysis.png; DateJuly 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df107_SingleTopAnalysis.py. tutorialsdataframedf107_SingleTopAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:400,Modifiability,adapt,adapted,400,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:2576,Performance,load,load,2576," run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF =",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:2681,Performance,load,load,2681,"; parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/OutreachDatasets/2020-01-22""; else: dataset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF = const ROOT::RVecF &;; using cRVecI = const ROOT::RVecI &;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, ",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:3487,Performance,perform,performing,3487,"taset_path = ""root://eospublic.cern.ch//eos/root-eos/reduced_atlas_opendata/singletop""; ; # Create a ROOT dataframe for each dataset; # Note that we load the filenames from the external json file placed in the same folder than this script.; files = json.load(open(os.path.join(ROOT.gROOT.GetTutorialsDir(), ""dataframe/df107_SingleTopAnalysis.json""))); processes = files.keys(); df = {}; xsecs = {}; sumws = {}; samples = []; for p in processes:; for d in files[p]:; # Construct the dataframes; folder = d[0] # Folder name; sample = d[1] # Sample name; xsecs[sample] = d[2] # Cross-section; sumws[sample] = d[3] # Sum of weights; num_events = d[4] # Number of events; samples.append(sample); df[sample] = ROOT.RDataFrame(""mini"", ""{}/1lep/{}/{}.1lep.root"".format(dataset_path, folder, sample)); ; # Scale down the datasets if requested; if args.full_dataset and lumi_scale < 1.0:; df[sample] = df[sample].Range(int(num_events * lumi_scale)); ; # Select events for the analysis and make histograms of the top mass; ; # Just-in-time compile custom helper function performing complex computations; ROOT.gInterpreter.Declare(""""""; using cRVecF = const ROOT::RVecF &;; using cRVecI = const ROOT::RVecI &;; int FindGoodLepton(cRVecI goodlep, cRVecI type, cRVecF lep_pt, cRVecF lep_eta, cRVecF lep_phi, cRVecF lep_e, cRVecF trackd0pv, cRVecF tracksigd0pv, cRVecF z0); {; int idx = -1; // Return -1 if no good lepton is found.; for(auto i = 0; i < type.size(); i++) {; if(!goodlep[i]) continue;; if (type[i] == 11 && abs(lep_eta[i]) < 2.47 && (abs(lep_eta[i]) < 1.37 || abs(lep_eta[i]) > 1.52) && abs(trackd0pv[i] / tracksigd0pv[i]) < 5) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i], lep_phi[i], lep_e[i]);; if (abs(z0[i] * sin(p.Theta())) < 0.5) {; if (idx == -1) idx = i;; else return -1; // Accept only events with exactly one good lepton; }; }; if (type[i] == 13 && abs(lep_eta[i]) < 2.5 && abs(trackd0pv[i] / tracksigd0pv[i]) < 3) {; const ROOT::Math::PtEtaPhiEVector p(lep_pt[i], lep_eta[i]",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:8348,Performance,concurren,concurrently,8348,"at ComputeTopMass(float lep_pt, float lep_eta, float lep_phi, float lep_e, float jet_pt, float jet_eta, float jet_phi, float jet_e, float met_et, float met_phi); {; const ROOT::Math::PtEtaPhiEVector lep(lep_pt / 1000.0, lep_eta, lep_phi, lep_e / 1000.0);; const ROOT::Math::PtEtaPhiEVector met(met_et / 1000.0, 0, met_phi, met_et / 1000.0);; const ROOT::Math::PtEtaPhiEVector bjet(jet_pt / 1000.0, jet_eta, jet_phi, jet_e / 1000.0);; // Please note that we treat here the missing transverse energy as the neutrino, even though the z component is missing!; return (lep + met + bjet).M();; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""top_mass"", ""ComputeTopMass(lep_pt[idx_lep], lep_eta[idx_lep], lep_phi[idx_lep], lep_E[idx_lep], jet_pt[idx_tagged], jet_eta[idx_tagged], jet_phi[idx_tagged], jet_E[idx_tagged], met_et, met_phi)""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(""top_mass"", """", 10, 100, 400), ""top_mass"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected nor",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:11941,Performance,concurren,concurrently,11941,", ""#sqrt{{s}} = 13 TeV, {:.1f} fb^{{-1}}"".format(lumi * lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df107_SingleTopAnalysis.png""); print(""Saved figure to df107_SingleTopAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.5 fb^-1 ...; Saved figure to df107_SingleTopAnalysis.png; DateJuly 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df107_SingleTopAnalysis.py. tutorialsdataframedf107_SingleTopAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:12071,Performance,multi-thread,multi-threading,12071,", ""#sqrt{{s}} = 13 TeV, {:.1f} fb^{{-1}}"".format(lumi * lumi_scale / 1000.0)); ; # Save the plot; c.SaveAs(""df107_SingleTopAnalysis.png""); print(""Saved figure to df107_SingleTopAnalysis.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; int; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::RDF::TH1DModelA struct which stores the parameters of a TH1D.Definition HistoModels.hxx:30; RangeTa Range(0, 0, 1, 1); Run on data corresponding to 0.5 fb^-1 ...; Saved figure to df107_SingleTopAnalysis.png; DateJuly 2020 ; AuthorStefan Wunsch (KIT, CERN) ; Definition in file df107_SingleTopAnalysis.py. tutorialsdataframedf107_SingleTopAnalysis.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:544,Safety,detect,detector,544,". ROOT: tutorials/dataframe/df107_SingleTopAnalysis.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; df107_SingleTopAnalysis.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; This tutorial is the analysis of single top production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b:",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:9272,Security,validat,validation,9272,"f the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); twtb = merge_histos(""twtb""); singletop = merge_histos(""singletop""); wjets = merge_histos(""wjets""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas with pad; c = ROOT.TCanvas(""c"", """", 600, 600); pad = ROOT.TPad(""upper_pad"", """", 0, 0, 1, 1); pad.SetTickx(False); pad.SetTicky(False); pad.Draw(); pad.cd(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); wjets.Scale(1.1) # Corrected normalization derived from a validation region; for h, color in zip(; [wjets, twtb, singletop],; [(222, 90, 106), (155, 152, 204), (208, 240, 193)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetColor(*color)); stack.Add(h); stack.Draw(""HIST""); stack.GetXaxis().SetTitle(""m_{W(l#nu)+b} [GeV]""); stack.GetYaxis().SetTitle(""Events""); stack.GetYaxis().SetLabelSize(0.04); stack.GetYaxis().SetTitleSize(0.045); stack.GetXaxis().SetLabelSize(0.04); stack.GetXaxis().SetTitleSize(0.045); stack.SetMinimum(0); stack.SetMaximum(5000 * lumi_scale); stack.GetYaxis().ChangeLabel(1, -1, 0); ; # Draw data; data.SetMarkerStyle(20); data.SetMarkerSize(1.2); data.SetLineWidth(2); data.SetLineColor(ROOT.kBlack); data.Draw(""E SAME""); ; # Add legend; legend = ROOT.TLegend(0.60, 0.65, 0.92, 0.92); legend.SetTextFont(42); legend.SetFillStyle(0); legend.SetBorderSize(0); legend.SetTextSize(0.035); legend.SetTextAlign(32); legend.AddEntry(data, ""Data"" ,""lep""); legend.AddEntry(singletop, ""Single top + jet"", ""f""); legend.AddEntry(twtb, ""t#bar{t},Wt,t#bar{b}"", ",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html:1402,Usability,usab,usable,1402,"production adapted from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. Top quarks with a mass of about 172 GeV are mostly produced in pairs but also appear alone, dominantly from the decays of a W boson in association with a light jet.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the full-dataset argument and you can also run only on a fraction of the original dataset using the argument lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.05,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df107_SingleTopAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.05 # The preskimmed dataset contains only 0.5 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.1f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,doc/master/df107__SingleTopAnalysis_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/df107__SingleTopAnalysis_8py.html
https://root.cern/doc/master/Dfactir_8h_source.html:1254,Integrability,rout,routine,1254,"Glebe, L. Moneta 2005; 3 ; 4#ifndef ROOT_Math_Dfactir; 5#define ROOT_Math_Dfactir; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 02. Apr 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: Determinant of a square matrix, needed for Dfinv(); 23// Code was taken from CERNLIB::kernlib dfact function, translated; 24// from FORTRAN to C++ and optimized.; 25//; 26// changes:; 27// 02 Apr 2001 (TG) creation; 28//; 29// ********************************************************************; 30 ; 31#include <cmath>; 32 ; 33namespace ROOT {; 34 ; 35 namespace Math {; 36 ; 37 ; 38/** Dfactir.; 39 Function to compute the determinant from a square matrix, Det(A) of; 40 dimension idim and order n. A working area ir is returned which is; 41 needed by the Dfinv routine.; 42 ; 43 @author T. Glebe; 44*/; 45template <class Matrix, unsigned int n, unsigned int idim>; 46bool Dfactir(Matrix& rhs, typename Matrix::value_type& det, unsigned int* ir); 47 // int *n, float *a, int *idim, int *ir, int *ifail, float *det, int *jfail); 48{; 49 ; 50#ifdef XXX; 51 if (idim < n || n <= 0) {; 52 return false;; 53 }; 54#endif; 55 ; 56 ; 57 /* Initialized data */; 58 typename Matrix::value_type* a = rhs.Array();; 59 ; 60 /* Local variables */; 61 unsigned int nxch, i, j, k, l;; 62 typename Matrix::value_type p, q, tf;; 63 ; 64 /* Parameter adjustments */; 65 a -= idim + 1;; 66 --ir;; 67 ; 68 /* Function Body */; 69 ; 70 // fact.inc; 71 nxch = 0;; 72 det = 1.;; 73 for (j = 1; j <= n; ++j) {; 74 const unsigned int ji = j * idim;; 75 const unsigned int jj = j + ji;; 76 ; 77 k = j;; 78 p = std::abs(a[jj]);; 79 ; 80 if (j != n) {; 81 for (i = j + 1; i <= n; ++i) {; 82 q = std::abs(a[i + ji]);; 83 if (q > p) {; 84 k = i;; 85 p = q;; 86 }; 8",MatchSource.WIKI,doc/master/Dfactir_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Dfactir_8h_source.html
https://root.cern/doc/master/Dfactir_8h_source.html:1712,Modifiability,variab,variables,1712,"translated; 24// from FORTRAN to C++ and optimized.; 25//; 26// changes:; 27// 02 Apr 2001 (TG) creation; 28//; 29// ********************************************************************; 30 ; 31#include <cmath>; 32 ; 33namespace ROOT {; 34 ; 35 namespace Math {; 36 ; 37 ; 38/** Dfactir.; 39 Function to compute the determinant from a square matrix, Det(A) of; 40 dimension idim and order n. A working area ir is returned which is; 41 needed by the Dfinv routine.; 42 ; 43 @author T. Glebe; 44*/; 45template <class Matrix, unsigned int n, unsigned int idim>; 46bool Dfactir(Matrix& rhs, typename Matrix::value_type& det, unsigned int* ir); 47 // int *n, float *a, int *idim, int *ir, int *ifail, float *det, int *jfail); 48{; 49 ; 50#ifdef XXX; 51 if (idim < n || n <= 0) {; 52 return false;; 53 }; 54#endif; 55 ; 56 ; 57 /* Initialized data */; 58 typename Matrix::value_type* a = rhs.Array();; 59 ; 60 /* Local variables */; 61 unsigned int nxch, i, j, k, l;; 62 typename Matrix::value_type p, q, tf;; 63 ; 64 /* Parameter adjustments */; 65 a -= idim + 1;; 66 --ir;; 67 ; 68 /* Function Body */; 69 ; 70 // fact.inc; 71 nxch = 0;; 72 det = 1.;; 73 for (j = 1; j <= n; ++j) {; 74 const unsigned int ji = j * idim;; 75 const unsigned int jj = j + ji;; 76 ; 77 k = j;; 78 p = std::abs(a[jj]);; 79 ; 80 if (j != n) {; 81 for (i = j + 1; i <= n; ++i) {; 82 q = std::abs(a[i + ji]);; 83 if (q > p) {; 84 k = i;; 85 p = q;; 86 }; 87 } // for i; 88 ; 89 if (k != j) {; 90 for (l = 1; l <= n; ++l) {; 91 const unsigned int li = l*idim;; 92 const unsigned int jli = j + li;; 93 const unsigned int kli = k + li;; 94 tf = a[jli];; 95 a[jli] = a[kli];; 96 a[kli] = tf;; 97 } // for l; 98 ++nxch;; 99 ir[nxch] = (j << 12) + k;; 100 } // if k != j; 101 } // if j!=n; 102 ; 103 if (p <= 0.) {; 104 det = 0;; 105 return false;; 106 }; 107 ; 108 det *= a[jj];; 109#ifdef XXX; 110 t = std::abs(det);; 111 if (t < 1e-19 || t > 1e19) {; 112 det = 0;; 113 return false;; 114 }; 115#endif; 116 ; 117 a[jj] = 1. / a[jj];; ",MatchSource.WIKI,doc/master/Dfactir_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Dfactir_8h_source.html
https://root.cern/doc/master/Dfactir_8h_source.html:840,Performance,optimiz,optimized,840,". ROOT: math/smatrix/inc/Math/Dfactir.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Dfactir.h. Go to the documentation of this file. 1// @(#)root/smatrix:$Id$; 2// Authors: T. Glebe, L. Moneta 2005; 3 ; 4#ifndef ROOT_Math_Dfactir; 5#define ROOT_Math_Dfactir; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 02. Apr 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: Determinant of a square matrix, needed for Dfinv(); 23// Code was taken from CERNLIB::kernlib dfact function, translated; 24// from FORTRAN to C++ and optimized.; 25//; 26// changes:; 27// 02 Apr 2001 (TG) creation; 28//; 29// ********************************************************************; 30 ; 31#include <cmath>; 32 ; 33namespace ROOT {; 34 ; 35 namespace Math {; 36 ; 37 ; 38/** Dfactir.; 39 Function to compute the determinant from a square matrix, Det(A) of; 40 dimension idim and order n. A working area ir is returned which is; 41 needed by the Dfinv routine.; 42 ; 43 @author T. Glebe; 44*/; 45template <class Matrix, unsigned int n, unsigned int idim>; 46bool Dfactir(Matrix& rhs, typename Matrix::value_type& det, unsigned int* ir); 47 // int *n, float *a, int *idim, int *ir, int *ifail, float *det, int *jfail); 48{; 49 ; 50#ifdef XXX; 51 if (idim < n || n <= 0) {; 52 return false;; 53 }; 54#endif; 55 ; 56 ; 57 /* Initialized data */; 58 typename Matrix::value_type* a = rhs.Array();; 59 ; 60 /* Local variables */; 61 unsigned int nxch, i, j, k, l;; 62 typename Matrix::value_type p, q, tf;; 63 ; 64 /* Parameter adjustments */; 65 a -= idim + 1;; 66 --ir;; 67 ; 68 /* Function Body */; 69 ; 70 // fact.inc; 71 nxch = 0;; 72 det = 1.;; 73 for (j = 1; j <= n; ++j) {; 74 const unsigned int j",MatchSource.WIKI,doc/master/Dfactir_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Dfactir_8h_source.html
https://root.cern/doc/master/Dfinv_8h_source.html:1154,Integrability,rout,routine,1154,"#)root/smatrix:$Id$; 2// Authors: T. Glebe, L. Moneta 2005; 3 ; 4#ifndef ROOT_Math_Dfinv; 5#define ROOT_Math_Dfinv; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 03. Apr 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: Matrix inversion; 23// Code was taken from CERNLIB::kernlib dfinv function, translated; 24// from FORTRAN to C++ and optimized.; 25//; 26// changes:; 27// 03 Apr 2001 (TG) creation; 28//; 29// ********************************************************************; 30 ; 31 ; 32namespace ROOT {; 33 ; 34 namespace Math {; 35 ; 36 ; 37 ; 38 ; 39/** Dfinv.; 40 Function to compute the inverse of a square matrix (\f$A^{-1}\f$) of; 41 dimension \f$idim\f$ and order \f$n\f$. The routine Dfactir must be called; 42 before Dfinv!; 43 ; 44 @author T. Glebe; 45*/; 46template <class Matrix, unsigned int n, unsigned int idim>; 47bool Dfinv(Matrix& rhs, unsigned int* ir) {; 48#ifdef XXX; 49 if (idim < n || n <= 0 || n==1) {; 50 return false;; 51 }; 52#endif; 53 ; 54 typename Matrix::value_type* a = rhs.Array();; 55 ; 56 /* Local variables */; 57 unsigned int nxch, i, j, k, m, ij;; 58 unsigned int im2, nm1, nmi;; 59 typename Matrix::value_type s31, s34, ti;; 60 ; 61 /* Parameter adjustments */; 62 a -= idim + 1;; 63 --ir;; 64 ; 65 /* Function Body */; 66 ; 67 /* finv.inc */; 68 ; 69 a[idim + 2] = -a[(idim << 1) + 2] * (a[idim + 1] * a[idim + 2]);; 70 a[(idim << 1) + 1] = -a[(idim << 1) + 1];; 71 ; 72 if (n != 2) {; 73 for (i = 3; i <= n; ++i) {; 74 const unsigned int ii = i * idim;; 75 const unsigned int iii = i + ii;; 76 const unsigned int imi = ii - idim;; 77 const unsigned int iimi = i + imi;; 78 im2 = i - 2;; 79 for (j = 1; j <= im2; ++j) {; 80 const unsigned int ji = j * idim;; 81 const unsigned",MatchSource.WIKI,doc/master/Dfinv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Dfinv_8h_source.html
https://root.cern/doc/master/Dfinv_8h_source.html:1503,Modifiability,variab,variables,1503,"/ Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: Matrix inversion; 23// Code was taken from CERNLIB::kernlib dfinv function, translated; 24// from FORTRAN to C++ and optimized.; 25//; 26// changes:; 27// 03 Apr 2001 (TG) creation; 28//; 29// ********************************************************************; 30 ; 31 ; 32namespace ROOT {; 33 ; 34 namespace Math {; 35 ; 36 ; 37 ; 38 ; 39/** Dfinv.; 40 Function to compute the inverse of a square matrix (\f$A^{-1}\f$) of; 41 dimension \f$idim\f$ and order \f$n\f$. The routine Dfactir must be called; 42 before Dfinv!; 43 ; 44 @author T. Glebe; 45*/; 46template <class Matrix, unsigned int n, unsigned int idim>; 47bool Dfinv(Matrix& rhs, unsigned int* ir) {; 48#ifdef XXX; 49 if (idim < n || n <= 0 || n==1) {; 50 return false;; 51 }; 52#endif; 53 ; 54 typename Matrix::value_type* a = rhs.Array();; 55 ; 56 /* Local variables */; 57 unsigned int nxch, i, j, k, m, ij;; 58 unsigned int im2, nm1, nmi;; 59 typename Matrix::value_type s31, s34, ti;; 60 ; 61 /* Parameter adjustments */; 62 a -= idim + 1;; 63 --ir;; 64 ; 65 /* Function Body */; 66 ; 67 /* finv.inc */; 68 ; 69 a[idim + 2] = -a[(idim << 1) + 2] * (a[idim + 1] * a[idim + 2]);; 70 a[(idim << 1) + 1] = -a[(idim << 1) + 1];; 71 ; 72 if (n != 2) {; 73 for (i = 3; i <= n; ++i) {; 74 const unsigned int ii = i * idim;; 75 const unsigned int iii = i + ii;; 76 const unsigned int imi = ii - idim;; 77 const unsigned int iimi = i + imi;; 78 im2 = i - 2;; 79 for (j = 1; j <= im2; ++j) {; 80 const unsigned int ji = j * idim;; 81 const unsigned int jii = j + ii;; 82 s31 = 0.;; 83 for (k = j; k <= im2; ++k) {; 84 s31 += a[k + ji] * a[i + k * idim];; 85 a[jii] += a[j + (k + 1) * idim] * a[k + 1 + ii];; 86 } // for k; 87 a[i + ji] = -a[iii] * (a[i - 1 + ji] * a[iimi] + s31);; 88 a[jii] *= -1;; 89 } // for j; 90 a[iimi] = -a[iii] * (a[i - 1 + imi] * a[iimi]);; 91 a[i - 1 + ii] *= -1;; 92 } // for i; 93 } // if n!=2; 94 ; 95 nm1 = n - 1;; 96 for (i = 1; i <= nm1; ++",MatchSource.WIKI,doc/master/Dfinv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Dfinv_8h_source.html
https://root.cern/doc/master/Dfinv_8h_source.html:798,Performance,optimiz,optimized,798,". ROOT: math/smatrix/inc/Math/Dfinv.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Dfinv.h. Go to the documentation of this file. 1// @(#)root/smatrix:$Id$; 2// Authors: T. Glebe, L. Moneta 2005; 3 ; 4#ifndef ROOT_Math_Dfinv; 5#define ROOT_Math_Dfinv; 6// ********************************************************************; 7//; 8// source:; 9//; 10// type: source code; 11//; 12// created: 03. Apr 2001; 13//; 14// author: Thorsten Glebe; 15// HERA-B Collaboration; 16// Max-Planck-Institut fuer Kernphysik; 17// Saupfercheckweg 1; 18// 69117 Heidelberg; 19// Germany; 20// E-mail: T.Glebe@mpi-hd.mpg.de; 21//; 22// Description: Matrix inversion; 23// Code was taken from CERNLIB::kernlib dfinv function, translated; 24// from FORTRAN to C++ and optimized.; 25//; 26// changes:; 27// 03 Apr 2001 (TG) creation; 28//; 29// ********************************************************************; 30 ; 31 ; 32namespace ROOT {; 33 ; 34 namespace Math {; 35 ; 36 ; 37 ; 38 ; 39/** Dfinv.; 40 Function to compute the inverse of a square matrix (\f$A^{-1}\f$) of; 41 dimension \f$idim\f$ and order \f$n\f$. The routine Dfactir must be called; 42 before Dfinv!; 43 ; 44 @author T. Glebe; 45*/; 46template <class Matrix, unsigned int n, unsigned int idim>; 47bool Dfinv(Matrix& rhs, unsigned int* ir) {; 48#ifdef XXX; 49 if (idim < n || n <= 0 || n==1) {; 50 return false;; 51 }; 52#endif; 53 ; 54 typename Matrix::value_type* a = rhs.Array();; 55 ; 56 /* Local variables */; 57 unsigned int nxch, i, j, k, m, ij;; 58 unsigned int im2, nm1, nmi;; 59 typename Matrix::value_type s31, s34, ti;; 60 ; 61 /* Parameter adjustments */; 62 a -= idim + 1;; 63 --ir;; 64 ; 65 /* Function Body */; 66 ; 67 /* finv.inc */; 68 ; 69 a[idim + 2] = -a[(idim << 1) + 2] * (a[idim + 1] * a[idim + 2]);; 70 a[(idim << 1) + 1] = -a[(idim << 1) + 1];; 71 ; 72 if (n != 2) {; 73 for (i = 3; i <= n; ++i) {; 74 const unsigned int ii = i * idim;; 75 const unsigned int iii = i + ii;;",MatchSource.WIKI,doc/master/Dfinv_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Dfinv_8h_source.html
https://root.cern/doc/master/dir_1c665cc5526164787b3a14a24f921a4b.html:156,Integrability,depend,dependency,156,". ROOT: core/base Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. base Directory Reference. Directory dependency graph for base:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; doc; ; inc; ; src; ; v7; . corebase. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_1c665cc5526164787b3a14a24f921a4b.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_1c665cc5526164787b3a14a24f921a4b.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:467,Availability,error,error,467,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:500,Availability,error,error,500,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:689,Availability,error,error,689,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:741,Availability,error,error,741,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:805,Availability,error,errors,805,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:165,Integrability,depend,dependency,165,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:411,Testability,test,test,411,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:1408,Testability,test,test,1408,"n Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; labels1.C;  Setting alphanumeric labels in a 1-d histogram. ; ; labels2.C;  Setting alphanumeric labels. ; ; motorcycle.C;  Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; ; multigraph.C;  Create and Draw a TMultiGraph. ; ; multigraphpalettecolor.C;  Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color),",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:1466,Testability,log,logarithmic,1466,"n Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; labels1.C;  Setting alphanumeric labels in a 1-d histogram. ; ; labels2.C;  Setting alphanumeric labels. ; ; motorcycle.C;  Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; ; multigraph.C;  Create and Draw a TMultiGraph. ; ; multigraphpalettecolor.C;  Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color),",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:2187,Testability,test,test,2187,"h. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; labels1.C;  Setting alphanumeric labels in a 1-d histogram. ; ; labels2.C;  Setting alphanumeric labels. ; ; motorcycle.C;  Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; ; multigraph.C;  Create and Draw a TMultiGraph. ; ; multigraphpalettecolor.C;  Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; multipalette.C;  Draw color plots using different color palettes. ; ; scatter.C;  Draw a scatter plot. ; ; seism.C;  Strip chart example. ; ; splines_test.C;  Examples of use of the spline classes. ; ; surfaces.C;  Draw 2-Dim functions. ; ; timeonaxis.C;  This macro illustrates the use of the time mode on the axis with different time intervals and time formats. ; ; timeonaxis2.C;  Define the time offset as 2003, January 1st. ; ; timeonaxis3.C;  This example compares what the system time function gmtime and localtime give with what gives TGaxis. ; ; timeSeriesFromCSV.C;  This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage st",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:3701,Testability,log,log,3701,"anumeric labels. ; ; motorcycle.C;  Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; ; multigraph.C;  Create and Draw a TMultiGraph. ; ; multigraphpalettecolor.C;  Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; multipalette.C;  Draw color plots using different color palettes. ; ; scatter.C;  Draw a scatter plot. ; ; seism.C;  Strip chart example. ; ; splines_test.C;  Examples of use of the spline classes. ; ; surfaces.C;  Draw 2-Dim functions. ; ; timeonaxis.C;  This macro illustrates the use of the time mode on the axis with different time intervals and time formats. ; ; timeonaxis2.C;  Define the time offset as 2003, January 1st. ; ; timeonaxis3.C;  This example compares what the system time function gmtime and localtime give with what gives TGaxis. ; ; timeSeriesFromCSV.C;  This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ; ; timeSeriesFromCSV.py;  This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ; ; timeSeriesFromCSV_TDF.C;  This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017. ; ; waves.C;  Hint: Spherical waves ; ; zdemo.C;  This macro is an example of graphs in log scales with annotations. ; ; zones.C;  Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads. ; ; zones.py;  Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads. ; . tutorialsgraphs. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:836,Usability,simpl,simple,836,". ROOT: tutorials/graphs Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. graphs Directory Reference. Directory dependency graph for graphs:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; annotation3d.C;  This example show how to put some annotation on a 3D plot using 3D polylines. ; ; approx.C;  Macro to test interpolation function Approx ; ; bent.C;  Bent error bars ; ; bent.py;  Bent error bars. ; ; exclusiongraph.C;  Draw three graphs with an exclusion zone. ; ; exclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates ",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html:1582,Usability,simpl,simple,1582,"xclusiongraph2.C;  Draw several graphs with an exclusion zones. ; ; gerrors.C;  Draw a graph with error bars ; ; gerrors2.C;  Draw two graphs with error bars ; ; gmultierrors.C;  Draw a graph with multiple y errors ; ; graph.C;  Draw a simple graph. ; ; graph2derrorsfit.C;  Draw and fit a TGraph2DErrors ; ; graphApply.C;  A macro to demonstrate the functionality of TGraph::Apply() method. ; ; graphpalettecolor.C;  Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; graphpolar.C;  Create and draw a polar graph. ; ; graphpolar2.C;  Create and draw a polar graph with PI axis ; ; graphpolar3.C;  Create and draw a polar graph with PI axis using a TF1. ; ; graphreverse.C;  This example test all the various case of reverse graphs combined with logarithmic scale. ; ; graphShade.C;  Show how to shade an area between two graphs ; ; graphstruct.C;  Draw a simple graph structure. ; ; graphtext.C;  Draw a graph with text attached to each point. ; ; gtime.C;  Example of TGraphTime. ; ; gtime2.C;  Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program. ; ; hlGraph1.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; hlGraph2.C; This tutorial demonstrates how to use the highlight mode on graph. ; ; labels1.C;  Setting alphanumeric labels in a 1-d histogram. ; ; labels2.C;  Setting alphanumeric labels. ; ; motorcycle.C;  Macro to test scatterplot smoothers: ksmooth, lowess, supsmu as described in: ; ; multigraph.C;  Create and Draw a TMultiGraph. ; ; multigraphpalettecolor.C;  Palette coloring for multi-graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; multipalette.C;  Draw color plots using different color palettes. ; ; scatter.C;  D",MatchSource.WIKI,doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_21ec31480a793facd4ea3dd8f2d42294.html
https://root.cern/doc/master/dir_581b2f84e81921659261a687f8475ad3.html:159,Integrability,depend,dependency,159,". ROOT: core/base/inc Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. inc Directory Reference. Directory dependency graph for inc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; ROOT; . Files; Bswapcpy.h; ; Buttons.h; ; Bytes.h; ; Byteswap.h; ; GLConstants.h; ; Gtypes.h; ; Htypes.h; ; KeySymbols.h; ; Match.h; ; MessageTypes.h; ; RConfig.h; ; Riostream.h; ; Rpair.h; ; RQ_OBJECT.h; ; RStipples.h; ; Rtypes.h; ; RtypesImp.h; ; Strlen.h; ; TApplication.h; ; TAtt3D.h; ; TAttAxis.h; ; TAttBBox.h; ; TAttBBox2D.h; ; TAttFill.h; ; TAttLine.h; ; TAttMarker.h; ; TAttPad.h; ; TAttText.h; ; TBase64.h; ; TBenchmark.h; ; TBuffer.h; ; TBuffer3D.h; ; TBuffer3DTypes.h; ; TColor.h; ; TColorGradient.h; ; TDatime.h; ; TDirectory.h; ; TEnv.h; ; TException.h; ; TExec.h; ; TFileCollection.h; ; TFileInfo.h; ; TFolder.h; ; TInetAddress.h; ; TMacro.h; ; TMathBase.h; ; TMD5.h; ; TMemberInspector.h; ; TMessageHandler.h; ; TNamed.h; ; TNotifyLink.h; ; TObject.h; ; TObjString.h; ; TParameter.h; ; TPluginManager.h; ; TPoint.h; ; TPRegexp.h; ; TProcessID.h; ; TProcessUUID.h; ; TQClass.h; ; TQCommand.h; ; TQConnection.h; ; TQObject.h; ; TRedirectOutputGuard.h; ; TRef.h; ; TRefCnt.h; ; TRegexp.h; ; TRemoteObject.h; ; TROOT.h; ; TRootIOCtor.h; ; TStopwatch.h; ; TStorage.h; ; TString.h; ; TStringLong.h; ; TStyle.h; ; TSysEvtHandler.h; ; TSystem.h; ; TSystemDirectory.h; ; TSystemFile.h; ; TTask.h; ; TThreadSlots.h; ; TTime.h; ; TTimer.h; ; TTimeStamp.h; ; TUri.h; ; TUrl.h; ; TUUID.h; ; TVersionCheck.h; ; TVirtualAuth.h; ; TVirtualFFT.h; ; TVirtualGL.h; ; TVirtualMapFile.h; ; TVirtualMonitoring.h; ; TVirtualMutex.h; ; TVirtualPad.h; ; TVirtualPadEditor.h; ; TVirtualPadPainter.h; ; TVirtualPerfStats.h; ; TVi",MatchSource.WIKI,doc/master/dir_581b2f84e81921659261a687f8475ad3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_581b2f84e81921659261a687f8475ad3.html
https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html:157,Integrability,depend,dependency,157,". ROOT: tutorials/io Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. io Directory Reference. Directory dependency graph for io:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; copyFiles.C;  Example of script showing how to copy all objects (including directories) from a source file. ; ; dirs.C;  This macro illustrates how to create a hierarchy of directories in a Root file. ; ; double32.C;  Tutorial illustrating use and precision of the Double32_t data type You should run this tutorial with ACLIC: a dictionary will be automatically created. ; ; fildir.C;  This macro displays the ROOT Directory data structure ; ; file.C;  This macro displays the physical ROOT file structure ; ; float16.C;  Tutorial illustrating use and precision of the Float16_t data type. ; ; hadd.C;  Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ; ; importCode.C;  Example of script showing how to create a ROOT file with subdirectories. ; ; loopdir.C;  Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ; ; loopdir11.C;  Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ; ; mergeSelective.C;  Merge only part of the content of a set of files. ; ; readCode.C;  Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory. ; ; testMergeCont.C;  Macro demonstrating the merging of containers. ; ; testTMPIFile.C; This macro shows the usage of TMPIFile to simulate event reconstruction and merging them in parallel. ; . tutorialsio. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html
https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html:1626,Testability,test,testMergeCont,1626,". ROOT: tutorials/io Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. io Directory Reference. Directory dependency graph for io:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; copyFiles.C;  Example of script showing how to copy all objects (including directories) from a source file. ; ; dirs.C;  This macro illustrates how to create a hierarchy of directories in a Root file. ; ; double32.C;  Tutorial illustrating use and precision of the Double32_t data type You should run this tutorial with ACLIC: a dictionary will be automatically created. ; ; fildir.C;  This macro displays the ROOT Directory data structure ; ; file.C;  This macro displays the physical ROOT file structure ; ; float16.C;  Tutorial illustrating use and precision of the Float16_t data type. ; ; hadd.C;  Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ; ; importCode.C;  Example of script showing how to create a ROOT file with subdirectories. ; ; loopdir.C;  Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ; ; loopdir11.C;  Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ; ; mergeSelective.C;  Merge only part of the content of a set of files. ; ; readCode.C;  Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory. ; ; testMergeCont.C;  Macro demonstrating the merging of containers. ; ; testTMPIFile.C; This macro shows the usage of TMPIFile to simulate event reconstruction and merging them in parallel. ; . tutorialsio. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html
https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html:1698,Testability,test,testTMPIFile,1698,". ROOT: tutorials/io Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. io Directory Reference. Directory dependency graph for io:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; copyFiles.C;  Example of script showing how to copy all objects (including directories) from a source file. ; ; dirs.C;  This macro illustrates how to create a hierarchy of directories in a Root file. ; ; double32.C;  Tutorial illustrating use and precision of the Double32_t data type You should run this tutorial with ACLIC: a dictionary will be automatically created. ; ; fildir.C;  This macro displays the ROOT Directory data structure ; ; file.C;  This macro displays the physical ROOT file structure ; ; float16.C;  Tutorial illustrating use and precision of the Float16_t data type. ; ; hadd.C;  Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ; ; importCode.C;  Example of script showing how to create a ROOT file with subdirectories. ; ; loopdir.C;  Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ; ; loopdir11.C;  Example script to loop over all the objects of a ROOT file directory and print in Postscript all the TH1 derived objects. ; ; mergeSelective.C;  Merge only part of the content of a set of files. ; ; readCode.C;  Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory. ; ; testMergeCont.C;  Macro demonstrating the merging of containers. ; ; testTMPIFile.C; This macro shows the usage of TMPIFile to simulate event reconstruction and merging them in parallel. ; . tutorialsio. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_715fafd9bc85e47ed5557926189f8f1b.html
https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html:168,Integrability,depend,dependency,168,". ROOT: tutorials/v7/ntuple Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ntuple Directory Reference. Directory dependency graph for ntuple:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; ntpl001_staff.C;  Write and read tabular data with RNTuple. ; ; ntpl002_vector.C;  Write and read STL vectors with RNTuple. ; ; ntpl004_dimuon.C;  Mini-Analysis on CMS OpenData with RDataFrame. ; ; ntpl005_introspection.C;  Write and read an RNTuple from a user-defined class. ; ; ntpl006_friends.C;  Work with befriended RNTuples. ; ; ntpl007_mtFill.C;  Example of multi-threaded writes using multiple REntry objects ; ; ntpl008_import.C;  Example of converting data stored in a TTree into an RNTuple ; ; ntpl009_parallelWriter.C;  Example of multi-threaded writes using RNTupleParallelWriter. ; ; ntpl010_skim.C;  Example creating a derived RNTuple ; ; ntpl011_global_temperatures.C;  This ROOT 7 example demonstrates how to use RNTuple in combination with ROOT 6 features like RDataframe and visualizations. ; ; ntpl012_processor.C;  Demonstrate the RNTupleProcessor using multiple RNTuples ; ; ntpl013_staged.C;  Example of staged cluster committing in multi-threaded writing using RNTupleParallelWriter. ; ; ntpl014_framework.C;  ; . tutorialsv7ntuple. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html
https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html:673,Performance,multi-thread,multi-threaded,673,". ROOT: tutorials/v7/ntuple Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ntuple Directory Reference. Directory dependency graph for ntuple:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; ntpl001_staff.C;  Write and read tabular data with RNTuple. ; ; ntpl002_vector.C;  Write and read STL vectors with RNTuple. ; ; ntpl004_dimuon.C;  Mini-Analysis on CMS OpenData with RDataFrame. ; ; ntpl005_introspection.C;  Write and read an RNTuple from a user-defined class. ; ; ntpl006_friends.C;  Work with befriended RNTuples. ; ; ntpl007_mtFill.C;  Example of multi-threaded writes using multiple REntry objects ; ; ntpl008_import.C;  Example of converting data stored in a TTree into an RNTuple ; ; ntpl009_parallelWriter.C;  Example of multi-threaded writes using RNTupleParallelWriter. ; ; ntpl010_skim.C;  Example creating a derived RNTuple ; ; ntpl011_global_temperatures.C;  This ROOT 7 example demonstrates how to use RNTuple in combination with ROOT 6 features like RDataframe and visualizations. ; ; ntpl012_processor.C;  Demonstrate the RNTupleProcessor using multiple RNTuples ; ; ntpl013_staged.C;  Example of staged cluster committing in multi-threaded writing using RNTupleParallelWriter. ; ; ntpl014_framework.C;  ; . tutorialsv7ntuple. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html
https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html:857,Performance,multi-thread,multi-threaded,857,". ROOT: tutorials/v7/ntuple Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ntuple Directory Reference. Directory dependency graph for ntuple:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; ntpl001_staff.C;  Write and read tabular data with RNTuple. ; ; ntpl002_vector.C;  Write and read STL vectors with RNTuple. ; ; ntpl004_dimuon.C;  Mini-Analysis on CMS OpenData with RDataFrame. ; ; ntpl005_introspection.C;  Write and read an RNTuple from a user-defined class. ; ; ntpl006_friends.C;  Work with befriended RNTuples. ; ; ntpl007_mtFill.C;  Example of multi-threaded writes using multiple REntry objects ; ; ntpl008_import.C;  Example of converting data stored in a TTree into an RNTuple ; ; ntpl009_parallelWriter.C;  Example of multi-threaded writes using RNTupleParallelWriter. ; ; ntpl010_skim.C;  Example creating a derived RNTuple ; ; ntpl011_global_temperatures.C;  This ROOT 7 example demonstrates how to use RNTuple in combination with ROOT 6 features like RDataframe and visualizations. ; ; ntpl012_processor.C;  Demonstrate the RNTupleProcessor using multiple RNTuples ; ; ntpl013_staged.C;  Example of staged cluster committing in multi-threaded writing using RNTupleParallelWriter. ; ; ntpl014_framework.C;  ; . tutorialsv7ntuple. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html
https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html:1282,Performance,multi-thread,multi-threaded,1282,". ROOT: tutorials/v7/ntuple Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ntuple Directory Reference. Directory dependency graph for ntuple:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; ntpl001_staff.C;  Write and read tabular data with RNTuple. ; ; ntpl002_vector.C;  Write and read STL vectors with RNTuple. ; ; ntpl004_dimuon.C;  Mini-Analysis on CMS OpenData with RDataFrame. ; ; ntpl005_introspection.C;  Write and read an RNTuple from a user-defined class. ; ; ntpl006_friends.C;  Work with befriended RNTuples. ; ; ntpl007_mtFill.C;  Example of multi-threaded writes using multiple REntry objects ; ; ntpl008_import.C;  Example of converting data stored in a TTree into an RNTuple ; ; ntpl009_parallelWriter.C;  Example of multi-threaded writes using RNTupleParallelWriter. ; ; ntpl010_skim.C;  Example creating a derived RNTuple ; ; ntpl011_global_temperatures.C;  This ROOT 7 example demonstrates how to use RNTuple in combination with ROOT 6 features like RDataframe and visualizations. ; ; ntpl012_processor.C;  Demonstrate the RNTupleProcessor using multiple RNTuples ; ; ntpl013_staged.C;  Example of staged cluster committing in multi-threaded writing using RNTupleParallelWriter. ; ; ntpl014_framework.C;  ; . tutorialsv7ntuple. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_74d0bdb54707d3eaa1a5a0931b591e7a.html
https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html:157,Integrability,depend,dependency,157,". ROOT: tutorials/v7 Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. v7 Directory Reference. Directory dependency graph for v7:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; ntuple; . Files; browser.cxx; ; concurrentfill.cxx; ; filedialog.cxx; ; fitpanel.cxx; ; fitpanel6.cxx; ; histops.cxx; ; perf.cxx; ; perfcomp.cxx; ; simple.cxx; . tutorialsv7. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_87a15b6630bbbec9854bba9437a28716.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html
https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html:318,Performance,concurren,concurrentfill,318,". ROOT: tutorials/v7 Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. v7 Directory Reference. Directory dependency graph for v7:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; ntuple; . Files; browser.cxx; ; concurrentfill.cxx; ; filedialog.cxx; ; fitpanel.cxx; ; fitpanel6.cxx; ; histops.cxx; ; perf.cxx; ; perfcomp.cxx; ; simple.cxx; . tutorialsv7. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_87a15b6630bbbec9854bba9437a28716.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html
https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html:448,Usability,simpl,simple,448,". ROOT: tutorials/v7 Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. v7 Directory Reference. Directory dependency graph for v7:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; ntuple; . Files; browser.cxx; ; concurrentfill.cxx; ; filedialog.cxx; ; fitpanel.cxx; ; fitpanel6.cxx; ; histops.cxx; ; perf.cxx; ; perfcomp.cxx; ; simple.cxx; . tutorialsv7. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_87a15b6630bbbec9854bba9437a28716.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_87a15b6630bbbec9854bba9437a28716.html
https://root.cern/doc/master/dir_983ef7a33b0c59dc2d471f36240bf58a.html:168,Integrability,depend,dependency,168,". ROOT: tutorials/tmva/keras Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. keras Directory Reference. Directory dependency graph for keras:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; ApplicationClassificationKeras.py;  This tutorial shows how to apply a trained model to new data. ; ; ApplicationRegressionKeras.py;  This tutorial shows how to apply a trained model to new data (regression). ; ; ClassificationKeras.py;  This tutorial shows how to do classification in TMVA with neural networks trained with keras. ; ; GenerateModel.py;  This tutorial shows how to define and generate a keras model for use with TMVA. ; ; MulticlassKeras.py;  This tutorial shows how to do multiclass classification in TMVA with neural networks trained with keras. ; ; RegressionKeras.py;  This tutorial shows how to do regression in TMVA with neural networks trained with keras. ; . tutorialstmvakeras. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_983ef7a33b0c59dc2d471f36240bf58a.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_983ef7a33b0c59dc2d471f36240bf58a.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:3743,Availability,down,downloads,3743,";  Implement a custom action to fill THns. ; ; df019_Cache.C;  Cache a processed RDataFrame in memory for further usage. ; ; df019_Cache.py;  Cache a processed RDataFrame in memory for further usage. ; ; df020_helpers.C;  Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ; ; df021_createTGraph.C;  Fill a TGraph using RDataFrame. ; ; df021_createTGraph.py;  Fill a TGraph using RDataFrame. ; ; df022_useKahan.C;  Implement a custom action that evaluates a Kahan sum. ; ; df023_aggregate.C;  Use the Aggregate action to specify arbitrary data aggregations. ; ; df024_Display.C;  Use the Display action to inspect entry values. ; ; df024_Display.py;  Use the Display action to inspect entry values. ; ; df025_RNode.C;  Manipulate RDF objects in functions, loops and conditional branches. ; ; df026_AsNumpyArrays.py;  Read data from RDataFrame into Numpy arrays. ; ; df027_SQliteDependencyOverVersion.C;  Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; ; df028_SQliteIPLocation.C;  Plot the location of ROOT downloads reading a remote sqlite3 file. ; ; df029_SQlitePlatformDistribution.C;  Use RDataFrame to display data about ROOT downloads. ; ; df030_SQliteVersionsOfROOT.C;  Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; ; df031_Stats.C;  Use the Stats action to extract the statistics of a column. ; ; df031_Stats.py;  Use the Stats action to extract the statistics of a column. ; ; df032_RDFFromNumpy.py;  Read data from Numpy arrays into RDataFrame. ; ; df033_Describe.py;  Get information about the dataframe with the convenience method Describe. ; ; df034_SaveGraph.C;  Basic SaveGraph usage. ; ; df034_SaveGraph.py;  Basic SaveGraph usage. ; ; df035_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTre",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:3865,Availability,down,downloads,3865," for further usage. ; ; df019_Cache.py;  Cache a processed RDataFrame in memory for further usage. ; ; df020_helpers.C;  Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ; ; df021_createTGraph.C;  Fill a TGraph using RDataFrame. ; ; df021_createTGraph.py;  Fill a TGraph using RDataFrame. ; ; df022_useKahan.C;  Implement a custom action that evaluates a Kahan sum. ; ; df023_aggregate.C;  Use the Aggregate action to specify arbitrary data aggregations. ; ; df024_Display.C;  Use the Display action to inspect entry values. ; ; df024_Display.py;  Use the Display action to inspect entry values. ; ; df025_RNode.C;  Manipulate RDF objects in functions, loops and conditional branches. ; ; df026_AsNumpyArrays.py;  Read data from RDataFrame into Numpy arrays. ; ; df027_SQliteDependencyOverVersion.C;  Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; ; df028_SQliteIPLocation.C;  Plot the location of ROOT downloads reading a remote sqlite3 file. ; ; df029_SQlitePlatformDistribution.C;  Use RDataFrame to display data about ROOT downloads. ; ; df030_SQliteVersionsOfROOT.C;  Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; ; df031_Stats.C;  Use the Stats action to extract the statistics of a column. ; ; df031_Stats.py;  Use the Stats action to extract the statistics of a column. ; ; df032_RDFFromNumpy.py;  Read data from Numpy arrays into RDataFrame. ; ; df033_Describe.py;  Get information about the dataframe with the convenience method Describe. ; ; df034_SaveGraph.C;  Basic SaveGraph usage. ; ; df034_SaveGraph.py;  Basic SaveGraph usage. ; ; df035_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFra",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:3992,Availability,down,downloads,3992,"; df020_helpers.C;  Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ; ; df021_createTGraph.C;  Fill a TGraph using RDataFrame. ; ; df021_createTGraph.py;  Fill a TGraph using RDataFrame. ; ; df022_useKahan.C;  Implement a custom action that evaluates a Kahan sum. ; ; df023_aggregate.C;  Use the Aggregate action to specify arbitrary data aggregations. ; ; df024_Display.C;  Use the Display action to inspect entry values. ; ; df024_Display.py;  Use the Display action to inspect entry values. ; ; df025_RNode.C;  Manipulate RDF objects in functions, loops and conditional branches. ; ; df026_AsNumpyArrays.py;  Read data from RDataFrame into Numpy arrays. ; ; df027_SQliteDependencyOverVersion.C;  Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; ; df028_SQliteIPLocation.C;  Plot the location of ROOT downloads reading a remote sqlite3 file. ; ; df029_SQlitePlatformDistribution.C;  Use RDataFrame to display data about ROOT downloads. ; ; df030_SQliteVersionsOfROOT.C;  Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; ; df031_Stats.C;  Use the Stats action to extract the statistics of a column. ; ; df031_Stats.py;  Use the Stats action to extract the statistics of a column. ; ; df032_RDFFromNumpy.py;  Read data from Numpy arrays into RDataFrame. ; ; df033_Describe.py;  Get information about the dataframe with the convenience method Describe. ; ; df034_SaveGraph.C;  Basic SaveGraph usage. ; ; df034_SaveGraph.py;  Basic SaveGraph usage. ; ; df035_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ;",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:4111,Availability,down,downloads,4111,"f021_createTGraph.C;  Fill a TGraph using RDataFrame. ; ; df021_createTGraph.py;  Fill a TGraph using RDataFrame. ; ; df022_useKahan.C;  Implement a custom action that evaluates a Kahan sum. ; ; df023_aggregate.C;  Use the Aggregate action to specify arbitrary data aggregations. ; ; df024_Display.C;  Use the Display action to inspect entry values. ; ; df024_Display.py;  Use the Display action to inspect entry values. ; ; df025_RNode.C;  Manipulate RDF objects in functions, loops and conditional branches. ; ; df026_AsNumpyArrays.py;  Read data from RDataFrame into Numpy arrays. ; ; df027_SQliteDependencyOverVersion.C;  Plot the ROOT downloads based on the version reading a remote sqlite3 file. ; ; df028_SQliteIPLocation.C;  Plot the location of ROOT downloads reading a remote sqlite3 file. ; ; df029_SQlitePlatformDistribution.C;  Use RDataFrame to display data about ROOT downloads. ; ; df030_SQliteVersionsOfROOT.C;  Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ; ; df031_Stats.C;  Use the Stats action to extract the statistics of a column. ; ; df031_Stats.py;  Use the Stats action to extract the statistics of a column. ; ; df032_RDFFromNumpy.py;  Read data from Numpy arrays into RDataFrame. ; ; df033_Describe.py;  Get information about the dataframe with the convenience method Describe. ; ; df034_SaveGraph.C;  Basic SaveGraph usage. ; ; df034_SaveGraph.py;  Basic SaveGraph usage. ; ; df035_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.py;  Show how NanoAOD files can be processed with RDataFrame. ; ; df103_",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:2047,Deployability,update,update,2047,"limit the amount of data processed. ; ; df006_ranges.py;  Use Range to limit the amount of data processed. ; ; df007_snapshot.C;  Write ROOT data with RDataFrame. ; ; df007_snapshot.py;  Write ROOT data with RDataFrame. ; ; df008_createDataSetFromScratch.C;  Create data from scratch with RDataFrame. ; ; df008_createDataSetFromScratch.py;  Create data from scratch with RDataFrame. ; ; df009_FromScratchVSTTree.C;  Compare creation of a ROOT dataset with RDataFrame and TTree. ; ; df010_trivialDataSource.C;  Use the ""trivial data source"", an example data source implementation. ; ; df010_trivialDataSource.py;  Use the ""trivial data source"", an example data source implementation. ; ; df012_DefinesAndFiltersAsStrings.C;  Use just-in-time-compiled Filters and Defines for quick prototyping. ; ; df012_DefinesAndFiltersAsStrings.py;  Use just-in-time-compiled Filters and Defines for quick prototyping. ; ; df013_InspectAnalysis.C;  Use callbacks to update a plot and a progress bar during the event loop. ; ; df014_CSVDataSource.C;  Process a CSV file with RDataFrame and the CSV data source. ; ; df014_CSVDataSource.py;  Process a CSV file with RDataFrame and the CSV data source. ; ; df015_LazyDataSource.C;  Use the lazy RDataFrame data source to concatenate computation graphs. ; ; df016_vecOps.C;  Process collections in RDataFrame with the help of RVec. ; ; df016_vecOps.py;  Process collections in RDataFrame with the help of RVec. ; ; df017_vecOpsHEP.C;  Use RVecs to plot the transverse momentum of selected particles. ; ; df017_vecOpsHEP.py;  Use RVecs to plot the transverse momentum of selected particles. ; ; df018_customActions.C;  Implement a custom action to fill THns. ; ; df019_Cache.C;  Cache a processed RDataFrame in memory for further usage. ; ; df019_Cache.py;  Cache a processed RDataFrame in memory for further usage. ; ; df020_helpers.C;  Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelper",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:5543,Deployability,release,release,5543," df034_SaveGraph.py;  Basic SaveGraph usage. ; ; df035_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.py;  Show how NanoAOD files can be processed with RDataFrame. ; ; df103_NanoAODHiggsAnalysis.C;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis.py;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis_python.h; Header file with functions needed to execute the Python version of the NanoAOD Higgs tutorial. ; ; df104_HiggsToTwoPhotons.py;  The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; ; df105_WBosonAnalysis.py;  The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.C;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.py;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df107_SingleTopAnalysis.py;  A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; ; distrdf001_spark_connection.py;  Configure a Spark connection and fill two histograms distributedly. ; ; distrdf002_dask_connection.py;  Configure a Dask connection and fill two histograms distributedly. ; ; distrdf003_live_visualization.py;  Configure a Dask connection and visualize the filling of a 1D and 2D histograms distributedly. ; ; distrdf004_dask_lxbatch.py; . tutorialsdataframe. ROOT master - Reference Guide Generated on Tue No",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:5653,Deployability,release,release,5653,"35_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.py;  Show how NanoAOD files can be processed with RDataFrame. ; ; df103_NanoAODHiggsAnalysis.C;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis.py;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis_python.h; Header file with functions needed to execute the Python version of the NanoAOD Higgs tutorial. ; ; df104_HiggsToTwoPhotons.py;  The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; ; df105_WBosonAnalysis.py;  The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.C;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.py;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df107_SingleTopAnalysis.py;  A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; ; distrdf001_spark_connection.py;  Configure a Spark connection and fill two histograms distributedly. ; ; distrdf002_dask_connection.py;  Configure a Dask connection and fill two histograms distributedly. ; ; distrdf003_live_visualization.py;  Configure a Dask connection and visualize the filling of a 1D and 2D histograms distributedly. ; ; distrdf004_dask_lxbatch.py; . tutorialsdataframe. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:5782,Deployability,release,release,5782,"35_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.py;  Show how NanoAOD files can be processed with RDataFrame. ; ; df103_NanoAODHiggsAnalysis.C;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis.py;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis_python.h; Header file with functions needed to execute the Python version of the NanoAOD Higgs tutorial. ; ; df104_HiggsToTwoPhotons.py;  The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; ; df105_WBosonAnalysis.py;  The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.C;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.py;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df107_SingleTopAnalysis.py;  A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; ; distrdf001_spark_connection.py;  Configure a Spark connection and fill two histograms distributedly. ; ; distrdf002_dask_connection.py;  Configure a Dask connection and fill two histograms distributedly. ; ; distrdf003_live_visualization.py;  Configure a Dask connection and visualize the filling of a 1D and 2D histograms distributedly. ; ; distrdf004_dask_lxbatch.py; . tutorialsdataframe. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:5912,Deployability,release,release,5912,"35_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.py;  Show how NanoAOD files can be processed with RDataFrame. ; ; df103_NanoAODHiggsAnalysis.C;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis.py;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis_python.h; Header file with functions needed to execute the Python version of the NanoAOD Higgs tutorial. ; ; df104_HiggsToTwoPhotons.py;  The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; ; df105_WBosonAnalysis.py;  The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.C;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.py;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df107_SingleTopAnalysis.py;  A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; ; distrdf001_spark_connection.py;  Configure a Spark connection and fill two histograms distributedly. ; ; distrdf002_dask_connection.py;  Configure a Dask connection and fill two histograms distributedly. ; ; distrdf003_live_visualization.py;  Configure a Dask connection and visualize the filling of a 1D and 2D histograms distributedly. ; ; distrdf004_dask_lxbatch.py; . tutorialsdataframe. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:6030,Deployability,release,release,6030,"35_RDFFromPandas.py;  Read data from Pandas Data Frame into RDataFrame. ; ; df036_missingBranches.C;  ; ; df036_missingBranches.py; ; df037_TTreeEventMatching.C;  ; ; df037_TTreeEventMatching.py; ; df101_h1Analysis.C;  Show how to express ROOT's standard H1 analysis with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.C;  Show how NanoAOD files can be processed with RDataFrame. ; ; df102_NanoAODDimuonAnalysis.py;  Show how NanoAOD files can be processed with RDataFrame. ; ; df103_NanoAODHiggsAnalysis.C;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis.py;  An example of complex analysis with RDataFrame: reconstructing the Higgs boson. ; ; df103_NanoAODHiggsAnalysis_python.h; Header file with functions needed to execute the Python version of the NanoAOD Higgs tutorial. ; ; df104_HiggsToTwoPhotons.py;  The Higgs to two photons analysis from the ATLAS Open Data 2020 release, with RDataFrame. ; ; df105_WBosonAnalysis.py;  The W boson mass analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.C;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df106_HiggsToFourLeptons.py;  The Higgs to four lepton analysis from the ATLAS Open Data release of 2020, with RDataFrame. ; ; df107_SingleTopAnalysis.py;  A single top analysis using the ATLAS Open Data release of 2020, with RDataFrame. ; ; distrdf001_spark_connection.py;  Configure a Spark connection and fill two histograms distributedly. ; ; distrdf002_dask_connection.py;  Configure a Dask connection and fill two histograms distributedly. ; ; distrdf003_live_visualization.py;  Configure a Dask connection and visualize the filling of a 1D and 2D histograms distributedly. ; ; distrdf004_dask_lxbatch.py; . tutorialsdataframe. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:171,Integrability,depend,dependency,171,". ROOT: tutorials/dataframe Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. dataframe Directory Reference. Directory dependency graph for dataframe:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; df000_simple.C;  Simple RDataFrame example in C++. ; ; df000_simple.py;  Simple RDataFrame example in Python. ; ; df001_introduction.C;  Basic RDataFrame usage. ; ; df001_introduction.py;  Basic usage of RDataFrame from python. ; ; df002_dataModel.C;  Show how to work with non-flat data models, e.g. ; ; df002_dataModel.py;  Show how to work with non-flat data models, e.g. ; ; df003_profiles.C;  Use TProfiles with RDataFrame. ; ; df003_profiles.py;  Use TProfiles with RDataFrame. ; ; df004_cutFlowReport.C;  Display cut/Filter efficiencies with RDataFrame. ; ; df004_cutFlowReport.py;  Display cut/Filter efficiencies with RDataFrame. ; ; df005_fillAnyObject.C;  Using the generic Fill action. ; ; df006_ranges.C;  Use Range to limit the amount of data processed. ; ; df006_ranges.py;  Use Range to limit the amount of data processed. ; ; df007_snapshot.C;  Write ROOT data with RDataFrame. ; ; df007_snapshot.py;  Write ROOT data with RDataFrame. ; ; df008_createDataSetFromScratch.C;  Create data from scratch with RDataFrame. ; ; df008_createDataSetFromScratch.py;  Create data from scratch with RDataFrame. ; ; df009_FromScratchVSTTree.C;  Compare creation of a ROOT dataset with RDataFrame and TTree. ; ; df010_trivialDataSource.C;  Use the ""trivial data source"", an example data source implementation. ; ; df010_trivialDataSource.py;  Use the ""trivial data source"", an example data source implementation. ; ; df012_DefinesAndFiltersAsStrings.C;  Use just-in-time-compiled Filters and Defines for quick prototyping. ; ; df012_DefinesAndFiltersAsStrings.py;  Use just-in-time-compiled Filters and Defines for quick prototyping. ; ;",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html:2067,Usability,progress bar,progress bar,2067,"limit the amount of data processed. ; ; df006_ranges.py;  Use Range to limit the amount of data processed. ; ; df007_snapshot.C;  Write ROOT data with RDataFrame. ; ; df007_snapshot.py;  Write ROOT data with RDataFrame. ; ; df008_createDataSetFromScratch.C;  Create data from scratch with RDataFrame. ; ; df008_createDataSetFromScratch.py;  Create data from scratch with RDataFrame. ; ; df009_FromScratchVSTTree.C;  Compare creation of a ROOT dataset with RDataFrame and TTree. ; ; df010_trivialDataSource.C;  Use the ""trivial data source"", an example data source implementation. ; ; df010_trivialDataSource.py;  Use the ""trivial data source"", an example data source implementation. ; ; df012_DefinesAndFiltersAsStrings.C;  Use just-in-time-compiled Filters and Defines for quick prototyping. ; ; df012_DefinesAndFiltersAsStrings.py;  Use just-in-time-compiled Filters and Defines for quick prototyping. ; ; df013_InspectAnalysis.C;  Use callbacks to update a plot and a progress bar during the event loop. ; ; df014_CSVDataSource.C;  Process a CSV file with RDataFrame and the CSV data source. ; ; df014_CSVDataSource.py;  Process a CSV file with RDataFrame and the CSV data source. ; ; df015_LazyDataSource.C;  Use the lazy RDataFrame data source to concatenate computation graphs. ; ; df016_vecOps.C;  Process collections in RDataFrame with the help of RVec. ; ; df016_vecOps.py;  Process collections in RDataFrame with the help of RVec. ; ; df017_vecOpsHEP.C;  Use RVecs to plot the transverse momentum of selected particles. ; ; df017_vecOpsHEP.py;  Use RVecs to plot the transverse momentum of selected particles. ; ; df018_customActions.C;  Implement a custom action to fill THns. ; ; df019_Cache.C;  Cache a processed RDataFrame in memory for further usage. ; ; df019_Cache.py;  Cache a processed RDataFrame in memory for further usage. ; ; df020_helpers.C;  Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelper",MatchSource.WIKI,doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b0d055c02f6056ea201bfa3ee242a7.html
https://root.cern/doc/master/dir_a1b91ffd476e3b26d4c2a148c14f4d99.html:159,Integrability,depend,dependency,159,". ROOT: core/cont/inc Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. inc Directory Reference. Directory dependency graph for inc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; ROOT; . Files; TArray.h; ; TArrayC.h; ; TArrayD.h; ; TArrayF.h; ; TArrayI.h; ; TArrayL.h; ; TArrayL64.h; ; TArrayS.h; ; TBits.h; ; TBtree.h; ; TClassTable.h; ; TClonesArray.h; ; TCollection.h; ; TCollectionProxyInfo.h; ; TExMap.h; ; THashList.h; ; THashTable.h; ; TIterator.h; ; TList.h; ; TMap.h; ; TObjArray.h; ; TObjectTable.h; ; TOrdCollection.h; ; TRefArray.h; ; TRefTable.h; ; TSeqCollection.h; ; TSortedList.h; ; TVirtualCollectionProxy.h; . corecontinc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a1b91ffd476e3b26d4c2a148c14f4d99.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a1b91ffd476e3b26d4c2a148c14f4d99.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:698,Availability,error,error,698,". ROOT: tutorials/fit Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; combinedFit.C;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; combinedFit.py;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Ex",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:765,Availability,error,errors,765,". ROOT: tutorials/fit Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; combinedFit.C;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; combinedFit.py;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Ex",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:1423,Availability,error,errors,1423,"stogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a histogram, a TGraph2D or a TMultiGraph ; ; fitLinear2.C;  Fit a 5d hyperplane by n points, using the linear fitter directly ; ; fitLinearRobust.C;  This tutorial shows how the least trimmed squares regression, included in the TLinearFitter class, can be used for fitting in cases when the data contains outliers",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:2562,Availability,error,errors,2562," Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a histogram, a TGraph2D or a TMultiGraph ; ; fitLinear2.C;  Fit a 5d hyperplane by n points, using the linear fitter directly ; ; fitLinearRobust.C;  This tutorial shows how the least trimmed squares regression, included in the TLinearFitter class, can be used for fitting in cases when the data contains outliers. ; ; fitMultiGraph.C;  fitting a parabola to a multigraph of 3 partly overlapping graphs with different errors ; ; fitNormSum.C;  Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ; ; fitNormSum.py;  Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ; ; fitpanel_playback.C; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; ; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:4150,Availability,error,errors,4150,"; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C;  Test generation of random numbers distributed according to a function defined by the user ; ; TestBinomial.C;  Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; ; TwoHistoFit2D.C;  Example to fit two histograms at the same time. ; ; vectorizedFit.C;  Tutorial for creating a Vectorized TF1 function using a f",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:4390,Availability,error,errors,4390,"d ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C;  Test generation of random numbers distributed according to a function defined by the user ; ; TestBinomial.C;  Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; ; TwoHistoFit2D.C;  Example to fit two histograms at the same time. ; ; vectorizedFit.C;  Tutorial for creating a Vectorized TF1 function using a formula expression and use it for fitting an histogram ; . tutorialsfit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:4855,Availability,error,errors,4855,"d ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C;  Test generation of random numbers distributed according to a function defined by the user ; ; TestBinomial.C;  Perform a fit to a set of data with binomial errors like those derived from the division of two histograms. ; ; TwoHistoFit2D.C;  Example to fit two histograms at the same time. ; ; vectorizedFit.C;  Tutorial for creating a Vectorized TF1 function using a formula expression and use it for fitting an histogram ; . tutorialsfit. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:3848,Deployability,configurat,configurations,3848,"an be set: ; ; fitpanel_playback.C; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; ; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C;  Test generation of random numbers distributed according to a function defined by the user ; ; TestBinomial.C;  Perform a fit to a set of data with binomial ",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:159,Integrability,depend,dependency,159,". ROOT: tutorials/fit Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; combinedFit.C;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; combinedFit.py;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Ex",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:938,Integrability,depend,depends,938,". ROOT: tutorials/fit Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; combinedFit.C;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; combinedFit.py;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Ex",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:951,Modifiability,variab,variables,951,". ROOT: tutorials/fit Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; combinedFit.C;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; combinedFit.py;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Ex",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:3848,Modifiability,config,configurations,3848,"an be set: ; ; fitpanel_playback.C; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; ; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C;  Test generation of random numbers distributed according to a function defined by the user ; ; TestBinomial.C;  Perform a fit to a set of data with binomial ",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:3668,Performance,perform,performance,3668,"Parameters can be set: ; ; fitNormSum.py;  Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ; ; fitpanel_playback.C; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; ; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C; ",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:928,Safety,predict,predictor,928,". ROOT: tutorials/fit Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fit Directory Reference. Directory dependency graph for fit:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; combinedFit.C;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; combinedFit.py;  Combined (simultaneous) fit of two histogram with separate functions and some common parameters ; ; ConfidenceIntervals.C;  Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ; ; ErrorIntegral.C;  Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; ; exampleFit3D.C;  example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; ; fit1.C;  Simple fitting example (1-d histogram with an interpreted function) ; ; fit2.C;  Fitting a 2-D histogram This tutorial illustrates : ; ; fit2a.C;  Fitting a 2-D histogram (a variant) This tutorial illustrates : ; ; fit2d.C;  Example illustrating how to fit a 2-d histogram of type y=f(x) ; ; fit2dHist.C;  Example to fit two histograms at the same time via the Fitter class. ; ; fitCircle.C;  Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; ; fitcont.C;  Example illustrating how to draw the n-sigma contour of a Minuit fit. ; ; fitConvolution.C;  Tutorial for convolution of two functions ; ; fitConvolution.py;  Tutorial for convolution of two functions ; ; fitEllipseTGraphDLSF.cxx; ; fitEllipseTGraphRMM.cxx; ; fitExclude.C;  Illustrates how to fit excluding points in a given range. ; ; fithist.C;  Example of fit where the model is histogram + function ; ; FitHistoInFile.C;  ; ; fitLinear.C;  Ex",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:2909,Testability,test,test,2909,"  ; ; fitLinear.C;  Example of fitting with a linear function, using TLinearFitter This example is for a TGraphErrors, but it can also be used when fitting a histogram, a TGraph2D or a TMultiGraph ; ; fitLinear2.C;  Fit a 5d hyperplane by n points, using the linear fitter directly ; ; fitLinearRobust.C;  This tutorial shows how the least trimmed squares regression, included in the TLinearFitter class, can be used for fitting in cases when the data contains outliers. ; ; fitMultiGraph.C;  fitting a parabola to a multigraph of 3 partly overlapping graphs with different errors ; ; fitNormSum.C;  Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ; ; fitNormSum.py;  Tutorial for normalized sum of two functions Here: a background exponential and a crystalball function Parameters can be set: ; ; fitpanel_playback.C; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; ; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting mu",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html:3783,Testability,benchmark,benchmark,3783,"ctions Here: a background exponential and a crystalball function Parameters can be set: ; ; fitpanel_playback.C; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; ; fitslicesy.C;  Illustrates how to use the TH1::FitSlicesY function It uses the TH2F histogram generated in macro hsimple.C It invokes FitSlicesY and draw the fitted ""mean"" and ""sigma"" in 2 sepate pads. ; ; FittingDemo.C;  Example for fitting signal/background. ; ; graph2dfit.C;  Fitting a TGraph2D ; ; Ifit.C;  Example of a program to fit non-equidistant data points ; ; langaus.C;  Convoluted Landau and Gaussian Fitting Function (using ROOT's Landau and Gauss functions) ; ; line3Dfit.C;  Fitting of a TGraph2D with a 3D straight line ; ; minuit2FitBench.C;  Demonstrate performance and usage of Minuit2 and Fumili2 for monodimensional fits. ; ; minuit2FitBench2D.C;  Minuit2 fit 2D benchmark. ; ; minuit2GausFit.C;  Perform fits with different configurations using Minuit2 ; ; multidimfit.C;  Multi-Dimensional Parametrisation and Fitting ; ; multifit.C;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; multifit.py;  Fitting multiple functions to different ranges of a 1-D histogram Example showing how to fit in a sub-range of an histogram A histogram is created and filled with the bin contents and errors defined in the table below. ; ; myfit.C;  Get in memory an histogram from a root file and fit a user defined function. ; ; NumericalMinimization.C;  Example on how to use the new Minimizer class in ROOT Show usage with all the possible minimizers. ; ; NumericalMinimization.py; ; qa2.C;  Test generation of random numbers distributed according to a function defined by t",MatchSource.WIKI,doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_a29432302a7afdbe7cd0744ed0070754.html
https://root.cern/doc/master/dir_ac6de6fe74d4e903f2b7ff14e6aeb864.html:168,Integrability,depend,dependency,168,". ROOT: core/foundation Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. foundation Directory Reference. Directory dependency graph for foundation:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; inc; ; res; ; src; ; v7; . corefoundation. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_ac6de6fe74d4e903f2b7ff14e6aeb864.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_ac6de6fe74d4e903f2b7ff14e6aeb864.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:161,Integrability,depend,dependency,161,". ROOT: tutorials/tmva Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tmva Directory Reference. Directory dependency graph for tmva:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; envelope; ; keras; ; pytorch; . Files; createData.C; Plot the variables. ; ; PyTorch_Generate_CNN_Model.py; ; RBatchGenerator_filters_vectors.py; ; RBatchGenerator_NumPy.py;  Example of getting batches of events from a ROOT dataset as Python generators of numpy arrays. ; ; RBatchGenerator_PyTorch.py;  Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; RBatchGenerator_TensorFlow.py;  Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered b",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1201,Integrability,interface,interfaces,1201,"rowser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; envelope; ; keras; ; pytorch; . Files; createData.C; Plot the variables. ; ; PyTorch_Generate_CNN_Model.py; ; RBatchGenerator_filters_vectors.py; ; RBatchGenerator_NumPy.py;  Example of getting batches of events from a ROOT dataset as Python generators of numpy arrays. ; ; RBatchGenerator_PyTorch.py;  Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; RBatchGenerator_TensorFlow.py;  Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; ; TMVA_CNN_Classification.C;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_CNN_Classification.py;  TMVA Classification Example Using a Convolutional ",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:357,Modifiability,variab,variables,357,". ROOT: tutorials/tmva Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tmva Directory Reference. Directory dependency graph for tmva:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; envelope; ; keras; ; pytorch; . Files; createData.C; Plot the variables. ; ; PyTorch_Generate_CNN_Model.py; ; RBatchGenerator_filters_vectors.py; ; RBatchGenerator_NumPy.py;  Example of getting batches of events from a ROOT dataset as Python generators of numpy arrays. ; ; RBatchGenerator_PyTorch.py;  Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; RBatchGenerator_TensorFlow.py;  Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered b",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1736,Testability,test,test,1736,"rom a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; ; TMVA_CNN_Classification.C;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_CNN_Classification.py;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_Higgs_Classification.C;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_Higgs_Classification.py;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_RNN_Classification.C;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_RNN_Classification.py;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_SOFIE_GNN.py; ; TMVA_SOFIE_GNN_Application.C; ; TMVA_SOFIE_GNN_Parser.py; ; TMVA_SOFIE_Inference.py;  This macro provides an example of using a tra",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5036,Testability,test,testing,5036,"cation.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ; ; TMVA_SOFIE_RDataFrame.py;  Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ; ; TMVA_SOFIE_RDataFrame_JIT.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_RSofieReader.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; ; TMVAClassification.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVAClassificationApplication.C;  This macro provides a simple example on how to use the trained classifiers within an analysis module ; ; TMVAClassificationCategory.C;  This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5299,Testability,test,testing,5299,"DataFrame, of a model trained with Keras. ; ; TMVA_SOFIE_RDataFrame_JIT.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_RSofieReader.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; ; TMVAClassification.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVAClassificationApplication.C;  This macro provides a simple example on how to use the trained classifiers within an analysis module ; ; TMVAClassificationCategory.C;  This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example fo",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6318,Testability,test,testing,6318,"rovides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVARegressionApplication.C;  This macro provides a simple example on how to use the trained regression MVAs within an analysis module ; . tutorialstmva. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6962,Testability,test,testing,6962,"rovides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVARegressionApplication.C;  This macro provides a simple example on how to use the trained regression MVAs within an analysis module ; . tutorialstmva. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1492,Usability,learn,learning,1492,"atchGenerator_NumPy.py;  Example of getting batches of events from a ROOT dataset as Python generators of numpy arrays. ; ; RBatchGenerator_PyTorch.py;  Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; RBatchGenerator_TensorFlow.py;  Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; ; TMVA_CNN_Classification.C;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_CNN_Classification.py;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_Higgs_Classification.C;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_Higgs_Classification.py;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_RNN_Classification.C;  T",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1586,Usability,learn,learning,1586,".py;  Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ; ; RBatchGenerator_TensorFlow.py;  Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; ; TMVA_CNN_Classification.C;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_CNN_Classification.py;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_Higgs_Classification.C;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_Higgs_Classification.py;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_RNN_Classification.C;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_RNN_Classification.py;  TMVA Classification Example Using a Recurrent Neural N",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:1848,Usability,learn,learn,1848,"rom a ROOT dataset into a basic TensorFlow workflow. ; ; tmva001_RTensor.C;  This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ; ; tmva002_RDataFrameAsTensor.C;  This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ; ; tmva003_RReader.C;  This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ; ; tmva004_RStandardScaler.C;  This tutorial illustrates the usage of the standard scaler as preprocessing method. ; ; tmva100_DataPreparation.py;  This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ; ; tmva101_Training.py;  This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ; ; tmva102_Testing.py;  This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ; ; tmva103_Application.C;  This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ; ; TMVA_CNN_Classification.C;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_CNN_Classification.py;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_Higgs_Classification.C;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_Higgs_Classification.py;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_RNN_Classification.C;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_RNN_Classification.py;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_SOFIE_GNN.py; ; TMVA_SOFIE_GNN_Application.C; ; TMVA_SOFIE_GNN_Parser.py; ; TMVA_SOFIE_Inference.py;  This macro provides an example of using a tra",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3035,Usability,simpl,simple,3035, TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_CNN_Classification.py;  TMVA Classification Example Using a Convolutional Neural Network ; ; TMVA_Higgs_Classification.C;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_Higgs_Classification.py;  Classification example of TMVA based on public Higgs UCI dataset ; ; TMVA_RNN_Classification.C;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_RNN_Classification.py;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_SOFIE_GNN.py; ; TMVA_SOFIE_GNN_Application.C; ; TMVA_SOFIE_GNN_Parser.py; ; TMVA_SOFIE_Inference.py;  This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_Keras.C;  This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_Keras_HiggsModel.C;  This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ; ; TMVA_SOFIE_Models.py;  Example of inference with SOFIE using a set of models trained with Keras. ; ; TMVA_SOFIE_ONNX.C;  This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_PyTorch.C;  This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_RDataFrame.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial ,MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3495,Usability,simpl,simple,3495,"lassification.py;  TMVA Classification Example Using a Recurrent Neural Network ; ; TMVA_SOFIE_GNN.py; ; TMVA_SOFIE_GNN_Application.C; ; TMVA_SOFIE_GNN_Parser.py; ; TMVA_SOFIE_Inference.py;  This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_Keras.C;  This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_Keras_HiggsModel.C;  This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ; ; TMVA_SOFIE_Models.py;  Example of inference with SOFIE using a set of models trained with Keras. ; ; TMVA_SOFIE_ONNX.C;  This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_PyTorch.C;  This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_RDataFrame.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ; ; TMVA_SOFIE_RDataFrame.py;  Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ; ; TMVA_SOFIE_RDataFrame_JIT.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras mode",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:3671,Usability,simpl,simple,3671,"IE_GNN_Parser.py; ; TMVA_SOFIE_Inference.py;  This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_Keras.C;  This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_Keras_HiggsModel.C;  This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ; ; TMVA_SOFIE_Models.py;  Example of inference with SOFIE using a set of models trained with Keras. ; ; TMVA_SOFIE_ONNX.C;  This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_PyTorch.C;  This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ; ; TMVA_SOFIE_RDataFrame.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model Then you need to run the macro TMVA_SOFIE_Keras_HiggsModel.C to generate the corresponding header file using SOFIE. ; ; TMVA_SOFIE_RDataFrame.py;  Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ; ; TMVA_SOFIE_RDataFrame_JIT.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_RSofieReader.C;  This macro pro",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5132,Usability,simpl,simple,5132,"o generate the corresponding header file using SOFIE. ; ; TMVA_SOFIE_RDataFrame.py;  Example of inference with SOFIE and RDataFrame, of a model trained with Keras. ; ; TMVA_SOFIE_RDataFrame_JIT.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_RSofieReader.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; ; TMVAClassification.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVAClassificationApplication.C;  This macro provides a simple example on how to use the trained classifiers within an analysis module ; ; TMVAClassificationCategory.C;  This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contain",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5426,Usability,simpl,simple,5426,E and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ; ; TMVA_SOFIE_RSofieReader.C;  This macro provides an example of using a trained model with Keras and make inference using SOFIE with the RSofieReader class This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before to generate the trained Keras model ; ; TMVAClassification.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVAClassificationApplication.C;  This macro provides a simple example on how to use the trained classifiers within an analysis module ; ; TMVAClassificationCategory.C;  This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass,MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:5960,Usability,simpl,simple,5960,"assification.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVAClassificationApplication.C;  This macro provides a simple example on how to use the trained classifiers within an analysis module ; ; TMVAClassificationCategory.C;  This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6073,Usability,simpl,simple,6073,"; TMVAClassificationApplication.C;  This macro provides a simple example on how to use the trained classifiers within an analysis module ; ; TMVAClassificationCategory.C;  This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVARegressionApplication.C;  This macro provides a simple example on",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6282,Usability,simpl,simple,6282,"rovides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVARegressionApplication.C;  This macro provides a simple example on how to use the trained regression MVAs within an analysis module ; . tutorialstmva. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:6423,Usability,simpl,simple,6423,"rovides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVARegressionApplication.C;  This macro provides a simple example on how to use the trained regression MVAs within an analysis module ; . tutorialstmva. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html:7054,Usability,simpl,simple,7054,"rovides examples for the training and testing of the TMVA classifiers in categorisation mode. ; ; TMVAClassificationCategoryApplication.C;  This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ; ; TMVACrossValidation.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVACrossValidationApplication.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ; ; TMVACrossValidationRegression.C;  This macro provides an example of how to use TMVA for k-folds cross evaluation. ; ; TMVAGAexample.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA ; ; TMVAGAexample2.C;  This executable gives an example of a very simple use of the genetic algorithm of TMVA. ; ; TMVAMinimalClassification.C;  Minimal self-contained example for setting up TMVA with binary classification. ; ; TMVAMulticlass.C;  This macro provides a simple example for the training and testing of the TMVA multiclass classification ; ; TMVAMulticlassApplication.C;  This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ; ; TMVAMultipleBackgroundExample.C;  This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ; ; TMVARegression.C;  This macro provides examples for the training and testing of the TMVA classifiers. ; ; TMVARegressionApplication.C;  This macro provides a simple example on how to use the trained regression MVAs within an analysis module ; . tutorialstmva. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_afb41fc0ce910d0ed999b271277cf431.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:6280,Availability,fault,faulty,6280,";  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; tprofile2polyRealistic.C;  Different charges depending on region ; ; tprofile2polyRealisticModuleError.C;  Simulate faulty detector panel w.r.t. ; ; transpad.C;  Example of a canvas showing two histograms with different scales. ; ; twoscales.C;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; twoscales.py;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; xyplot.C;  Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ; ; ZoomHistogram.C;  Changing the Range on the X-Axis of a Histogram ; . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:6198,Energy Efficiency,charge,charges,6198,";  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; tprofile2polyRealistic.C;  Different charges depending on region ; ; tprofile2polyRealisticModuleError.C;  Simulate faulty detector panel w.r.t. ; ; transpad.C;  Example of a canvas showing two histograms with different scales. ; ; twoscales.C;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; twoscales.py;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; xyplot.C;  Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ; ; ZoomHistogram.C;  Changing the Range on the X-Axis of a Histogram ; . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:161,Integrability,depend,dependency,161,". ROOT: tutorials/hist Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. hist Directory Reference. Directory dependency graph for hist:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; candledecay.C;  Candle Decay, illustrate a time development of a certain value. ; ; candlehisto.C;  Example showing how to combine the various candle plot options. ; ; candleplot.C;  Example of candle plot with 2-D histograms. ; ; candleplotoption.C;  Example showing how to combine the various candle plot options. ; ; candleplotstack.C;  Example showing how a THStack with candle plot option. ; ; candleplotwhiskers.C;  Example of candle plot showing the whiskers definition. ; ; candlescaled.C;  Candle Scaled, illustrates what scaling does on candle and violin charts. ; ; ContourList.C;  Getting Contours From TH2D. ; ; cumulative.C;  Illustrate use of the TH1::GetCumulative method. ; ; draw2dopt.C;  Display the various 2-d drawing options ; ; DynamicSlice.C;  Show the slice of a TH2 following the mouse position. ; ; exec1.C; Echo object at mouse position. ; ; exec2.C; Echo object at mouse position and show a graphics line. ; ; Fibonacci.C;  A TH2Poly build with Fibonacci numbers. ; ; fillhistosauto2p.C; Fill multiple histograms with different functions and automatic binning. ; ; fillrandom.C;  Fill a 1-D histogram from a parametric function. ; ; fillrandom.py;  Fill a 1-D histogram from a parametric function. ; ; FirstContour.C;  Make a contour plot and get the first contour in a TPolyMarker. ; ; h1ReadAndDraw.C;  Read a 1-D histogram from a ROOT File and draw it. ; ; h2_cut.C;  This example demonstrates how to display a 2D histogram and use TCutG object to select bins for drawing. ; ; h2proj.C;  This example demonstrates how to display a histogram and its two projections. ; ; hbars.C;  Example of bar charts with 1-d histograms. ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:6206,Integrability,depend,depending,6206,";  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; tprofile2polyRealistic.C;  Different charges depending on region ; ; tprofile2polyRealisticModuleError.C;  Simulate faulty detector panel w.r.t. ; ; transpad.C;  Example of a canvas showing two histograms with different scales. ; ; twoscales.C;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; twoscales.py;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; xyplot.C;  Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ; ; ZoomHistogram.C;  Changing the Range on the X-Axis of a Histogram ; . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:4902,Modifiability,variab,variable,4902,"for it. ; ; ratioplot3.py;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot4.C;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot4.py;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot5.C;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot5.py;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot6.C;  Example showing a fit residual plot, where the separation margin has been set to 0. ; ; ratioplot6.py;  Example showing a fit residual plot, where the separation margin has been set to 0. ; ; ratioplotOld.C; Example displaying two histograms and their ratio. ; ; rebin.C;  Rebin a variable bin-width histogram. ; ; reverseaxis.C;  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrate",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:5037,Performance,perform,performance,5037,"s custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot4.py;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot5.C;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot5.py;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot6.C;  Example showing a fit residual plot, where the separation margin has been set to 0. ; ; ratioplot6.py;  Example showing a fit residual plot, where the separation margin has been set to 0. ; ; ratioplotOld.C; Example displaying two histograms and their ratio. ; ; rebin.C;  Rebin a variable bin-width histogram. ; ; reverseaxis.C;  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Pa",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:6287,Safety,detect,detector,6287,";  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; tprofile2polyRealistic.C;  Different charges depending on region ; ; tprofile2polyRealisticModuleError.C;  Simulate faulty detector panel w.r.t. ; ; transpad.C;  Example of a canvas showing two histograms with different scales. ; ; twoscales.C;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; twoscales.py;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; xyplot.C;  Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ; ; ZoomHistogram.C;  Changing the Range on the X-Axis of a Histogram ; . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:5927,Security,access,accessible,5927,"stogram. ; ; reverseaxis.C;  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; tprofile2polyRealistic.C;  Different charges depending on region ; ; tprofile2polyRealisticModuleError.C;  Simulate faulty detector panel w.r.t. ; ; transpad.C;  Example of a canvas showing two histograms with different scales. ; ; twoscales.C;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; twoscales.py;  Example of macro illustrating how to superimpose two histograms with different scales in the ""same"" pad. ; ; xyplot.C;  Example showing how to produce a plot with an orthogonal axis system centered at (0,0). ; ; ZoomHistogram.C;  Changing the Range on the X-Axis of a Histogram ; . tutorialshist. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3123,Testability,log,logscales,3123," (Palette Line Color) and AMC (Palette Marker Color). ; ; hksimple.C;  Illustrates the advantages of a TH1K histogram ; ; hlabels1.C;  1-D histograms with alphanumeric labels ; ; hlabels2.C;  2-D histograms with alphanumeric labels. ; ; hlHisto1.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hlHisto2.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hlHisto3.C; This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ; ; hlHisto4.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hstack.C;  Example of stacked histograms: class THStack. ; ; hstackpads.C;  Drawing stack histograms on subpads. ; ; hsum.C;  Histograms filled and drawn in a loop. ; ; hsumTimer.C;  Demo of Timers. ; ; legendautoplaced.C;  The legend can be placed automatically in the current pad in an empty space found at painting time. ; ; logscales.C;  Draw parametric functions with log scales. ; ; movepalette.C;  When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ; ; multicolor.C;  Use a THStack to show a 2-D hist with cells with different colors. ; ; NormalizeHistogram.C;  Normalizing a Histogram ; ; ratioplot1.C;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot1.py;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot2.C;  Example of a fit residual plot. ; ; ratioplot2.py;  Example of a fit residual plot. ; ; ratioplot3.C;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot3.py;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot4.C;  Example that shows custom dashed lines on the lower plot, specifi",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3169,Testability,log,log,3169,"alette Marker Color). ; ; hksimple.C;  Illustrates the advantages of a TH1K histogram ; ; hlabels1.C;  1-D histograms with alphanumeric labels ; ; hlabels2.C;  2-D histograms with alphanumeric labels. ; ; hlHisto1.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hlHisto2.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hlHisto3.C; This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ; ; hlHisto4.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hstack.C;  Example of stacked histograms: class THStack. ; ; hstackpads.C;  Drawing stack histograms on subpads. ; ; hsum.C;  Histograms filled and drawn in a loop. ; ; hsumTimer.C;  Demo of Timers. ; ; legendautoplaced.C;  The legend can be placed automatically in the current pad in an empty space found at painting time. ; ; logscales.C;  Draw parametric functions with log scales. ; ; movepalette.C;  When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ; ; multicolor.C;  Use a THStack to show a 2-D hist with cells with different colors. ; ; NormalizeHistogram.C;  Normalizing a Histogram ; ; ratioplot1.C;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot1.py;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot2.C;  Example of a fit residual plot. ; ; ratioplot2.py;  Example of a fit residual plot. ; ; ratioplot3.C;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot3.py;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot4.C;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:5187,Testability,test,testSmooth,5187,"ows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot5.C;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot5.py;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot6.C;  Example showing a fit residual plot, where the separation margin has been set to 0. ; ; ratioplot6.py;  Example showing a fit residual plot, where the separation margin has been set to 0. ; ; ratioplotOld.C; Example displaying two histograms and their ratio. ; ; rebin.C;  Rebin a variable bin-width histogram. ; ; reverseaxis.C;  Example showing an histogram with reverse axis. ; ; sparsehist.C; Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ; ; statsEditing.C;  Edit statistics box. ; ; testSmooth.C;  Histogram smoothing. ; ; th2polyBoxes.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ; ; th2polyEurope.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ; ; th2polyHoneycomb.C;  This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ; ; th2polyUSA.C;  This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ; ; thstack2palettecolor.C;  Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ; ; thstackcolorscheme.C;  This example demonstrates how to use the accessible color schemes with THStack. ; ; thstackpalettecolor.C;  Palette coloring for histograms' stack is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color). ; ; tprofile2polyRealistic.C;  D",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3512,Usability,simpl,simple,3512,"mechanism can be used on an histogram. ; ; hlHisto3.C; This tutorial demonstrates how the highlight mechanism can be used on a ntuple. ; ; hlHisto4.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hstack.C;  Example of stacked histograms: class THStack. ; ; hstackpads.C;  Drawing stack histograms on subpads. ; ; hsum.C;  Histograms filled and drawn in a loop. ; ; hsumTimer.C;  Demo of Timers. ; ; legendautoplaced.C;  The legend can be placed automatically in the current pad in an empty space found at painting time. ; ; logscales.C;  Draw parametric functions with log scales. ; ; movepalette.C;  When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ; ; multicolor.C;  Use a THStack to show a 2-D hist with cells with different colors. ; ; NormalizeHistogram.C;  Normalizing a Histogram ; ; ratioplot1.C;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot1.py;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot2.C;  Example of a fit residual plot. ; ; ratioplot2.py;  Example of a fit residual plot. ; ; ratioplot3.C;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot3.py;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot4.C;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot4.py;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot5.C;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot5.py;  Example that shows how you can set the colors of the confidence interval bands by us",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:3622,Usability,simpl,simple,3622,"sm can be used on a ntuple. ; ; hlHisto4.C; This tutorial demonstrates how the highlight mechanism can be used on an histogram. ; ; hstack.C;  Example of stacked histograms: class THStack. ; ; hstackpads.C;  Drawing stack histograms on subpads. ; ; hsum.C;  Histograms filled and drawn in a loop. ; ; hsumTimer.C;  Demo of Timers. ; ; legendautoplaced.C;  The legend can be placed automatically in the current pad in an empty space found at painting time. ; ; logscales.C;  Draw parametric functions with log scales. ; ; movepalette.C;  When an histogram is drawn with the option COLZ, a palette is automatically drawn vertically on the right side of the plot. ; ; multicolor.C;  Use a THStack to show a 2-D hist with cells with different colors. ; ; NormalizeHistogram.C;  Normalizing a Histogram ; ; ratioplot1.C;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot1.py;  Example creating a simple ratio plot of two histograms using the pois division option. ; ; ratioplot2.C;  Example of a fit residual plot. ; ; ratioplot2.py;  Example of a fit residual plot. ; ; ratioplot3.C;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot3.py;  Example which shows how you can get the graph of the lower plot and set the y axis range for it. ; ; ratioplot4.C;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot4.py;  Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ; ; ratioplot5.C;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot5.py;  Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ; ; ratioplot6.C;  Example showing a fit residual ",MatchSource.WIKI,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html
https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:616,Availability,error,error,616,". ROOT: tutorials/pyroot Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. pyroot Directory Reference. Directory dependency graph for pyroot:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; demo.py; To run, do ""python <path-to>/demo.py"". ; ; demoshelp.py;  Display demo help. ; ; DynamicSlice.py;  Example of function called when a mouse event occurs in a pad. ; ; fit1.py;  Fit example. ; ; fit1_py.py; ; formula1.py;  TF1 example. ; ; geometry.py;  Geometry ; ; gerrors.py;  A Simple Graph with error bars ; ; graph.py;  A Simple Graph Example ; ; gui_ex.py; A Simple GUI Example. ; ; h1ReadAndDraw.py;  A Simple histogram drawing example ; ; hsimple.py;  This program creates : ; ; hsum.py;  Simple example illustrating how to use the C++ interpreter ; ; mrt.py;  Build ROOT Ntuple from other source. ; ; na49geomfile.py; Before executing this macro, the file makegeometry.C must have been executed. ; ; na49view.py; This macro generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyRO",MatchSource.WIKI,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html
https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:1380,Deployability,update,updated,1380,". ; ; demoshelp.py;  Display demo help. ; ; DynamicSlice.py;  Example of function called when a mouse event occurs in a pad. ; ; fit1.py;  Fit example. ; ; fit1_py.py; ; formula1.py;  TF1 example. ; ; geometry.py;  Geometry ; ; gerrors.py;  A Simple Graph with error bars ; ; graph.py;  A Simple Graph Example ; ; gui_ex.py; A Simple GUI Example. ; ; h1ReadAndDraw.py;  A Simple histogram drawing example ; ; hsimple.py;  This program creates : ; ; hsum.py;  Simple example illustrating how to use the C++ interpreter ; ; mrt.py;  Build ROOT Ntuple from other source. ; ; na49geomfile.py; Before executing this macro, the file makegeometry.C must have been executed. ; ; na49view.py; This macro generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ; ; pyroot004_NumbaDeclare.py;  This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; ; pyroot005_tfile_context_manager.",MatchSource.WIKI,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html
https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:165,Integrability,depend,dependency,165,". ROOT: tutorials/pyroot Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. pyroot Directory Reference. Directory dependency graph for pyroot:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; demo.py; To run, do ""python <path-to>/demo.py"". ; ; demoshelp.py;  Display demo help. ; ; DynamicSlice.py;  Example of function called when a mouse event occurs in a pad. ; ; fit1.py;  Fit example. ; ; fit1_py.py; ; formula1.py;  TF1 example. ; ; geometry.py;  Geometry ; ; gerrors.py;  A Simple Graph with error bars ; ; graph.py;  A Simple Graph Example ; ; gui_ex.py; A Simple GUI Example. ; ; h1ReadAndDraw.py;  A Simple histogram drawing example ; ; hsimple.py;  This program creates : ; ; hsum.py;  Simple example illustrating how to use the C++ interpreter ; ; mrt.py;  Build ROOT Ntuple from other source. ; ; na49geomfile.py; Before executing this macro, the file makegeometry.C must have been executed. ; ; na49view.py; This macro generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyRO",MatchSource.WIKI,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html
https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:1106,Safety,detect,detector,1106,". Loading...; Searching...; No Matches. pyroot Directory Reference. Directory dependency graph for pyroot:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Files; demo.py; To run, do ""python <path-to>/demo.py"". ; ; demoshelp.py;  Display demo help. ; ; DynamicSlice.py;  Example of function called when a mouse event occurs in a pad. ; ; fit1.py;  Fit example. ; ; fit1_py.py; ; formula1.py;  TF1 example. ; ; geometry.py;  Geometry ; ; gerrors.py;  A Simple Graph with error bars ; ; graph.py;  A Simple Graph Example ; ; gui_ex.py; A Simple GUI Example. ; ; h1ReadAndDraw.py;  A Simple histogram drawing example ; ; hsimple.py;  This program creates : ; ; hsum.py;  Simple example illustrating how to use the C++ interpreter ; ; mrt.py;  Build ROOT Ntuple from other source. ; ; na49geomfile.py; Before executing this macro, the file makegeometry.C must have been executed. ; ; na49view.py; This macro generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e",MatchSource.WIKI,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html
https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:2917,Testability,log,log,2917,"o generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ; ; pyroot004_NumbaDeclare.py;  This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; ; pyroot005_tfile_context_manager.py;  This tutorial demonstrates the usage of the TFile class as a Python context manager. ; ; pyroot006_tcontext_context_manager.py;  This tutorial demonstrates the usage of the TContext class as a Python context manager. ; ; ratioplot.py;  Display two histograms and their ratio. ; ; shapes.py;  Draw the geometry using the x3d viewver. ; ; staff.py;  example of macro to read data from an ascii file and create a root file with a Tree. ; ; surfaces.py;  Surfaces example ; ; tornado.py; Tornado example. ; ; zdemo.py;  This macro is an example of graphs in log scales with annotations. ; . tutorialspyroot. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html
https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html:2274,Usability,usab,usable,2274,"o generates two views of the NA49 detector. ; ; na49visible.py; Set visibility attributes for the NA49 geometry Set Shape attributes. ; ; ntuple1.py;  Ntuple drawing example. ; ; numberEntry.py; Example frame with one box where the user can increase or decrease a number and the shown value will be updated accordingly. ; ; parse_CSV_file_with_TTree_ReadStream.py; This function provides an example of how one might massage a csv data file to read into a ROOT TTree via TTree::ReadStream. ; ; pyroot001_arrayInterface.py;  This tutorial illustrates the conversion of STL vectors and TVec to numpy arrays without copying the data. ; ; pyroot002_pythonizationDecorator.py;  This tutorial shows how to use the @pythonization decorator to add extra behaviour to C++ user classes that are used from Python via PyROOT. ; ; pyroot003_prettyPrinting.py;  This tutorial illustrates the pretty printing feature of PyROOT, which reveals the content of the object if a string representation is requested, e.g., by Python's print statement. ; ; pyroot004_NumbaDeclare.py;  This tutorial illustrates how PyROOT supports declaring C++ callables from Python callables making them, for example, usable with RDataFrame. ; ; pyroot005_tfile_context_manager.py;  This tutorial demonstrates the usage of the TFile class as a Python context manager. ; ; pyroot006_tcontext_context_manager.py;  This tutorial demonstrates the usage of the TContext class as a Python context manager. ; ; ratioplot.py;  Display two histograms and their ratio. ; ; shapes.py;  Draw the geometry using the x3d viewver. ; ; staff.py;  example of macro to read data from an ascii file and create a root file with a Tree. ; ; surfaces.py;  Surfaces example ; ; tornado.py; Tornado example. ; ; zdemo.py;  This macro is an example of graphs in log scales with annotations. ; . tutorialspyroot. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_d39463c0be040a84eab8424485bc26d4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d39463c0be040a84eab8424485bc26d4.html
https://root.cern/doc/master/dir_d7ff98e99d8733492dd662d455f89a38.html:161,Integrability,depend,dependency,161,". ROOT: tutorials Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tutorials Directory Reference. Directory dependency graph for tutorials:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; cocoa; ; cont; ; dataframe; ; eve; ; eve7; ; fft; ; fit; ; fitsio; ; foam; ; geom; ; gl; ; graphics; ; graphs; ; gui; ; hist; ; histfactory; ; http; ; image; ; io; ; legacy; ; math; ; matrix; ; mc; ; multicore; ; net; ; physics; ; proof; ; pyroot; ; pythia; ; quadp; ; r; ; rcanvas; ; roofit; ; roostats; ; spectrum; ; splot; ; sql; ; tmva; ; tree; ; unfold; ; unuran; ; v7; ; vecops; ; webcanv; ; webgui; ; xml; . Files; .enableImplicitMTWrapper.py; ; .rootlogon.py; ; demos.C; This macro shows a control bar to run some of the ROOT tutorials. ; ; demoshelp.C; This macro shows help on running the Demos. ; ; hsimple.C;  This program creates : ; ; rootlogoff.C; Example of rootlogoff.C. ; ; rootlogon.C; Example of rootlogon.C. ; . tutorials. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_d7ff98e99d8733492dd662d455f89a38.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d7ff98e99d8733492dd662d455f89a38.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:1838,Deployability,install,installed,1838,".C; Example to write & read a Tree built with a complex class inheritance tree. ; ; clonesA_Event.cxx; ; clonesA_Event.h; ; copytree.C;  Copy a subset of a Tree to a new Tree ; ; copytree2.C;  Copy a subset of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.C;  TTreeReader simplest example. ; ; htest.C;  Save histograms in Tree branches ; ; hvector.C;  Write and read STL vectors in a tree. ; ; JetEvent.cxx; ; JetEvent.h; ; jets.C; Usage of a Tree using the JetEvent class. ; ; ntuple1.C;  Simple tree analysis. ; ; parallelcoord.C;  Script illustrating the use of the TParallelCoord class ; ; parallelcoordtrans.C;  Use of transparency with ||-Coord. ; ; printSizes.C;  This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ; ; run_h1analysis.C;  Macro driving the analysis can specify file name and type ; ; spider.C;  TSpider example. ; ; staff.C;  Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tu",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:1239,Energy Efficiency,efficient,efficient,1239,"pera instead. Directories; dictionary; . Files; basic.C;  Read data from an ascii file and create a root file with an histogram and an ntuple. ; ; basic2.C;  Create can ntuple reading data from an ascii file. ; ; bill.C;  Benchmark comparing row-wise and column-wise storage performance ; ; cernbuild.C;  Read data (CERN staff) from an ascii file and create a root file with a Tree. ; ; cernstaff.C;  Playing with a Tree containing variables of type character ; ; circular.C;  Example of a circular Tree ; ; clonesA_Event.C; Example to write & read a Tree built with a complex class inheritance tree. ; ; clonesA_Event.cxx; ; clonesA_Event.h; ; copytree.C;  Copy a subset of a Tree to a new Tree ; ; copytree2.C;  Copy a subset of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.C;  TTreeReader simplest example. ; ; htest.C;  Save histograms in Tree branches ; ; hvector.C;  Write and read STL vectors in a tree. ; ; JetEvent.cxx; ; JetEvent.h; ; jets.C; Usage of a Tree using the JetEvent class. ; ; ntuple1.C;  Simple ",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:161,Integrability,depend,dependency,161,". ROOT: tutorials/tree Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tree Directory Reference. Directory dependency graph for tree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; dictionary; . Files; basic.C;  Read data from an ascii file and create a root file with an histogram and an ntuple. ; ; basic2.C;  Create can ntuple reading data from an ascii file. ; ; bill.C;  Benchmark comparing row-wise and column-wise storage performance ; ; cernbuild.C;  Read data (CERN staff) from an ascii file and create a root file with a Tree. ; ; cernstaff.C;  Playing with a Tree containing variables of type character ; ; circular.C;  Example of a circular Tree ; ; clonesA_Event.C; Example to write & read a Tree built with a complex class inheritance tree. ; ; clonesA_Event.cxx; ; clonesA_Event.h; ; copytree.C;  Copy a subset of a Tree to a new Tree ; ; copytree2.C;  Copy a subset of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:708,Modifiability,variab,variables,708,". ROOT: tutorials/tree Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tree Directory Reference. Directory dependency graph for tree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; dictionary; . Files; basic.C;  Read data from an ascii file and create a root file with an histogram and an ntuple. ; ; basic2.C;  Create can ntuple reading data from an ascii file. ; ; bill.C;  Benchmark comparing row-wise and column-wise storage performance ; ; cernbuild.C;  Read data (CERN staff) from an ascii file and create a root file with a Tree. ; ; cernstaff.C;  Playing with a Tree containing variables of type character ; ; circular.C;  Example of a circular Tree ; ; clonesA_Event.C; Example to write & read a Tree built with a complex class inheritance tree. ; ; clonesA_Event.cxx; ; clonesA_Event.h; ; copytree.C;  Copy a subset of a Tree to a new Tree ; ; copytree2.C;  Copy a subset of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:865,Modifiability,inherit,inheritance,865,". ROOT: tutorials/tree Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tree Directory Reference. Directory dependency graph for tree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; dictionary; . Files; basic.C;  Read data from an ascii file and create a root file with an histogram and an ntuple. ; ; basic2.C;  Create can ntuple reading data from an ascii file. ; ; bill.C;  Benchmark comparing row-wise and column-wise storage performance ; ; cernbuild.C;  Read data (CERN staff) from an ascii file and create a root file with a Tree. ; ; cernstaff.C;  Playing with a Tree containing variables of type character ; ; circular.C;  Example of a circular Tree ; ; clonesA_Event.C; Example to write & read a Tree built with a complex class inheritance tree. ; ; clonesA_Event.cxx; ; clonesA_Event.h; ; copytree.C;  Copy a subset of a Tree to a new Tree ; ; copytree2.C;  Copy a subset of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:3227,Modifiability,variab,variables,3227,"the hsimpleProxy example. ; ; hsimpleReader.C;  TTreeReader simplest example. ; ; htest.C;  Save histograms in Tree branches ; ; hvector.C;  Write and read STL vectors in a tree. ; ; JetEvent.cxx; ; JetEvent.h; ; jets.C; Usage of a Tree using the JetEvent class. ; ; ntuple1.C;  Simple tree analysis. ; ; parallelcoord.C;  Script illustrating the use of the TParallelCoord class ; ; parallelcoordtrans.C;  Use of transparency with ||-Coord. ; ; printSizes.C;  This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ; ; run_h1analysis.C;  Macro driving the analysis can specify file name and type ; ; spider.C;  TSpider example. ; ; staff.C;  Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ; ; tcl.C;  How to write a TClonesArray to a TTree ; ; temperature.C; This tutorial illustrates how to use the highlight mode with trees. ; ; tree.C;  Display the Tree data structures ; ; tree0.C;  Simple Event class example ; ; tree1.C;  This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; ; tree2.C;  This example illustrates how to make a Tree from variables or arrays in a C struct - without a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; ; tree2a.C;  This example is the same as tree2.C, but uses a class instead of a C-struct. ; ; tree3.C;  Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel. ; ; tree4.C;  This example writes a tree with objects of the class Event. ; ; treefriend.C;  Illustrates how to use Tree friends: ; ; treegetval.C;  Illustrates how to retrieve TTree variables in arrays. ; ; tv3.C; ; tvdemo.C; . tutorialstree. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:3521,Modifiability,variab,variable,3521,"the hsimpleProxy example. ; ; hsimpleReader.C;  TTreeReader simplest example. ; ; htest.C;  Save histograms in Tree branches ; ; hvector.C;  Write and read STL vectors in a tree. ; ; JetEvent.cxx; ; JetEvent.h; ; jets.C; Usage of a Tree using the JetEvent class. ; ; ntuple1.C;  Simple tree analysis. ; ; parallelcoord.C;  Script illustrating the use of the TParallelCoord class ; ; parallelcoordtrans.C;  Use of transparency with ||-Coord. ; ; printSizes.C;  This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ; ; run_h1analysis.C;  Macro driving the analysis can specify file name and type ; ; spider.C;  TSpider example. ; ; staff.C;  Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ; ; tcl.C;  How to write a TClonesArray to a TTree ; ; temperature.C; This tutorial illustrates how to use the highlight mode with trees. ; ; tree.C;  Display the Tree data structures ; ; tree0.C;  Simple Event class example ; ; tree1.C;  This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; ; tree2.C;  This example illustrates how to make a Tree from variables or arrays in a C struct - without a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; ; tree2a.C;  This example is the same as tree2.C, but uses a class instead of a C-struct. ; ; tree3.C;  Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel. ; ; tree4.C;  This example writes a tree with objects of the class Event. ; ; treefriend.C;  Illustrates how to use Tree friends: ; ; treegetval.C;  Illustrates how to retrieve TTree variables in arrays. ; ; tv3.C; ; tvdemo.C; . tutorialstree. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:3785,Modifiability,variab,variables,3785,"the hsimpleProxy example. ; ; hsimpleReader.C;  TTreeReader simplest example. ; ; htest.C;  Save histograms in Tree branches ; ; hvector.C;  Write and read STL vectors in a tree. ; ; JetEvent.cxx; ; JetEvent.h; ; jets.C; Usage of a Tree using the JetEvent class. ; ; ntuple1.C;  Simple tree analysis. ; ; parallelcoord.C;  Script illustrating the use of the TParallelCoord class ; ; parallelcoordtrans.C;  Use of transparency with ||-Coord. ; ; printSizes.C;  This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ; ; run_h1analysis.C;  Macro driving the analysis can specify file name and type ; ; spider.C;  TSpider example. ; ; staff.C;  Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ; ; tcl.C;  How to write a TClonesArray to a TTree ; ; temperature.C; This tutorial illustrates how to use the highlight mode with trees. ; ; tree.C;  Display the Tree data structures ; ; tree0.C;  Simple Event class example ; ; tree1.C;  This example is a variant of hsimple.C but using a TTree instead of a TNtuple. ; ; tree2.C;  This example illustrates how to make a Tree from variables or arrays in a C struct - without a dictionary, by creating the branches for builtin types (int, float, double) and arrays explicitly. ; ; tree2a.C;  This example is the same as tree2.C, but uses a class instead of a C-struct. ; ; tree3.C;  Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel. ; ; tree4.C;  This example writes a tree with objects of the class Event. ; ; treefriend.C;  Illustrates how to use Tree friends: ; ; treegetval.C;  Illustrates how to retrieve TTree variables in arrays. ; ; tv3.C; ; tvdemo.C; . tutorialstree. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:51 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:545,Performance,perform,performance,545,". ROOT: tutorials/tree Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. tree Directory Reference. Directory dependency graph for tree:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; dictionary; . Files; basic.C;  Read data from an ascii file and create a root file with an histogram and an ntuple. ; ; basic2.C;  Create can ntuple reading data from an ascii file. ; ; bill.C;  Benchmark comparing row-wise and column-wise storage performance ; ; cernbuild.C;  Read data (CERN staff) from an ascii file and create a root file with a Tree. ; ; cernstaff.C;  Playing with a Tree containing variables of type character ; ; circular.C;  Example of a circular Tree ; ; clonesA_Event.C; Example to write & read a Tree built with a complex class inheritance tree. ; ; clonesA_Event.cxx; ; clonesA_Event.h; ; copytree.C;  Copy a subset of a Tree to a new Tree ; ; copytree2.C;  Copy a subset of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html:2018,Usability,simpl,simplest,2018,"t of a Tree to a new Tree, one branch in a separate file. ; ; copytree3.C;  Example of Root macro to copy a subset of a Tree to a new Tree, selecting entries. ; ; drawsparse.C;  Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; ; h1analysis.C;  Example of analysis class for the H1 data. ; ; h1analysis.h; ; h1analysisProxy.C; Example of analysis class for the H1 data using code generated by MakeProxy. ; ; h1analysisProxy.h; ; h1analysisProxyCut.C; ; h1analysisTreeReader.C; H1 analysis example expressed in terms of TTreeReader (see h1analysis.C). ; ; h1analysisTreeReader.h; ; h1chain.C;  Creates a TChain to be used by the h1analysis.C class the symbol H1 must point to a directory where the H1 data sets have been installed. ; ; hsimpleProxy.C;  Used by hsimpleProxyDriver.C. ; ; hsimpleProxyDriver.C;  This is the driver of the hsimpleProxy example. ; ; hsimpleReader.C;  TTreeReader simplest example. ; ; htest.C;  Save histograms in Tree branches ; ; hvector.C;  Write and read STL vectors in a tree. ; ; JetEvent.cxx; ; JetEvent.h; ; jets.C; Usage of a Tree using the JetEvent class. ; ; ntuple1.C;  Simple tree analysis. ; ; parallelcoord.C;  Script illustrating the use of the TParallelCoord class ; ; parallelcoordtrans.C;  Use of transparency with ||-Coord. ; ; printSizes.C;  This macro can be used to get aggregate information on the size take on disk or in memory by the various branches in a TTree. ; ; run_h1analysis.C;  Macro driving the analysis can specify file name and type ; ; spider.C;  TSpider example. ; ; staff.C;  Create a plot of the data in cernstaff.root To create cernstaff.root, execute tutorial $ROOTSYS/tutorials/tree/cernbuild.C ; ; tcl.C;  How to write a TClonesArray to a TTree ; ; temperature.C; This tutorial illustrates how to use the highlight mode with trees. ; ; tree.C;  Display the Tree data structur",MatchSource.WIKI,doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_d8553f50e1e7f7818badd4fd8ca54378.html
https://root.cern/doc/master/dir_dab74c5cdd3a71e5814fe91e0c8171fa.html:156,Integrability,depend,dependency,156,". ROOT: core/cont Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. cont Directory Reference. Directory dependency graph for cont:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; doc; ; inc; ; src; . corecont. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_dab74c5cdd3a71e5814fe91e0c8171fa.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_dab74c5cdd3a71e5814fe91e0c8171fa.html
https://root.cern/doc/master/dir_eb0888ddaad283ef2de2c9df75228bfd.html:165,Integrability,depend,dependency,165,". ROOT: core/foundation/inc Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. inc Directory Reference. Directory dependency graph for inc:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; ROOT; . Files; DllImport.h; ; ESTLType.h; ; RStringView.h; ; Rstrstream.h; ; RtypesCore.h; ; RVersion.h; ; TClassEdit.h; ; TError.h; ; ThreadLocalStorage.h; . corefoundationinc. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_eb0888ddaad283ef2de2c9df75228bfd.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_eb0888ddaad283ef2de2c9df75228bfd.html
https://root.cern/doc/master/dir_ed1accc5bc42b26d499c0c84b15b16d5.html:151,Integrability,depend,dependency,151,". ROOT: core Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. core Directory Reference. Directory dependency graph for core:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; base; ; clingutils; ; cont; ; dictgen; ; foundation; ; gui; ; imt; ; macosx; ; meta; ; metacling; ; multiproc; ; rint; ; testsupport; ; thread; ; unix; ; winnt; ; zip; . core. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_ed1accc5bc42b26d499c0c84b15b16d5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_ed1accc5bc42b26d499c0c84b15b16d5.html
https://root.cern/doc/master/dir_ed1accc5bc42b26d499c0c84b15b16d5.html:423,Testability,test,testsupport,423,". ROOT: core Directory Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. core Directory Reference. Directory dependency graph for core:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Directories; base; ; clingutils; ; cont; ; dictgen; ; foundation; ; gui; ; imt; ; macosx; ; meta; ; metacling; ; multiproc; ; rint; ; testsupport; ; thread; ; unix; ; winnt; ; zip; . core. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/dir_ed1accc5bc42b26d499c0c84b15b16d5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/dir_ed1accc5bc42b26d499c0c84b15b16d5.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1504,Availability,avail,available,1504,"tion parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); #",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1755,Availability,avail,availability,1755,"k RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.Set",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:460,Deployability,configurat,configuration,460,". ROOT: tutorials/dataframe/distrdf001_spark_connection.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; distrdf001_spark_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Spark connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Spark cluster, namely a SparkConf object holding configuration parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1004,Deployability,configurat,configuration,1004,". ROOT: tutorials/dataframe/distrdf001_spark_connection.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; distrdf001_spark_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Spark connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Spark cluster, namely a SparkConf object holding configuration parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1071,Deployability,configurat,configuration,1071,"rence. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; distrdf001_spark_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Spark connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Spark cluster, namely a SparkConf object holding configuration parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # ",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1857,Deployability,configurat,configuration,1857,"k RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.Set",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2086,Deployability,configurat,configuration,2086,"ame: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponen",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2204,Deployability,configurat,configuration,2204,"ble for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf00",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2283,Deployability,configurat,configuration,2283,"Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf001"", ""distrdf001"", 800, 400); c.Divide(2, 1); c.cd(1); h_gaus.DrawCopy(); c",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2502,Deployability,configurat,configuration,2502,"ble cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf001"", ""distrdf001"", 800, 400); c.Divide(2, 1); c.cd(1); h_gaus.DrawCopy(); c.cd(2); h_exp.DrawCopy(); ; # Save the canvas; c.SaveAs(""distrdf001_spark_connection.png""); print(""Saved figure to distrdf001_spark_connection.png""); . DateMarch 2021 ; AuthorVincenzo Eduardo Padulano ; Definition in file distrdf001_s",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:460,Modifiability,config,configuration,460,". ROOT: tutorials/dataframe/distrdf001_spark_connection.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; distrdf001_spark_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Spark connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Spark cluster, namely a SparkConf object holding configuration parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1004,Modifiability,config,configuration,1004,". ROOT: tutorials/dataframe/distrdf001_spark_connection.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; distrdf001_spark_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Spark connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Spark cluster, namely a SparkConf object holding configuration parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1071,Modifiability,config,configuration,1071,"rence. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; distrdf001_spark_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Spark connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Spark cluster, namely a SparkConf object holding configuration parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # ",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1857,Modifiability,config,configuration,1857,"k RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.Set",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2086,Modifiability,config,configuration,2086,"ame: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponen",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2204,Modifiability,config,configuration,2204,"ble for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf00",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2283,Modifiability,config,configuration,2283,"Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf001"", ""distrdf001"", 800, 400); c.Divide(2, 1); c.cd(1); h_gaus.DrawCopy(); c",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:2502,Modifiability,config,configuration,2502,"ble cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a backend for computations; df = RDataFrame(1000, sparkcontext=sparkcontext); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf001"", ""distrdf001"", 800, 400); c.Divide(2, 1); c.cd(1); h_gaus.DrawCopy(); c.cd(2); h_exp.DrawCopy(); ; # Save the canvas; c.SaveAs(""distrdf001_spark_connection.png""); print(""Saved figure to distrdf001_spark_connection.png""); . DateMarch 2021 ; AuthorVincenzo Eduardo Padulano ; Definition in file distrdf001_s",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1477,Performance,concurren,concurrent,1477,"tion parameters and a SparkContext object created with the desired options. After this initial setup, an RDataFrame with distributed capabilities is created and connected to the SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); #",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1581,Security,access,access,1581,"e SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a back",MatchSource.WIKI,doc/master/distrdf001__spark__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:2625,Availability,avail,available,2625,"rectly the object previously created. In case the cluster was setup; externally, you need to provide an endpoint URL to the client, e.g.; 'https://myscheduler.domain:8786'.; ; Through Dask, you can connect to various types of cluster resources. For; example, you can connect together a set of machines through SSH and use them; to run your computations. This is done through the `SSHCluster` class. For; example:; ; ```python; from dask.distributed import SSHCluster; cluster = SSHCluster(; # A list with machine host names, the first name will be used as; # scheduler, following names will become workers.; hosts=[""machine1"",""machine2"",""machine3""],; # A dictionary of options for each worker node, here we set the number; # of cores to be used on each node.; worker_options={""nprocs"":4,},; ); ```; ; Another common usecase is interfacing Dask to a batch system like HTCondor or; Slurm. A separate package called dask-jobqueue (https://jobqueue.dask.org); extends the available Dask cluster classes to enable running Dask computations; as batch jobs. In this case, the cluster object usually receives the parameters; that would be written in the job description file. For example:; ; ```python; from dask_jobqueue import HTCondorCluster; cluster = HTCondorCluster(; cores=1,; memory='2000MB',; disk='1000MB',; ); # Use the scale method to send as many jobs as needed; cluster.scale(4); ```; ; In this tutorial, a cluster object is created for the local machine, using; multiprocessing (processes=True) on 2 workers (n_workers=2) each using only; 1 core (threads_per_worker=1) and 2GiB of RAM (memory_limit=""2GiB"").; """"""; cluster = LocalCluster(n_workers=2, threads_per_worker=1, processes=True, memory_limit=""2GiB""); client = Client(cluster); return client; ; ; # This tutorial uses Python multiprocessing, so the creation of the cluster; # needs to be wrapped in the main clause as described in the Python docs; # https://docs.python.org/3/library/multiprocessing.html; if __name__ == ""__main__"":; ;",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:2216,Energy Efficiency,schedul,scheduler,2216,". To use; only the local machine (e.g. your laptop), a `LocalCluster` object can be; used. This step can be skipped if you have access to an existing Dask; cluster; in that case, the cluster administrator should provide you with a; URL to connect to the cluster in step 2. More options for cluster creation; can be found in the Dask docs at; http://distributed.dask.org/en/stable/api.html#cluster .; 2. Creating a Dask client object that connects to the cluster. This accepts; directly the object previously created. In case the cluster was setup; externally, you need to provide an endpoint URL to the client, e.g.; 'https://myscheduler.domain:8786'.; ; Through Dask, you can connect to various types of cluster resources. For; example, you can connect together a set of machines through SSH and use them; to run your computations. This is done through the `SSHCluster` class. For; example:; ; ```python; from dask.distributed import SSHCluster; cluster = SSHCluster(; # A list with machine host names, the first name will be used as; # scheduler, following names will become workers.; hosts=[""machine1"",""machine2"",""machine3""],; # A dictionary of options for each worker node, here we set the number; # of cores to be used on each node.; worker_options={""nprocs"":4,},; ); ```; ; Another common usecase is interfacing Dask to a batch system like HTCondor or; Slurm. A separate package called dask-jobqueue (https://jobqueue.dask.org); extends the available Dask cluster classes to enable running Dask computations; as batch jobs. In this case, the cluster object usually receives the parameters; that would be written in the job description file. For example:; ; ```python; from dask_jobqueue import HTCondorCluster; cluster = HTCondorCluster(; cores=1,; memory='2000MB',; disk='1000MB',; ); # Use the scale method to send as many jobs as needed; cluster.scale(4); ```; ; In this tutorial, a cluster object is created for the local machine, using; multiprocessing (processes=True) on 2 workers (n_work",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:1132,Integrability,depend,depending,1132,"...; No Matches. Namespaces ; distrdf002_dask_connection.py File ReferenceTutorials  Dataframe tutorials. Detailed Description; Configure a Dask connection and fill two histograms distributedly. ; This tutorial shows the ingredients needed to setup the connection to a Dask cluster (e.g. a LocalCluster for a single machine). After this initial setup, an RDataFrame with distributed capabilities is created and connected to a Dask Client instance. Finally, a couple of histograms are drawn from the created columns in the dataset. Relevant documentation can be found at http://distributed.dask.org/en/stable .; from dask.distributed import LocalCluster, Client; import ROOT; ; # Point RDataFrame calls to Dask RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; ; ; def create_connection():; """"""; Setup connection to a Dask cluster. Two ingredients are needed:; 1. Creating a cluster object that represents computing resources. This can be; done in various ways depending on the type of resources at disposal. To use; only the local machine (e.g. your laptop), a `LocalCluster` object can be; used. This step can be skipped if you have access to an existing Dask; cluster; in that case, the cluster administrator should provide you with a; URL to connect to the cluster in step 2. More options for cluster creation; can be found in the Dask docs at; http://distributed.dask.org/en/stable/api.html#cluster .; 2. Creating a Dask client object that connects to the cluster. This accepts; directly the object previously created. In case the cluster was setup; externally, you need to provide an endpoint URL to the client, e.g.; 'https://myscheduler.domain:8786'.; ; Through Dask, you can connect to various types of cluster resources. For; example, you can connect together a set of machines through SSH and use them; to run your computations. This is done through the `SSHCluster` class. For; example:; ; ```python; from dask.distributed import SSHCluster; cluster = SSH",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:3510,Integrability,wrap,wrapped,3510,"ons={""nprocs"":4,},; ); ```; ; Another common usecase is interfacing Dask to a batch system like HTCondor or; Slurm. A separate package called dask-jobqueue (https://jobqueue.dask.org); extends the available Dask cluster classes to enable running Dask computations; as batch jobs. In this case, the cluster object usually receives the parameters; that would be written in the job description file. For example:; ; ```python; from dask_jobqueue import HTCondorCluster; cluster = HTCondorCluster(; cores=1,; memory='2000MB',; disk='1000MB',; ); # Use the scale method to send as many jobs as needed; cluster.scale(4); ```; ; In this tutorial, a cluster object is created for the local machine, using; multiprocessing (processes=True) on 2 workers (n_workers=2) each using only; 1 core (threads_per_worker=1) and 2GiB of RAM (memory_limit=""2GiB"").; """"""; cluster = LocalCluster(n_workers=2, threads_per_worker=1, processes=True, memory_limit=""2GiB""); client = Client(cluster); return client; ; ; # This tutorial uses Python multiprocessing, so the creation of the cluster; # needs to be wrapped in the main clause as described in the Python docs; # https://docs.python.org/3/library/multiprocessing.html; if __name__ == ""__main__"":; ; # Create the connection to the mock Dask cluster on the local machine; connection = create_connection(); # Create an RDataFrame that will use Dask as a backend for computations; df = RDataFrame(1000, daskclient=connection); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf002"", ""distrdf002"", 800, 400); c.Divide(2, 1); c.cd(1); h_gaus.",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:2613,Modifiability,extend,extends,2613,"rectly the object previously created. In case the cluster was setup; externally, you need to provide an endpoint URL to the client, e.g.; 'https://myscheduler.domain:8786'.; ; Through Dask, you can connect to various types of cluster resources. For; example, you can connect together a set of machines through SSH and use them; to run your computations. This is done through the `SSHCluster` class. For; example:; ; ```python; from dask.distributed import SSHCluster; cluster = SSHCluster(; # A list with machine host names, the first name will be used as; # scheduler, following names will become workers.; hosts=[""machine1"",""machine2"",""machine3""],; # A dictionary of options for each worker node, here we set the number; # of cores to be used on each node.; worker_options={""nprocs"":4,},; ); ```; ; Another common usecase is interfacing Dask to a batch system like HTCondor or; Slurm. A separate package called dask-jobqueue (https://jobqueue.dask.org); extends the available Dask cluster classes to enable running Dask computations; as batch jobs. In this case, the cluster object usually receives the parameters; that would be written in the job description file. For example:; ; ```python; from dask_jobqueue import HTCondorCluster; cluster = HTCondorCluster(; cores=1,; memory='2000MB',; disk='1000MB',; ); # Use the scale method to send as many jobs as needed; cluster.scale(4); ```; ; In this tutorial, a cluster object is created for the local machine, using; multiprocessing (processes=True) on 2 workers (n_workers=2) each using only; 1 core (threads_per_worker=1) and 2GiB of RAM (memory_limit=""2GiB"").; """"""; cluster = LocalCluster(n_workers=2, threads_per_worker=1, processes=True, memory_limit=""2GiB""); client = Client(cluster); return client; ; ; # This tutorial uses Python multiprocessing, so the creation of the cluster; # needs to be wrapped in the main clause as described in the Python docs; # https://docs.python.org/3/library/multiprocessing.html; if __name__ == ""__main__"":; ;",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:1306,Security,access,access,1306," ingredients needed to setup the connection to a Dask cluster (e.g. a LocalCluster for a single machine). After this initial setup, an RDataFrame with distributed capabilities is created and connected to a Dask Client instance. Finally, a couple of histograms are drawn from the created columns in the dataset. Relevant documentation can be found at http://distributed.dask.org/en/stable .; from dask.distributed import LocalCluster, Client; import ROOT; ; # Point RDataFrame calls to Dask RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; ; ; def create_connection():; """"""; Setup connection to a Dask cluster. Two ingredients are needed:; 1. Creating a cluster object that represents computing resources. This can be; done in various ways depending on the type of resources at disposal. To use; only the local machine (e.g. your laptop), a `LocalCluster` object can be; used. This step can be skipped if you have access to an existing Dask; cluster; in that case, the cluster administrator should provide you with a; URL to connect to the cluster in step 2. More options for cluster creation; can be found in the Dask docs at; http://distributed.dask.org/en/stable/api.html#cluster .; 2. Creating a Dask client object that connects to the cluster. This accepts; directly the object previously created. In case the cluster was setup; externally, you need to provide an endpoint URL to the client, e.g.; 'https://myscheduler.domain:8786'.; ; Through Dask, you can connect to various types of cluster resources. For; example, you can connect together a set of machines through SSH and use them; to run your computations. This is done through the `SSHCluster` class. For; example:; ; ```python; from dask.distributed import SSHCluster; cluster = SSHCluster(; # A list with machine host names, the first name will be used as; # scheduler, following names will become workers.; hosts=[""machine1"",""machine2"",""machine3""],; # A dictionary of options for each worker node, her",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf002__dask__connection_8py.html:3689,Testability,mock,mock,3689,"en in the job description file. For example:; ; ```python; from dask_jobqueue import HTCondorCluster; cluster = HTCondorCluster(; cores=1,; memory='2000MB',; disk='1000MB',; ); # Use the scale method to send as many jobs as needed; cluster.scale(4); ```; ; In this tutorial, a cluster object is created for the local machine, using; multiprocessing (processes=True) on 2 workers (n_workers=2) each using only; 1 core (threads_per_worker=1) and 2GiB of RAM (memory_limit=""2GiB"").; """"""; cluster = LocalCluster(n_workers=2, threads_per_worker=1, processes=True, memory_limit=""2GiB""); client = Client(cluster); return client; ; ; # This tutorial uses Python multiprocessing, so the creation of the cluster; # needs to be wrapped in the main clause as described in the Python docs; # https://docs.python.org/3/library/multiprocessing.html; if __name__ == ""__main__"":; ; # Create the connection to the mock Dask cluster on the local machine; connection = create_connection(); # Create an RDataFrame that will use Dask as a backend for computations; df = RDataFrame(1000, daskclient=connection); ; # Set the random seed and define two columns of the dataset with random numbers.; ROOT.gRandom.SetSeed(1); df_1 = df.Define(""gaus"", ""gRandom->Gaus(10, 1)"").Define(""exponential"", ""gRandom->Exp(10)""); ; # Book an histogram for each column; h_gaus = df_1.Histo1D((""gaus"", ""Normal distribution"", 50, 0, 30), ""gaus""); h_exp = df_1.Histo1D((""exponential"", ""Exponential distribution"", 50, 0, 30), ""exponential""); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(""distrdf002"", ""distrdf002"", 800, 400); c.Divide(2, 1); c.cd(1); h_gaus.DrawCopy(); c.cd(2); h_exp.DrawCopy(); ; # Save the canvas; c.SaveAs(""distrdf002_dask_connection.png""); print(""Saved figure to distrdf002_dask_connection.png""); . DateFebruary 2022 ; AuthorVincenzo Eduardo Padulano ; Definition in file distrdf002_dask_connection.py. tutorialsdataframedistrdf002_dask_connection.py. ROOT master - Reference Guide Generated on Tue No",MatchSource.WIKI,doc/master/distrdf002__dask__connection_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf002__dask__connection_8py.html
https://root.cern/doc/master/distrdf003__live__visualization_8py.html:1566,Modifiability,variab,variable,1566,"ng up real-time data representation for distributed computations. By calling the LiveVisualize function, you can observe the canvas updating with the intermediate results of the histograms as the distributed computation progresses.; from dask.distributed import LocalCluster, Client; import ROOT; ; # Import the live visualization function; LiveVisualize = ROOT.RDF.Experimental.Distributed.LiveVisualize; ; # Point RDataFrame calls to Dask RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; ; # Function to create a Dask cluster and return the client; def create_connection():; cluster = LocalCluster(n_workers=4, threads_per_worker=1, processes=True, memory_limit=""2GiB""); client = Client(cluster); return client; ; # Function to fit a Gaussian function to the plot; def fit_gaus(plot):; plot.Fit(""gaus""); ; if __name__ == ""__main__"":; # Setup connection to a Dask cluster; connection = create_connection(); ; # Create an RDataFrame that will use Dask as a backend for computations; num_entries = 100000000; d = RDataFrame(num_entries, daskclient=connection, npartitions=30); ; # Define a gaussean distribution with a variable mean; dd = d.Define(""x"", f""gRandom->Gaus(10*rdfentry_/{num_entries}, 2)"")\; .Define(""y"", f""gRandom->Gaus(10*rdfentry_/{num_entries}, 3)"")\; ; # Create a 1D and a 2D histogram using the defined columns; h_normal_1d = dd.Histo1D((""normal_1d"", ""1D Histogram of a Normal Distribution"",; 100, -10, 20),; ""x""); ; h_normal_2d = dd.Histo2D((""normal_2d"", ""2D Histogram of a Normal Distribution"",; 100, -15, 25, ; 100, -15, 25; ), ""x"", ""y""); ; # Apply LiveVisualize to the histograms. ; # The `fit_gaus` function will be applied to the accumulating partial result ; # of the 1D histogram. The 2D histogram will not be further modified, just drawn. ; # Find more details about usage of LiveVisualize in the RDataFrame docs.; LiveVisualize({h_normal_1d: fit_gaus, h_normal_2d: None}); ; # Plot the histograms side by side on a canvas; c = ROOT.TCanvas(",MatchSource.WIKI,doc/master/distrdf003__live__visualization_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/distrdf003__live__visualization_8py.html
https://root.cern/doc/master/DNN_2DataLoader_8h_source.html:6783,Integrability,rout,routine,6783,"input matrix into the given host buffer. Function to be specialized by; 161 * the architecture-specific backend. */; 162 void CopyInput(HostBuffer_t &buffer, IndexIterator_t begin, size_t batchSize);; 163 /** Copy output matrix into the given host buffer. Function to be specialized; 164 * by the architecture-specific backend. */; 165 void CopyOutput(HostBuffer_t &buffer, IndexIterator_t begin, size_t batchSize);; 166 /** Copy weight matrix into the given host buffer. Function to be specialized; 167 * by the architecture-specific backend. */; 168 void CopyWeights(HostBuffer_t &buffer, IndexIterator_t begin, size_t batchSize);; 169 ; 170 BatchIterator_t begin() {return TBatchIterator<Data_t, AArchitecture>(*this);}; 171 BatchIterator_t end(); 172 {; 173 return TBatchIterator<Data_t, AArchitecture>(*this, fNSamples / fBatchSize);; 174 }; 175 ; 176 /** Shuffle the order of the samples in the batch. The shuffling is indirect,; 177 * i.e. only the indices are shuffled. No input data is moved by this; 178 * routine. */; 179 void Shuffle();; 180 ; 181 /** Return the next batch from the training set. The TDataLoader object; 182 * keeps an internal counter that cycles over the batches in the training; 183 * set. */; 184 TBatch<AArchitecture> GetBatch();; 185 ; 186};; 187 ; 188//; 189// TBatch Class.; 190//______________________________________________________________________________; 191template <typename AArchitecture>; 192TBatch<AArchitecture>::TBatch(Matrix_t &inputMatrix, Matrix_t &outputMatrix, Matrix_t &weightMatrix); 193 : fInputMatrix(inputMatrix), fOutputMatrix(outputMatrix), fWeightMatrix(weightMatrix); 194{; 195 // Nothing to do here.; 196}; 197 ; 198//; 199// TDataLoader Class.; 200//______________________________________________________________________________; 201template<typename Data_t, typename AArchitecture>; 202TDataLoader<Data_t, AArchitecture>::TDataLoader(; 203 const Data_t & data, size_t nSamples, size_t batchSize,; 204 size_t nInputFeatures, size_t nOut",MatchSource.WIKI,doc/master/DNN_2DataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DNN_2DataLoader_8h_source.html
https://root.cern/doc/master/DNN_2DataLoader_8h_source.html:16623,Modifiability,variab,variable,16623,"fDeviceBuffersDefinition DataLoader.h:146; TMVA::DNN::TDataLoader::operator=TDataLoader & operator=(const TDataLoader &)=default; TMVA::DNN::TDataLoader::Matrix_ttypename AArchitecture::Matrix_t Matrix_tDefinition DataLoader.h:134; TMVA::DNN::TDataLoader::fNStreamssize_t fNStreamsNumber of buffer pairs.Definition DataLoader.h:145; TMVA::DNN::TDataLoader::TDataLoaderTDataLoader(const Data_t &data, size_t nSamples, size_t batchSize, size_t nInputFeatures, size_t nOutputFeatures, size_t nStreams=1)Definition DataLoader.h:202; TMVA::DNN::TDataLoader::fBatchIndexsize_t fBatchIndexDefinition DataLoader.h:143; TMVA::DNN::TDataLoader::fBatchSizesize_t fBatchSizeDefinition DataLoader.h:140; TMVA::DNN::TDataLoader::HostBuffer_ttypename AArchitecture::HostBuffer_t HostBuffer_tDefinition DataLoader.h:132; TMVA::DNN::TDataLoader::Shufflevoid Shuffle()Shuffle the order of the samples in the batch.Definition DataLoader.h:269; TMVA::DNN::TDataLoader::fNOutputFeaturessize_t fNOutputFeaturesDefinition DataLoader.h:142; TMVA::DNN::TDataLoader::CopyWeightsvoid CopyWeights(HostBuffer_t &buffer, IndexIterator_t begin, size_t batchSize)Copy weight matrix into the given host buffer.; TMVA::DNN::TDataLoader::TDataLoaderTDataLoader(const TDataLoader &)=default; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMatrixTTMatrixT.Definition TMatrixT.h:40; TMVA::DNN::IndexIterator_ttypename std::vector< size_t >::iterator IndexIterator_tDefinition DataLoader.h:42; TMVA::DNN::TMVAInput_tstd::tuple< const std::vector< Event * > &, const DataSetInfo & > TMVAInput_tDefinition DataLoader.h:40; TMVA::DNN::MatrixInput_tstd::tuple< const TMatrixT< Double_t > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & > MatrixInput_tDefinition DataLoader.h:38; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22. tmvatmvaincTMVADNNDataLoader.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:57 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/DNN_2DataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DNN_2DataLoader_8h_source.html
https://root.cern/doc/master/DNN_2DataLoader_8h_source.html:719,Performance,load,loader,719,". ROOT: tmva/tmva/inc/TMVA/DNN/DataLoader.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. DataLoader.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Simon Pfreundschuh 08/08/16; 3 ; 4/*************************************************************************; 5 * Copyright (C) 2016, Simon Pfreundschuh *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/////////////////////////////////////////////////////////////////////; 13// Generic data loader for neural network input data. Provides a //; 14// high level abstraction for the transfer of training data to the //; 15// device. //; 16/////////////////////////////////////////////////////////////////////; 17 ; 18#ifndef TMVA_DNN_DATALOADER; 19#define TMVA_DNN_DATALOADER; 20 ; 21#include ""TMatrix.h""; 22#include ""TMVA/Event.h""; 23 ; 24#include <algorithm>; 25#include <random>; 26#include <vector>; 27#include <utility>; 28 ; 29namespace TMVA {; 30 ; 31class DataSetInfo;; 32 ; 33namespace DNN {; 34 ; 35//; 36// Input Data Types; 37//______________________________________________________________________________; 38using MatrixInput_t = std::tuple<const TMatrixT<Double_t> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 39using TMVAInput_t =; 40 std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 41 ; 42using IndexIterator_t = typename std::vector<size_t>::iterator;; 43 ; 44/** TBatch; 45 *; 46 * Class representing training batches consisting of a matrix of input data; 47 * and a matrix of output data. The input and output data can be accessed using; 48 * the GetInput() and GetOutput() member functions.; 49 *; 50 * \tparam AArchitecture The underlying architecture.; 51 */; 52//_________________________________________________________",MatchSource.WIKI,doc/master/DNN_2DataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DNN_2DataLoader_8h_source.html
https://root.cern/doc/master/DNN_2DataLoader_8h_source.html:1799,Security,access,accessed,1799," of training data to the //; 15// device. //; 16/////////////////////////////////////////////////////////////////////; 17 ; 18#ifndef TMVA_DNN_DATALOADER; 19#define TMVA_DNN_DATALOADER; 20 ; 21#include ""TMatrix.h""; 22#include ""TMVA/Event.h""; 23 ; 24#include <algorithm>; 25#include <random>; 26#include <vector>; 27#include <utility>; 28 ; 29namespace TMVA {; 30 ; 31class DataSetInfo;; 32 ; 33namespace DNN {; 34 ; 35//; 36// Input Data Types; 37//______________________________________________________________________________; 38using MatrixInput_t = std::tuple<const TMatrixT<Double_t> &, const TMatrixT<Double_t> &, const TMatrixT<Double_t> &>;; 39using TMVAInput_t =; 40 std::tuple<const std::vector<Event *> &, const DataSetInfo &>;; 41 ; 42using IndexIterator_t = typename std::vector<size_t>::iterator;; 43 ; 44/** TBatch; 45 *; 46 * Class representing training batches consisting of a matrix of input data; 47 * and a matrix of output data. The input and output data can be accessed using; 48 * the GetInput() and GetOutput() member functions.; 49 *; 50 * \tparam AArchitecture The underlying architecture.; 51 */; 52//______________________________________________________________________________; 53template <typename AArchitecture>; 54class TBatch; 55{; 56private:; 57 ; 58 using Matrix_t = typename AArchitecture::Matrix_t;; 59 ; 60 Matrix_t fInputMatrix;; 61 Matrix_t fOutputMatrix;; 62 Matrix_t fWeightMatrix;; 63 ; 64public:; 65 TBatch(Matrix_t &, Matrix_t &, Matrix_t &);; 66 TBatch(const TBatch &) = default;; 67 TBatch( TBatch &&) = default;; 68 TBatch & operator=(const TBatch &) = default;; 69 TBatch & operator=( TBatch &&) = default;; 70 ; 71 /** Return the matrix representing the input data. */; 72 Matrix_t &GetInput() { return fInputMatrix; }; 73 /** Return the matrix representing the output data. */; 74 Matrix_t &GetOutput() { return fOutputMatrix; }; 75 /** Return the matrix holding the event weights. */; 76 Matrix_t &GetWeights() { return fWeightMatrix; }; 77};; 78 ;",MatchSource.WIKI,doc/master/DNN_2DataLoader_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DNN_2DataLoader_8h_source.html
https://root.cern/doc/master/double32_8C.html:446,Integrability,depend,depending,446,". ROOT: tutorials/io/double32.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. double32.C File ReferenceTutorials  IO tutorials. Detailed Description; Tutorial illustrating use and precision of the Double32_t data type You should run this tutorial with ACLIC: a dictionary will be automatically created. ; root > .x double32.C+; The following cases are supported for streaming a Double32_t type depending on the range declaration in the comment field of the data member:. Case Declaration . A Double32_t fNormal; . B Double32_t fTemperature; //[0,100] . C Double32_t fCharge; //[-1,1,2] . D Double32_t fVertex[3]; //[-30,30,10] . E Double32_t fChi2; //[0,0,6] . F Int_t fNsp;; Double32_t* fPointValue; //[fNsp][0,3] . Case A fNormal is converted from a Double_t to a Float_t; Case B fTemperature is converted to a 32 bit unsigned integer; Case C fCharge is converted to a 2 bits unsigned integer; Case D the array elements of fVertex are converted to an unsigned 10 bits integer; Case E fChi2 is converted to a Float_t with truncated precision at 6 bits; Case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer. Note that the range specifier must follow the dimension specifier. Case B has more precision than case A: 9 to 10 significative digits and 6 to 7 digits respectively. The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]. Examples; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8] Note that:; If nbits is not specified, or nbits <2 or nbits>32 it is set to 32; If (xmin==0 and xmax==0 and nbits <=14) the double word will be converted to a float and its mantissa truncated to nbits significative bits. IMPORTANT NOTE; Lets assume an original variable double x. When using the format [0,0,8] (i.e. range not specified) you get the best relative precision when storing and reading back the truncated x, say xt. The variance of (x-xt)/x will be better than",MatchSource.WIKI,doc/master/double32_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/double32_8C.html
https://root.cern/doc/master/double32_8C.html:1790,Modifiability,variab,variable,1790,"ormal is converted from a Double_t to a Float_t; Case B fTemperature is converted to a 32 bit unsigned integer; Case C fCharge is converted to a 2 bits unsigned integer; Case D the array elements of fVertex are converted to an unsigned 10 bits integer; Case E fChi2 is converted to a Float_t with truncated precision at 6 bits; Case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer. Note that the range specifier must follow the dimension specifier. Case B has more precision than case A: 9 to 10 significative digits and 6 to 7 digits respectively. The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]. Examples; [0,1]; [-10,100];; [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; [-10,100,16]; [0,0,8] Note that:; If nbits is not specified, or nbits <2 or nbits>32 it is set to 32; If (xmin==0 and xmax==0 and nbits <=14) the double word will be converted to a float and its mantissa truncated to nbits significative bits. IMPORTANT NOTE; Lets assume an original variable double x. When using the format [0,0,8] (i.e. range not specified) you get the best relative precision when storing and reading back the truncated x, say xt. The variance of (x-xt)/x will be better than when specifying a range for the same number of bits. However the precision relative to the range (x-xt)/(xmax-xmin) will be worse, and vice-versa. The format [0,0,8] is also interesting when the range of x is infinite or unknown. ; #include ""ROOT/TSeq.hxx""; #include ""TCanvas.h""; #include ""TFile.h""; #include ""TGraph.h""; #include ""TH1.h""; #include ""TLegend.h""; #include ""TMath.h""; #include ""TRandom3.h""; #include ""TTree.h""; ; class DemoDouble32 {; private:; Double_t fD64; // reference member with full double precision; Double32_t fF32; // saved as a 32 bit Float_t; Double32_t fI32; //[-pi,pi] saved as a 32 bit unsigned int; Double32_t fI30; //[-pi,pi,30] saved as a 30 bit unsigned int; Double32_t fI28; //[-pi,pi,28] saved as a 28 bit unsigned int; Double32_t fI26; //[-pi",MatchSource.WIKI,doc/master/double32_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/double32_8C.html
https://root.cern/doc/master/double32_8C.html:10375,Testability,log,logarithm,10375," zip bytes in the branch if option =""*"" includes all sub-branches of this branc...Definition TBranch.cxx:2238; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; c1return c1Definition legend1.C:41; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::TSeqITSeq< int > TSeqIDefinition TSeq.hxx:203; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; TMath::RMSDouble_t RMS(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the Standard Deviation of an array a with length n.Definition TMath.h:1188; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; AuthorRene Brun ; Definition in file double32.C. tutorialsiodouble32.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/double32_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/double32_8C.html
https://root.cern/doc/master/double32_8C_source.html:540,Integrability,depend,depending,540,". ROOT: tutorials/io/double32.C Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. double32.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_io; 3/// \notebook -js; 4/// Tutorial illustrating use and precision of the Double32_t data type; 5/// You should run this tutorial with ACLIC: a dictionary will be automatically; 6/// created.; 7/// ~~~{.bash}; 8/// root > .x double32.C+; 9/// ~~~; 10/// The following cases are supported for streaming a Double32_t type; 11/// depending on the range declaration in the comment field of the data member:; 12///; 13/// Case | Declaration; 14/// -----|------------; 15/// A | Double32_t fNormal;; 16/// B | Double32_t fTemperature; //[0,100]; 17/// C | Double32_t fCharge; //[-1,1,2]; 18/// D | Double32_t fVertex[3]; //[-30,30,10]; 19/// E | Double32_t fChi2; //[0,0,6]; 20/// F | Int_t fNsp;<br>Double32_t* fPointValue; //[fNsp][0,3]; 21///; 22/// * Case A fNormal is converted from a Double_t to a Float_t; 23/// * Case B fTemperature is converted to a 32 bit unsigned integer; 24/// * Case C fCharge is converted to a 2 bits unsigned integer; 25/// * Case D the array elements of fVertex are converted to an unsigned 10 bits integer; 26/// * Case E fChi2 is converted to a Float_t with truncated precision at 6 bits; 27/// * Case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer. Note that the range specifier must follow the dimension specifier.; 28///; 29/// Case B has more precision than case A: 9 to 10 significative digits and 6 to 7 digits respectively.; 30/// The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]. Examples; 31/// * [0,1]; 32/// * [-10,100];; 33/// * [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; 34/// * [-10,100,16]; 35/// * [0,0,8]; 36/// Note that:; 37/// * If nbits is not specified, or nbits <2 or nbits>32 it is set to 32; 38/// * If (xmin==0 and xmax==0 and nbits <=14) the double word will be converted t",MatchSource.WIKI,doc/master/double32_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/double32_8C_source.html
https://root.cern/doc/master/double32_8C_source.html:2130,Modifiability,variab,variable,2130,"Charge is converted to a 2 bits unsigned integer; 25/// * Case D the array elements of fVertex are converted to an unsigned 10 bits integer; 26/// * Case E fChi2 is converted to a Float_t with truncated precision at 6 bits; 27/// * Case F the fNsp elements of array fPointvalue are converted to an unsigned 32 bit integer. Note that the range specifier must follow the dimension specifier.; 28///; 29/// Case B has more precision than case A: 9 to 10 significative digits and 6 to 7 digits respectively.; 30/// The range specifier has the general format: [xmin,xmax] or [xmin,xmax,nbits]. Examples; 31/// * [0,1]; 32/// * [-10,100];; 33/// * [-pi,pi], [-pi/2,pi/4],[-2pi,2*pi]; 34/// * [-10,100,16]; 35/// * [0,0,8]; 36/// Note that:; 37/// * If nbits is not specified, or nbits <2 or nbits>32 it is set to 32; 38/// * If (xmin==0 and xmax==0 and nbits <=14) the double word will be converted to a float and its mantissa truncated to nbits significative bits.; 39///; 40/// ## IMPORTANT NOTE; 41/// Lets assume an original variable double x.; 42/// When using the format [0,0,8] (i.e. range not specified) you get the best; 43/// relative precision when storing and reading back the truncated x, say xt.; 44/// The variance of (x-xt)/x will be better than when specifying a range; 45/// for the same number of bits. However the precision relative to the; 46/// range (x-xt)/(xmax-xmin) will be worse, and vice-versa.; 47/// The format [0,0,8] is also interesting when the range of x is infinite; 48/// or unknown.; 49///; 50/// \macro_image; 51/// \macro_code; 52///; 53/// \author Rene Brun; 54 ; 55#include ""ROOT/TSeq.hxx""; 56#include ""TCanvas.h""; 57#include ""TFile.h""; 58#include ""TGraph.h""; 59#include ""TH1.h""; 60#include ""TLegend.h""; 61#include ""TMath.h""; 62#include ""TRandom3.h""; 63#include ""TTree.h""; 64 ; 65class DemoDouble32 {; 66private:; 67 Double_t fD64; // reference member with full double precision; 68 Double32_t fF32; // saved as a 32 bit Float_t; 69 Double32_t fI32; //[-pi,pi] save",MatchSource.WIKI,doc/master/double32_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/double32_8C_source.html
https://root.cern/doc/master/double32_8C_source.html:11337,Testability,log,logarithm,11337,"(Option_t *option="""") constReturn total number of zip bytes in the branch if option =""*"" includes all sub-branches of this branc...Definition TBranch.cxx:2238; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; c1return c1Definition legend1.C:41; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::TSeqITSeq< int > TSeqIDefinition TSeq.hxx:203; TMVA_SOFIE_GNN_Parser.treetreeDefinition TMVA_SOFIE_GNN_Parser.py:169; TMath::RMSDouble_t RMS(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the Standard Deviation of an array a with length n.Definition TMath.h:1188; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762. tutorialsiodouble32.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:09 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/double32_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/double32_8C_source.html
https://root.cern/doc/master/drawsparse_8C.html:247,Energy Efficiency,efficient,efficient,247,". ROOT: tutorials/tree/drawsparse.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. drawsparse.C File ReferenceTutorials  Tree tutorials. Detailed Description; Convert a THnSparse to a TTree using efficient iteration through the THnSparse and draw a THnSparse using TParallelCoord. ; The plot will contain one line for each filled bin, with the bin's coordinates on each axis, and the bin's content on the rightmost axis.; Run as .L $ROOTSYS/tutorials/tree/drawsparse.C+. ; ; ; #include ""TParallelCoord.h""; #include ""TParallelCoordVar.h""; #include ""TROOT.h""; #include ""TTree.h""; #include ""TLeaf.h""; #include ""THnSparse.h""; #include ""TAxis.h""; #include ""TCanvas.h""; #include ""TRandom.h""; #include ""TFile.h""; #include ""TH3.h""; ; TTree* toTree(THnSparse* h); {; // Creates a TTree and fills it with the coordinates of all; // filled bins. The tree will have one branch for each dimension,; // and one for the bin content.; ; Int_t dim = h->GetNdimensions();; TString name(h->GetName()); name += ""_tree"";; TString title(h->GetTitle()); title += "" tree"";; ; TTree* tree = new TTree(name, title);; Double_t* x = new Double_t[dim + 1];; memset(x, 0, sizeof(Double_t) * (dim + 1));; ; TString branchname;; for (Int_t d = 0; d < dim; ++d) {; if (branchname.Length()); branchname += "":"";; TAxis* axis = h->GetAxis(d);; branchname += axis->GetName();; branchname += ""/D"";; }; tree->Branch(""coord"", x, branchname);; tree->Branch(""bincontent"", &x[dim], ""bincontent/D"");; ; Int_t *bins = new Int_t[dim];; for (Long64_t i = 0; i < h->GetNbins(); ++i) {; x[dim] = h->GetBinContent(i, bins);; for (Int_t d = 0; d < dim; ++d) {; x[d] = h->GetAxis(d)->GetBinCenter(bins[d]);; }; ; tree->Fill();; }; ; delete [] bins;; //delete [] x;; return tree;; }; ; ; void drawsparse_draw(THnSparse* h); {; // Draw a THnSparse using TParallelCoord, creating a temporary TTree.; ; TTree* tree = toTree(h);; ; TString whatToDraw;; TIter iLeaf(tree->GetListOfLeaves());; const TLeaf* le",MatchSource.WIKI,doc/master/drawsparse_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/drawsparse_8C.html
https://root.cern/doc/master/DynamicSlice_8C.html:1179,Energy Efficiency,power,powerful,1179," Histograms tutorials. Detailed Description; Show the slice of a TH2 following the mouse position. . ; ; void DynamicSlice(); {; // Create a new canvas.; TCanvas* c1 = new TCanvas(""c1"",""Dynamic Slice Example"", 10, 10, 700, 500);; ; //create a 2-d histogram, fill and draw it; TH2F *hpxpy = new TH2F(""hpxpy"", ""py vs px"", 40,-4,4, 40,-4,4);; hpxpy->SetStats(0);; Double_t px,py;; for (Int_t i = 0; i < 50000; i++) {; gRandom->Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->Draw(""col"");; ; //Add a TExec object to the canvas; c1->AddExec(""dynamic"", ""DynamicExec()"");; }; ; void DynamicExec(); {; // Example of function called when a mouse event occurs in a pad.; // When moving the mouse in the canvas, a second canvas shows the; // projection along X of the bin corresponding to the Y position; // of the mouse. The resulting histogram is fitted with a gaussian.; // A ""dynamic"" line shows the current bin position in Y.; // This more elaborated example can be used as a starting point; // to develop more powerful interactive applications exploiting Cling; // as a development engine.; ; static int pyold = 0;; ; float uxmin = gPad->GetUxmin();; float uxmax = gPad->GetUxmax();; int pxmin = gPad->XtoAbsPixel(uxmin);; int pxmax = gPad->XtoAbsPixel(uxmax);; int px = gPad->GetEventX();; int py = gPad->GetEventY();; TObject *select = gPad->GetSelected();; ; gPad->GetCanvas()->FeedbackMode(kTRUE);; if (pyold) {; // erase line at old position; gVirtualX->DrawLine(pxmin, pyold, pxmax, pyold);; pyold = 0;; }; ; if(!select || !select->InheritsFrom(TH2::Class())); return;; ; TH2 *h = (TH2*)select;; ; // draw a line at current position; gVirtualX->DrawLine(pxmin, py, pxmax, py);; pyold = py;; ; Float_t upy = gPad->AbsPixeltoY(py);; Float_t y = gPad->PadtoY(upy);; ; //create or set the new canvas c2; TVirtualPad *padsav = gPad;; TCanvas *c2 = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(""c2"");; if(c2) delete c2->GetPrimitive(""Projection"");; else c2 = new TCanvas(""c2"",""Projection Canvas"",710,10,",MatchSource.WIKI,doc/master/DynamicSlice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DynamicSlice_8C.html
https://root.cern/doc/master/DynamicSlice_8C.html:4712,Modifiability,inherit,inherits,4712,"t(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetFunctionvirtual TF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TH1.cxx:9051; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TH2::Classstatic TClass * Class(); TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TPad::FindObjectTObject * FindObject(const char *name) const overrideSearch if object named name is inside this pad or in pads inside this pad.Definition TPad.cxx:2700; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::cdvirtual TVirtualPad * cd(Int_t subpadnumber=0)=0; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; DynamicSliceDefinition DynamicSlice.py:1; AuthorsRene Brun, Sergey Linev ; Definition in file DynamicSlice",MatchSource.WIKI,doc/master/DynamicSlice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DynamicSlice_8C.html
https://root.cern/doc/master/DynamicSlice_8py.html:619,Energy Efficiency,power,powerful,619,". ROOT: tutorials/pyroot/DynamicSlice.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; DynamicSlice.py File ReferenceTutorials  PyRoot tutorials. Detailed Description; Example of function called when a mouse event occurs in a pad. ; When moving the mouse in the canvas, a second canvas shows the projection along X of the bin corresponding to the Y position of the mouse. The resulting histogram is fitted with a gaussian. A ""dynamic"" line shows the current bin position in Y. This more elaborated example can be used as a starting point to develop more powerful interactive applications exploiting CINT as a development engine.; Note that a class is used to hold on to the canvas that display the selected slice. ; import sys; import ctypes; ; from ROOT import gRandom, gPad, gROOT, gVirtualX; from ROOT import kTRUE, kRed; from ROOT import TCanvas, TH2, TH2F; ; ; class DynamicExec:; ; def __init__( self ):; self._cX = None; self._cY = None; self._old = None; ; def __call__( self ):; ; h = gPad.GetSelected();; if not h:; return; ; if not isinstance( h, TH2 ):; return; ; gPad.GetCanvas().FeedbackMode( kTRUE ); ; # erase old position and draw a line at current position; px = gPad.GetEventX(); py = gPad.GetEventY(); ; uxmin, uxmax = gPad.GetUxmin(), gPad.GetUxmax(); uymin, uymax = gPad.GetUymin(), gPad.GetUymax(); pxmin, pxmax = gPad.XtoAbsPixel( uxmin ), gPad.XtoAbsPixel( uxmax ); pymin, pymax = gPad.YtoAbsPixel( uymin ), gPad.YtoAbsPixel( uymax ); ; if self._old != None:; gVirtualX.DrawLine( pxmin, self._old[1], pxmax, self._old[1] ); gVirtualX.DrawLine( self._old[0], pymin, self._old[0], pymax ); gVirtualX.DrawLine( pxmin, py, pxmax, py ); gVirtualX.DrawLine( px, pymin, px, pymax ); ; self._old = px, py; ; upx = gPad.AbsPixeltoX( px ); x = gPad.PadtoX( upx ); upy = gPad.AbsPixeltoY( py ); y = gPad.PadtoY( upy ); ; padsav = gPad; ; # create or set the display canvases; if not self._cX:; self._cX = TCanvas( 'c2', 'P",MatchSource.WIKI,doc/master/DynamicSlice_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/DynamicSlice_8py.html
https://root.cern/doc/master/efficienciesMulticlass_8cxx.html:528,Integrability,depend,dependency,528,". ROOT: tmva/tmvagui/src/efficienciesMulticlass.cxx File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions |; Variables ; efficienciesMulticlass.cxx File Reference. #include ""TMVA/efficienciesMulticlass.h""; #include ""TMVA/Config.h""; #include ""TMVA/tmvaglob.h""; #include ""TControlBar.h""; #include ""TFile.h""; #include ""TGraph.h""; #include ""TH2F.h""; #include ""TIterator.h""; #include ""TKey.h""; #include ""TROOT.h""; #include <iostream>. Include dependency graph for efficienciesMulticlass.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class EfficiencyPlotWrapper; Note: This file assumes a certain structure on the input file. More...; . Namespaces; namespace TMVA; create variable transformations ; . Typedefs; usingclasscanvasmap_t = std::map< TString, EfficiencyPlotWrapper * >; ; usingroccurvelist_t = std::vector< std::tuple< TString, TString, TGraph * > >; . Functions; std::vector< TString >TMVA::getclassnames (TString dataset, TString fin); ; roccurvelist_tTMVA::getRocCurves (TDirectory *binDir, TString methodPrefix, TString graphNameRef); ; voidTMVA::plotEfficienciesMulticlass (roccurvelist_t rocCurves, classcanvasmap_t classCanvasMap); . Variables; const char *BUTTON_TYPE = ""button""; . Typedef Documentation. classcanvasmap_t. using classcanvasmap_t = std::map<TString, EfficiencyPlotWrapper *>. Definition at line 116 of file efficienciesMulticlass.cxx. roccurvelist_t. using roccurvelist_t = std::vector<std::tuple<TString, TString, TGraph *> >. Definition at line 117 of file efficienciesMulticlass.cxx. Variable Documentation. BUTTON_TYPE. const char* BUTTON_TYPE = ""button"". Definition at line 120 of file efficienciesMulticlass.cxx. tmvatmvaguisrcefficienciesMulticlass.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/efficienciesMulticlass_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/efficienciesMulticlass_8cxx.html
https://root.cern/doc/master/efficienciesMulticlass_8cxx.html:815,Modifiability,variab,variable,815,". ROOT: tmva/tmvagui/src/efficienciesMulticlass.cxx File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions |; Variables ; efficienciesMulticlass.cxx File Reference. #include ""TMVA/efficienciesMulticlass.h""; #include ""TMVA/Config.h""; #include ""TMVA/tmvaglob.h""; #include ""TControlBar.h""; #include ""TFile.h""; #include ""TGraph.h""; #include ""TH2F.h""; #include ""TIterator.h""; #include ""TKey.h""; #include ""TROOT.h""; #include <iostream>. Include dependency graph for efficienciesMulticlass.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class EfficiencyPlotWrapper; Note: This file assumes a certain structure on the input file. More...; . Namespaces; namespace TMVA; create variable transformations ; . Typedefs; usingclasscanvasmap_t = std::map< TString, EfficiencyPlotWrapper * >; ; usingroccurvelist_t = std::vector< std::tuple< TString, TString, TGraph * > >; . Functions; std::vector< TString >TMVA::getclassnames (TString dataset, TString fin); ; roccurvelist_tTMVA::getRocCurves (TDirectory *binDir, TString methodPrefix, TString graphNameRef); ; voidTMVA::plotEfficienciesMulticlass (roccurvelist_t rocCurves, classcanvasmap_t classCanvasMap); . Variables; const char *BUTTON_TYPE = ""button""; . Typedef Documentation. classcanvasmap_t. using classcanvasmap_t = std::map<TString, EfficiencyPlotWrapper *>. Definition at line 116 of file efficienciesMulticlass.cxx. roccurvelist_t. using roccurvelist_t = std::vector<std::tuple<TString, TString, TGraph *> >. Definition at line 117 of file efficienciesMulticlass.cxx. Variable Documentation. BUTTON_TYPE. const char* BUTTON_TYPE = ""button"". Definition at line 120 of file efficienciesMulticlass.cxx. tmvatmvaguisrcefficienciesMulticlass.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:26 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/efficienciesMulticlass_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/efficienciesMulticlass_8cxx.html
https://root.cern/doc/master/entrylistblock__figure1_8C_source.html:9889,Usability,simpl,simple,9889,"ne(0.66,0.24,0.66,0.26);; 282 line->Draw();; 283 line = new TLine(0.76,0.24,0.76,0.26);; 284 line->Draw();; 285 line = new TLine(0.86,0.24,0.86,0.26);; 286 line->Draw();; 287 line = new TLine(0.96,0.24,0.96,0.26);; 288 line->Draw();; 289}; c#define c(i)Definition RSha256.hxx:101; kWhite@ kWhiteDefinition Rtypes.h:65; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TPave::SetBorderSizevirtual void SetBorderSize(Int_t bordersize=4)Sets the border size of the TPave box and shadow.Definition TPave.h:77; TTextBase class for several text objects.Definition TText.h:22; lineTLine * lineDefinition entrylistblock_figure1.C:235; ptTPaveText * ptDefinition entrylistblock_figure1.C:7; textTText * textDefinition entrylistblock_figure1.C:9; arrowDefinition RArrowDS.hxx:17. treetreedocmacrosentrylistblock_f",MatchSource.WIKI,doc/master/entrylistblock__figure1_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/entrylistblock__figure1_8C_source.html
https://root.cern/doc/master/ErrorIntegral_8C.html:227,Availability,error,error,227,". ROOT: tutorials/fit/ErrorIntegral.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; --------------------------",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:294,Availability,error,errors,294,". ROOT: tutorials/fit/ErrorIntegral.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; --------------------------",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:349,Availability,error,error,349,". ROOT: tutorials/fit/ErrorIntegral.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; --------------------------",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:511,Availability,error,error,511,". ROOT: tutorials/fit/ErrorIntegral.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; --------------------------",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:553,Availability,error,error,553,". ROOT: tutorials/fit/ErrorIntegral.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; --------------------------",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:658,Availability,error,error,658,". ROOT: tutorials/fit/ErrorIntegral.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; --------------------------",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:1053,Availability,error,error,1053," Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; -------------------------------; 0 | 0.000978 0.009147 ; 1 | 0.009147 1.018 ; ; Integral = 19.0047 +/- 0.6164",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:1065,Availability,error,error,1065," Guide ; . . Loading...; Searching...; No Matches. ErrorIntegral.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; -------------------------------; 0 | 0.000978 0.009147 ; 1 | 0.009147 1.018 ; ; Integral = 19.0047 +/- 0.6164",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:1163,Availability,error,error,1163,"ed Description; Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit. ; The error is estimated also using the correlations values obtained from the fit; run the macro doing:; .x ErrorIntegral.C; After having computed the integral and its error using the integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; -------------------------------; 0 | 0.000978 0.009147 ; 1 | 0.009147 1.018 ; ; Integral = 19.0047 +/- 0.616472; ; #include ""TF1.h""; #include ""TH1D.h""; #include ""TFitResult.h""; #include ""TMath.h""; #include <cassert>; #inclu",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:1605,Availability,error,error,1605,"integral and the integral error using the generic functions TF1::Integral and TF1::IntegralError, we compute the integrals and its error analytically using the fact that the fitting function is \( f(x) = p[1]* sin(p[0]*x) \).; Therefore we have:; integral in [0,1] : ic = p[1]* (1-std::cos(p[0]) )/p[0]; derivative of integral with respect to p0: c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0]; derivative of integral with respect to p1: c1c = (1-std::cos(p[0]) )/p[0]. and then we can compute the integral error using error propagation and the covariance matrix for the parameters p obtained from the fit.; integral error : sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1) + 2.* c0c*c1c * covMatrix(0,1)); Note that, if possible, one should fit directly the function integral, which are the number of events of the different components (e.g. signal and background). In this way one obtains a better and more correct estimate of the integrals uncertainties, since they are obtained directly from the fit without using the approximation of error propagation. This is possible in ROOT. when using the TF1NormSum class, see the tutorial fitNormSum.C. ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 49.5952; NDf = 48; Edm = 1.61787e-06; NCalls = 58; p0 = 3.13205 +/- 0.0312726 ; p1 = 29.7625 +/- 1.00876 ; Covariance matrix from the fit ; 2x2 matrix is as follows; ; | 0 | 1 |; -------------------------------; 0 | 0.000978 0.009147 ; 1 | 0.009147 1.018 ; ; Integral = 19.0047 +/- 0.616472; ; #include ""TF1.h""; #include ""TH1D.h""; #include ""TFitResult.h""; #include ""TMath.h""; #include <cassert>; #include <iostream>; #include <cmath>; ; TF1 * fitFunc; // fit function pointer; ; const int NPAR = 2; // number of function parameters;; ; //____________________________________________________________________; double f(double * x, double * p) {; // function used to fit the data; return p[1]*TMath::Sin( p[0] * x[0] );; }; ; //_______",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:3554,Availability,error,error,3554,"__________________; void ErrorIntegral() {; fitFunc = new TF1(""f"",f,0,1,NPAR);; TH1D * h1 = new TH1D(""h1"",""h1"",50,0,1);; ; double par[NPAR] = { 3.14, 1.};; fitFunc->SetParameters(par);; ; h1->FillRandom(""f"",1000); // fill histogram sampling fitFunc; fitFunc->SetParameter(0,3.); // vary a little the parameters; auto fitResult = h1->Fit(fitFunc,""S""); // fit the histogram and get fit result pointer; ; h1->Draw();; ; /* calculate the integral*/; double integral = fitFunc->Integral(0,1);; ; auto covMatrix = fitResult->GetCovarianceMatrix();; std::cout << ""Covariance matrix from the fit "";; covMatrix.Print();; ; // need to pass covariance matrix to fit result.; // Parameters values are are stored inside the function but we can also retrieve from TFitResult; double sigma_integral = fitFunc->IntegralError(0,1, fitResult->GetParams() , covMatrix.GetMatrixArray());; ; std::cout << ""Integral = "" << integral << "" +/- "" << sigma_integral; << std::endl;; ; // estimated integral and error analytically; ; double * p = fitFunc->GetParameters();; double ic = p[1]* (1-std::cos(p[0]) )/p[0];; double c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0];; double c1c = (1-std::cos(p[0]) )/p[0];; ; // estimated error with correlations; double sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1); + 2.* c0c*c1c * covMatrix(0,1));; ; if ( std::fabs(sigma_integral-sic) > 1.E-6*sic ); std::cout << "" ERROR: test failed : different analytical integral : ""; << ic << "" +/- "" << sic << std::endl;; }; f#define f(i)Definition RSha256.hxx:104; TF1.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TH1D.h; TMath.h; TF11-Dim function classDefinition TF1.h:233; TF1::IntegralErrorvirtual Double_t IntegralError(Double_t a, Double_t b, const Double_t *params=nullptr, const Double_t *covmat=nullptr, Double_t epsilon=1.E-2)Return Error on Integral of a parametric function between a and b due to the parameter uncertainties ...Defin",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:3791,Availability,error,error,3791,"ng fitFunc; fitFunc->SetParameter(0,3.); // vary a little the parameters; auto fitResult = h1->Fit(fitFunc,""S""); // fit the histogram and get fit result pointer; ; h1->Draw();; ; /* calculate the integral*/; double integral = fitFunc->Integral(0,1);; ; auto covMatrix = fitResult->GetCovarianceMatrix();; std::cout << ""Covariance matrix from the fit "";; covMatrix.Print();; ; // need to pass covariance matrix to fit result.; // Parameters values are are stored inside the function but we can also retrieve from TFitResult; double sigma_integral = fitFunc->IntegralError(0,1, fitResult->GetParams() , covMatrix.GetMatrixArray());; ; std::cout << ""Integral = "" << integral << "" +/- "" << sigma_integral; << std::endl;; ; // estimated integral and error analytically; ; double * p = fitFunc->GetParameters();; double ic = p[1]* (1-std::cos(p[0]) )/p[0];; double c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0];; double c1c = (1-std::cos(p[0]) )/p[0];; ; // estimated error with correlations; double sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1); + 2.* c0c*c1c * covMatrix(0,1));; ; if ( std::fabs(sigma_integral-sic) > 1.E-6*sic ); std::cout << "" ERROR: test failed : different analytical integral : ""; << ic << "" +/- "" << sic << std::endl;; }; f#define f(i)Definition RSha256.hxx:104; TF1.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TH1D.h; TMath.h; TF11-Dim function classDefinition TF1.h:233; TF1::IntegralErrorvirtual Double_t IntegralError(Double_t a, Double_t b, const Double_t *params=nullptr, const Double_t *covmat=nullptr, Double_t epsilon=1.E-2)Return Error on Integral of a parametric function between a and b due to the parameter uncertainties ...Definition TF1.cxx:2708; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition T",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ErrorIntegral_8C.html:4001,Testability,test,test,4001,"tegral(0,1);; ; auto covMatrix = fitResult->GetCovarianceMatrix();; std::cout << ""Covariance matrix from the fit "";; covMatrix.Print();; ; // need to pass covariance matrix to fit result.; // Parameters values are are stored inside the function but we can also retrieve from TFitResult; double sigma_integral = fitFunc->IntegralError(0,1, fitResult->GetParams() , covMatrix.GetMatrixArray());; ; std::cout << ""Integral = "" << integral << "" +/- "" << sigma_integral; << std::endl;; ; // estimated integral and error analytically; ; double * p = fitFunc->GetParameters();; double ic = p[1]* (1-std::cos(p[0]) )/p[0];; double c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0];; double c1c = (1-std::cos(p[0]) )/p[0];; ; // estimated error with correlations; double sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1); + 2.* c0c*c1c * covMatrix(0,1));; ; if ( std::fabs(sigma_integral-sic) > 1.E-6*sic ); std::cout << "" ERROR: test failed : different analytical integral : ""; << ic << "" +/- "" << sic << std::endl;; }; f#define f(i)Definition RSha256.hxx:104; TF1.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TH1D.h; TMath.h; TF11-Dim function classDefinition TF1.h:233; TF1::IntegralErrorvirtual Double_t IntegralError(Double_t a, Double_t b, const Double_t *params=nullptr, const Double_t *covmat=nullptr, Double_t epsilon=1.E-2)Return Error on Integral of a parametric function between a and b due to the parameter uncertainties ...Definition TF1.cxx:2708; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TH1D1-D histogram with a double per channel",MatchSource.WIKI,doc/master/ErrorIntegral_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html
https://root.cern/doc/master/ESTLType_8h_source.html:1636,Integrability,interface,interface,1636,"; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// ROOT::ESTLType //; 19// //; 20// Enum describing STL collections and some std classes //; 21// This is used in TClassEdit, TStreamerInfo, TClassEdit //; 22// and TStreamerElement. //; 23// //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26namespace ROOT {; 27 ; 28 enum ESTLType {; 29 kNotSTL = 0,; 30 kSTLvector = 1,; 31 kSTLlist = 2,; 32 kSTLdeque = 3,; 33 kSTLmap = 4,; 34 kSTLmultimap = 5,; 35 kSTLset = 6,; 36 kSTLmultiset = 7,; 37 kSTLbitset = 8,; 38 // Here the c++11 containers start. Order counts. For example,; 39 // tstreamerelements in written rootfiles carry a value and we cannot; 40 // introduce shifts.; 41 kSTLforwardlist = 9,; 42 kSTLunorderedset = 10,; 43 kSTLunorderedmultiset = 11,; 44 kSTLunorderedmap = 12,; 45 kSTLunorderedmultimap = 13,; 46 kROOTRVec = 14, /* ROOT type with STL container interface */; 47 kSTLend = 15,; 48 kSTLany = 300 /* TVirtualStreamerInfo::kSTL */,; 49 kSTLstring = 365 /* TVirtualStreamerInfo::kSTLstring */,; 50 };; 51 ; 52}; 53 ; 54#endif; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::kSTLbitset@ kSTLbitsetDefinition ESTLType.h:37; ROOT::kSTLmap@ kSTLmapDefinition ESTLType.h:33; ROOT::kSTLunorderedmultiset@ kSTLunorderedmultisetDefinition ESTLType.h:43; ROOT::kROOTRVec@ kROOTRVecDefinition ESTLType.h:46; ROOT::kSTLend@ kSTLendDefinition ESTLType.h:47; ROOT::kSTLstring@ kSTLstringDefinition ESTLType.h:49; ROOT::kSTLset@ kSTLsetDefinition ESTLType.h:35; ROOT::kSTLmultiset@ kSTLmultisetDefinition ESTLType.h:36; ROOT::kSTLdeque@ kSTLdequeDefinition ESTLType.h:32; ROOT::kSTLvector@ kSTLvectorDefinition ESTLType.h:30; ROOT::kSTLany@ kSTLanyDefinition ESTLType.h:48; ROOT::kSTLunorderedmultimap@ kSTLunorderedmultimapDefinition ESTLType.h:45; ROOT::kS",MatchSource.WIKI,doc/master/ESTLType_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/ESTLType_8h_source.html
https://root.cern/doc/master/etaMax_8h_source.html:943,Testability,log,log,943,". ROOT: math/genvector/inc/Math/GenVector/etaMax.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. etaMax.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11 ; 12// Header source file for function etaMax; 13//; 14// Created by: Mark Fischler at Thu Jun 2 2005; 15 ; 16 ; 17#ifndef ROOT_Math_GenVector_etaMax; 18#define ROOT_Math_GenVector_etaMax 1; 19 ; 20 ; 21#include <limits>; 22#include <cmath>; 23 ; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 ; 29 /**; 30 The following function could be called to provide the maximum possible; 31 value of pseudorapidity for a non-zero rho. This is log ( max/min ); 32 where max and min are the extrema of positive values for type; 33 long double.; 34 */; 35 inline; 36 long double etaMax_impl() {; 37 using std::log;; 38 return log ( std::numeric_limits<long double>::max()/256.0l ) -; 39 log ( std::numeric_limits<long double>::denorm_min()*256.0l ); 40 + 16.0 * log(2.0);; 41 // Actual usage of etaMax() simply returns the number 22756, which is; 42 // the answer this would supply, rounded to a higher integer.; 43 }; 44 ; 45 /**; 46 Function providing the maximum possible value of pseudorapidity for; 47 a non-zero rho, in the Scalar type with the largest dynamic range.; 48 */; 49 template <class T>; 50 inline; 51 T etaMax() {; 52 return static_cast<T>(22756.0);; 53 }; 54 ; 55 } // namespace Math; 56 ; 57} // namespace ROOT; 58 ; 59 ; 60#endif /* ROOT_Math_GenVector_etaMax */; MathNamespace for new Math classes and functions.; ROOT::Math::etaMax_impllong double etaMax_impl()The following function could be called to provide the maximum possible value of pseudorapidity for a ...Definition etaMa",MatchSource.WIKI,doc/master/etaMax_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/etaMax_8h_source.html
https://root.cern/doc/master/etaMax_8h_source.html:1107,Testability,log,log,1107,"Loading...; Searching...; No Matches. etaMax.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11 ; 12// Header source file for function etaMax; 13//; 14// Created by: Mark Fischler at Thu Jun 2 2005; 15 ; 16 ; 17#ifndef ROOT_Math_GenVector_etaMax; 18#define ROOT_Math_GenVector_etaMax 1; 19 ; 20 ; 21#include <limits>; 22#include <cmath>; 23 ; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 ; 29 /**; 30 The following function could be called to provide the maximum possible; 31 value of pseudorapidity for a non-zero rho. This is log ( max/min ); 32 where max and min are the extrema of positive values for type; 33 long double.; 34 */; 35 inline; 36 long double etaMax_impl() {; 37 using std::log;; 38 return log ( std::numeric_limits<long double>::max()/256.0l ) -; 39 log ( std::numeric_limits<long double>::denorm_min()*256.0l ); 40 + 16.0 * log(2.0);; 41 // Actual usage of etaMax() simply returns the number 22756, which is; 42 // the answer this would supply, rounded to a higher integer.; 43 }; 44 ; 45 /**; 46 Function providing the maximum possible value of pseudorapidity for; 47 a non-zero rho, in the Scalar type with the largest dynamic range.; 48 */; 49 template <class T>; 50 inline; 51 T etaMax() {; 52 return static_cast<T>(22756.0);; 53 }; 54 ; 55 } // namespace Math; 56 ; 57} // namespace ROOT; 58 ; 59 ; 60#endif /* ROOT_Math_GenVector_etaMax */; MathNamespace for new Math classes and functions.; ROOT::Math::etaMax_impllong double etaMax_impl()The following function could be called to provide the maximum possible value of pseudorapidity for a ...Definition etaMax.h:36; ROOT::Math::etaMaxT etaMax()Function providing the maximum possible value of pseudorapidity for a ",MatchSource.WIKI,doc/master/etaMax_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/etaMax_8h_source.html
https://root.cern/doc/master/etaMax_8h_source.html:1123,Testability,log,log,1123,"Loading...; Searching...; No Matches. etaMax.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11 ; 12// Header source file for function etaMax; 13//; 14// Created by: Mark Fischler at Thu Jun 2 2005; 15 ; 16 ; 17#ifndef ROOT_Math_GenVector_etaMax; 18#define ROOT_Math_GenVector_etaMax 1; 19 ; 20 ; 21#include <limits>; 22#include <cmath>; 23 ; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 ; 29 /**; 30 The following function could be called to provide the maximum possible; 31 value of pseudorapidity for a non-zero rho. This is log ( max/min ); 32 where max and min are the extrema of positive values for type; 33 long double.; 34 */; 35 inline; 36 long double etaMax_impl() {; 37 using std::log;; 38 return log ( std::numeric_limits<long double>::max()/256.0l ) -; 39 log ( std::numeric_limits<long double>::denorm_min()*256.0l ); 40 + 16.0 * log(2.0);; 41 // Actual usage of etaMax() simply returns the number 22756, which is; 42 // the answer this would supply, rounded to a higher integer.; 43 }; 44 ; 45 /**; 46 Function providing the maximum possible value of pseudorapidity for; 47 a non-zero rho, in the Scalar type with the largest dynamic range.; 48 */; 49 template <class T>; 50 inline; 51 T etaMax() {; 52 return static_cast<T>(22756.0);; 53 }; 54 ; 55 } // namespace Math; 56 ; 57} // namespace ROOT; 58 ; 59 ; 60#endif /* ROOT_Math_GenVector_etaMax */; MathNamespace for new Math classes and functions.; ROOT::Math::etaMax_impllong double etaMax_impl()The following function could be called to provide the maximum possible value of pseudorapidity for a ...Definition etaMax.h:36; ROOT::Math::etaMaxT etaMax()Function providing the maximum possible value of pseudorapidity for a ",MatchSource.WIKI,doc/master/etaMax_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/etaMax_8h_source.html
https://root.cern/doc/master/etaMax_8h_source.html:1184,Testability,log,log,1184,"athcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11 ; 12// Header source file for function etaMax; 13//; 14// Created by: Mark Fischler at Thu Jun 2 2005; 15 ; 16 ; 17#ifndef ROOT_Math_GenVector_etaMax; 18#define ROOT_Math_GenVector_etaMax 1; 19 ; 20 ; 21#include <limits>; 22#include <cmath>; 23 ; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 ; 29 /**; 30 The following function could be called to provide the maximum possible; 31 value of pseudorapidity for a non-zero rho. This is log ( max/min ); 32 where max and min are the extrema of positive values for type; 33 long double.; 34 */; 35 inline; 36 long double etaMax_impl() {; 37 using std::log;; 38 return log ( std::numeric_limits<long double>::max()/256.0l ) -; 39 log ( std::numeric_limits<long double>::denorm_min()*256.0l ); 40 + 16.0 * log(2.0);; 41 // Actual usage of etaMax() simply returns the number 22756, which is; 42 // the answer this would supply, rounded to a higher integer.; 43 }; 44 ; 45 /**; 46 Function providing the maximum possible value of pseudorapidity for; 47 a non-zero rho, in the Scalar type with the largest dynamic range.; 48 */; 49 template <class T>; 50 inline; 51 T etaMax() {; 52 return static_cast<T>(22756.0);; 53 }; 54 ; 55 } // namespace Math; 56 ; 57} // namespace ROOT; 58 ; 59 ; 60#endif /* ROOT_Math_GenVector_etaMax */; MathNamespace for new Math classes and functions.; ROOT::Math::etaMax_impllong double etaMax_impl()The following function could be called to provide the maximum possible value of pseudorapidity for a ...Definition etaMax.h:36; ROOT::Math::etaMaxT etaMax()Function providing the maximum possible value of pseudorapidity for a non-zero rho,...Definition etaMax.h:51; ROOTtbb::task_arena is an alias of tbb::interface7::task_are",MatchSource.WIKI,doc/master/etaMax_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/etaMax_8h_source.html
https://root.cern/doc/master/etaMax_8h_source.html:1259,Testability,log,log,1259,"Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11 ; 12// Header source file for function etaMax; 13//; 14// Created by: Mark Fischler at Thu Jun 2 2005; 15 ; 16 ; 17#ifndef ROOT_Math_GenVector_etaMax; 18#define ROOT_Math_GenVector_etaMax 1; 19 ; 20 ; 21#include <limits>; 22#include <cmath>; 23 ; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 ; 29 /**; 30 The following function could be called to provide the maximum possible; 31 value of pseudorapidity for a non-zero rho. This is log ( max/min ); 32 where max and min are the extrema of positive values for type; 33 long double.; 34 */; 35 inline; 36 long double etaMax_impl() {; 37 using std::log;; 38 return log ( std::numeric_limits<long double>::max()/256.0l ) -; 39 log ( std::numeric_limits<long double>::denorm_min()*256.0l ); 40 + 16.0 * log(2.0);; 41 // Actual usage of etaMax() simply returns the number 22756, which is; 42 // the answer this would supply, rounded to a higher integer.; 43 }; 44 ; 45 /**; 46 Function providing the maximum possible value of pseudorapidity for; 47 a non-zero rho, in the Scalar type with the largest dynamic range.; 48 */; 49 template <class T>; 50 inline; 51 T etaMax() {; 52 return static_cast<T>(22756.0);; 53 }; 54 ; 55 } // namespace Math; 56 ; 57} // namespace ROOT; 58 ; 59 ; 60#endif /* ROOT_Math_GenVector_etaMax */; MathNamespace for new Math classes and functions.; ROOT::Math::etaMax_impllong double etaMax_impl()The following function could be called to provide the maximum possible value of pseudorapidity for a ...Definition etaMax.h:36; ROOT::Math::etaMaxT etaMax()Function providing the maximum possible value of pseudorapidity for a non-zero rho,...Definition etaMax.h:51; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Defin",MatchSource.WIKI,doc/master/etaMax_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/etaMax_8h_source.html
https://root.cern/doc/master/etaMax_8h_source.html:1301,Usability,simpl,simply,1301,"**************; 5 * *; 6 * Copyright (c) 2005 , FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11 ; 12// Header source file for function etaMax; 13//; 14// Created by: Mark Fischler at Thu Jun 2 2005; 15 ; 16 ; 17#ifndef ROOT_Math_GenVector_etaMax; 18#define ROOT_Math_GenVector_etaMax 1; 19 ; 20 ; 21#include <limits>; 22#include <cmath>; 23 ; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 ; 29 /**; 30 The following function could be called to provide the maximum possible; 31 value of pseudorapidity for a non-zero rho. This is log ( max/min ); 32 where max and min are the extrema of positive values for type; 33 long double.; 34 */; 35 inline; 36 long double etaMax_impl() {; 37 using std::log;; 38 return log ( std::numeric_limits<long double>::max()/256.0l ) -; 39 log ( std::numeric_limits<long double>::denorm_min()*256.0l ); 40 + 16.0 * log(2.0);; 41 // Actual usage of etaMax() simply returns the number 22756, which is; 42 // the answer this would supply, rounded to a higher integer.; 43 }; 44 ; 45 /**; 46 Function providing the maximum possible value of pseudorapidity for; 47 a non-zero rho, in the Scalar type with the largest dynamic range.; 48 */; 49 template <class T>; 50 inline; 51 T etaMax() {; 52 return static_cast<T>(22756.0);; 53 }; 54 ; 55 } // namespace Math; 56 ; 57} // namespace ROOT; 58 ; 59 ; 60#endif /* ROOT_Math_GenVector_etaMax */; MathNamespace for new Math classes and functions.; ROOT::Math::etaMax_impllong double etaMax_impl()The following function could be called to provide the maximum possible value of pseudorapidity for a ...Definition etaMax.h:36; ROOT::Math::etaMaxT etaMax()Function providing the maximum possible value of pseudorapidity for a non-zero rho,...Definition etaMax.h:51; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathgenvectorincMathGenVectoretaMax.h. ROOT mas",MatchSource.WIKI,doc/master/etaMax_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/etaMax_8h_source.html
https://root.cern/doc/master/EulerAngles_8cxx_source.html:662,Deployability,update,update,662,". ROOT: math/genvector/src/EulerAngles.cxx Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. EulerAngles.cxx. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for rotation in 3 dimensions, represented by EulerAngles; 12//; 13// Created by: Mark Fischler Thurs June 9 2005; 14//; 15// Last update: $Id$; 16//; 17#include ""Math/GenVector/EulerAngles.h""; 18 ; 19#include <cmath>; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/Rotation3D.h""; 24#include ""Math/GenVector/Quaternion.h""; 25#include ""Math/GenVector/RotationX.h""; 26#include ""Math/GenVector/RotationY.h""; 27#include ""Math/GenVector/RotationZ.h""; 28 ; 29#include ""Math/GenVector/AxisAnglefwd.h""; 30 ; 31namespace ROOT {; 32 ; 33namespace Math {; 34 ; 35// ========== Constructors and Assignment =====================; 36 ; 37void EulerAngles::Rectify(); 38{; 39 // rectify; 40 if ( fTheta < 0 || fTheta > Pi() ) {; 41 Scalar t = fTheta - std::floor( fTheta/(2*Pi()) ) * 2*Pi();; 42 if ( t <= Pi() ) {; 43 fTheta = t;; 44 } else {; 45 fTheta = 2*Pi() - t;; 46 fPhi = fPhi + Pi();; 47 fPsi = fPsi + Pi();; 48 }; 49 }; 50 ; 51 if ( fPhi <= -Pi()|| fPhi > Pi() ) {; 52 fPhi = fPhi - std::floor( fPhi/(2*Pi()) +.5 ) * 2*Pi();; 53 }; 54 ; 55 if ( fPsi <= -Pi()|| fPsi > Pi() ) {; 56 fPsi = fPsi - std::floor( fPsi/(2*Pi()) +.5 ) * 2*Pi();; 57 }; 58 ; 59} // Rectify(); 60 ; 61 ; 62// ========== Operations =====================; 63 ; 64// DisplacementVector3D< Cartesian3D<double> >; 65// EulerAngles::; 66// operator() (const DisplacementVector3D< Cartesian3D<double> > & v) const; 67// {; 68// r",MatchSource.WIKI,doc/master/EulerAngles_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/EulerAngles_8cxx_source.html
https://root.cern/doc/master/EulerAngles_8cxx_source.html:3592,Performance,perform,performance,3592," combine with a RotationX; 93 return EulerAngles ( Quaternion(*this) * r );; 94}; 95 ; 96EulerAngles EulerAngles::operator * (const RotationY & r) const {; 97 // combine with a RotationY; 98 return EulerAngles ( Quaternion(*this) * r );; 99}; 100 ; 101EulerAngles EulerAngles::operator * (const RotationZ & r) const {; 102 // combine with a RotationZ; 103 // TODO -- this can be made much faster because it merely adds; 104 // the r.Angle() to phi.; 105 Scalar newPhi = fPhi + r.Angle();; 106 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 107 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 108 }; 109 return EulerAngles ( newPhi, fTheta, fPsi );; 110}; 111 ; 112EulerAngles operator * ( RotationX const & r, EulerAngles const & e ) {; 113 return EulerAngles(r) * e; // TODO: improve performance; 114}; 115 ; 116EulerAngles operator * ( RotationY const & r, EulerAngles const & e ) {; 117 return EulerAngles(r) * e; // TODO: improve performance; 118}; 119 ; 120EulerAngles; 121operator * ( RotationZ const & r, EulerAngles const & e ) {; 122 return EulerAngles(r) * e; // TODO: improve performance; 123}; 124 ; 125// ========== I/O =====================; 126 ; 127std::ostream & operator<< (std::ostream & os, const EulerAngles & e) {; 128 // TODO - this will need changing for machine-readable issues; 129 // and even the human readable form may need formatting improvements; 130 os << ""\n{phi: "" << e.Phi() << "" theta: "" << e.Theta(); 131 << "" psi: "" << e.Psi() << ""}\n"";; 132 return os;; 133}; 134 ; 135 ; 136} //namespace Math; 137} //namespace ROOT; AxisAnglefwd.h; Cartesian3D.h; DisplacementVector3D.h; EulerAngles.h; Quaternion.h; Rotation3D.h; RotationX.h; RotationY.h; RotationZ.h; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefini",MatchSource.WIKI,doc/master/EulerAngles_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/EulerAngles_8cxx_source.html
https://root.cern/doc/master/EulerAngles_8cxx_source.html:3741,Performance,perform,performance,3741," combine with a RotationX; 93 return EulerAngles ( Quaternion(*this) * r );; 94}; 95 ; 96EulerAngles EulerAngles::operator * (const RotationY & r) const {; 97 // combine with a RotationY; 98 return EulerAngles ( Quaternion(*this) * r );; 99}; 100 ; 101EulerAngles EulerAngles::operator * (const RotationZ & r) const {; 102 // combine with a RotationZ; 103 // TODO -- this can be made much faster because it merely adds; 104 // the r.Angle() to phi.; 105 Scalar newPhi = fPhi + r.Angle();; 106 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 107 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 108 }; 109 return EulerAngles ( newPhi, fTheta, fPsi );; 110}; 111 ; 112EulerAngles operator * ( RotationX const & r, EulerAngles const & e ) {; 113 return EulerAngles(r) * e; // TODO: improve performance; 114}; 115 ; 116EulerAngles operator * ( RotationY const & r, EulerAngles const & e ) {; 117 return EulerAngles(r) * e; // TODO: improve performance; 118}; 119 ; 120EulerAngles; 121operator * ( RotationZ const & r, EulerAngles const & e ) {; 122 return EulerAngles(r) * e; // TODO: improve performance; 123}; 124 ; 125// ========== I/O =====================; 126 ; 127std::ostream & operator<< (std::ostream & os, const EulerAngles & e) {; 128 // TODO - this will need changing for machine-readable issues; 129 // and even the human readable form may need formatting improvements; 130 os << ""\n{phi: "" << e.Phi() << "" theta: "" << e.Theta(); 131 << "" psi: "" << e.Psi() << ""}\n"";; 132 return os;; 133}; 134 ; 135 ; 136} //namespace Math; 137} //namespace ROOT; AxisAnglefwd.h; Cartesian3D.h; DisplacementVector3D.h; EulerAngles.h; Quaternion.h; Rotation3D.h; RotationX.h; RotationY.h; RotationZ.h; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefini",MatchSource.WIKI,doc/master/EulerAngles_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/EulerAngles_8cxx_source.html
https://root.cern/doc/master/EulerAngles_8cxx_source.html:3894,Performance,perform,performance,3894," combine with a RotationX; 93 return EulerAngles ( Quaternion(*this) * r );; 94}; 95 ; 96EulerAngles EulerAngles::operator * (const RotationY & r) const {; 97 // combine with a RotationY; 98 return EulerAngles ( Quaternion(*this) * r );; 99}; 100 ; 101EulerAngles EulerAngles::operator * (const RotationZ & r) const {; 102 // combine with a RotationZ; 103 // TODO -- this can be made much faster because it merely adds; 104 // the r.Angle() to phi.; 105 Scalar newPhi = fPhi + r.Angle();; 106 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 107 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 108 }; 109 return EulerAngles ( newPhi, fTheta, fPsi );; 110}; 111 ; 112EulerAngles operator * ( RotationX const & r, EulerAngles const & e ) {; 113 return EulerAngles(r) * e; // TODO: improve performance; 114}; 115 ; 116EulerAngles operator * ( RotationY const & r, EulerAngles const & e ) {; 117 return EulerAngles(r) * e; // TODO: improve performance; 118}; 119 ; 120EulerAngles; 121operator * ( RotationZ const & r, EulerAngles const & e ) {; 122 return EulerAngles(r) * e; // TODO: improve performance; 123}; 124 ; 125// ========== I/O =====================; 126 ; 127std::ostream & operator<< (std::ostream & os, const EulerAngles & e) {; 128 // TODO - this will need changing for machine-readable issues; 129 // and even the human readable form may need formatting improvements; 130 os << ""\n{phi: "" << e.Phi() << "" theta: "" << e.Theta(); 131 << "" psi: "" << e.Psi() << ""}\n"";; 132 return os;; 133}; 134 ; 135 ; 136} //namespace Math; 137} //namespace ROOT; AxisAnglefwd.h; Cartesian3D.h; DisplacementVector3D.h; EulerAngles.h; Quaternion.h; Rotation3D.h; RotationX.h; RotationY.h; RotationZ.h; a#define a(i)Definition RSha256.hxx:99; e#define e(i)Definition RSha256.hxx:103; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefini",MatchSource.WIKI,doc/master/EulerAngles_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/EulerAngles_8cxx_source.html
https://root.cern/doc/master/eval_8C.html:2311,Usability,simpl,simple,2311,"->DrawLine(12,8,6,8);; ar1->DrawArrow(3,5,4.4,5,0.02,""|>"");; ar1->DrawArrow(7.8,5,8.9,5,0.02,""|>"");; }; ; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TArrow::DrawArrowvirtual TArrow * DrawArrow(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Float_t arrowsize=0, Option_t *option="""")Draw this arrow with new coordinates.Definition TArrow.cxx:135; TArrow::Drawvoid Draw(Option_t *option="""") overrideDraw this arrow with its current attributes.Definition TArrow.cxx:120; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TTextBase class for several text objects.Definition TText.h",MatchSource.WIKI,doc/master/eval_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eval_8C.html
https://root.cern/doc/master/eveGeoBrowser_8C.html:257,Integrability,depend,dependency,257,". ROOT: tutorials/eve7/eveGeoBrowser.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Functions ; eveGeoBrowser.C File Reference. #include <ROOT/REveGeoTopNode.hxx>; #include <ROOT/REveManager.hxx>. Include dependency graph for eveGeoBrowser.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; voideveGeoBrowser (bool showDet=true); ; TGeoNode *getNodeFromPath (TGeoNode *top, std::string path); ; TGeoNode *rootgeom (); ; TGeoNode *testCmsGeo (); . Function Documentation. eveGeoBrowser(). void eveGeoBrowser ; (; bool; showDet = true). Definition at line 169 of file eveGeoBrowser.C. getNodeFromPath(). TGeoNode * getNodeFromPath ; (; TGeoNode *; top, . std::string; path. ). Definition at line 9 of file eveGeoBrowser.C. rootgeom(). TGeoNode * rootgeom ; (; ). Definition at line 47 of file eveGeoBrowser.C. testCmsGeo(). TGeoNode * testCmsGeo ; (; ). Definition at line 20 of file eveGeoBrowser.C. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/eveGeoBrowser_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C.html
https://root.cern/doc/master/eveGeoBrowser_8C.html:538,Testability,test,testCmsGeo,538,". ROOT: tutorials/eve7/eveGeoBrowser.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Functions ; eveGeoBrowser.C File Reference. #include <ROOT/REveGeoTopNode.hxx>; #include <ROOT/REveManager.hxx>. Include dependency graph for eveGeoBrowser.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; voideveGeoBrowser (bool showDet=true); ; TGeoNode *getNodeFromPath (TGeoNode *top, std::string path); ; TGeoNode *rootgeom (); ; TGeoNode *testCmsGeo (); . Function Documentation. eveGeoBrowser(). void eveGeoBrowser ; (; bool; showDet = true). Definition at line 169 of file eveGeoBrowser.C. getNodeFromPath(). TGeoNode * getNodeFromPath ; (; TGeoNode *; top, . std::string; path. ). Definition at line 9 of file eveGeoBrowser.C. rootgeom(). TGeoNode * rootgeom ; (; ). Definition at line 47 of file eveGeoBrowser.C. testCmsGeo(). TGeoNode * testCmsGeo ; (; ). Definition at line 20 of file eveGeoBrowser.C. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/eveGeoBrowser_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C.html
https://root.cern/doc/master/eveGeoBrowser_8C.html:929,Testability,test,testCmsGeo,929,". ROOT: tutorials/eve7/eveGeoBrowser.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Functions ; eveGeoBrowser.C File Reference. #include <ROOT/REveGeoTopNode.hxx>; #include <ROOT/REveManager.hxx>. Include dependency graph for eveGeoBrowser.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; voideveGeoBrowser (bool showDet=true); ; TGeoNode *getNodeFromPath (TGeoNode *top, std::string path); ; TGeoNode *rootgeom (); ; TGeoNode *testCmsGeo (); . Function Documentation. eveGeoBrowser(). void eveGeoBrowser ; (; bool; showDet = true). Definition at line 169 of file eveGeoBrowser.C. getNodeFromPath(). TGeoNode * getNodeFromPath ; (; TGeoNode *; top, . std::string; path. ). Definition at line 9 of file eveGeoBrowser.C. rootgeom(). TGeoNode * rootgeom ; (; ). Definition at line 47 of file eveGeoBrowser.C. testCmsGeo(). TGeoNode * testCmsGeo ; (; ). Definition at line 20 of file eveGeoBrowser.C. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/eveGeoBrowser_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C.html
https://root.cern/doc/master/eveGeoBrowser_8C.html:954,Testability,test,testCmsGeo,954,". ROOT: tutorials/eve7/eveGeoBrowser.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Functions ; eveGeoBrowser.C File Reference. #include <ROOT/REveGeoTopNode.hxx>; #include <ROOT/REveManager.hxx>. Include dependency graph for eveGeoBrowser.C:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; voideveGeoBrowser (bool showDet=true); ; TGeoNode *getNodeFromPath (TGeoNode *top, std::string path); ; TGeoNode *rootgeom (); ; TGeoNode *testCmsGeo (); . Function Documentation. eveGeoBrowser(). void eveGeoBrowser ; (; bool; showDet = true). Definition at line 169 of file eveGeoBrowser.C. getNodeFromPath(). TGeoNode * getNodeFromPath ; (; TGeoNode *; top, . std::string; path. ). Definition at line 9 of file eveGeoBrowser.C. rootgeom(). TGeoNode * rootgeom ; (; ). Definition at line 47 of file eveGeoBrowser.C. testCmsGeo(). TGeoNode * testCmsGeo ; (; ). Definition at line 20 of file eveGeoBrowser.C. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/eveGeoBrowser_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C.html
https://root.cern/doc/master/eveGeoBrowser_8C_source.html:9430,Performance,cache,cacheDir,9430,"on REveElement.cxx:855; ROOT::Experimental::REveGeoTopNodeDataDefinition REveGeoTopNode.hxx:17; ROOT::Experimental::REveGeoTopNodeVizDefinition REveGeoTopNode.hxx:40; ROOT::Experimental::REveManager::GetEventSceneREveScene * GetEventScene() constDefinition REveManager.hxx:184; ROOT::Experimental::REveManager::SpawnNewSceneREveScene * SpawnNewScene(const char *name, const char *title="""")Create a new scene.Definition REveManager.cxx:239; ROOT::Experimental::REveManager::SpawnNewViewerREveViewer * SpawnNewViewer(const char *name, const char *title="""")Create a new GL viewer.Definition REveManager.cxx:229; ROOT::Experimental::REveManager::Showvoid Show(const RWebDisplayArgs &args="""")Show eve manager in specified browser.Definition REveManager.cxx:1169; ROOT::Experimental::REveViewer::AddScenevirtual void AddScene(REveScene *scene)Add 'scene' to the list of scenes.Definition REveViewer.cxx:58; R; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoMana",MatchSource.WIKI,doc/master/eveGeoBrowser_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html
https://root.cern/doc/master/eveGeoBrowser_8C_source.html:9545,Performance,cache,cache,9545,"on REveElement.cxx:855; ROOT::Experimental::REveGeoTopNodeDataDefinition REveGeoTopNode.hxx:17; ROOT::Experimental::REveGeoTopNodeVizDefinition REveGeoTopNode.hxx:40; ROOT::Experimental::REveManager::GetEventSceneREveScene * GetEventScene() constDefinition REveManager.hxx:184; ROOT::Experimental::REveManager::SpawnNewSceneREveScene * SpawnNewScene(const char *name, const char *title="""")Create a new scene.Definition REveManager.cxx:239; ROOT::Experimental::REveManager::SpawnNewViewerREveViewer * SpawnNewViewer(const char *name, const char *title="""")Create a new GL viewer.Definition REveManager.cxx:229; ROOT::Experimental::REveManager::Showvoid Show(const RWebDisplayArgs &args="""")Show eve manager in specified browser.Definition REveManager.cxx:1169; ROOT::Experimental::REveViewer::AddScenevirtual void AddScene(REveScene *scene)Add 'scene' to the list of scenes.Definition REveViewer.cxx:58; R; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::MakeArb8TGeoVolume * MakeArb8(const char *name, TGeoMedium *medium, Double_t dz, Double_t *vertices=nullptr)Make an TGeoArb8 volume.Definition TGeoManager.cxx:3161; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoMana",MatchSource.WIKI,doc/master/eveGeoBrowser_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html
https://root.cern/doc/master/eveGeoBrowser_8C_source.html:586,Testability,test,testCmsGeo,586,". ROOT: tutorials/eve7/eveGeoBrowser.C Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. eveGeoBrowser.C. Go to the documentation of this file. 1 ; 2#include <ROOT/REveGeoTopNode.hxx>; 3#include <ROOT/REveManager.hxx>; 4 ; 5 ; 6namespace REX = ROOT::Experimental;; 7 ; 8 ; 9TGeoNode *getNodeFromPath(TGeoNode *top, std::string path); 10{; 11 TGeoNode *node = top;; 12 std::istringstream f(path);; 13 std::string s;; 14 while (getline(f, s, '/')); 15 node = node->GetVolume()->FindNode(s.c_str());; 16 ; 17 return node;; 18}; 19 ; 20TGeoNode* testCmsGeo(); 21{; 22 TFile::SetCacheFileDir(""."");; 23 ; 24 TGeoManager::Import(""https://root.cern/files/cms.root"");; 25 ; 26 gGeoManager->DefaultColors();; 27 gGeoManager->GetVolume(""TRAK"")->InvisibleAll();; 28 gGeoManager->GetVolume(""HVP2"")->SetTransparency(20);; 29 gGeoManager->GetVolume(""HVEQ"")->SetTransparency(20);; 30 gGeoManager->GetVolume(""YE4"")->SetTransparency(10);; 31 gGeoManager->GetVolume(""YE3"")->SetTransparency(20);; 32 gGeoManager->GetVolume(""RB2"")->SetTransparency(99);; 33 gGeoManager->GetVolume(""RB3"")->SetTransparency(99);; 34 gGeoManager->GetVolume(""COCF"")->SetTransparency(99);; 35 gGeoManager->GetVolume(""HEC1"")->SetLineColor(7);; 36 gGeoManager->GetVolume(""EAP1"")->SetLineColor(7);; 37 gGeoManager->GetVolume(""EAP2"")->SetLineColor(7);; 38 gGeoManager->GetVolume(""EAP3"")->SetLineColor(7);; 39 gGeoManager->GetVolume(""EAP4"")->SetLineColor(7);; 40 gGeoManager->GetVolume(""HTC1"")->SetLineColor(2);; 41 ; 42 TGeoNode* top = gGeoManager->GetTopVolume()->FindNode(""CMSE_1"");; 43 TGeoNode* n = getNodeFromPath(top, ""MUON_1"");; 44 return top;; 45}; 46 ; 47TGeoNode* rootgeom(); 48{; 49 TGeoManager *geom = new TGeoManager(""simple1"", ""Simple geometry"");; 50 ; 51 TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; 52 TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; 53// //--- define some media; 54 TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; 55 TGeoMedium *",MatchSource.WIKI,doc/master/eveGeoBrowser_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html
https://root.cern/doc/master/eveGeoBrowser_8C_source.html:6957,Testability,test,testCmsGeo,6957,"ombi1);; 134 ; 135 //--- make letter 'T'; 136 TGeoVolume *T = geom->MakeBox(""T"", Vacuum, 25., 25., 5.);; 137 T->SetVisibility(kFALSE);; 138 TGeoVolume *bar5 = geom->MakeBox(""bar5"", Al, 5., 20., 5.);; 139 bar5->SetLineColor(kBlue);; 140 T->AddNode(bar5, 1, tr8);; 141 TGeoVolume *bar6 = geom->MakeBox(""bar6"", Al, 17.5, 5., 5.);; 142 ; 143 bar6->SetLineColor(kBlue);; 144 T->AddNode(bar6, 1, tr9);; 145 ; 146 rootbox->AddNode(R, 1, tr10);; 147 rootbox->AddNode(O, 1, tr11);; 148 rootbox->AddNode(O, 2, tr12);; 149 rootbox->AddNode(T, 1, tr13);; 150 ; 151 replica->AddNode(rootbox, 1, tr14);; 152 replica->AddNode(rootbox, 2, combi2);; 153 replica->AddNode(rootbox, 3, combi3);; 154 replica->AddNode(rootbox, 4, combi4);; 155 replica->AddNode(rootbox, 5, combi5);; 156 replica->AddNode(rootbox, 6, combi6);; 157 ; 158 top->AddNode(replica, 1, new TGeoTranslation(-150, -150, 0));; 159 top->AddNode(replica, 2, new TGeoTranslation(150, -150, 0));; 160 top->AddNode(replica, 3, new TGeoTranslation(150, 150, 0));; 161 top->AddNode(replica, 4, new TGeoTranslation(-150, 150, 0));; 162 ; 163 //--- close the geometry; 164 geom->CloseGeometry();; 165 return gGeoManager->GetTopNode();; 166}; 167 ; 168 ; 169void eveGeoBrowser(bool showDet = true); 170{; 171 auto eveMng = REX::REveManager::Create();; 172 // eveMng->AllowMultipleRemoteConnections(false, false);; 173 ; 174 TGeoNode *gn;; 175 int vislevel = 4;; 176 if (showDet) {; 177 gn = testCmsGeo();; 178 vislevel = 2;; 179 } else {; 180 gn = rootgeom();; 181 vislevel = 8;; 182 }; 183 ; 184 // initialize RGeomDesc from TGeoNode; 185 auto data = new REX::REveGeoTopNodeData();; 186 data->SetTNode(gn);; 187 data->RefDescription().SetVisLevel(vislevel);; 188 ; 189 // make geoTable; 190 auto scene = eveMng->SpawnNewScene(""GeoSceneTable"");; 191 auto view = eveMng->SpawnNewViewer(""GeoTable"");; 192 view->AddScene(scene);; 193 scene->AddElement(data);; 194 ; 195 // 3D representation; 196 auto geoViz = new REX::REveGeoTopNodeViz();; 197 geoViz->SetGeoData",MatchSource.WIKI,doc/master/eveGeoBrowser_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html
https://root.cern/doc/master/eveGeoBrowser_8C_source.html:13456,Testability,test,testCmsGeoTGeoNode,13456," ...Definition TGeoMedium.h:23; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoNode::GetVolumeTGeoVolume * GetVolume() constDefinition TGeoNode.h:99; TGeoRotationClass describing rotations.Definition TGeoMatrix.h:168; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideset visibility of this volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::FindNodeTGeoNode * FindNode(const char *name) constsearch a daughter inside the list of nodesDefinition TGeoVolume.cxx:1721; eveMngROOT::Experimental::REveManager * eveMngDefinition collection_proxies.C:59; eveGeoBrowservoid eveGeoBrowser(bool showDet=true)Definition eveGeoBrowser.C:169; getNodeFromPathTGeoNode * getNodeFromPath(TGeoNode *top, std::string path)Definition eveGeoBrowser.C:9; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47; testCmsGeoTGeoNode * testCmsGeo()Definition eveGeoBrowser.C:20; nconst Int_t nDefinition legend1.C:16; ROOT::ExperimentalDefinition RDirectory.hxx:30. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/eveGeoBrowser_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html
https://root.cern/doc/master/eveGeoBrowser_8C_source.html:13477,Testability,test,testCmsGeo,13477," ...Definition TGeoMedium.h:23; TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoNode::GetVolumeTGeoVolume * GetVolume() constDefinition TGeoNode.h:99; TGeoRotationClass describing rotations.Definition TGeoMatrix.h:168; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::SetVisibilityvoid SetVisibility(Bool_t vis=kTRUE) overrideset visibility of this volumeDefinition TGeoVolume.cxx:2347; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::InvisibleAllvoid InvisibleAll(Bool_t flag=kTRUE)Make volume and each of it daughters (in)visible.Definition TGeoVolume.cxx:795; TGeoVolume::SetLineColorvoid SetLineColor(Color_t lcolor) overrideSet the line color.Definition TGeoVolume.cxx:2169; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; TGeoVolume::FindNodeTGeoNode * FindNode(const char *name) constsearch a daughter inside the list of nodesDefinition TGeoVolume.cxx:1721; eveMngROOT::Experimental::REveManager * eveMngDefinition collection_proxies.C:59; eveGeoBrowservoid eveGeoBrowser(bool showDet=true)Definition eveGeoBrowser.C:169; getNodeFromPathTGeoNode * getNodeFromPath(TGeoNode *top, std::string path)Definition eveGeoBrowser.C:9; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47; testCmsGeoTGeoNode * testCmsGeo()Definition eveGeoBrowser.C:20; nconst Int_t nDefinition legend1.C:16; ROOT::ExperimentalDefinition RDirectory.hxx:30. tutorialseve7eveGeoBrowser.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/eveGeoBrowser_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/eveGeoBrowser_8C_source.html
https://root.cern/doc/master/event_8C.html:2747,Usability,simpl,simple,2747,"PaveText(4,11,6,12);; p6->SetTextAlign(12);; p6->SetFillColor(42);; p6->AddText(""10 bytes"");; p6->Draw();; TText text;; text.SetTextAlign(12);; text.SetTextSize(0.04);; text.SetTextFont(72);; text.DrawText(6.2,11.5,""Header:Event_flag"");; text.DrawText(7.2,9.5,""Trigger_Info"");; text.DrawText(8.2,7.5,""Muon_Detector: TOF"");; text.DrawText(9.2,5.5,""Calorimeters"");; text.DrawText(10.2,3.5,""Forward_Detectors"");; text.DrawText(11.2,1.5,""TPCs"");; }; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; TTextBase class for several text objects.Definition TText.h:22; lineTLine * lineDefinition entrylistblock_figure1.C:235; c1return c1Definition legend1.C:41; arrowDefinition RArrowDS.hxx:17; AuthorRene Brun ; Definition in file event.C. tutorialsgraphicsevent.C. ROOT master - Refere",MatchSource.WIKI,doc/master/event_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/event_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:1414,Availability,error,errors,1414,"he predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char ",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:2362,Availability,error,error,2362," the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF3.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitRe",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:3008,Availability,error,error,3008,"esult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF3.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; R",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:4572,Availability,error,errors,4572,"::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF3A 3-Dim function with parameters.Definition TF3.h:28; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; AuthorLorenzo Moneta ; Definition in file exampleFit3D.C. tutorialsfitexampleFit3D.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:312,Integrability,depend,depends,312,". ROOT: tutorials/fit/exampleFit3D.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. exampleFit3D.C File ReferenceTutorials  Fit Tutorials. Detailed Description; example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 prob",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:1591,Integrability,wrap,wrapped,1591,"5; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF3.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize vo",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:1632,Integrability,interface,interface,1632,"5; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF3.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize vo",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:4124,Integrability,interface,interface,4124,":52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF3A 3-Dim function with parameters.Definition TF3.h:28; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; AuthorLorenzo Moneta ; Definition in",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:4264,Integrability,interface,interface,4264,"::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF3A 3-Dim function with parameters.Definition TF3.h:28; TRandom2Random number generator class based on the maximally quidistributed combined Tausworthe generator by ...Definition TRandom2.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; AuthorLorenzo Moneta ; Definition in file exampleFit3D.C. tutorialsfitexampleFit3D.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:325,Modifiability,variab,variables,325,". ROOT: tutorials/fit/exampleFit3D.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. exampleFit3D.C File ReferenceTutorials  Fit Tutorials. Detailed Description; example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 prob",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:3528,Performance,perform,performing,3528,"GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *ind",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:3921,Performance,perform,performed,3921,"WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TF3A 3-Dim function with parameters.Definition TF3.h:28; TRandom2Random number generator class based on the maximally quidistributed combined Tau",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:302,Safety,predict,predictor,302,". ROOT: tutorials/fit/exampleFit3D.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. exampleFit3D.C File ReferenceTutorials  Fit Tutorials. Detailed Description; example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 prob",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:1383,Safety,predict,predictor,1383,"he predictor depends on 3 variables ; In the case of 1 or 2D one can use the TGraph classes but since no TGraph3D class exists this tutorial provide an example of fitting 3D points; ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 993.065; NDf = 997; Edm = 2.2677e-24; NCalls = 7; p0 = 0.993546 +/- 0.00475134 ; p1 = 0.99397 +/- 0.00434249 ; p2 = 0.997895 +/- 0.000545663 ; Good fit : p-value = 0.529221; ; ; #include ""TRandom2.h""; #include ""TF3.h""; #include ""TError.h""; #include ""Fit/BinData.h""; #include ""Fit/Fitter.h""; #include ""Math/WrappedMultiTF1.h""; ; void exampleFit3D() {; ; const int n = 1000;; double x[n], y[n], z[n], v[n];; double ev = 0.1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char ",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exampleFit3D_8C.html:1974,Testability,test,test,1974,"1;; ; // generate the data; TRandom2 r;; for (int i = 0; i < n; ++i) {; x[i] = r.Uniform(0,10);; y[i] = r.Uniform(0,10);; z[i] = r.Uniform(0,10);; v[i] = sin(x[i] ) + cos(y[i]) + z[i] + r.Gaus(0,ev);; }; ; // create a 3d binned data structure; ROOT::Fit::BinData data(n,3);; double xx[3];; for(int i = 0; i < n; ++i) {; xx[0] = x[i];; xx[1] = y[i];; xx[2] = z[i];; // add the 3d-data coordinate, the predictor value (v[i]) and its errors; data.Add(xx, v[i], ev);; }; ; TF3 * f3 = new TF3(""f3"",""[0] * sin(x) + [1] * cos(y) + [2] * z"",0,10,0,10,0,10);; f3->SetParameters(2,2,2);; ROOT::Fit::Fitter fitter;; // wrapped the TF1 in a IParamMultiFunction interface for the Fitter class; ROOT::Math::WrappedMultiTF1 wf(*f3,3);; fitter.SetFunction(wf);; //; bool ret = fitter.Fit(data);; if (ret) {; const ROOT::Fit::FitResult & res = fitter.Result();; // print result (should be around 1); res.Print(std::cout);; // copy all fit result info (values, chi2, etc..) in TF3; f3->SetFitResult(res);; // test fit p-value (chi2 probability); double prob = res.Prob();; if (prob < 1.E-2); Error(""exampleFit3D"",""Bad data fit - fit p-value is %f"",prob);; else; std::cout << ""Good fit : p-value = "" << prob << std::endl;; ; }; else; Error(""exampleFit3D"",""3D fit failed"");; }; BinData.h; Fitter.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF3.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; WrappedMultiTF1.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates,",MatchSource.WIKI,doc/master/exampleFit3D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exampleFit3D_8C.html
https://root.cern/doc/master/exclusiongraph2_8C.html:5586,Testability,log,log,5586,"nition RSha256.hxx:101; TAttAxis::SetLabelSizevirtual void SetLabelSize(Float_t size=0.04)Set size of axis labels.Definition TAttAxis.cxx:203; TAttAxis::SetTickLengthvirtual void SetTickLength(Float_t length=0.03)Set tick mark length.Definition TAttAxis.cxx:284; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TAxis::SetMoreLogLabelsvoid SetMoreLogLabels(Bool_t more=kTRUE)Set the kMoreLogLabels bit flag When this option is selected more labels are drawn when in log scale ...Definition TAxis.h:223; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TGraph::SetNamevoid SetName(const char *name="""") overrideSet graph name.Definition TGraph.cxx:2381; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the ",MatchSource.WIKI,doc/master/exclusiongraph2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exclusiongraph2_8C.html
https://root.cern/doc/master/exec1_8C.html:1285,Availability,error,error,1285,". master. Reference Guide ; . . Loading...; Searching...; No Matches. exec1.C File ReferenceTutorials  Histograms tutorials. Detailed Description; Echo object at mouse position. ; Example of macro called when a pad is redrawn one must create a TExec object in the following way gPad->AddExec(""ex1"", "".x exec1.C"");; gPad#define gPadDefinition TVirtualPad.h:308; this macro prints the bin number and the bin content when one clicks on the histogram contour of any histogram in a pad; ; ; void exec1(); {; if (!gPad) {; Error(""exec1"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; Int_t event = gPad->GetEvent();; int px = gPad->GetEventX();; TObject *select = gPad->GetSelected();; ; if (select && select->InheritsFrom(TH1::Class())) {; TH1 *h = (TH1*)select;; Float_t xx = gPad->AbsPixeltoX(px);; Float_t x = gPad->PadtoX(xx);; Int_t binx = h->GetXaxis()->FindBin(x);; printf(""event=%d, hist:%s, bin=%d, content=%f\n"", event, h->GetName(), binx, h->GetBinContent(binx));; }; }; ; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Classstatic TClass * Class(); TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; xDouble_t x[n]Definition legend1.C:17; AuthorsRene Brun, Sergey Linev ; Definition in file exec1.C. tutorialshistexec1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/exec1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exec1_8C.html
https://root.cern/doc/master/exec1_8C.html:1771,Modifiability,inherit,inherits,1771,". master. Reference Guide ; . . Loading...; Searching...; No Matches. exec1.C File ReferenceTutorials  Histograms tutorials. Detailed Description; Echo object at mouse position. ; Example of macro called when a pad is redrawn one must create a TExec object in the following way gPad->AddExec(""ex1"", "".x exec1.C"");; gPad#define gPadDefinition TVirtualPad.h:308; this macro prints the bin number and the bin content when one clicks on the histogram contour of any histogram in a pad; ; ; void exec1(); {; if (!gPad) {; Error(""exec1"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; Int_t event = gPad->GetEvent();; int px = gPad->GetEventX();; TObject *select = gPad->GetSelected();; ; if (select && select->InheritsFrom(TH1::Class())) {; TH1 *h = (TH1*)select;; Float_t xx = gPad->AbsPixeltoX(px);; Float_t x = gPad->PadtoX(xx);; Int_t binx = h->GetXaxis()->FindBin(x);; printf(""event=%d, hist:%s, bin=%d, content=%f\n"", event, h->GetName(), binx, h->GetBinContent(binx));; }; }; ; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Classstatic TClass * Class(); TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; xDouble_t x[n]Definition legend1.C:17; AuthorsRene Brun, Sergey Linev ; Definition in file exec1.C. tutorialshistexec1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/exec1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exec1_8C.html
https://root.cern/doc/master/exec2_8C.html:2794,Availability,error,error,2794," TH2 *h = dynamic_cast<TH2 *>(select);; if(!h) return;; ; //erase old position and draw a line at current position; gVirtualX->DrawLine(pxmin, py, pxmax, py);; gPad->SetUniqueID(py);; ; Float_t upy = gPad->AbsPixeltoY(py);; Float_t y = gPad->PadtoY(upy);; ; //create or set the new canvas c2; auto padsav = gPad;; if(c2) delete c2->GetPrimitive(""Projection"");; else c2 = new TCanvas(""c2"",""Projection Canvas"",710,10,700,500);; c2->SetGrid();; c2->cd();; ; //draw slice corresponding to mouse position; Int_t biny = h->GetYaxis()->FindBin(y);; TH1D *hp = h->ProjectionX("""",biny,biny);; hp->SetName(""Projection"");; hp->SetTitle(TString::Format(""Projection of biny=%d"",biny));; hp->Fit(""gaus"",""ql"");; c2->Update();; ; padsav->cd();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gROOT#define gROOTDefinition TROOT.h:406; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; ROOT::Fit::FitResult::Updatebool Update(const std::shared_ptr< ROOT::Math::Minimizer > &min, const ROOT::Fit::FitConfig &fconfig, bool isValid, unsigned int ncalls=0)Update the fit result with a new minimization status To be run only if same fit is performed with sam...Definition FitResult.cxx:224; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH2Service class ",MatchSource.WIKI,doc/master/exec2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exec2_8C.html
https://root.cern/doc/master/exec2_8C.html:1020,Energy Efficiency,power,powerful,1020,"hist/exec2.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. exec2.C File ReferenceTutorials  Histograms tutorials. Detailed Description; Echo object at mouse position and show a graphics line. ; Example of macro called when a mouse event occurs in a pad.; Example: TFile::Open(""hsimple.root"");; hpxpy->Draw(""colz"");; gPad->AddExec(""ex2"", "".x exec2.C"");; gPad#define gPadDefinition TVirtualPad.h:308; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; When moving the mouse in the canvas, a second canvas shows the projection along X of the bin corresponding to the Y position of the mouse. The resulting histogram is fitted with a gaussian. A ""dynamic"" line shows the current bin position in Y. This more elaborated example can be used as a starting point to develop more powerful interactive applications exploiting CLING as a development engine.; ; void exec2(); {; if (!gPad) {; Error(""exec2"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; int px = gPad->GetEventX();; int py = gPad->GetEventY();; float uxmin = gPad->GetUxmin();; float uxmax = gPad->GetUxmax();; int pxmin = gPad->XtoAbsPixel(uxmin);; int pxmax = gPad->XtoAbsPixel(uxmax);; TObject *select = gPad->GetSelected();; TCanvas *c2 = (TCanvas*)gROOT->GetListOfCanvases()->FindObject(""c2"");; ; gPad->GetCanvas()->FeedbackMode(kTRUE);; ; int pyold = gPad->GetUniqueID(); // misuse of pad unique for last draw position; ; if (pyold && c2) {; // erase line at old position; gVirtualX->DrawLine(pxmin, pyold, pxmax, pyold);; gPad->SetUniqueID(0);; }; ; TH2 *h = dynamic_cast<TH2 *>(select);; if(!h) return;; ; //erase old position and draw a line at current position; gVirtualX->DrawLine(pxmin, py, pxmax, py);; gPad->SetUniqueID(py);; ; Float_t upy = gPad->AbsPixeltoY(py);; Float_t y",MatchSource.WIKI,doc/master/exec2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exec2_8C.html
https://root.cern/doc/master/exec2_8C.html:3181,Performance,perform,performed,3181,"e new canvas c2; auto padsav = gPad;; if(c2) delete c2->GetPrimitive(""Projection"");; else c2 = new TCanvas(""c2"",""Projection Canvas"",710,10,700,500);; c2->SetGrid();; c2->cd();; ; //draw slice corresponding to mouse position; Int_t biny = h->GetYaxis()->FindBin(y);; TH1D *hp = h->ProjectionX("""",biny,biny);; hp->SetName(""Projection"");; hp->SetTitle(TString::Format(""Projection of biny=%d"",biny));; hp->Fit(""gaus"",""ql"");; c2->Update();; ; padsav->cd();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gROOT#define gROOTDefinition TROOT.h:406; gVirtualX#define gVirtualXDefinition TVirtualX.h:337; ROOT::Fit::FitResult::Updatebool Update(const std::shared_ptr< ROOT::Math::Minimizer > &min, const ROOT::Fit::FitConfig &fconfig, bool isValid, unsigned int ncalls=0)Update the fit result with a new minimization status To be run only if same fit is performed with sam...Definition FitResult.cxx:224; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::SetTitlevoid SetTitle(const char *title) overrideChange/set the title.Definition TH1.cxx:6718; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::SetNamevoid SetName(const char *name) overrideChange the name of this histogram.Definition TH1.cxx:8960; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set ",MatchSource.WIKI,doc/master/exec2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/exec2_8C.html
https://root.cern/doc/master/Expression_8h_source.html:1953,Integrability,wrap,wrapper,1953,"ced by rows, cols; 29// 10 Okt 2001 (TG) added print() and operator<<() for Expr class; 30//; 31// ********************************************************************; 32 ; 33/**; 34\defgroup Expression Expression Template Classes; 35\ingroup SMatrixGroup; 36*/; 37 ; 38//==============================================================================; 39// Expr: class representing SVector expressions; 40//=============================================================================; 41 ; 42// modified BinaryOp with two extension BinaryOpCopyL and BinaryOpCopyR to store the; 43// object in BinaryOp by value and not reference. When used with constant BinaryOp reference give problems; 44// on some compilers (like Windows) where a temporary Constant object is ccreated and then destructed; 45 ; 46 ; 47#include <iomanip>; 48#include <iostream>; 49 ; 50namespace ROOT {; 51 ; 52 namespace Math {; 53 ; 54 ; 55 ; 56// template <class T, unsigned int D, unsigned int D2> class MatRepStd;; 57 ; 58/**; 59 Expression wrapper class for Vector objects; 60 ; 61 @ingroup Expression; 62*/; 63template <class ExprType, class T, unsigned int D >; 64class VecExpr {; 65 ; 66public:; 67 typedef T value_type;; 68 ; 69 ///; 70 VecExpr(const ExprType& rhs) :; 71 rhs_(rhs) {}; 72 ; 73 ///; 74 ~VecExpr() {}; 75 ; 76 ///; 77 inline T apply(unsigned int i) const {; 78 return rhs_.apply(i);; 79 }; 80 ; 81 inline T operator() (unsigned int i) const {; 82 return rhs_.apply(i);; 83 }; 84 ; 85 ; 86#ifdef OLD_IMPL; 87 ///; 88 static const unsigned int rows = D;; 89 ///; 90 ///static const unsigned int cols = D2;; 91#else; 92 // use enumerations; 93 enum {; 94 ; 95 kRows = D; 96 ; 97 };; 98#endif; 99 ; 100 /**; 101 function to determine if any use operand; 102 is being used (has same memory address); 103 */; 104 inline bool IsInUse (const T * p) const {; 105 return rhs_.IsInUse(p);; 106 }; 107 ; 108 ; 109 /// used by operator<<(); 110 std::ostream& print(std::ostream& os) const {; 111 os.setf(std::ios::rig",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/Expression_8h_source.html:3239,Integrability,wrap,wrapper,3239," 81 inline T operator() (unsigned int i) const {; 82 return rhs_.apply(i);; 83 }; 84 ; 85 ; 86#ifdef OLD_IMPL; 87 ///; 88 static const unsigned int rows = D;; 89 ///; 90 ///static const unsigned int cols = D2;; 91#else; 92 // use enumerations; 93 enum {; 94 ; 95 kRows = D; 96 ; 97 };; 98#endif; 99 ; 100 /**; 101 function to determine if any use operand; 102 is being used (has same memory address); 103 */; 104 inline bool IsInUse (const T * p) const {; 105 return rhs_.IsInUse(p);; 106 }; 107 ; 108 ; 109 /// used by operator<<(); 110 std::ostream& print(std::ostream& os) const {; 111 os.setf(std::ios::right,std::ios::adjustfield);; 112 unsigned int i=0;; 113 os << ""[ "";; 114 for(; i<D-1; ++i) {; 115 os << apply(i) << "", "";; 116 }; 117 os << apply(i);; 118 os << "" ]"";; 119 ; 120 return os;; 121 }; 122 ; 123private:; 124 ExprType rhs_; // cannot be a reference!; 125};; 126 ; 127 ; 128/**; 129 Expression wrapper class for Matrix objects; 130 ; 131 @ingroup Expression; 132*/; 133 ; 134template <class T, unsigned int D, unsigned int D2> class MatRepStd;; 135 ; 136template <class ExprType, class T, unsigned int D, unsigned int D2 = 1,; 137 class R1=MatRepStd<T,D,D2> >; 138class Expr {; 139public:; 140 typedef T value_type;; 141 ; 142 ///; 143 Expr(const ExprType& rhs) :; 144 rhs_(rhs) {}; 145 ; 146 ///; 147 ~Expr() {}; 148 ; 149 ///; 150 inline T apply(unsigned int i) const {; 151 return rhs_.apply(i);; 152 }; 153 inline T operator() (unsigned int i, unsigned j) const {; 154 return rhs_(i,j);; 155 }; 156 ; 157 /**; 158 function to determine if any use operand; 159 is being used (has same memory address); 160 */; 161 inline bool IsInUse (const T * p) const {; 162 return rhs_.IsInUse(p);; 163 }; 164 ; 165 ; 166 ; 167#ifdef OLD_IMPL; 168 ///; 169 static const unsigned int rows = D;; 170 ///; 171 static const unsigned int cols = D2;; 172#else; 173 // use enumerations; 174 enum {; 175 ///; 176 kRows = D,; 177 ///; 178 kCols = D2; 179 };; 180#endif; 181 ; 182 /// used by operator",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/Expression_8h_source.html:15392,Integrability,wrap,wrapper,15392,"nstant(const T &rhs)Definition Expression.h:403; ROOT::Math::ExprDefinition Expression.h:138; ROOT::Math::Expr::applyT apply(unsigned int i) constDefinition Expression.h:150; ROOT::Math::Expr::printstd::ostream & print(std::ostream &os) constused by operator<<() simplify to use apply(i,j)Definition Expression.h:184; ROOT::Math::Expr::ExprExpr(const ExprType &rhs)Definition Expression.h:143; ROOT::Math::Expr::value_typeT value_typeDefinition Expression.h:140; ROOT::Math::Expr::rhs_ExprType rhs_Definition Expression.h:203; ROOT::Math::Expr::operator()T operator()(unsigned int i, unsigned j) constDefinition Expression.h:153; ROOT::Math::Expr::kCols@ kColsDefinition Expression.h:178; ROOT::Math::Expr::kRows@ kRowsDefinition Expression.h:176; ROOT::Math::Expr::~Expr~Expr()Definition Expression.h:147; ROOT::Math::Expr::IsInUsebool IsInUse(const T *p) constfunction to determine if any use operand is being used (has same memory address)Definition Expression.h:161; ROOT::Math::MatRepStdExpression wrapper class for Matrix objects.Definition MatrixRepresentationsStatic.h:54; ROOT::Math::UnaryOpUnaryOperation class A class representing unary operators in the parse tree.Definition Expression.h:361; ROOT::Math::UnaryOp::rhs_const RHS & rhs_Definition Expression.h:384; ROOT::Math::UnaryOp::applyT apply(unsigned int i) constDefinition Expression.h:371; ROOT::Math::UnaryOp::UnaryOpUnaryOp(Operator, const RHS &rhs)Definition Expression.h:364; ROOT::Math::UnaryOp::~UnaryOp~UnaryOp()Definition Expression.h:368; ROOT::Math::UnaryOp::IsInUsebool IsInUse(const T *p) constDefinition Expression.h:378; ROOT::Math::UnaryOp::operator()T operator()(unsigned int i, unsigned int j) constDefinition Expression.h:374; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; ROOT::Math::VecExpr::applyT apply(unsigned int i) constDefinition Expression.h:77; ROOT::Math::VecExpr::rhs_ExprType rhs_Definition Expression.h:124; ROOT::Math::VecExpr::value_typeT value_typeDe",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/Expression_8h_source.html:16133,Integrability,wrap,wrapper,16133,":176; ROOT::Math::Expr::~Expr~Expr()Definition Expression.h:147; ROOT::Math::Expr::IsInUsebool IsInUse(const T *p) constfunction to determine if any use operand is being used (has same memory address)Definition Expression.h:161; ROOT::Math::MatRepStdExpression wrapper class for Matrix objects.Definition MatrixRepresentationsStatic.h:54; ROOT::Math::UnaryOpUnaryOperation class A class representing unary operators in the parse tree.Definition Expression.h:361; ROOT::Math::UnaryOp::rhs_const RHS & rhs_Definition Expression.h:384; ROOT::Math::UnaryOp::applyT apply(unsigned int i) constDefinition Expression.h:371; ROOT::Math::UnaryOp::UnaryOpUnaryOp(Operator, const RHS &rhs)Definition Expression.h:364; ROOT::Math::UnaryOp::~UnaryOp~UnaryOp()Definition Expression.h:368; ROOT::Math::UnaryOp::IsInUsebool IsInUse(const T *p) constDefinition Expression.h:378; ROOT::Math::UnaryOp::operator()T operator()(unsigned int i, unsigned int j) constDefinition Expression.h:374; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; ROOT::Math::VecExpr::applyT apply(unsigned int i) constDefinition Expression.h:77; ROOT::Math::VecExpr::rhs_ExprType rhs_Definition Expression.h:124; ROOT::Math::VecExpr::value_typeT value_typeDefinition Expression.h:67; ROOT::Math::VecExpr::VecExprVecExpr(const ExprType &rhs)Definition Expression.h:70; ROOT::Math::VecExpr::IsInUsebool IsInUse(const T *p) constfunction to determine if any use operand is being used (has same memory address)Definition Expression.h:104; ROOT::Math::VecExpr::operator()T operator()(unsigned int i) constDefinition Expression.h:81; ROOT::Math::VecExpr::kRows@ kRowsDefinition Expression.h:95; ROOT::Math::VecExpr::printstd::ostream & print(std::ostream &os) constused by operator<<()Definition Expression.h:110; ROOT::Math::VecExpr::~VecExpr~VecExpr()Definition Expression.h:74; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which does",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/Expression_8h_source.html:4563,Safety,avoid,avoid,4563,"hs) :; 144 rhs_(rhs) {}; 145 ; 146 ///; 147 ~Expr() {}; 148 ; 149 ///; 150 inline T apply(unsigned int i) const {; 151 return rhs_.apply(i);; 152 }; 153 inline T operator() (unsigned int i, unsigned j) const {; 154 return rhs_(i,j);; 155 }; 156 ; 157 /**; 158 function to determine if any use operand; 159 is being used (has same memory address); 160 */; 161 inline bool IsInUse (const T * p) const {; 162 return rhs_.IsInUse(p);; 163 }; 164 ; 165 ; 166 ; 167#ifdef OLD_IMPL; 168 ///; 169 static const unsigned int rows = D;; 170 ///; 171 static const unsigned int cols = D2;; 172#else; 173 // use enumerations; 174 enum {; 175 ///; 176 kRows = D,; 177 ///; 178 kCols = D2; 179 };; 180#endif; 181 ; 182 /// used by operator<<(); 183 /// simplify to use apply(i,j); 184 std::ostream& print(std::ostream& os) const {; 185 os.setf(std::ios::right,std::ios::adjustfield);; 186 os << ""[ "";; 187 for (unsigned int i=0; i < D; ++i) {; 188 unsigned int d2 = D2; // to avoid some annoying warnings in case of vectors (D2 = 0); 189 for (unsigned int j=0; j < D2; ++j) {; 190 os << std::setw(12) << this->operator() (i,j);; 191 if ((!((j+1)%12)) && (j < d2-1)); 192 os << std::endl << "" ..."";; 193 }; 194 if (i != D - 1); 195 os << std::endl << "" "";; 196 }; 197 os << "" ]"";; 198 ; 199 return os;; 200 }; 201 ; 202private:; 203 ExprType rhs_; // cannot be a reference!; 204};; 205 ; 206//==============================================================================; 207// operator<<; 208//==============================================================================; 209template <class A, class T, unsigned int D>; 210inline std::ostream& operator<<(std::ostream& os, const VecExpr<A,T,D>& rhs) {; 211 return rhs.print(os);; 212}; 213 ; 214template <class A, class T, unsigned int D1, unsigned int D2, class R1>; 215inline std::ostream& operator<<(std::ostream& os, const Expr<A,T,D1,D2,R1>& rhs) {; 216 return rhs.print(os);; 217}; 218 ; 219/**; 220 BinaryOperation class; 221 A class representing binary op",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/Expression_8h_source.html:4340,Usability,simpl,simplify,4340," 129 Expression wrapper class for Matrix objects; 130 ; 131 @ingroup Expression; 132*/; 133 ; 134template <class T, unsigned int D, unsigned int D2> class MatRepStd;; 135 ; 136template <class ExprType, class T, unsigned int D, unsigned int D2 = 1,; 137 class R1=MatRepStd<T,D,D2> >; 138class Expr {; 139public:; 140 typedef T value_type;; 141 ; 142 ///; 143 Expr(const ExprType& rhs) :; 144 rhs_(rhs) {}; 145 ; 146 ///; 147 ~Expr() {}; 148 ; 149 ///; 150 inline T apply(unsigned int i) const {; 151 return rhs_.apply(i);; 152 }; 153 inline T operator() (unsigned int i, unsigned j) const {; 154 return rhs_(i,j);; 155 }; 156 ; 157 /**; 158 function to determine if any use operand; 159 is being used (has same memory address); 160 */; 161 inline bool IsInUse (const T * p) const {; 162 return rhs_.IsInUse(p);; 163 }; 164 ; 165 ; 166 ; 167#ifdef OLD_IMPL; 168 ///; 169 static const unsigned int rows = D;; 170 ///; 171 static const unsigned int cols = D2;; 172#else; 173 // use enumerations; 174 enum {; 175 ///; 176 kRows = D,; 177 ///; 178 kCols = D2; 179 };; 180#endif; 181 ; 182 /// used by operator<<(); 183 /// simplify to use apply(i,j); 184 std::ostream& print(std::ostream& os) const {; 185 os.setf(std::ios::right,std::ios::adjustfield);; 186 os << ""[ "";; 187 for (unsigned int i=0; i < D; ++i) {; 188 unsigned int d2 = D2; // to avoid some annoying warnings in case of vectors (D2 = 0); 189 for (unsigned int j=0; j < D2; ++j) {; 190 os << std::setw(12) << this->operator() (i,j);; 191 if ((!((j+1)%12)) && (j < d2-1)); 192 os << std::endl << "" ..."";; 193 }; 194 if (i != D - 1); 195 os << std::endl << "" "";; 196 }; 197 os << "" ]"";; 198 ; 199 return os;; 200 }; 201 ; 202private:; 203 ExprType rhs_; // cannot be a reference!; 204};; 205 ; 206//==============================================================================; 207// operator<<; 208//==============================================================================; 209template <class A, class T, unsigned int D>; 210inline std:",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/Expression_8h_source.html:14652,Usability,simpl,simplify,14652,"apply(unsigned int i) constDefinition Expression.h:244; ROOT::Math::BinaryOp::IsInUsebool IsInUse(const T *p) constDefinition Expression.h:251; ROOT::Math::BinaryOp::operator()T operator()(unsigned int i, unsigned int j) constDefinition Expression.h:247; ROOT::Math::ConstantConstant expression class A class representing constant expressions (literals) in the parse tree.Definition Expression.h:400; ROOT::Math::Constant::applyT apply(unsigned int) constDefinition Expression.h:410; ROOT::Math::Constant::rhs_const T rhs_Definition Expression.h:418; ROOT::Math::Constant::~Constant~Constant()Definition Expression.h:407; ROOT::Math::Constant::operator()T operator()(unsigned int, unsigned int) constDefinition Expression.h:412; ROOT::Math::Constant::ConstantConstant(const T &rhs)Definition Expression.h:403; ROOT::Math::ExprDefinition Expression.h:138; ROOT::Math::Expr::applyT apply(unsigned int i) constDefinition Expression.h:150; ROOT::Math::Expr::printstd::ostream & print(std::ostream &os) constused by operator<<() simplify to use apply(i,j)Definition Expression.h:184; ROOT::Math::Expr::ExprExpr(const ExprType &rhs)Definition Expression.h:143; ROOT::Math::Expr::value_typeT value_typeDefinition Expression.h:140; ROOT::Math::Expr::rhs_ExprType rhs_Definition Expression.h:203; ROOT::Math::Expr::operator()T operator()(unsigned int i, unsigned j) constDefinition Expression.h:153; ROOT::Math::Expr::kCols@ kColsDefinition Expression.h:178; ROOT::Math::Expr::kRows@ kRowsDefinition Expression.h:176; ROOT::Math::Expr::~Expr~Expr()Definition Expression.h:147; ROOT::Math::Expr::IsInUsebool IsInUse(const T *p) constfunction to determine if any use operand is being used (has same memory address)Definition Expression.h:161; ROOT::Math::MatRepStdExpression wrapper class for Matrix objects.Definition MatrixRepresentationsStatic.h:54; ROOT::Math::UnaryOpUnaryOperation class A class representing unary operators in the parse tree.Definition Expression.h:361; ROOT::Math::UnaryOp::rhs_const RHS ",MatchSource.WIKI,doc/master/Expression_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Expression_8h_source.html
https://root.cern/doc/master/feynman_8C.html:2730,Usability,simpl,simple,2730,"rlyArc(110, 30, 12.5*sqrt(2), 315, 45);; gluon1->Draw();; ; t.DrawLatex(135,6,""#bar{q}"");; t.DrawLatex(135,55,""q"");; t.DrawLatex(135,30,""g"");; c1->Update();; gStyle->SetLineWidth(linsav);; }; a#define a(i)Definition RSha256.hxx:99; Int_tint Int_tDefinition RtypesCore.h:45; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TArcCreate an Arc.Definition TArc.h:26; TAttLine::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCurlyArcImplements curly or wavy arcs used to draw Feynman diagrams.Definition TCurlyArc.h:16; TCurlyLineImplements curly or wavy polylines used to draw Feynman diagrams.Definition TCurlyLine.h:19; TCurlyLine::SetWavyvirtual void SetWavy()Set wavy.Definition TCurlyLine.cxx:369; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPolyLine::Drawvoid Draw(Option_t *option="""") overrideDraw this polyline with its current attributes.Definition TPolyLine.cxx:215; c1return c1Definition legend1.C:41; ginitstatic int ginitDefinition rsalib.cxx:256; lTLine lDefinition textangle.C:4; AuthorOtto Schaile ; Definition in file feynman.C. tutorialsgraphicsfeynman.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/feynman_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/feynman_8C.html
https://root.cern/doc/master/file_8C.html:3551,Testability,log,logical,3551,"wText(9.2, 10,""Deleted"");; hori->DrawText(9.2, 9.5,""Object"");; line->DrawLine( 6.9, 8.5, 10.5, 11);; line->DrawLine( 6.9, 11, 10.5, 8.5);; TText *tbig = new TText(17,9.75,""............"");; tbig->SetTextAlign(22);; tbig->SetTextSize(0.03);; tbig->Draw();; tbig->DrawText(2.6, 7, ""fBEGIN"");; tbig->DrawText(20., 7, ""fEND"");; arrow->DrawArrow( 2.6,7, 2.6,8.4,0.01,""|>"");; arrow->DrawArrow( 20,7, 20,8.4,0.01,""|>"");; ; //file header; TPaveText *header = new TPaveText(0.5,.2,9.4,6.5);; header->SetFillColor(44);; header->Draw();; TText *fh=header->AddText(""File Header"");; fh->SetTextAlign(22);; fh->SetTextSize(0.04);; header->SetTextSize(0.027);; header->SetTextAlign(12);; header->AddText("" "");; header->AddLine(0,0,0,0);; header->AddText(""\""root\"": Root File Identifier"");; header->AddText(""fVersion: File version identifier"");; header->AddText(""fBEGIN: Pointer to first data record"");; header->AddText(""fEND: Pointer to first free word at EOF"");; header->AddText(""fSeekFree: Pointer to FREE data record"");; header->AddText(""fNbytesFree: Number of bytes in FREE"");; header->AddText(""fNfree: Number of free data records"");; header->AddText(""fNbytesName: Number of bytes in name/title"");; header->AddText(""fUnits: Number of bytes for pointers"");; header->AddText(""fCompress: Compression level"");; ; //logical record header; TPaveText *lrecord = new TPaveText(10,0.2,19.5,6.5);; lrecord->SetFillColor(33);; lrecord->Draw();; TText *tlrh = lrecord->AddText(""Logical Record Header (TKEY)"");; tlrh->SetTextAlign(22);; tlrh->SetTextSize(0.04);; lrecord->SetTextSize(0.027);; lrecord->SetTextAlign(12);; lrecord->AddText("" "");; lrecord->AddLine(0,0,0,0);; lrecord->AddText(""fNbytes: Length of compressed object"");; lrecord->AddText(""fVersion: Key version identifier"");; lrecord->AddText(""fObjLen: Length of uncompressed object"");; lrecord->AddText(""fDatime: Date/Time when written to store"");; lrecord->AddText(""fKeylen: Number of bytes for the key"");; lrecord->AddText(""fCycle : Cycle number"");; lrecord->Ad",MatchSource.WIKI,doc/master/file_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/file_8C.html
https://root.cern/doc/master/file_8C.html:5260,Usability,simpl,simple,5260,"lrecord->AddText(""fSeekKey: Pointer to object on file"");; lrecord->AddText(""fSeekPdir: Pointer to directory on file"");; lrecord->AddText(""fClassName: class name of the object"");; lrecord->AddText(""fName: name of the object"");; lrecord->AddText(""fTitle: title of the object"");; ; c1->Update();; c1->Print(""file.png"");; }; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLine::DrawLinevirtual TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2)Draw this line with new coordinates.Definition TLine.cxx:103; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::AddLinevirtual TLine * AddLine(Double_t x1=0, Double_t y1=0, Double_t x2=0, Double_t y2=0)Add a new graphics line to this pavetext.Definition TPaveText.cxx:177; TPaveText::Drawvoi",MatchSource.WIKI,doc/master/file_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/file_8C.html
https://root.cern/doc/master/fillhistosauto2p_8C.html:332,Energy Efficiency,power,power-of-two,332,". ROOT: tutorials/hist/fillhistosauto2p.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fillhistosauto2p.C File ReferenceTutorials  Histograms tutorials. Detailed Description; Fill multiple histograms with different functions and automatic binning. ; Illustrates merging with the power-of-two autobin algorithm; ; OBJ: TStatistic min Mean = -0.219 +- 0.09858 RMS = 0.31172 Count = 10 Min = -0.7688 Max = 0.187; OBJ: TStatistic max Mean = 6.2275 +- 0.1806 RMS = 0.57103 Count = 10 Min = 5.5275 Max = 7.3222; OBJ: TStatistic dif Mean = 6.4465 +- 0.2203 RMS = 0.69652 Count = 10 Min = 5.3405 Max = 7.6243; OBJ: TStatistic mean Mean = 3.0008 +- 0.005044 RMS = 0.01595 Count = 10 Min = 2.9789 Max = 3.0264; OBJ: TStatistic rms Mean = 1.005 +- 0.01028 RMS = 0.032511 Count = 10 Min = 0.95837 Max = 1.0666; ent: 10010; TH1.Print Name = myh0, Entries= 10010, Total sum= 10004; TH1.Print Name = myhref, Entries= 10010, Total sum= 10010; ; #include ""TF1.h""; #include ""TH1D.h""; #include ""TMath.h""; #include ""TF1.h""; #include ""TCanvas.h""; #include ""TRandom3.h""; #include ""TStatistic.h""; #include ""TFile.h""; #include ""TStyle.h""; ; TF1 *gam = new TF1(""gam"", ""1/(1+0.1*x*0.1*x)"", -100., 100.);; TF1 *gam1 = new TF1(""gam"", ""1/(1+0.1*x*0.1*x)"", -1., .25);; TF1 *iga = new TF1(""inv gam"", ""1.-1/(1+0.1*x*0.1*x)"", -100., 100.);; TF1 *iga1 = new TF1(""inv gam"", ""1.-1/(1+0.1*x*0.1*x)"", -.5, 1.);; ; void fillhistosauto2p(unsigned opt = 1, unsigned n = 1001); {; ; UInt_t nh = 10;; UInt_t bsize = 1000;; ; TRandom3 rndm((Long64_t)time(0));; ; // Standard autobinning reference; auto href = new TH1D(""myhref"", ""current"", 50, 0., -1.);; href->SetBuffer(bsize);; ; // New autobinning 1-histo reference; auto href2 = new TH1D(""myhref"", ""Auto P2, sequential"", 50, 0., -1.);; href2->SetBit(TH1::kAutoBinPTwo);; href2->SetBuffer(bsize);; ; TList *hlist = new TList;; ; Int_t nbins = 50;; ; TStatistic x(""min""), y(""max""), d(""dif""), a(""mean""), r(""rms"");; for (UInt_t j = 0; j < nh;",MatchSource.WIKI,doc/master/fillhistosauto2p_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fillhistosauto2p_8C.html
https://root.cern/doc/master/fillhistosauto2p_8C.html:6333,Modifiability,variab,variable,6333,"omputation of statisti...Definition TH1.cxx:6925; TH1::kAutoBinPTwo@ kAutoBinPTwodifferent than 1.Definition TH1.h:174; TH1::Printvoid Print(Option_t *option="""") const overridePrint some global quantities for this histogram.Definition TH1.cxx:7009; TH1::GetEntriesvirtual Double_t GetEntries() constReturn the current number of entries.Definition TH1.cxx:4423; TH1::Mergevirtual Long64_t Merge(TCollection *list)Definition TH1.h:345; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstTObject * First() const overrideReturn the first object in the list. Returns 0 when list is empty.Definition TList.cxx:657; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TStatisticStatistical variable, defined by its mean and variance (RMS).Definition TStatistic.h:33; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; c3return c3Definition legend3.C:15; DateNovember 2017 ; AuthorGerardo Ganis ; Definition in file fillhistosauto2p.C. tutorialshistfillhistosauto2p.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fillhistosauto2p_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fillhistosauto2p_8C.html
https://root.cern/doc/master/fillpatterns_8C_source.html:965,Availability,avail,available,965,". ROOT: core/base/doc/macros/fillpatterns.C Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fillpatterns.C. Go to the documentation of this file. 1void box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2); 2{; 3 // Draw an box using the fill pattern ""pat"" with the ""pat"" value; 4 // written on top.; 5 ; 6 TBox b;; 7 b.SetFillColor(1);; 8 b.SetFillStyle(pat); b.DrawBox(x1,y1,x2,y2);; 9 b.SetFillStyle(0) ; b.DrawBox(x1,y1,x2,y2);; 10 b.SetFillColor(0) ; b.SetFillStyle(1000) ;; 11 Double_t dx = (x2-x1)/3;; 12 Double_t dy = (y2-y1)/3;; 13 Double_t h = (y2-y1)/2.5;; 14 b.DrawBox(x1+dx, y1+dy, x2-dx, y2-dy);; 15 b.SetFillStyle(0);; 16 b.DrawBox(x1+dx, y1+dy, x2-dx, y2-dy);; 17 ; 18 TLatex l;; 19 l.SetTextAlign(22); l.SetTextSize(h);; 20 l.DrawLatex((x1+x2)/2, (y1+y2)/2, Form(""%d"",pat));; 21}; 22 ; 23TCanvas * fillpatterns(int w=500, int h=700); 24{; 25 // Fill patterns example. This macro shows the available fill patterns.; 26 // The first table displays the 25 fixed patterns. They cannot be; 27 // customized unlike the hatches displayed in the second table which be; 28 // cutomized using:; 29 // - gStyle->SetHatchesSpacing() to define the spacing between hatches.; 30 // - gStyle->SetHatchesLineWidth() to define the hatches line width.; 31 //; 32 // Author: Olivier Couet.; 33 ; 34 TCanvas *Pat = new TCanvas(""Fill Patterns"", """",0,0,w,h);; 35 Pat->Range(0,0,1,1);; 36 Pat->SetBorderSize(2);; 37 Pat->SetFrameFillColor(0);; 38 Double_t bh = 0.059;; 39 Double_t db = 0.01;; 40 Double_t y = 0.995;; 41 Int_t i,j=3001;; 42 ; 43 // Fixed patterns.; 44 for (i=1; i<=5; i++) {; 45 box(j++, 0.01, y-bh, 0.19, y);; 46 box(j++, 0.21, y-bh, 0.39, y);; 47 box(j++, 0.41, y-bh, 0.59, y);; 48 box(j++, 0.61, y-bh, 0.79, y);; 49 box(j++, 0.81, y-bh, 0.99, y);; 50 y = y-bh-db;; 51 }; 52 ; 53 // Hatches; 54 y = y-3*db;; 55 gStyle->SetHatchesSpacing(2.0);; 56 gStyle->SetHatchesLineWidth(1);; 57 Int_t j1 = 3144;; 58 Int_t j2 = 3305;; 59 Int_t ",MatchSource.WIKI,doc/master/fillpatterns_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fillpatterns_8C_source.html
https://root.cern/doc/master/FirstContour_8C.html:431,Security,access,accessed,431,". ROOT: tutorials/hist/FirstContour.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. FirstContour.C File ReferenceTutorials  Histograms tutorials. Detailed Description; Make a contour plot and get the first contour in a TPolyMarker. ; This macro generates a color contour plot by selecting entries from an ntuple file. The TGraph object corresponding to the first contour line is accessed and displayed into a separate canvas.; ; void FirstContour(); {; TString dir = gROOT->GetTutorialDir();; dir.Append(""/hsimple.C"");; dir.ReplaceAll(""/./"",""/"");; if (!gInterpreter->IsLoaded(dir.Data())) gInterpreter->LoadMacro(dir.Data());; TFile *file = (TFile*)gROOT->ProcessLineFast(""hsimple(1)"");; if (!file) return;; TTree *ntuple = (TTree*)file->Get(""ntuple"");; ; TCanvas *c1 = new TCanvas(""c1"",""Contours"",10,10,800,600);; ntuple->Draw(""py:px"",""px*px+py*py < 20"", ""contz,list"");; ; //we must call Update to force the canvas to be painted. When; //painting the contour plot, the list of contours is generated; //and a reference to it added to the Root list of special objects; c1->Update();; ; TCanvas *c2 = new TCanvas(""c2"",""First contour"",100,100,800,600);; ; ; TObjArray *contours =; (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; if (!contours) return;; TList *lcontour1 = (TList*)contours->At(0);; if (!lcontour1) return;; TGraph *gc1 = (TGraph*)lcontour1->First();; if (!gc1) return;; if (gc1->GetN() < 10) return;; gc1->SetMarkerStyle(21);; gc1->Draw(""alp"");; ; //We make a TCutG object with the array obtained from this graph; TCutG *cutg = new TCutG(""cutg"",gc1->GetN(),gc1->GetX(),gc1->GetY());; ; //We create a polymarker object with npmax points.; const Int_t npmax = 50000;; TPolyMarker *pm = new TPolyMarker(npmax);; Int_t np = 0;; while(1) {; Double_t x = -4 +8*gRandom->Rndm();; Double_t y = -4 +8*gRandom->Rndm();; if (cutg->IsInside(x,y)) {; pm->SetPoint(np,x,y);; np++;; if (np == npmax) break;; }; }; pm->Draw();; }; Int_",MatchSource.WIKI,doc/master/FirstContour_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FirstContour_8C.html
https://root.cern/doc/master/first_8C.html:656,Energy Efficiency,power,powerful,656,". ROOT: tutorials/graphics/first.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. first.C File ReferenceTutorials  Graphics tutorials. Detailed Description; Show some basic primitives. . ; void first() {; ; TCanvas *nut = new TCanvas(""nut"", ""FirstSession"",100,10,700,900);; nut->Range(0,0,20,24);; nut->SetFillColor(10);; nut->SetBorderSize(2);; ; TPaveLabel *pl = new TPaveLabel(3,22,17,23.7,; ""My first ROOT interactive session"",""br"");; pl->SetFillColor(18);; pl->Draw();; ; TText t(0,0,""a"");; t.SetTextFont(62);; t.SetTextSize(0.025);; t.SetTextAlign(12);; t.DrawText(2,20.3,""ROOT is based on CLING, a powerful C/C++ interpreter."");; t.DrawText(2,19.3,""Blocks of lines can be entered within {...}."");; t.DrawText(2,18.3,""Previous typed lines can be recalled."");; ; t.SetTextFont(72);; t.SetTextSize(0.026);; t.DrawText(3,17,""Root > float x=5; float y=7;"");; t.DrawText(3,16,""Root > x*sqrt(y)"");; t.DrawText(3,14,; ""Root > for (int i=2;i<7;i++) printf(\""sqrt(%d) = %f\\n\"",i,sqrt(i));"");; t.DrawText(3,10,""Root > TF1 f1(\""f1\"",\""sin(x)/x\"",0,10)"");; t.DrawText(3, 9,""Root > f1.Draw()"");; t.SetTextFont(81);; t.SetTextSize(0.018);; t.DrawText(4,15,""(float) 13.2288f"");; t.DrawText(4,13.3,""sqrt(2) = 1.414214"");; t.DrawText(4,12.7,""sqrt(3) = 1.732051"");; t.DrawText(4,12.1,""sqrt(4) = 2.000000"");; t.DrawText(4,11.5,""sqrt(5) = 2.236068"");; t.DrawText(4,10.9,""sqrt(6) = 2.449490"");; ; TPad *pad = new TPad(""pad"",""pad"",.2,.05,.8,.35);; pad->Draw();; pad->cd();; pad->SetGrid();; TF1 *f1 = new TF1(""f1"",""sin(x)/x"",0,10);; f1->Draw();; }; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF1.cxx:1333; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::SetB",MatchSource.WIKI,doc/master/first_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/first_8C.html
https://root.cern/doc/master/fit1_8C.html:3197,Availability,error,error,3197,"(TF1*) gROOT.FindObject(""sqroot""); //; TF1 * sqroot = nullptr;; file->GetObject(""sqroot"",sqroot);; if (!sqroot){; Error(""fit1.C"",""Cannot find object sqroot of type TF1\n"");; return;; }; sqroot->Print();; ; //; // Now get and fit histogram h1f with the function sqroot; //; TH1F* h1f = nullptr;; file->GetObject(""h1f"",h1f);; if (!h1f){; Error(""fit1.C"",""Cannot find object h1f of type TH1F\n"");; return;; }; h1f->SetFillColor(45);; h1f->Fit(""sqroot"");; ; // We now annotate the picture by creating a PaveText object; // and displaying the list of commands in this macro; //; TPaveText * fitlabel = new TPaveText(0.6,0.4,0.9,0.75,""NDC"");; fitlabel->SetTextAlign(12);; fitlabel->SetFillColor(42);; fitlabel->ReadFile(Form(""%sfit1_C.txt"",dir.Data()));; fitlabel->Draw();; c1->Update();; gBenchmark->Show(""fit1"");; }; TBenchmark.h; gBenchmarkR__EXTERN TBenchmark * gBenchmarkDefinition TBenchmark.h:59; TCanvas.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1.h; TFile.h; TFrame.h; TH1.h; TInterpreter.h; TPaveText.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TBenchmark::Startvirtual void Start(const char *name)Starts Benchmark with the specified name.Definition TBenchmark.cxx:172; TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TF11-Dim function classDefinition TF1.h:233; TF1::Printvoid Print(Option_t *option="""") const over",MatchSource.WIKI,doc/master/fit1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit1_8C.html
https://root.cern/doc/master/fit1_8C.html:5429,Security,access,access,5429," TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TF11-Dim function classDefinition TF1.h:233; TF1::Printvoid Print(Option_t *option="""") const overrideThis method must be overridden when a class wants to print itself.Definition TF1.cxx:2897; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; c1return c1Definition legend1.C:41; fit1_py.fitlabelfitlabelDefinition fit1_py.py:12; fit1Definition fit1.py:1; AuthorRene Brun ; Definition in file fit1.C. tutorialsfitfit1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fit1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit1_8C.html
https://root.cern/doc/master/fit1_8C.html:5463,Security,access,access,5463," TBenchmark::Showvirtual void Show(const char *name)Stops Benchmark name and Prints results.Definition TBenchmark.cxx:155; TCanvasThe Canvas class.Definition TCanvas.h:23; TDirectory::GetObjectvoid GetObject(const char *namecycle, T *&ptr)Get an object with proper type checking.Definition TDirectory.h:212; TF11-Dim function classDefinition TF1.h:233; TF1::Printvoid Print(Option_t *option="""") const overrideThis method must be overridden when a class wants to print itself.Definition TF1.cxx:2897; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::lsvoid ls(Option_t *option="""") const overrideList file contents.Definition TFile.cxx:1457; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; c1return c1Definition legend1.C:41; fit1_py.fitlabelfitlabelDefinition fit1_py.py:12; fit1Definition fit1.py:1; AuthorRene Brun ; Definition in file fit1.C. tutorialsfitfit1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fit1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit1_8C.html
https://root.cern/doc/master/fit2a_8C.html:4018,Energy Efficiency,power,power,4018,"ams[ 5] *= ratio;; f2params[10] *= ratio;; f2->SetParameters(f2params);; h2->Fit(""f2"",""N"");; auto cutg = new TCutG(""cutg"",5);; cutg->SetPoint(0,-7,-7);; cutg->SetPoint(1, 2,-7);; cutg->SetPoint(2, 2, 2);; cutg->SetPoint(3,-7, 2);; cutg->SetPoint(4,-7,-7);; h2->Draw(""lego2 0"");; h2->SetFillColor(38);; f2->SetNpx(80);; f2->SetNpy(80);; f2->Draw(""surf1 same bb [cutg]"");; return c;; }; c#define c(i)Definition RSha256.hxx:101; TCanvas.h; TCutG.h; TF2.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH2.h; nentriesint nentriesDefinition THbookFile.cxx:91; TMath.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TCutGGraphical cut class.Definition TCutG.h:20; TF2A 2-Dim function with parameters.Definition TF2.h:29; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; double; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::ratiodouble ratio(double numerator, double denominator)Definition MathFuncs.h:103; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; AuthorRene Brun ; Definition in file fit2a.C. tutorialsfitfit2a.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fit2a_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2a_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:5274,Availability,error,errors,5274,"+ my2;; }; h->Fill(x,y);; ; }; }; ; ; ; ; int fit2dHist(int option=1) {; ; // create two histograms; ; int nbx1 = 50;; int nby1 = 50;; int nbx2 = 50;; int nby2 = 50;; double xlow1 = 0.;; double ylow1 = 0.;; double xup1 = 10.;; double yup1 = 10.;; double xlow2 = 5.;; double ylow2 = 5.;; double xup2 = 20.;; double yup2 = 20.;; ; auto h1 = new TH2D(""h1"",""core"",nbx1,xlow1,xup1,nby1,ylow1,yup1);; auto h2 = new TH2D(""h2"",""tails"",nbx2,xlow2,xup2,nby2,ylow2,yup2);; ; double iniParams[10] = { 100, 6., 2., 7., 3, 100, 12., 3., 11., 2. };; // create fit function; TF2 * func = new TF2(""func"",my2Dfunc,xlow2,xup2,ylow2,yup2, 10);; func->SetParameters(iniParams);; ; // fill Histos; int n1 = 1000000;; int n2 = 1000000;; FillHisto(h1,n1,iniParams);; FillHisto(h2,n2,iniParams);; ; // scale histograms to same heights (for fitting); double dx1 = (xup1-xlow1)/double(nbx1);; double dy1 = (yup1-ylow1)/double(nby1);; double dx2 = (xup2-xlow2)/double(nbx2);; double dy2 = (yup2-ylow2)/double(nby2);; // scale histo 2 to scale of 1; h2->Sumw2();; h2->Scale( ( double(n1) * dx1 * dy1 ) / ( double(n2) * dx2 * dy2 ) );; ; bool global = false;; if (option > 10) global = true;; // do global combined fit; if (global) {; // fill data structure for fit (coordinates + values + errors); std::cout << ""Do global fit"" << std::endl;; // fit now all the function together; ; ROOT::Fit::Fitter fitter;; //The default minimizer is Minuit, you can also try Minuit2; ; MyFcn myFcn(h1,h2);; fitter.SetFCN(10, myFcn);; if (option%10 == 2) fitter.Config().SetMinimizer(""Minuit2"");; ; // set parameter initial value, name and step size; for (int i = 0; i < 10; ++i) {; fitter.Config().ParSettings(i) = ROOT::Fit::ParameterSettings(func->GetParName(i), func->GetParameter(i), 0.01);; }; ; bool ret = fitter.FitFCN();; if (!ret) {; Error(""fit2DHist"",""Fit Failed to converge"");; return -1;; }; ; //get result; double minParams[10];; double parErrors[10];; for (int i = 0; i < 10; ++i) {; minParams[i] = fitter.Result().Parameter(i);; ",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:7194,Availability,error,error,7194,"meters(minParams);; func->SetParErrors(parErrors);; func->SetChisquare(chi2);; int ndf = npfits - fitter.Result().NFreeParameters();; func->SetNDF(ndf);; ; // add to list of functions; h1->GetListOfFunctions()->Add(func);; h2->GetListOfFunctions()->Add(func);; }; else {; // fit independently; h1->Fit(func, ""0"");; h2->Fit(func, ""0"");; }; ; // Create a new canvas.; TCanvas * c1 = new TCanvas(""c1"",""Two HIstogram Fit example"",100,10,900,800);; c1->Divide(2,2);; gStyle->SetOptFit();; gStyle->SetStatY(0.6);; ; c1->cd(1);; h1->Draw();; func->SetRange(xlow1,ylow1,xup1,yup1);; func->DrawCopy(""cont3 same"");; c1->cd(2);; h1->Draw(""lego"");; func->DrawCopy(""surf1 same"");; c1->cd(3);; func->SetRange(xlow2,ylow2,xup2,yup2);; h2->Draw();; func->DrawCopy(""cont3 same"");; c1->cd(4);; h2->Draw(""lego"");; gPad->SetLogz();; func->Draw(""surf1 same"");; ; return 0;; }; Fitter.h; h#define h(i)Definition RSha256.hxx:106; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF2.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2D.h; TList.h; operator()TRObject operator()(const T1 &t1) constDefinition TRFunctionImport__oprtr.h:14; TRandom3.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the param",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:8336,Availability,error,error,8336,"Proxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2D.h; TList.h; operator()TRObject operator()(const T1 &t1) constDefinition TRFunctionImport__oprtr.h:14; TRandom3.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitResult.h:179; ROOT::Fit::FitResult::MinFcnValuedouble MinFcnValue() constReturn value of the objective function (chi2 or likelihood) used in the fit.Definition FitResult.h:111; ROOT::Fit::FitResult::Edmdouble Edm() constExpected distance from minimum.Definition FitResult.h:117; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing doubl",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:10456,Availability,error,errors,10456," Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associ",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:10467,Availability,error,errors,10467," Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associ",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:10538,Availability,error,errors,10538," Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associ",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:11466,Availability,error,error,11466,"onst Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition ",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:9439,Deployability,configurat,configuration,9439,"FcnValue() constReturn value of the objective function (chi2 or likelihood) used in the fit.Definition FitResult.h:111; ROOT::Fit::FitResult::Edmdouble Edm() constExpected distance from minimum.Definition FitResult.h:117; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:9439,Modifiability,config,configuration,9439,"FcnValue() constReturn value of the objective function (chi2 or likelihood) used in the fit.Definition FitResult.h:111; ROOT::Fit::FitResult::Edmdouble Edm() constExpected distance from minimum.Definition FitResult.h:117; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2dHist_8C.html:8947,Performance,perform,performing,8947,"h:308; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitResult.h:179; ROOT::Fit::FitResult::MinFcnValuedouble MinFcnValue() constReturn value of the objective function (chi2 or likelihood) used in the fit.Definition FitResult.h:111; ROOT::Fit::FitResult::Edmdouble Edm() constExpected distance from minimum.Definition FitResult.h:117; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; TAxisC",MatchSource.WIKI,doc/master/fit2dHist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2dHist_8C.html
https://root.cern/doc/master/fit2_8C.html:2999,Energy Efficiency,power,power,2999,"x[0]-par[1])/par[2]);; double r2 = double((x[1]-par[3])/par[4]);; return par[0]*TMath::Exp(-0.5*(r1*r1+r2*r2));; }; double fun2(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; double *p3 = &par[10];; double result = g2(x,p1) + g2(x,p2) + g2(x,p3);; return result;; }; ; void fit2() {; const int npar = 15;; double f2params[npar] =; {100,-3,3,-3,3,160,0,0.8,0,0.9,40,4,0.7,4,0.7};; TF2 *f2 = new TF2(""f2"",fun2,-10,10,-10,10, npar);; f2->SetParameters(f2params);; ; //Create an histogram and fill it randomly with f2; TH2F *h2 = new TH2F(""h2"",""from f2"",40,-10,10,40,-10,10);; int nentries = 100000;; h2->FillRandom(""f2"",nentries);; //Fit h2 with original function f2; float ratio = 4*nentries/100000;; f2params[ 0] *= ratio;; f2params[ 5] *= ratio;; f2params[10] *= ratio;; f2->SetParameters(f2params);; h2->Fit(""f2"");; }; TF2.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH2.h; nentriesint nentriesDefinition THbookFile.cxx:91; TMath.h; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF2A 2-Dim function with parameters.Definition TF2.h:29; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; double; xDouble_t x[n]Definition legend1.C:17; RooFit::Detail::MathFuncs::ratiodouble ratio(double numerator, double denominator)Definition MathFuncs.h:103; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; AuthorRene Brun ; Definition in file fit2.C. tutorialsfitfit2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fit2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fit2_8C.html
https://root.cern/doc/master/fitCircle_8C.html:244,Availability,error,errors,244,". ROOT: tutorials/fit/fitCircle.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitCircle.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Generate points distributed with some errors around a circle Fit a circle through the points and draw To run the script, do, eg ; root > .x fitCircle.C (10000 points by default); root > .x fitCircle.C(100); (with only 100 points; root > .x fitCircle.C++(100000); with ACLIC; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148. ; ****************************************; Minimizer is Minuit2 / Migrad; MinFCN = 903.174; NDf = 0; Edm = 8.44653e-07; NCalls = 65; x0 = 0.00667903 +/- 0.0141774 ; y0 = 0.00535479 +/- 0.0141954 ; R = 3.995 +/- 0.0100048 ; ; #include ""TCanvas.h""; #include ""TRandom3.h""; #include ""TGraph.h""; #include ""TMath.h""; #include ""TArc.h""; #include ""Fit/Fitter.h""; #include <Math/Functor.h>; ; //____________________________________________________________________; void fitCircle(int n=10000) {; //generates n points around a circle and fit them; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,600);; c1->SetGrid();; TGraph* gr = new TGraph(n);; if (n> 999) gr->SetMarkerStyle(1);; else gr->SetMarkerStyle(3);; TRandom3 r;; double x,y;; for (int i=0;i<n;i++) {; r.Circle(x,y,r.Gaus(4,0.3));; gr->SetPoint(i,x,y);; }; c1->DrawFrame(-5,-5,5,5);; gr->Draw(""p"");; ; ; auto chi2Function = [&](const double *par) {; //minimisation function computing the sum of squares of residuals; // looping at the graph points; int np = gr->GetN();; double f = 0;; double *x = gr->GetX();; double *y = gr->GetY();; for (int i=0;i<np;i++) {; double u = x[i] - par[0];; double v = y[i] - par[1];; double dr = par[2] - std::sqrt(u*u+v*v);; f += dr*dr;; }; return f;; };; ; // wrap chi2 function in a function object for the fit; // 3 ",MatchSource.WIKI,doc/master/fitCircle_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitCircle_8C.html
https://root.cern/doc/master/fitCircle_8C.html:2930,Availability,error,error,2930," return f;; };; ; // wrap chi2 function in a function object for the fit; // 3 is the number of fit parameters (size of array par); ROOT::Math::Functor fcn(chi2Function,3);; ROOT::Fit::Fitter fitter;; ; ; double pStart[3] = {0,0,1};; fitter.SetFCN(fcn, pStart);; fitter.Config().ParSettings(0).SetName(""x0"");; fitter.Config().ParSettings(1).SetName(""y0"");; fitter.Config().ParSettings(2).SetName(""R"");; ; // do the fit; bool ok = fitter.FitFCN();; if (!ok) {; Error(""line3Dfit"",""Line3D Fit failed"");; }; ; const ROOT::Fit::FitResult & result = fitter.Result();; result.Print(std::cout);; ; //Draw the circle on top of the points; TArc *arc = new TArc(result.Parameter(0),result.Parameter(1),result.Parameter(2));; arc->SetLineColor(kRed);; arc->SetLineWidth(4);; arc->SetFillStyle(0);; arc->Draw();; }; Fitter.h; Functor.h; f#define f(i)Definition RSha256.hxx:104; kRed@ kRedDefinition Rtypes.h:66; TArc.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTex",MatchSource.WIKI,doc/master/fitCircle_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitCircle_8C.html
https://root.cern/doc/master/fitCircle_8C.html:4986,Deployability,configurat,configuration,4986,"ributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TGraph.h; TMath.h; TRandom3.h; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettings::SetNamevoid SetName(const std::string &name)interactionDefinition ParameterSettings.h:113; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; TArcCreate an Arc.Definition TArc.h:26; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker st",MatchSource.WIKI,doc/master/fitCircle_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitCircle_8C.html
https://root.cern/doc/master/fitCircle_8C.html:1943,Integrability,wrap,wrap,1943,"e-07; NCalls = 65; x0 = 0.00667903 +/- 0.0141774 ; y0 = 0.00535479 +/- 0.0141954 ; R = 3.995 +/- 0.0100048 ; ; #include ""TCanvas.h""; #include ""TRandom3.h""; #include ""TGraph.h""; #include ""TMath.h""; #include ""TArc.h""; #include ""Fit/Fitter.h""; #include <Math/Functor.h>; ; //____________________________________________________________________; void fitCircle(int n=10000) {; //generates n points around a circle and fit them; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,600);; c1->SetGrid();; TGraph* gr = new TGraph(n);; if (n> 999) gr->SetMarkerStyle(1);; else gr->SetMarkerStyle(3);; TRandom3 r;; double x,y;; for (int i=0;i<n;i++) {; r.Circle(x,y,r.Gaus(4,0.3));; gr->SetPoint(i,x,y);; }; c1->DrawFrame(-5,-5,5,5);; gr->Draw(""p"");; ; ; auto chi2Function = [&](const double *par) {; //minimisation function computing the sum of squares of residuals; // looping at the graph points; int np = gr->GetN();; double f = 0;; double *x = gr->GetX();; double *y = gr->GetY();; for (int i=0;i<np;i++) {; double u = x[i] - par[0];; double v = y[i] - par[1];; double dr = par[2] - std::sqrt(u*u+v*v);; f += dr*dr;; }; return f;; };; ; // wrap chi2 function in a function object for the fit; // 3 is the number of fit parameters (size of array par); ROOT::Math::Functor fcn(chi2Function,3);; ROOT::Fit::Fitter fitter;; ; ; double pStart[3] = {0,0,1};; fitter.SetFCN(fcn, pStart);; fitter.Config().ParSettings(0).SetName(""x0"");; fitter.Config().ParSettings(1).SetName(""y0"");; fitter.Config().ParSettings(2).SetName(""R"");; ; // do the fit; bool ok = fitter.FitFCN();; if (!ok) {; Error(""line3Dfit"",""Line3D Fit failed"");; }; ; const ROOT::Fit::FitResult & result = fitter.Result();; result.Print(std::cout);; ; //Draw the circle on top of the points; TArc *arc = new TArc(result.Parameter(0),result.Parameter(1),result.Parameter(2));; arc->SetLineColor(kRed);; arc->SetLineWidth(4);; arc->SetFillStyle(0);; arc->Draw();; }; Fitter.h; Functor.h; f#define f(i)Definition RSha256.hxx:104; kRed@ kRedDefinition Rtypes.h:66",MatchSource.WIKI,doc/master/fitCircle_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitCircle_8C.html
https://root.cern/doc/master/fitCircle_8C.html:4986,Modifiability,config,configuration,4986,"ributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TGraph.h; TMath.h; TRandom3.h; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettings::SetNamevoid SetName(const std::string &name)interactionDefinition ParameterSettings.h:113; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; TArcCreate an Arc.Definition TArc.h:26; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker st",MatchSource.WIKI,doc/master/fitCircle_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitCircle_8C.html
https://root.cern/doc/master/fitCircle_8C.html:4494,Performance,perform,performing,4494,"inition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TGraph.h; TMath.h; TRandom3.h; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::ParameterSettings::SetNamevoid SetName(const std::string &name)interactionDefinition ParameterSettings.h:113; ROOT::Math::FunctorDocumentation for class Functor cl",MatchSource.WIKI,doc/master/fitCircle_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitCircle_8C.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:1105,Availability,error,errors,1105,". Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Thu Sep 21 16:21:29 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class FitConfig; 12 ; 13#include ""Fit/FitConfig.h""; 14 ; 15#include ""Fit/FitResult.h""; 16 ; 17#include ""Math/IParamFunction.h""; 18#include ""Math/Util.h""; 19 ; 20#include ""Math/Minimizer.h""; 21#include ""Math/Factory.h""; 22 ; 23#include <cmath>; 24 ; 25#include <string>; 26#include <sstream>; 27 ; 28#include ""Math/Error.h""; 29 ; 30//#define DEBUG; 31#ifdef DEBUG; 32#endif; 33 ; 34namespace ROOT {; 35 ; 36namespace Fit {; 37 ; 38 ; 39 ; 40FitConfig::FitConfig(unsigned int npar) :; 41 fNormErrors(false),; 42 fParabErrors(false), // ensure that in any case correct parabolic errors are estimated; 43 fMinosErrors(false), // do full Minos error analysis for all parameters; 44 fUpdateAfterFit(true), // update after fit; 45 fWeightCorr(false),; 46 fSettings(std::vector<ParameterSettings>(npar) ); 47{; 48 // constructor implementation; 49}; 50 ; 51 ; 52FitConfig::~FitConfig(); 53{; 54 // destructor implementation. No Operations; 55}; 56 ; 57FitConfig::FitConfig(const FitConfig &rhs) {; 58 // Implementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const Fit",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:1168,Availability,error,error,1168,". Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Thu Sep 21 16:21:29 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class FitConfig; 12 ; 13#include ""Fit/FitConfig.h""; 14 ; 15#include ""Fit/FitResult.h""; 16 ; 17#include ""Math/IParamFunction.h""; 18#include ""Math/Util.h""; 19 ; 20#include ""Math/Minimizer.h""; 21#include ""Math/Factory.h""; 22 ; 23#include <cmath>; 24 ; 25#include <string>; 26#include <sstream>; 27 ; 28#include ""Math/Error.h""; 29 ; 30//#define DEBUG; 31#ifdef DEBUG; 32#endif; 33 ; 34namespace ROOT {; 35 ; 36namespace Fit {; 37 ; 38 ; 39 ; 40FitConfig::FitConfig(unsigned int npar) :; 41 fNormErrors(false),; 42 fParabErrors(false), // ensure that in any case correct parabolic errors are estimated; 43 fMinosErrors(false), // do full Minos error analysis for all parameters; 44 fUpdateAfterFit(true), // update after fit; 45 fWeightCorr(false),; 46 fSettings(std::vector<ParameterSettings>(npar) ); 47{; 48 // constructor implementation; 49}; 50 ; 51 ; 52FitConfig::~FitConfig(); 53{; 54 // destructor implementation. No Operations; 55}; 56 ; 57FitConfig::FitConfig(const FitConfig &rhs) {; 58 // Implementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const Fit",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:3481,Availability,error,errors,3481,"();; 87 if (fSettings.size() != npar) {; 88 fSettings.clear();; 89 fSettings.resize(npar);; 90 }; 91 // fill the parameter settings; 92 for (unsigned int i = 0; i < npar; ++i) {; 93 if (result.IsParameterFixed(i) ); 94 fSettings[i].Set(result.ParName(i), result.Value(i) );; 95 else {; 96 fSettings[i].Set( result.ParName(i), result.Value(i), result.Error(i) );; 97 // check if parameter is bound; 98 double lower = 0;; 99 double upper = 0;; 100 if (result.ParameterBounds(i,lower,upper) ) {; 101 if (lower == -std::numeric_limits<double>::infinity()) fSettings[i].SetUpperLimit(upper);; 102 else if (upper == std::numeric_limits<double>::infinity()) fSettings[i].SetLowerLimit(lower);; 103 else fSettings[i].SetLimits(lower,upper);; 104 }; 105 ; 106 // query if parameter needs to run Minos; 107 if (result.HasMinosError(i) ) {; 108 if (fMinosParams.empty()) {; 109 fMinosErrors = true;; 110 fMinosParams.reserve(npar-i);; 111 }; 112 fMinosParams.push_back(i);; 113 }; 114 }; 115 }; 116 ; 117 // set information about errors; 118 SetNormErrors( result.NormalizedErrors() );; 119 ; 120 // set also minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; ",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:11398,Availability,error,error,11398,"_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; Util.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::FitConfigFitConfig(unsigned int npar=0)Default constructor.Definition FitConfig.cxx:40; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parame",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:11868,Availability,error,error,11868," fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::FitConfigFitConfig(unsigned int npar=0)Default constructor.Definition FitConfig.cxx:40; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrors",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:12868,Availability,error,errors,12868,"ize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() cons",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:13412,Availability,error,error,13412,"om number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...D",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:13990,Availability,error,errors,13990,"ptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::Minim",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:15461,Availability,toler,toleranceDefinition,15461,"arameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOptions.h:213; ROOT::Math::MinimizerOptions::Strategyint Strategy() conststrategyDefinition MinimizerOptions.h:183; ROOT::Math::MinimizerOptions::ExtraOptionsconst IOptions * ExtraOptions() constreturn extra options (NULL pointer if they are not present)Definition MinimizerOptions.h:195; ROOT::Math::MinimizerOptions::Tolerancedouble Tolerance() constabsolute toleranceDefinition MinimizerOptions.h:186; ROOT::Math::MinimizerOptions::Precisiondouble Precision() constprecision in the objective function calculation (value <=0 means left to default)Definition MinimizerOptions.h:189; ROOT::Math::MinimizerOptions::SetMinimizerTypevoid SetMinimizerType(const char *type)set minimizer typeDefinition MinimizerOptions.h:231; ROOT::Math::MinimizerOptions::MinimizerAlgorithmconst std::string & MinimizerAlgorithm() consttype of algorithmDefinition MinimizerOptions.h:201; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)Set the default Minimizer type and corresponding algorithms.Definition MinimizerOptions.cxx:43; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:17679,Availability,error,errorsDefinition,17679,"Type() consttype of minimizerDefinition MinimizerOptions.h:198; ROOT::Math::MinimizerOptions::MaxIterationsunsigned int MaxIterations() constmax iterationsDefinition MinimizerOptions.h:180; ROOT::Math::MinimizerOptions::MaxFunctionCallsunsigned int MaxFunctionCalls() constmax number of function callsDefinition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetStrategyvoid SetStrategy(int strategyLevel)set the strategyDefinition Minimizer.h:344; ROOT::Math::Minimizer::SetPrecisionvoid SetPrecision(double prec)set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer wi...Definition Minimizer.h:341; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::SetExtraOptionsvoid SetExtraOptions(const IOptions ",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:17829,Availability,error,error,17829,"() constmax iterationsDefinition MinimizerOptions.h:180; ROOT::Math::MinimizerOptions::MaxFunctionCallsunsigned int MaxFunctionCalls() constmax number of function callsDefinition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetStrategyvoid SetStrategy(int strategyLevel)set the strategyDefinition Minimizer.h:344; ROOT::Math::Minimizer::SetPrecisionvoid SetPrecision(double prec)set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer wi...Definition Minimizer.h:341; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::SetExtraOptionsvoid SetExtraOptions(const IOptions &extraOptions)set only the extra optionsDefinition Minimizer.h:358; Factory.h; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Fop",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:17971,Availability,toler,toleranceDefinition,17971,"finition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetStrategyvoid SetStrategy(int strategyLevel)set the strategyDefinition Minimizer.h:344; ROOT::Math::Minimizer::SetPrecisionvoid SetPrecision(double prec)set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer wi...Definition Minimizer.h:341; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::SetExtraOptionsvoid SetExtraOptions(const IOptions &extraOptions)set only the extra optionsDefinition Minimizer.h:358; Factory.h; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Math::Util::ToStringstd::",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:1232,Deployability,update,update,1232,". Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Thu Sep 21 16:21:29 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class FitConfig; 12 ; 13#include ""Fit/FitConfig.h""; 14 ; 15#include ""Fit/FitResult.h""; 16 ; 17#include ""Math/IParamFunction.h""; 18#include ""Math/Util.h""; 19 ; 20#include ""Math/Minimizer.h""; 21#include ""Math/Factory.h""; 22 ; 23#include <cmath>; 24 ; 25#include <string>; 26#include <sstream>; 27 ; 28#include ""Math/Error.h""; 29 ; 30//#define DEBUG; 31#ifdef DEBUG; 32#endif; 33 ; 34namespace ROOT {; 35 ; 36namespace Fit {; 37 ; 38 ; 39 ; 40FitConfig::FitConfig(unsigned int npar) :; 41 fNormErrors(false),; 42 fParabErrors(false), // ensure that in any case correct parabolic errors are estimated; 43 fMinosErrors(false), // do full Minos error analysis for all parameters; 44 fUpdateAfterFit(true), // update after fit; 45 fWeightCorr(false),; 46 fSettings(std::vector<ParameterSettings>(npar) ); 47{; 48 // constructor implementation; 49}; 50 ; 51 ; 52FitConfig::~FitConfig(); 53{; 54 // destructor implementation. No Operations; 55}; 56 ; 57FitConfig::FitConfig(const FitConfig &rhs) {; 58 // Implementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const Fit",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:5382,Deployability,configurat,configuration,5382,"142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 168 ; 169 i++;; 170 }; 171}; 172 ; 173ROOT::Math::Minimizer * FitConfig::CreateMinimizer() {; 174 // create minimizer according to the chosen configuration using the; 175 // plug-in manager; 176 ; 177 // in case of empty string usesd default values; 178 if (fMinimizerOpts.MinimizerType().empty()); 179 fMinimizerOpts.SetMinimizerType(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str());; 180 if (fMinimizerOpts.MinimizerAlgorithm().empty()); 181 fMinimizerOpts.SetMinimizerAlgorithm(ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());; 182 ; 183 const std::string &minimType = fMinimizerOpts.MinimizerType();; 184 const std::string & algoType = fMinimizerOpts.MinimizerAlgorithm();; 185 ; 186 std::string defaultMinim = ROOT::Math::MinimizerOptions::DefaultMinimizerType();; 187 ; 188 ROOT::Math::Minimizer * min = ROOT::Math::Factory::CreateMinimizer(minimType, algoType);; 189 // check if a different minimizer is used (in case a default value is passed, then set correctly in FitConfig); 190 const std::string & minim_newDefault = ROOT::Math::MinimizerOptions::DefaultMinimizerType();; 191 if (defa",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:10826,Deployability,configurat,configuration,10826," Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; Util.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::FitConfigFitConfig(unsigned int npar=0)Default constructor.Definition FitConfig.cxx:40; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the o",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:13310,Deployability,configurat,configurationDefinition,13310,":SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:14109,Deployability,configurat,configuration,14109,"; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOpt",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:7415,Energy Efficiency,adapt,adapted,7415,"191 if (defaultMinim != minim_newDefault ) fMinimizerOpts.SetMinimizerType(minim_newDefault.c_str());; 192 ; 193 if (min == nullptr) {; 194 // if creation of minimizer failed force the use by default of Minuit; 195 std::string minim2 = ""Minuit"";; 196 if (minimType == ""Minuit"") minim2 = ""Minuit2"";; 197 if (minimType != minim2 ) {; 198 std::string msg = ""Could not create the "" + minimType + "" minimizer. Try using the minimizer "" + minim2;; 199 MATH_WARN_MSG(""FitConfig::CreateMinimizer"",msg.c_str());; 200 min = ROOT::Math::Factory::CreateMinimizer(minim2,""Migrad"");; 201 if (min == nullptr) {; 202 MATH_ERROR_MSG(""FitConfig::CreateMinimizer"",""Could not create the Minuit2 minimizer"");; 203 return nullptr;; 204 }; 205 SetMinimizer( minim2.c_str(),""Migrad"");; 206 }; 207 else {; 208 std::string msg = ""Could not create the Minimizer "" + minimType;; 209 MATH_ERROR_MSG(""FitConfig::CreateMinimizer"",msg.c_str());; 210 return nullptr;; 211 }; 212 }; 213 ; 214 // set default max of function calls according to the number of parameters; 215 // formula from Minuit2 (adapted); 216 if (fMinimizerOpts.MaxFunctionCalls() == 0) {; 217 unsigned int npar = fSettings.size();; 218 int maxfcn = 1000 + 100*npar + 5*npar*npar;; 219 fMinimizerOpts.SetMaxFunctionCalls(maxfcn);; 220 }; 221 ; 222 ; 223 // set default minimizer control parameters; 224 min->SetPrintLevel( fMinimizerOpts.PrintLevel() );; 225 min->SetMaxFunctionCalls( fMinimizerOpts.MaxFunctionCalls() );; 226 min->SetMaxIterations( fMinimizerOpts.MaxIterations() );; 227 min->SetTolerance( fMinimizerOpts.Tolerance() );; 228 min->SetPrecision( fMinimizerOpts.Precision() );; 229 min->SetValidError( fParabErrors );; 230 min->SetStrategy( fMinimizerOpts.Strategy() );; 231 min->SetErrorDef( fMinimizerOpts.ErrorDef() );; 232 // set extra options if existing; 233 if (fMinimizerOpts.ExtraOptions()); 234 min->SetExtraOptions(*fMinimizerOpts.ExtraOptions());; 235 ; 236 return min;; 237}; 238 ; 239std::string FitConfig::MinimizerName() const; 240{; ",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:17330,Integrability,interface,interface,17330,"ptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT::Math::MinimizerOptions::DefaultMinimizerAlgostatic const std::string & DefaultMinimizerAlgo()Definition MinimizerOptions.cxx:85; ROOT::Math::MinimizerOptions::MinimizerTypeconst std::string & MinimizerType() consttype of minimizerDefinition MinimizerOptions.h:198; ROOT::Math::MinimizerOptions::MaxIterationsunsigned int MaxIterations() constmax iterationsDefinition MinimizerOptions.h:180; ROOT::Math::MinimizerOptions::MaxFunctionCallsunsigned int MaxFunctionCalls() constmax number of function callsDefinition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetStrategyvoid SetStrategy(int strategyLevel)set the strategyDefinition Minimizer.h:344; ROOT::Math::Minimizer::SetPrecisionvoid SetPrecision(double prec)set in the minimizer the obj",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:5382,Modifiability,config,configuration,5382,"142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 168 ; 169 i++;; 170 }; 171}; 172 ; 173ROOT::Math::Minimizer * FitConfig::CreateMinimizer() {; 174 // create minimizer according to the chosen configuration using the; 175 // plug-in manager; 176 ; 177 // in case of empty string usesd default values; 178 if (fMinimizerOpts.MinimizerType().empty()); 179 fMinimizerOpts.SetMinimizerType(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str());; 180 if (fMinimizerOpts.MinimizerAlgorithm().empty()); 181 fMinimizerOpts.SetMinimizerAlgorithm(ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());; 182 ; 183 const std::string &minimType = fMinimizerOpts.MinimizerType();; 184 const std::string & algoType = fMinimizerOpts.MinimizerAlgorithm();; 185 ; 186 std::string defaultMinim = ROOT::Math::MinimizerOptions::DefaultMinimizerType();; 187 ; 188 ROOT::Math::Minimizer * min = ROOT::Math::Factory::CreateMinimizer(minimType, algoType);; 189 // check if a different minimizer is used (in case a default value is passed, then set correctly in FitConfig); 190 const std::string & minim_newDefault = ROOT::Math::MinimizerOptions::DefaultMinimizerType();; 191 if (defa",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:5414,Modifiability,plug-in,plug-in,5414,"142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 168 ; 169 i++;; 170 }; 171}; 172 ; 173ROOT::Math::Minimizer * FitConfig::CreateMinimizer() {; 174 // create minimizer according to the chosen configuration using the; 175 // plug-in manager; 176 ; 177 // in case of empty string usesd default values; 178 if (fMinimizerOpts.MinimizerType().empty()); 179 fMinimizerOpts.SetMinimizerType(ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str());; 180 if (fMinimizerOpts.MinimizerAlgorithm().empty()); 181 fMinimizerOpts.SetMinimizerAlgorithm(ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());; 182 ; 183 const std::string &minimType = fMinimizerOpts.MinimizerType();; 184 const std::string & algoType = fMinimizerOpts.MinimizerAlgorithm();; 185 ; 186 std::string defaultMinim = ROOT::Math::MinimizerOptions::DefaultMinimizerType();; 187 ; 188 ROOT::Math::Minimizer * min = ROOT::Math::Factory::CreateMinimizer(minimType, algoType);; 189 // check if a different minimizer is used (in case a default value is passed, then set correctly in FitConfig); 190 const std::string & minim_newDefault = ROOT::Math::MinimizerOptions::DefaultMinimizerType();; 191 if (defa",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:7415,Modifiability,adapt,adapted,7415,"191 if (defaultMinim != minim_newDefault ) fMinimizerOpts.SetMinimizerType(minim_newDefault.c_str());; 192 ; 193 if (min == nullptr) {; 194 // if creation of minimizer failed force the use by default of Minuit; 195 std::string minim2 = ""Minuit"";; 196 if (minimType == ""Minuit"") minim2 = ""Minuit2"";; 197 if (minimType != minim2 ) {; 198 std::string msg = ""Could not create the "" + minimType + "" minimizer. Try using the minimizer "" + minim2;; 199 MATH_WARN_MSG(""FitConfig::CreateMinimizer"",msg.c_str());; 200 min = ROOT::Math::Factory::CreateMinimizer(minim2,""Migrad"");; 201 if (min == nullptr) {; 202 MATH_ERROR_MSG(""FitConfig::CreateMinimizer"",""Could not create the Minuit2 minimizer"");; 203 return nullptr;; 204 }; 205 SetMinimizer( minim2.c_str(),""Migrad"");; 206 }; 207 else {; 208 std::string msg = ""Could not create the Minimizer "" + minimType;; 209 MATH_ERROR_MSG(""FitConfig::CreateMinimizer"",msg.c_str());; 210 return nullptr;; 211 }; 212 }; 213 ; 214 // set default max of function calls according to the number of parameters; 215 // formula from Minuit2 (adapted); 216 if (fMinimizerOpts.MaxFunctionCalls() == 0) {; 217 unsigned int npar = fSettings.size();; 218 int maxfcn = 1000 + 100*npar + 5*npar*npar;; 219 fMinimizerOpts.SetMaxFunctionCalls(maxfcn);; 220 }; 221 ; 222 ; 223 // set default minimizer control parameters; 224 min->SetPrintLevel( fMinimizerOpts.PrintLevel() );; 225 min->SetMaxFunctionCalls( fMinimizerOpts.MaxFunctionCalls() );; 226 min->SetMaxIterations( fMinimizerOpts.MaxIterations() );; 227 min->SetTolerance( fMinimizerOpts.Tolerance() );; 228 min->SetPrecision( fMinimizerOpts.Precision() );; 229 min->SetValidError( fParabErrors );; 230 min->SetStrategy( fMinimizerOpts.Strategy() );; 231 min->SetErrorDef( fMinimizerOpts.ErrorDef() );; 232 // set extra options if existing; 233 if (fMinimizerOpts.ExtraOptions()); 234 min->SetExtraOptions(*fMinimizerOpts.ExtraOptions());; 235 ; 236 return min;; 237}; 238 ; 239std::string FitConfig::MinimizerName() const; 240{; ",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:10826,Modifiability,config,configuration,10826," Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; Util.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::FitConfigFitConfig(unsigned int npar=0)Default constructor.Definition FitConfig.cxx:40; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the o",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:13310,Modifiability,config,configurationDefinition,13310,":SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:14109,Modifiability,config,configuration,14109,"; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOpt",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:17812,Performance,perform,perform,17812,"() constmax iterationsDefinition MinimizerOptions.h:180; ROOT::Math::MinimizerOptions::MaxFunctionCallsunsigned int MaxFunctionCalls() constmax number of function callsDefinition MinimizerOptions.h:177; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxiter)set maximum iterations (one iteration can have many function calls)Definition Minimizer.h:334; ROOT::Math::Minimizer::SetErrorDefvoid SetErrorDef(double up)set scale for calculating the errorsDefinition Minimizer.h:347; ROOT::Math::Minimizer::SetValidErrorvoid SetValidError(bool on)flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)Definition Minimizer.h:350; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::SetPrintLevelvoid SetPrintLevel(int level)set print levelDefinition Minimizer.h:328; ROOT::Math::Minimizer::SetStrategyvoid SetStrategy(int strategyLevel)set the strategyDefinition Minimizer.h:344; ROOT::Math::Minimizer::SetPrecisionvoid SetPrecision(double prec)set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer wi...Definition Minimizer.h:341; ROOT::Math::Minimizer::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition Minimizer.h:331; ROOT::Math::Minimizer::SetExtraOptionsvoid SetExtraOptions(const IOptions &extraOptions)set only the extra optionsDefinition Minimizer.h:358; Factory.h; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Fop",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:1753,Testability,test,test,1753,"ory.h""; 22 ; 23#include <cmath>; 24 ; 25#include <string>; 26#include <sstream>; 27 ; 28#include ""Math/Error.h""; 29 ; 30//#define DEBUG; 31#ifdef DEBUG; 32#endif; 33 ; 34namespace ROOT {; 35 ; 36namespace Fit {; 37 ; 38 ; 39 ; 40FitConfig::FitConfig(unsigned int npar) :; 41 fNormErrors(false),; 42 fParabErrors(false), // ensure that in any case correct parabolic errors are estimated; 43 fMinosErrors(false), // do full Minos error analysis for all parameters; 44 fUpdateAfterFit(true), // update after fit; 45 fWeightCorr(false),; 46 fSettings(std::vector<ParameterSettings>(npar) ); 47{; 48 // constructor implementation; 49}; 50 ; 51 ; 52FitConfig::~FitConfig(); 53{; 54 // destructor implementation. No Operations; 55}; 56 ; 57FitConfig::FitConfig(const FitConfig &rhs) {; 58 // Implementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const FitResult &result) {; 81 // Implementation of setting of parameters from the result of the fit; 82 // all the other options will stay the same.; 83 // If the size of parameters do not match they will be re-created; 84 // but in that case the bound on the parameter will be lost; 85 ; 86 unsigned int npar = result.NPar();; 87 if (fSettings.size() != npar) {; 88 fSettings.clear();; 89 fSettings.resize(npar);; 90 }; 91 // fill the parameter settings; 92 for (unsigned int i = 0; i < npar; ++i) {; 93 if (result.IsParameterFixed(i) ); 94 fSettings[i].Set(result.ParName(i), result.Value(i) );; 95 e",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:2516,Usability,clear,clear,2516,"plementation of copy constructor; 59 (*this) = rhs;; 60}; 61 ; 62FitConfig & FitConfig::operator = (const FitConfig &rhs) {; 63 // Implementation of assignment operator.; 64 if (this == &rhs) return *this; // time saving self-test; 65 ; 66 fNormErrors = rhs.fNormErrors;; 67 fParabErrors = rhs.fParabErrors;; 68 fMinosErrors = rhs.fMinosErrors;; 69 fUpdateAfterFit = rhs.fUpdateAfterFit;; 70 fWeightCorr = rhs.fWeightCorr;; 71 ; 72 fSettings = rhs.fSettings;; 73 fMinosParams = rhs.fMinosParams;; 74 ; 75 fMinimizerOpts = rhs.fMinimizerOpts;; 76 ; 77 return *this;; 78}; 79 ; 80void FitConfig::SetFromFitResult(const FitResult &result) {; 81 // Implementation of setting of parameters from the result of the fit; 82 // all the other options will stay the same.; 83 // If the size of parameters do not match they will be re-created; 84 // but in that case the bound on the parameter will be lost; 85 ; 86 unsigned int npar = result.NPar();; 87 if (fSettings.size() != npar) {; 88 fSettings.clear();; 89 fSettings.resize(npar);; 90 }; 91 // fill the parameter settings; 92 for (unsigned int i = 0; i < npar; ++i) {; 93 if (result.IsParameterFixed(i) ); 94 fSettings[i].Set(result.ParName(i), result.Value(i) );; 95 else {; 96 fSettings[i].Set( result.ParName(i), result.Value(i), result.Error(i) );; 97 // check if parameter is bound; 98 double lower = 0;; 99 double upper = 0;; 100 if (result.ParameterBounds(i,lower,upper) ) {; 101 if (lower == -std::numeric_limits<double>::infinity()) fSettings[i].SetUpperLimit(upper);; 102 else if (upper == std::numeric_limits<double>::infinity()) fSettings[i].SetLowerLimit(lower);; 103 else fSettings[i].SetLimits(lower,upper);; 104 }; 105 ; 106 // query if parameter needs to run Minos; 107 if (result.HasMinosError(i) ) {; 108 if (fMinosParams.empty()) {; 109 fMinosErrors = true;; 110 fMinosParams.reserve(npar-i);; 111 }; 112 fMinosParams.push_back(i);; 113 }; 114 }; 115 }; 116 ; 117 // set information about errors; 118 SetNormErrors( result.NormalizedErr",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:4223,Usability,clear,clear,4223,"o run Minos; 107 if (result.HasMinosError(i) ) {; 108 if (fMinosParams.empty()) {; 109 fMinosErrors = true;; 110 fMinosParams.reserve(npar-i);; 111 }; 112 fMinosParams.push_back(i);; 113 }; 114 }; 115 }; 116 ; 117 // set information about errors; 118 SetNormErrors( result.NormalizedErrors() );; 119 ; 120 // set also minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 16",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8cxx_source.html:4544,Usability,clear,clear,4544,"lso minimizer type; 121 // algorithm is after "" / ""; 122 const std::string & minname = result.MinimizerType();; 123 size_t pos = minname.find("" / "");; 124 if (pos != std::string::npos) {; 125 std::string minimType = minname.substr(0,pos);; 126 std::string algoType = minname.substr(pos+3,minname.length() );; 127 SetMinimizer(minimType.c_str(), algoType.c_str() );; 128 }; 129 else {; 130 SetMinimizer(minname.c_str());; 131 }; 132}; 133 ; 134 ; 135void FitConfig::SetParamsSettings(unsigned int npar, const double *params, const double * vstep ) {; 136 // initialize FitConfig from given parameter values and step sizes; 137 // if npar different than existing one - clear old one and create new ones; 138 if (params == nullptr) {; 139 fSettings = std::vector<ParameterSettings>(npar);; 140 return;; 141 }; 142 // if a vector of parameters is given and parameters are not existing or are of different size; 143 bool createNew = false;; 144 if (npar != fSettings.size() ) {; 145 fSettings.clear();; 146 fSettings.reserve(npar);; 147 createNew = true;; 148 }; 149 unsigned int i = 0;; 150 const double * end = params+npar;; 151 for (const double * ipar = params; ipar != end; ++ipar) {; 152 double val = *ipar;; 153 double step = 0;; 154 if (vstep == nullptr) {; 155 step = 0.3*std::fabs(val); // step size is 30% of par value; 156 //double step = 2.0*std::fabs(val); // step size is 30% of par value; 157 if (val == 0) step = 0.3;; 158 }; 159 else; 160 step = vstep[i];; 161 ; 162 if (createNew); 163 fSettings.push_back( ParameterSettings(""Par_"" + ROOT::Math::Util::ToString(i), val, step ) );; 164 else {; 165 fSettings[i].SetValue(val);; 166 fSettings[i].SetStepSize(step);; 167 }; 168 ; 169 i++;; 170 }; 171}; 172 ; 173ROOT::Math::Minimizer * FitConfig::CreateMinimizer() {; 174 // create minimizer according to the chosen configuration using the; 175 // plug-in manager; 176 ; 177 // in case of empty string usesd default values; 178 if (fMinimizerOpts.MinimizerType().empty()); 179 fMinimizerOpt",MatchSource.WIKI,doc/master/FitConfig_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:5610,Availability,error,errors,5610,,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:5763,Availability,error,errors,5763,,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:5848,Availability,error,errors,5848,,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:6107,Availability,error,error,6107,,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:6429,Availability,error,error,6429,Algorithm(); }; 193 ; 194 /**; 195 * return Minimizer full name (type / algorithm); 196 */; 197 std::string MinimizerName() const;; 198 ; 199 /**; 200 flag to check if resulting errors are be normalized according to chi2/ndf; 201 */; 202 bool NormalizeErrors() const { return fNormErrors; }; 203 ; 204 ///do analysis for parabolic errors; 205 bool ParabErrors() const { return fParabErrors; }; 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control ,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:6568,Availability,error,errors,6568,"99 /**; 200 flag to check if resulting errors are be normalized according to chi2/ndf; 201 */; 202 bool NormalizeErrors() const { return fNormErrors; }; 203 ; 204 ///do analysis for parabolic errors; 205 bool ParabErrors() const { return fParabErrors; }; 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:6663,Availability,error,errors,6663,"202 bool NormalizeErrors() const { return fNormErrors; }; 203 ; 204 ///do analysis for parabolic errors; 205 bool ParabErrors() const { return fParabErrors; }; 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:6822,Availability,error,error,6822," 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full err",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7668,Availability,error,error,7668," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7739,Availability,error,errors,7739," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7822,Availability,error,error,7822," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7983,Availability,error,errors,7983," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:10601,Availability,error,errors,10601,"escribing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSettingsstd::vector< ROOT::Fit::ParameterSettings > & ParamsSettings()get the vector of parameter settings (non-const method)Definition FitConfig.h:91; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:10735,Availability,error,error,10735,"Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSettingsstd::vector< ROOT::Fit::ParameterSettings > & ParamsSettings()get the vector of parameter settings (non-const method)Definition FitConfig.h:91; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.h:145; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized accord",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:11385,Availability,error,error,11385," FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSettingsstd::vector< ROOT::Fit::ParameterSettings > & ParamsSettings()get the vector of parameter settings (non-const method)Definition FitConfig.h:91; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.h:145; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(const std::vector< unsigned int > &paramInd)set parameter indices for running Minos this can be used for running Minos on a subset of parameters ...Definition FitConfig.h:237; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWei",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:11692,Availability,error,errors,11692, ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSettingsstd::vector< ROOT::Fit::ParameterSettings > & ParamsSettings()get the vector of parameter settings (non-const method)Definition FitConfig.h:91; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.h:145; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(const std::vector< unsigned int > &paramInd)set parameter indices for running Minos this can be used for running Minos on a subset of parameters ...Definition FitConfig.h:237; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetUpdateAfterFitvoid SetUpdateAfterFit(bool on=true)Update configuratio,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:12081,Availability,error,errorsDefinition,12081," type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSettingsstd::vector< ROOT::Fit::ParameterSettings > & ParamsSettings()get the vector of parameter settings (non-const method)Definition FitConfig.h:91; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.h:145; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(const std::vector< unsigned int > &paramInd)set parameter indices for running Minos this can be used for running Minos on a subset of parameters ...Definition FitConfig.h:237; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetUpdateAfterFitvoid SetUpdateAfterFit(bool on=true)Update configuration after a fit using the FitResult.Definition FitConfig.h:243; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROO",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:12423,Availability,error,error,12423,"error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.h:145; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(const std::vector< unsigned int > &paramInd)set parameter indices for running Minos this can be used for running Minos on a subset of parameters ...Definition FitConfig.h:237; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetUpdateAfterFitvoid SetUpdateAfterFit(bool on=true)Update configuration after a fit using the FitResult.Definition FitConfig.h:243; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correcti",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:13393,Availability,error,error,13393,"ionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetUpdateAfterFitvoid SetUpdateAfterFit(bool on=true)Update configuration after a fit using the FitResult.Definition FitConfig.h:243; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMi",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:13707,Availability,error,errors,13707,"FitResult.Definition FitConfig.h:243; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitR",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:14275,Availability,error,errorsDefinition,14275,"e (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst Paramete",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:14368,Availability,error,error,14368,") constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definit",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:15145,Availability,error,errors,15145,"according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits a",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:15861,Availability,error,errors,15861,"< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseParam::Parametersvirtual const double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default nam...Definition IParamFunction.h:86; ROOT::Math::IBaseParam::NParvirtual unsigned int NPar() const =0Return the number of Parameters.; ROOT::Math::IParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a d...Definition IParamFunction.h:108; RO",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:1099,Deployability,configurat,configuration,1099,"3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class FitConfig; 12 ; 13#ifndef ROOT_Fit_FitConfig; 14#define ROOT_Fit_FitConfig; 15 ; 16 ; 17#include ""Fit/ParameterSettings.h""; 18 ; 19#include ""Math/MinimizerOptions.h""; 20 ; 21#include ""Math/IParamFunctionfwd.h""; 22 ; 23#include ""TMath.h""; 24 ; 25#include <vector>; 26#include <string>; 27 ; 28namespace ROOT {; 29 ; 30 namespace Math {; 31 ; 32 class Minimizer;; 33 class MinimizerOptions;; 34 }; 35 ; 36 namespace Fit {; 37 ; 38 class FitResult;; 39 ; 40//___________________________________________________________________________________; 41/**; 42 Class describing the configuration of the fit, options and parameter settings; 43 using the ROOT::Fit::ParameterSettings class; 44 ; 45 @ingroup FitMain; 46*/; 47class FitConfig {; 48 ; 49public:; 50 ; 51 /**; 52 Default constructor; 53 */; 54 FitConfig (unsigned int npar = 0);; 55 ; 56 ; 57 /*; 58 Copy constructor; 59 */; 60 FitConfig(const FitConfig & rhs);; 61 ; 62 /**; 63 Destructor; 64 */; 65 ~FitConfig ();; 66 ; 67 /*; 68 Assignment operator; 69 */; 70 FitConfig & operator= (const FitConfig & rhs);; 71 ; 72 ; 73 /**; 74 get the parameter settings for the i-th parameter (const method); 75 */; 76 const ParameterSettings & ParSettings(unsigned int i) const { return fSettings.at(i); }; 77 ; 78 /**; 79 get the parameter settings for the i-th parameter (non-const method); 80 */; 81 ParameterSettings & ParSettings(unsigned int i) { return fSettings.at(i); }; 82 ; 83 /**; 84 get the vector of parameter settings (const method); 85 */; 86 const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const { return fSettings; }; 87 ; 88 /**; 89 get the vector of parameter settings (non-const method); 90 */; 91 std::vector<ROOT::Fit::ParameterSettings> & ParamsSetting",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:4467,Deployability,configurat,configuration,4467,"(ParameterSettings(func.ParameterName(i), val, step));; 130#ifdef DEBUG; 131 std::cout << ""FitConfig: add parameter "" << func.ParameterName(i) << "" val = "" << val << std::endl;; 132#endif; 133 i++;; 134 }; 135 }; 136 ; 137 /**; 138 set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list.; 139 */; 140 void SetParamsSettings(unsigned int npar, const double * params, const double * vstep = nullptr);; 141 ; 142 /*; 143 Set the parameter settings from a vector of parameter settings; 144 */; 145 void SetParamsSettings (const std::vector<ROOT::Fit::ParameterSettings>& pars) {; 146 fSettings = pars;; 147 }; 148 ; 149 ; 150 /*; 151 Set the parameter settings from a fit Result; 152 */; 153 void SetFromFitResult (const FitResult & rhs);; 154 ; 155 ; 156 ; 157 /**; 158 create a new minimizer according to chosen configuration; 159 */; 160 ROOT::Math::Minimizer * CreateMinimizer();; 161 ; 162 ; 163 ; 164 /**; 165 access to the minimizer control parameter (non const method); 166 */; 167 ROOT::Math::MinimizerOptions & MinimizerOptions() { return fMinimizerOpts; }; 168 ; 169 ; 170 /**; 171 set all the minimizer options using class MinimizerOptions; 172 */; 173 void SetMinimizerOptions(const ROOT::Math::MinimizerOptions & minopt);; 174 ; 175 ; 176 /**; 177 set minimizer type; 178 */; 179 void SetMinimizer(const char *type, const char *algo = nullptr) {; 180 if (type) fMinimizerOpts.SetMinimizerType(type);; 181 if (algo) fMinimizerOpts.SetMinimizerAlgorithm(algo);; 182 }; 183 ; 184 /**; 185 return type of minimizer package; 186 */; 187 const std::string & MinimizerType() const { return fMinimizerOpts.MinimizerType(); }; 188 ; 189 /**; 190 return type of minimizer algorithms; 191 */; 192 const std::string & MinimizerAlgoType() const { return fMinimizerOpts.MinimizerAlgorithm(); }; 193 ; 194 /**; 195 * return Minimizer full nam",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:5958,Deployability,configurat,configuration,5958,,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7263,Deployability,configurat,configuration,7263,"Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; /",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7881,Deployability,update,update,7881," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7892,Deployability,configurat,configuration,7892," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:9606,Deployability,configurat,configuration,9606," GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TMath.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:10154,Deployability,configurat,configuration,10154,"me wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TMath.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSetti",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:12664,Deployability,configurat,configuration,12664,"ormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(const std::vector< unsigned int > &paramInd)set parameter indices for running Minos this can be used for running Minos on a subset of parameters ...Definition FitConfig.h:237; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetUpdateAfterFitvoid SetUpdateAfterFit(bool on=true)Update configuration after a fit using the FitResult.Definition FitConfig.h:243; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:14149,Deployability,configurat,configurationDefinition,14149,"e parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWei",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:15447,Deployability,configurat,configuration,15447,"g::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseParam::Parametersvirtual const double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:16728,Integrability,interface,interface,16728,"rameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseParam::Parametersvirtual const double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default nam...Definition IParamFunction.h:86; ROOT::Math::IBaseParam::NParvirtual unsigned int NPar() const =0Return the number of Parameters.; ROOT::Math::IParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a d...Definition IParamFunction.h:108; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMinimizerTypevoid SetMinimizerType(const char *type)set minimizer typeDefinition MinimizerOptions.h:231; ROOT::Math::MinimizerOptions::MinimizerAlgorithmconst std::string & MinimizerAlgorithm() consttype of algorithmDefinition MinimizerOptions.h:201; ROOT::Math::MinimizerOptions::MinimizerTypeconst std::string & MinimizerType() consttype of minimizerDefinition MinimizerOptions.h:198; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlob",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:17563,Integrability,interface,interface,17563,"nst double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default nam...Definition IParamFunction.h:86; ROOT::Math::IBaseParam::NParvirtual unsigned int NPar() const =0Return the number of Parameters.; ROOT::Math::IParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a d...Definition IParamFunction.h:108; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMinimizerTypevoid SetMinimizerType(const char *type)set minimizer typeDefinition MinimizerOptions.h:231; ROOT::Math::MinimizerOptions::MinimizerAlgorithmconst std::string & MinimizerAlgorithm() consttype of algorithmDefinition MinimizerOptions.h:201; ROOT::Math::MinimizerOptions::MinimizerTypeconst std::string & MinimizerType() consttype of minimizerDefinition MinimizerOptions.h:198; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char *type)set minimizer algorithmDefinition MinimizerOptions.h:234; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoreincFitFitConfig.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:1099,Modifiability,config,configuration,1099,"3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class FitConfig; 12 ; 13#ifndef ROOT_Fit_FitConfig; 14#define ROOT_Fit_FitConfig; 15 ; 16 ; 17#include ""Fit/ParameterSettings.h""; 18 ; 19#include ""Math/MinimizerOptions.h""; 20 ; 21#include ""Math/IParamFunctionfwd.h""; 22 ; 23#include ""TMath.h""; 24 ; 25#include <vector>; 26#include <string>; 27 ; 28namespace ROOT {; 29 ; 30 namespace Math {; 31 ; 32 class Minimizer;; 33 class MinimizerOptions;; 34 }; 35 ; 36 namespace Fit {; 37 ; 38 class FitResult;; 39 ; 40//___________________________________________________________________________________; 41/**; 42 Class describing the configuration of the fit, options and parameter settings; 43 using the ROOT::Fit::ParameterSettings class; 44 ; 45 @ingroup FitMain; 46*/; 47class FitConfig {; 48 ; 49public:; 50 ; 51 /**; 52 Default constructor; 53 */; 54 FitConfig (unsigned int npar = 0);; 55 ; 56 ; 57 /*; 58 Copy constructor; 59 */; 60 FitConfig(const FitConfig & rhs);; 61 ; 62 /**; 63 Destructor; 64 */; 65 ~FitConfig ();; 66 ; 67 /*; 68 Assignment operator; 69 */; 70 FitConfig & operator= (const FitConfig & rhs);; 71 ; 72 ; 73 /**; 74 get the parameter settings for the i-th parameter (const method); 75 */; 76 const ParameterSettings & ParSettings(unsigned int i) const { return fSettings.at(i); }; 77 ; 78 /**; 79 get the parameter settings for the i-th parameter (non-const method); 80 */; 81 ParameterSettings & ParSettings(unsigned int i) { return fSettings.at(i); }; 82 ; 83 /**; 84 get the vector of parameter settings (const method); 85 */; 86 const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const { return fSettings; }; 87 ; 88 /**; 89 get the vector of parameter settings (non-const method); 90 */; 91 std::vector<ROOT::Fit::ParameterSettings> & ParamsSetting",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:4467,Modifiability,config,configuration,4467,"(ParameterSettings(func.ParameterName(i), val, step));; 130#ifdef DEBUG; 131 std::cout << ""FitConfig: add parameter "" << func.ParameterName(i) << "" val = "" << val << std::endl;; 132#endif; 133 i++;; 134 }; 135 }; 136 ; 137 /**; 138 set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list.; 139 */; 140 void SetParamsSettings(unsigned int npar, const double * params, const double * vstep = nullptr);; 141 ; 142 /*; 143 Set the parameter settings from a vector of parameter settings; 144 */; 145 void SetParamsSettings (const std::vector<ROOT::Fit::ParameterSettings>& pars) {; 146 fSettings = pars;; 147 }; 148 ; 149 ; 150 /*; 151 Set the parameter settings from a fit Result; 152 */; 153 void SetFromFitResult (const FitResult & rhs);; 154 ; 155 ; 156 ; 157 /**; 158 create a new minimizer according to chosen configuration; 159 */; 160 ROOT::Math::Minimizer * CreateMinimizer();; 161 ; 162 ; 163 ; 164 /**; 165 access to the minimizer control parameter (non const method); 166 */; 167 ROOT::Math::MinimizerOptions & MinimizerOptions() { return fMinimizerOpts; }; 168 ; 169 ; 170 /**; 171 set all the minimizer options using class MinimizerOptions; 172 */; 173 void SetMinimizerOptions(const ROOT::Math::MinimizerOptions & minopt);; 174 ; 175 ; 176 /**; 177 set minimizer type; 178 */; 179 void SetMinimizer(const char *type, const char *algo = nullptr) {; 180 if (type) fMinimizerOpts.SetMinimizerType(type);; 181 if (algo) fMinimizerOpts.SetMinimizerAlgorithm(algo);; 182 }; 183 ; 184 /**; 185 return type of minimizer package; 186 */; 187 const std::string & MinimizerType() const { return fMinimizerOpts.MinimizerType(); }; 188 ; 189 /**; 190 return type of minimizer algorithms; 191 */; 192 const std::string & MinimizerAlgoType() const { return fMinimizerOpts.MinimizerAlgorithm(); }; 193 ; 194 /**; 195 * return Minimizer full nam",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:5958,Modifiability,config,configuration,5958,,MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7263,Modifiability,config,configuration,7263,"Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; /",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:7892,Modifiability,config,configuration,7892," 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 bool fParabErrors; ///< get correct parabolic errors estimate (call Hesse after minimizing); 261 bool fMinosErrors; ///< do full error analysis using Minos; 262 bool fUpdateAfterFit; ///< update the configuration after a fit using the result; 263 bool fWeightCorr; ///< apply correction to errors for weights fits; 264 ; 265 std::vector<ROOT::Fit::ParameterSettings> fSettings; ///< vector with the parameter settings; 266 std::vector<unsigned int> fMinosParams; ///< vector with the parameter indices for running Minos; 267 ; 268 ROOT::Math::MinimizerOptions fMinimizerOpts; ///< minimizer control parameters including name and algo type; 269 ; 270};; 271 ; 272 } // end namespace Fit; 273 ; 274} // end namespace ROOT; 275 ; 276 ; 277#endif /* ROOT_Fit_FitConfig */; IParamFunctionfwd.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:9606,Modifiability,config,configuration,9606," GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TMath.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:10154,Modifiability,config,configuration,10154,"me wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TMath.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSetti",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:12664,Modifiability,config,configuration,12664,"ormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(const std::vector< unsigned int > &paramInd)set parameter indices for running Minos this can be used for running Minos on a subset of parameters ...Definition FitConfig.h:237; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetUpdateAfterFitvoid SetUpdateAfterFit(bool on=true)Update configuration after a fit using the FitResult.Definition FitConfig.h:243; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::fSettingsstd::vector< ROOT::Fit::ParameterSettings > fSettingsvector with the parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:14149,Modifiability,config,configurationDefinition,14149,"e parameter settingsDefinition FitConfig.h:265; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::fParabErrorsbool fParabErrorsget correct parabolic errors estimate (call Hesse after minimizing)Definition FitConfig.h:260; ROOT::Fit::FitConfig::fMinimizerOptsROOT::Math::MinimizerOptions fMinimizerOptsminimizer control parameters including name and algo typeDefinition FitConfig.h:268; ROOT::Fit::FitConfig::~FitConfig~FitConfig()Destructor.Definition FitConfig.cxx:52; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWei",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:15447,Modifiability,config,configuration,15447,"g::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseParam::Parametersvirtual const double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:6688,Performance,perform,performed,6688,"const { return fNormErrors; }; 203 ; 204 ///do analysis for parabolic errors; 205 bool ParabErrors() const { return fParabErrors; }; 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for error normalization; 260 ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:10626,Performance,perform,performed,10626,"escribing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::ParSettingsParameterSettings & ParSettings(unsigned int i)get the parameter settings for the i-th parameter (non-const method)Definition FitConfig.h:81; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::ParamsSettingsstd::vector< ROOT::Fit::ParameterSettings > & ParamsSettings()get the vector of parameter settings (non-const method)Definition FitConfig.h:91; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(const std::vector< ROOT::Fit::ParameterSettings > &pars)Definition FitConfig.",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:16515,Safety,avoid,avoid,16515,"ate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseParam::Parametersvirtual const double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default nam...Definition IParamFunction.h:86; ROOT::Math::IBaseParam::NParvirtual unsigned int NPar() const =0Return the number of Parameters.; ROOT::Math::IParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parametric functions It is a d...Definition IParamFunction.h:108; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMinimizerTypevoid SetMinimizerType(const char *type)set minimizer typeDefinition MinimizerOptions.h:231; ROOT::Math::MinimizerOptions::MinimizerAlgorithmconst std::string & MinimizerAlgorithm() consttype of algorithmDefinition MinimizerOptions.h:201; ROOT::Math::MinimizerOptions::MinimizerTypeconst std::string & MinimizerType() consttype of minimizerDefinition MinimizerOptions.h:198; ROOT::Math::MinimizerOptions::SetMinimizerAlgorithmvoid SetMinimizerAlgorithm(const char ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:4569,Security,access,access,4569,"(ParameterSettings(func.ParameterName(i), val, step));; 130#ifdef DEBUG; 131 std::cout << ""FitConfig: add parameter "" << func.ParameterName(i) << "" val = "" << val << std::endl;; 132#endif; 133 i++;; 134 }; 135 }; 136 ; 137 /**; 138 set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list.; 139 */; 140 void SetParamsSettings(unsigned int npar, const double * params, const double * vstep = nullptr);; 141 ; 142 /*; 143 Set the parameter settings from a vector of parameter settings; 144 */; 145 void SetParamsSettings (const std::vector<ROOT::Fit::ParameterSettings>& pars) {; 146 fSettings = pars;; 147 }; 148 ; 149 ; 150 /*; 151 Set the parameter settings from a fit Result; 152 */; 153 void SetFromFitResult (const FitResult & rhs);; 154 ; 155 ; 156 ; 157 /**; 158 create a new minimizer according to chosen configuration; 159 */; 160 ROOT::Math::Minimizer * CreateMinimizer();; 161 ; 162 ; 163 ; 164 /**; 165 access to the minimizer control parameter (non const method); 166 */; 167 ROOT::Math::MinimizerOptions & MinimizerOptions() { return fMinimizerOpts; }; 168 ; 169 ; 170 /**; 171 set all the minimizer options using class MinimizerOptions; 172 */; 173 void SetMinimizerOptions(const ROOT::Math::MinimizerOptions & minopt);; 174 ; 175 ; 176 /**; 177 set minimizer type; 178 */; 179 void SetMinimizer(const char *type, const char *algo = nullptr) {; 180 if (type) fMinimizerOpts.SetMinimizerType(type);; 181 if (algo) fMinimizerOpts.SetMinimizerAlgorithm(algo);; 182 }; 183 ; 184 /**; 185 return type of minimizer package; 186 */; 187 const std::string & MinimizerType() const { return fMinimizerOpts.MinimizerType(); }; 188 ; 189 /**; 190 return type of minimizer algorithms; 191 */; 192 const std::string & MinimizerAlgoType() const { return fMinimizerOpts.MinimizerAlgorithm(); }; 193 ; 194 /**; 195 * return Minimizer full nam",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:15707,Security,access,access,15707,"Result &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IBaseParam::Parametersvirtual const double * Parameters() const =0Access the parameter values.; ROOT::Math::IBaseParam::ParameterNamevirtual std::string ParameterName(unsigned int i) constReturn the name of the i-th parameter (starting from zero) Overwrite if want to avoid the default nam...Definition IParamFunction.h:86; ROOT::Math::IBaseParam::NParvirtual unsigned int NPar() const =0Return the number of Parameters.; ROOT::Math::IParametricFunction",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/FitConfig_8h_source.html:3104,Usability,clear,clear,3104,"gs; }; 87 ; 88 /**; 89 get the vector of parameter settings (non-const method); 90 */; 91 std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() { return fSettings; }; 92 ; 93 /**; 94 number of parameters settings; 95 */; 96 unsigned int NPar() const { return fSettings.size(); }; 97 ; 98 /**; 99 return a vector of stored parameter values (i.e initial fit parameters); 100 */; 101 std::vector<double> ParamsValues() const;; 102 ; 103 ; 104 /**; 105 set the parameter settings from a model function.; 106 Create always new parameter setting list from a given model function; 107 */; 108 template <class T>; 109 void CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl<T> &func) {; 110 // initialize from model function; 111 // set the parameters values from the function; 112 unsigned int npar = func.NPar();; 113 const double *begin = func.Parameters();; 114 if (!begin) {; 115 fSettings = std::vector<ParameterSettings>(npar);; 116 return;; 117 }; 118 ; 119 fSettings.clear();; 120 fSettings.reserve(npar);; 121 const double *end = begin + npar;; 122 unsigned int i = 0;; 123 for (const double *ipar = begin; ipar != end; ++ipar) {; 124 double val = *ipar;; 125 double step = 0.3 * fabs(val); // step size is 30% of par value; 126 // double step = 2.0*fabs(val); // step size is 30% of par value; 127 if (val == 0) step = 0.3;; 128 ; 129 fSettings.push_back(ParameterSettings(func.ParameterName(i), val, step));; 130#ifdef DEBUG; 131 std::cout << ""FitConfig: add parameter "" << func.ParameterName(i) << "" val = "" << val << std::endl;; 132#endif; 133 i++;; 134 }; 135 }; 136 ; 137 /**; 138 set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list.; 139 */; 140 void SetParamsSettings(unsigned int npar, const double * params, const double * vstep = nullptr);; 141 ; 142 /*; 143 Set the parameter settings from a vector ",MatchSource.WIKI,doc/master/FitConfig_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html
https://root.cern/doc/master/fitcont_8C.html:2620,Availability,error,error,2620,"date();; ; TCanvas *c2 = new TCanvas(""c2"",""contours"",10,10,600,800);; c2->Divide(1,2);; c2->cd(1);; /*get first contour for parameter 1 versus parameter 2*/; TGraph *gr12 = (TGraph*)gMinuit->Contour(40,1,2);; gr12->Draw(""alp"");; c2->cd(2);; /*Get contour for parameter 0 versus parameter 2 for ERRDEF=2*/; gMinuit->SetErrorDef(4); //note 4 and not 2!; TGraph *gr2 = (TGraph*)gMinuit->Contour(80,0,2);; gr2->SetFillColor(42);; gr2->Draw(""alf"");; /*Get contour for parameter 0 versus parameter 2 for ERRDEF=1*/; gMinuit->SetErrorDef(1);; TGraph *gr1 = (TGraph*)gMinuit->Contour(80,0,2);; gr1->SetFillColor(38);; gr1->Draw(""lf"");; }; h#define h(i)Definition RSha256.hxx:106; TCanvas.h; TGraph.h; TH1F.h; TMinuit.h; gMinuitR__EXTERN TMinuit * gMinuitDefinition TMinuit.h:271; TVirtualFitter.h; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TMinuit::SetErrorDefvirtual Int_t SetErrorDef(Double_t up)To get the n-sigma contour the error def parameter ""up"" has to set to n^2.Definition TMinuit.cxx:908; TMinuit::Contourvirtual TObject * Contour(Int_t npoints=10, Int_t pa1=0, Int_t pa2=1)Creates a TGraph object describing the n-sigma contour of a TMinuit fit.Definition TMinuit.cxx:653; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; c1return c1Definition legend1.C:41; c2return c2Definition legend2.C:14; AuthorRene Brun ; Definition in file fitcont.C. tutorialsfitfitcont.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fitcont_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitcont_8C.html
https://root.cern/doc/master/fitcont_8C.html:393,Integrability,rout,routine,393,". ROOT: tutorials/fit/fitcont.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitcont.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Example illustrating how to draw the n-sigma contour of a Minuit fit. ; To get the n-sigma contour the ERRDEF parameter in Minuit has to set to n^2. The fcn function has to be set before the routine is called.; WARNING!!! This test works only with TMinuit; The TGraph object is created via the interpreter. The user must cast it to a TGraph*. ; FCN=96.6163 FROM MIGRAD STATUS=CONVERGED 62 CALLS 63 TOTAL; EDM=2.07594e-08 STRATEGY= 1 ERROR MATRIX ACCURATE ; EXT PARAMETER STEP FIRST ; NO. NAME VALUE ERROR SIZE DERIVATIVE ; 1 Constant 1.43454e+02 2.29666e+00 9.00732e-03 -6.49594e-05; 2 Mean 1.60911e-02 1.30402e-02 6.28520e-05 3.57224e-03; 3 Sigma 9.87683e-01 9.45637e-03 1.24479e-05 2.14428e-02; ; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1F.h>; #include <TMinuit.h>; #include <TVirtualFitter.h>; ; void fitcont(); {; //be sure default is Minuit since we will use gMinuit; TVirtualFitter::SetDefaultFitter(""Minuit"");; ; TCanvas *c1 = new TCanvas(""c1"");; TH1F *h = new TH1F(""h"",""My histogram"",100,-3,3);; h->FillRandom(""gaus"",6000);; h->Fit(""gaus"");; c1->Update();; ; TCanvas *c2 = new TCanvas(""c2"",""contours"",10,10,600,800);; c2->Divide(1,2);; c2->cd(1);; /*get first contour for parameter 1 versus parameter 2*/; TGraph *gr12 = (TGraph*)gMinuit->Contour(40,1,2);; gr12->Draw(""alp"");; c2->cd(2);; /*Get contour for parameter 0 versus parameter 2 for ERRDEF=2*/; gMinuit->SetErrorDef(4); //note 4 and not 2!; TGraph *gr2 = (TGraph*)gMinuit->Contour(80,0,2);; gr2->SetFillColor(42);; gr2->Draw(""alf"");; /*Get contour for parameter 0 versus parameter 2 for ERRDEF=1*/; gMinuit->SetErrorDef(1);; TGraph *gr1 = (TGraph*)gMinuit->Contour(80,0,2);; gr1->SetFillColor(38);; gr1->Draw(""lf"");; }; h#define h(i)Definition RSha256.hxx:106; TCanvas.h; TGraph.h; TH1F.h; TMinuit.h; gMinuitR__EXTERN",MatchSource.WIKI,doc/master/fitcont_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitcont_8C.html
https://root.cern/doc/master/fitcont_8C.html:429,Testability,test,test,429,". ROOT: tutorials/fit/fitcont.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitcont.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Example illustrating how to draw the n-sigma contour of a Minuit fit. ; To get the n-sigma contour the ERRDEF parameter in Minuit has to set to n^2. The fcn function has to be set before the routine is called.; WARNING!!! This test works only with TMinuit; The TGraph object is created via the interpreter. The user must cast it to a TGraph*. ; FCN=96.6163 FROM MIGRAD STATUS=CONVERGED 62 CALLS 63 TOTAL; EDM=2.07594e-08 STRATEGY= 1 ERROR MATRIX ACCURATE ; EXT PARAMETER STEP FIRST ; NO. NAME VALUE ERROR SIZE DERIVATIVE ; 1 Constant 1.43454e+02 2.29666e+00 9.00732e-03 -6.49594e-05; 2 Mean 1.60911e-02 1.30402e-02 6.28520e-05 3.57224e-03; 3 Sigma 9.87683e-01 9.45637e-03 1.24479e-05 2.14428e-02; ; #include <TCanvas.h>; #include <TGraph.h>; #include <TH1F.h>; #include <TMinuit.h>; #include <TVirtualFitter.h>; ; void fitcont(); {; //be sure default is Minuit since we will use gMinuit; TVirtualFitter::SetDefaultFitter(""Minuit"");; ; TCanvas *c1 = new TCanvas(""c1"");; TH1F *h = new TH1F(""h"",""My histogram"",100,-3,3);; h->FillRandom(""gaus"",6000);; h->Fit(""gaus"");; c1->Update();; ; TCanvas *c2 = new TCanvas(""c2"",""contours"",10,10,600,800);; c2->Divide(1,2);; c2->cd(1);; /*get first contour for parameter 1 versus parameter 2*/; TGraph *gr12 = (TGraph*)gMinuit->Contour(40,1,2);; gr12->Draw(""alp"");; c2->cd(2);; /*Get contour for parameter 0 versus parameter 2 for ERRDEF=2*/; gMinuit->SetErrorDef(4); //note 4 and not 2!; TGraph *gr2 = (TGraph*)gMinuit->Contour(80,0,2);; gr2->SetFillColor(42);; gr2->Draw(""alf"");; /*Get contour for parameter 0 versus parameter 2 for ERRDEF=1*/; gMinuit->SetErrorDef(1);; TGraph *gr1 = (TGraph*)gMinuit->Contour(80,0,2);; gr1->SetFillColor(38);; gr1->Draw(""lf"");; }; h#define h(i)Definition RSha256.hxx:106; TCanvas.h; TGraph.h; TH1F.h; TMinuit.h; gMinuitR__EXTERN",MatchSource.WIKI,doc/master/fitcont_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitcont_8C.html
https://root.cern/doc/master/fitConvolution_8C.html:1508,Integrability,wrap,wrapping,1508," #include <TCanvas.h>; #include <TRandom.h>; #include <TF1Convolution.h>; #include <TF1.h>; #include <TH1F.h>; ; void fitConvolution(); {; // Construction of histogram to fit.; TH1F *h_ExpGauss = new TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0., 5.);; for (int i = 0; i < 1e6; i++) {; // Gives a alpha of -0.3 in the exp.; double x = gRandom->Exp(1. / 0.3);; x += gRandom->Gaus(0., 3.);; // Probability density function of the addition of two variables is the; // convolution of two density functions.; h_ExpGauss->Fill(x);; }; ; TF1Convolution *f_conv = new TF1Convolution(""expo"", ""gaus"", -1, 6, true);; f_conv->SetRange(-1., 6.);; f_conv->SetNofPointsFFT(1000);; TF1 *f = new TF1(""f"", *f_conv, 0., 5., f_conv->GetNpar());; f->SetParameters(1., -0.3, 0., 1.);; ; // Fit.; h_ExpGauss->Fit(""f"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TF1Convolution.h; TF1.h; TH1F.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::SetRangevoid SetRange(Double_t a, Double_t b) overrideSet the actual range used for the convolution.Definition TF1Convolution.cxx:452; TF1Convolution::SetNofPointsFFTvoid SetNofPointsFFT(Int_t n)Set the number of points used for the FFT convolution.Definition TF1Convolution.cxx:382; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribut",MatchSource.WIKI,doc/master/fitConvolution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitConvolution_8C.html
https://root.cern/doc/master/fitConvolution_8C.html:977,Modifiability,variab,variables,977,". ROOT: tutorials/fit/fitConvolution.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitConvolution.C File ReferenceTutorials  Fit Tutorials. Detailed Description; Tutorial for convolution of two functions . ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 298.12; NDf = 96; Edm = 1.67196e-06; NCalls = 448; p0 = 7.32861 +/- 0.0370492 ; p1 = 0.0733018 +/- 0.00243973 ; p2 = -2.26418 +/- 0.0491372 ; p3 = 1.12808 +/- 0.0628185 ; ; #include <TCanvas.h>; #include <TRandom.h>; #include <TF1Convolution.h>; #include <TF1.h>; #include <TH1F.h>; ; void fitConvolution(); {; // Construction of histogram to fit.; TH1F *h_ExpGauss = new TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0., 5.);; for (int i = 0; i < 1e6; i++) {; // Gives a alpha of -0.3 in the exp.; double x = gRandom->Exp(1. / 0.3);; x += gRandom->Gaus(0., 3.);; // Probability density function of the addition of two variables is the; // convolution of two density functions.; h_ExpGauss->Fill(x);; }; ; TF1Convolution *f_conv = new TF1Convolution(""expo"", ""gaus"", -1, 6, true);; f_conv->SetRange(-1., 6.);; f_conv->SetNofPointsFFT(1000);; TF1 *f = new TF1(""f"", *f_conv, 0., 5., f_conv->GetNpar());; f->SetParameters(1., -0.3, 0., 1.);; ; // Fit.; h_ExpGauss->Fit(""f"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TF1Convolution.h; TF1.h; TH1F.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::SetRangevoid SetRange(Double_t a, Double_t b) overrideSet the actual range used for the convolution.Definition TF1Convolution.cxx:452; TF1Convolution::SetNofPointsFFTvoid SetNofPointsFFT(Int_t n)Set the number of points used for the FFT convolution.Definition TF1Convolution.cxx:382; TF11-Dim function classDefinition TF1.h:233; TH",MatchSource.WIKI,doc/master/fitConvolution_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitConvolution_8C.html
https://root.cern/doc/master/fitConvolution_8C_source.html:1470,Integrability,wrap,wrapping,1470,"h>; 15#include <TF1.h>; 16#include <TH1F.h>; 17 ; 18void fitConvolution(); 19{; 20 // Construction of histogram to fit.; 21 TH1F *h_ExpGauss = new TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0., 5.);; 22 for (int i = 0; i < 1e6; i++) {; 23 // Gives a alpha of -0.3 in the exp.; 24 double x = gRandom->Exp(1. / 0.3);; 25 x += gRandom->Gaus(0., 3.);; 26 // Probability density function of the addition of two variables is the; 27 // convolution of two density functions.; 28 h_ExpGauss->Fill(x);; 29 }; 30 ; 31 TF1Convolution *f_conv = new TF1Convolution(""expo"", ""gaus"", -1, 6, true);; 32 f_conv->SetRange(-1., 6.);; 33 f_conv->SetNofPointsFFT(1000);; 34 TF1 *f = new TF1(""f"", *f_conv, 0., 5., f_conv->GetNpar());; 35 f->SetParameters(1., -0.3, 0., 1.);; 36 ; 37 // Fit.; 38 h_ExpGauss->Fit(""f"");; 39}; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TF1Convolution.h; TF1.h; TH1F.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::SetRangevoid SetRange(Double_t a, Double_t b) overrideSet the actual range used for the convolution.Definition TF1Convolution.cxx:452; TF1Convolution::SetNofPointsFFTvoid SetNofPointsFFT(Int_t n)Set the number of points used for the FFT convolution.Definition TF1Convolution.cxx:382; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribut",MatchSource.WIKI,doc/master/fitConvolution_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitConvolution_8C_source.html
https://root.cern/doc/master/fitConvolution_8C_source.html:901,Modifiability,variab,variables,901,". ROOT: tutorials/fit/fitConvolution.C Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitConvolution.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_fit; 3/// \notebook -js; 4/// Tutorial for convolution of two functions; 5///; 6/// \macro_image; 7/// \macro_output; 8/// \macro_code; 9///; 10/// \author Aurelie Flandi; 11 ; 12#include <TCanvas.h>; 13#include <TRandom.h>; 14#include <TF1Convolution.h>; 15#include <TF1.h>; 16#include <TH1F.h>; 17 ; 18void fitConvolution(); 19{; 20 // Construction of histogram to fit.; 21 TH1F *h_ExpGauss = new TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0., 5.);; 22 for (int i = 0; i < 1e6; i++) {; 23 // Gives a alpha of -0.3 in the exp.; 24 double x = gRandom->Exp(1. / 0.3);; 25 x += gRandom->Gaus(0., 3.);; 26 // Probability density function of the addition of two variables is the; 27 // convolution of two density functions.; 28 h_ExpGauss->Fill(x);; 29 }; 30 ; 31 TF1Convolution *f_conv = new TF1Convolution(""expo"", ""gaus"", -1, 6, true);; 32 f_conv->SetRange(-1., 6.);; 33 f_conv->SetNofPointsFFT(1000);; 34 TF1 *f = new TF1(""f"", *f_conv, 0., 5., f_conv->GetNpar());; 35 f->SetParameters(1., -0.3, 0., 1.);; 36 ; 37 // Fit.; 38 h_ExpGauss->Fit(""f"");; 39}; f#define f(i)Definition RSha256.hxx:104; TCanvas.h; TF1Convolution.h; TF1.h; TH1F.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TF1ConvolutionClass wrapping convolution of two functions.Definition TF1Convolution.h:20; TF1Convolution::GetNparInt_t GetNpar() constDefinition TF1Convolution.h:68; TF1Convolution::SetRangevoid SetRange(Double_t a, Double_t b) overrideSet the actual range used for the convolution.Definition TF1Convolution.cxx:452; TF1Convolution::SetNofPointsFFTvoid SetNofPointsFFT(Int_t n)Set the number of points used for the FFT convolution.Definition TF1Convolution.cxx:382; TF11-Dim function classDefinition TF1.h:233; TH1F1-D histogram with a float per chann",MatchSource.WIKI,doc/master/fitConvolution_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitConvolution_8C_source.html
https://root.cern/doc/master/fitConvolution_8py.html:855,Modifiability,variab,variables,855,". ROOT: tutorials/fit/fitConvolution.py File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Namespaces ; fitConvolution.py File ReferenceTutorials  Fit Tutorials. Detailed Description; Tutorial for convolution of two functions . ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 298.12; NDf = 96; Edm = 1.67196e-06; NCalls = 448; p0 = 7.32861 +/- 0.0370492 ; p1 = 0.0733018 +/- 0.00243973 ; p2 = -2.26418 +/- 0.0491372 ; p3 = 1.12808 +/- 0.0628185 ; ; import ROOT; ; # Construction of histogram to fit.; h_ExpGauss = ROOT.TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0.0, 5.0); for i in range(1000000):; # Gives a alpha of -0.3 in the exp.; x = ROOT.gRandom.Exp(1.0 / 0.3); x += ROOT.gRandom.Gaus(0.0, 3.0); # Probability density function of the addition of two variables is the; # convolution of two density functions.; h_ExpGauss.Fill(x); ; f_conv = ROOT.TF1Convolution(""expo"", ""gaus"", -1, 6, True); f_conv.SetRange(-1.0, 6.0); f_conv.SetNofPointsFFT(1000); f = ROOT.TF1(""f"", f_conv, 0.0, 5.0, f_conv.GetNpar()); f.SetParameters(1.0, -0.3, 0.0, 1.0); ; c1 = ROOT.TCanvas(""c1"", ""c1"", 800, 1000); ; # Fit and draw result of the fit; h_ExpGauss.Fit(""f""); ; c1.SaveAs(""fitConvolution.png""); AuthorJonas Rembser, Aurelie Flandi (C++ version) ; Definition in file fitConvolution.py. tutorialsfitfitConvolution.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fitConvolution_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitConvolution_8py.html
https://root.cern/doc/master/fitConvolution_8py_source.html:768,Modifiability,variab,variables,768,". ROOT: tutorials/fit/fitConvolution.py Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitConvolution.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_fit; 3## \notebook; 4## Tutorial for convolution of two functions; 5##; 6## \macro_image; 7## \macro_output; 8## \macro_code; 9##; 10## \author Jonas Rembser, Aurelie Flandi (C++ version); 11 ; 12import ROOT; 13 ; 14# Construction of histogram to fit.; 15h_ExpGauss = ROOT.TH1F(""h_ExpGauss"", ""Exponential convoluted by Gaussian"", 100, 0.0, 5.0); 16for i in range(1000000):; 17 # Gives a alpha of -0.3 in the exp.; 18 x = ROOT.gRandom.Exp(1.0 / 0.3); 19 x += ROOT.gRandom.Gaus(0.0, 3.0); 20 # Probability density function of the addition of two variables is the; 21 # convolution of two density functions.; 22 h_ExpGauss.Fill(x); 23 ; 24f_conv = ROOT.TF1Convolution(""expo"", ""gaus"", -1, 6, True); 25f_conv.SetRange(-1.0, 6.0); 26f_conv.SetNofPointsFFT(1000); 27f = ROOT.TF1(""f"", f_conv, 0.0, 5.0, f_conv.GetNpar()); 28f.SetParameters(1.0, -0.3, 0.0, 1.0); 29 ; 30c1 = ROOT.TCanvas(""c1"", ""c1"", 800, 1000); 31 ; 32# Fit and draw result of the fit; 33h_ExpGauss.Fit(""f""); 34 ; 35c1.SaveAs(""fitConvolution.png""). tutorialsfitfitConvolution.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fitConvolution_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitConvolution_8py_source.html
https://root.cern/doc/master/fitExclude_8C.html:1856,Testability,test,tested,1856,"4731 +/- 0.946564 ; p1 = -4.81581 +/- 0.26533 ; ; #include <TH1.h>; #include <TF1.h>; #include <TROOT.h>; ; bool reject;; double fline(double *x, double *par); {; if (reject && x[0] > 2.5 && x[0] < 3.5) {; TF1::RejectPoint();; return 0;; }; return par[0] + par[1]*x[0];; }; ; void fitExclude() {; //Create a source function; TF1 *f1 = new TF1(""f1"",""[0] +[1]*x +gaus(2)"",0,5);; f1->SetParameters(6,-1,5,3,0.2);; // create and fill histogram according to the source function; TH1F *h = new TH1F(""h"",""background + signal"",100,0,5);; h->FillRandom(""f1"",2000);; TF1 *fl = new TF1(""fl"",fline,0,5,2);; fl->SetParameters(2,-1);; //fit only the linear background excluding the signal area; reject = true;; h->Fit(fl,""0"");; reject = false;; //store 2 separate functions for visualization; TF1 *fleft = new TF1(""fleft"",fline,0,2.5,2);; fleft->SetParameters(fl->GetParameters());; h->GetListOfFunctions()->Add(fleft);; gROOT->GetListOfFunctions()->Remove(fleft);; TF1 *fright = new TF1(""fright"",fline,3.5,5,2);; fright->SetParameters(fl->GetParameters());; h->GetListOfFunctions()->Add(fright);; gROOT->GetListOfFunctions()->Remove(fright);; h->Draw();; }; ; h#define h(i)Definition RSha256.hxx:106; TF1.h; TH1.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TF11-Dim function classDefinition TF1.h:233; TF1::RejectPointstatic void RejectPoint(Bool_t reject=kTRUE)Static function to set the global flag to reject points the fgRejectPoint global flag is tested by al...Definition TF1.cxx:3683; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; xDouble_t x[n]Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; AuthorRene Brun ; Definition in file fitExclude.C. tutorialsfitfitExclude.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fitExclude_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitExclude_8C.html
https://root.cern/doc/master/fithist_8C.html:3209,Energy Efficiency,power,power,3209," to signal + background; ; histgen();; ; TFile *f = new TFile(""background.root"");; background = (TH1F*)f->Get(""background""); //pointer used in ftotal; TH1F *result = (TH1F*)f->Get(""result"");; ; TF1 *ftot = new TF1(""ftot"",ftotal,0,10,4);; double norm = result->GetMaximum();; ftot->SetParameters(0.5*norm,5,.2,norm);; ftot->SetParLimits(0,.3*norm,norm);; ; result->Fit(""ftot"",""b"");; }; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; TF1.h; TFile.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH1F.h; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; xDouble_t x[n]Definition legend1.C:17; f1TF1 * f1Definition legend1.C:11; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; AuthorRene Brun ; Definition in file fithist.C. tutorialsfitfithist.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fithist_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fithist_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:2358,Availability,error,errors,2358,"re the fastest to fit; lf->SetFormula(""hyp5"");; ; double *x=new double[n*10*5];; double *y=new double[n*10];; double *e=new double[n*10];; ; //Create the points and put them into the fitter; for (i=0; i<n; i++){; x[0 + i*5] = randNum.Uniform(-10, 10);; x[1 + i*5] = randNum.Uniform(-10, 10);; x[2 + i*5] = randNum.Uniform(-10, 10);; x[3 + i*5] = randNum.Uniform(-10, 10);; x[4 + i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //To avoid copying the data into the fitter, the following function can be used:; lf->AssignData(n, 5, x, y, e);; //A different way to put the points into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() funct",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:2409,Availability,error,errors,2409,"re the fastest to fit; lf->SetFormula(""hyp5"");; ; double *x=new double[n*10*5];; double *y=new double[n*10];; double *e=new double[n*10];; ; //Create the points and put them into the fitter; for (i=0; i<n; i++){; x[0 + i*5] = randNum.Uniform(-10, 10);; x[1 + i*5] = randNum.Uniform(-10, 10);; x[2 + i*5] = randNum.Uniform(-10, 10);; x[3 + i*5] = randNum.Uniform(-10, 10);; x[4 + i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //To avoid copying the data into the fitter, the following function can be used:; lf->AssignData(n, 5, x, y, e);; //A different way to put the points into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() funct",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:2485,Availability,error,errors,2485,"re the fastest to fit; lf->SetFormula(""hyp5"");; ; double *x=new double[n*10*5];; double *y=new double[n*10];; double *e=new double[n*10];; ; //Create the points and put them into the fitter; for (i=0; i<n; i++){; x[0 + i*5] = randNum.Uniform(-10, 10);; x[1 + i*5] = randNum.Uniform(-10, 10);; x[2 + i*5] = randNum.Uniform(-10, 10);; x[3 + i*5] = randNum.Uniform(-10, 10);; x[4 + i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //To avoid copying the data into the fitter, the following function can be used:; lf->AssignData(n, 5, x, y, e);; //A different way to put the points into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() funct",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:3123,Availability,error,errors,3123,"into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), e",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:3228,Availability,error,errors,3228,"into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), e",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:3620,Availability,error,errors,3620,"m.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the para",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:3729,Availability,error,errors,3729,"m.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the para",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:4028,Availability,error,errors,4028,"m.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the para",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:4132,Availability,error,errors,4132,"m.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nMore Points:\n"");; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the para",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:4626,Availability,error,errors,4626,"tParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors.Definition TLinearFitter.cxx:874; TLinearFitter::AssignDatavirtual void AssignData(Int_t npoints, Int_t xncols, Double_t *x, Double_t *y, Double_t *e=nullptr)This function is to use when you already have all the data in arrays and don't want to copy them into...Definition TLinearFitter.cxx:583; TLinearFitter::GetParametersvirtual void GetParameters(TVectorD &vpar)Returns parameter values.Definition TLinearFitter.cxx:1341; TLinearFitter::FixParametervoid FixParameter(Int_t ipar) overrideFixes paramter #ipar at its current value.Definition TLinearFitter.cxx:1001; TLinearFitter::SetFormulavirtual void SetFormula(const char *formula)Additive parts should be separated by ""++"".Definition TLinearFitter.cxx:1521; TRandomThis is the base class for the ROOT Random number generators.D",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:4794,Availability,error,errors,4794,"errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors.Definition TLinearFitter.cxx:874; TLinearFitter::AssignDatavirtual void AssignData(Int_t npoints, Int_t xncols, Double_t *x, Double_t *y, Double_t *e=nullptr)This function is to use when you already have all the data in arrays and don't want to copy them into...Definition TLinearFitter.cxx:583; TLinearFitter::GetParametersvirtual void GetParameters(TVectorD &vpar)Returns parameter values.Definition TLinearFitter.cxx:1341; TLinearFitter::FixParametervoid FixParameter(Int_t ipar) overrideFixes paramter #ipar at its current value.Definition TLinearFitter.cxx:1001; TLinearFitter::SetFormulavirtual void SetFormula(const char *formula)Additive parts should be separated by ""++"".Definition TLinearFitter.cxx:1521; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Ga",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:4254,Deployability,release,released,4254," printf(""chisquare=%.15f\n"", chisquare);; ; ; //Suppose, you are not satisfied with the result and want to try a different formula; //Without a constant:; //Since the AssignData() function was used, you don't have to add all points to the fitter again; lf->SetFormula(""x0++x1++x2++x3++x4"");; ; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nWithout Constant\n"");; for (int i=0; i<5; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; //Now suppose that you want to fix the value of one of the parameters; //Let's fix the first parameter at 4:; lf->SetFormula(""hyp5"");; lf->FixParameter(1, 4);; lf->Eval();; lf->GetParameters(params);; lf->GetErrors(errors);; printf(""\nFixed Constant:\n"");; for (i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; chisquare=lf->GetChisquare();; printf(""chisquare=%.15f\n"", chisquare);; ; //The fixed parameters can then be released by the ReleaseParameter method; delete lf;; ; }; ; e#define e(i)Definition RSha256.hxx:103; TF1.h; TLinearFitter.h; TRandom.h; TLinearFitterDefinition TLinearFitter.h:153; TLinearFitter::GetChisquarevirtual Double_t GetChisquare()Get the Chisquare.Definition TLinearFitter.cxx:1074; TLinearFitter::GetErrorsvirtual void GetErrors(TVectorD &vpar)Returns parameter errors.Definition TLinearFitter.cxx:1328; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors.Definition TLinearFitter.cxx:874; TLinearFitter::AssignDatavirtual void AssignData(Int_t npoints, Int_t xncols, Double_t *x, Double_t *y, Double_t *e=nullptr)This function is to use when you already have all the data in arrays and don't want to copy them into...Definition TLinearFitter.cxx:583; TLinearFitter::GetParametersvirtual void GetParameters(TVectorD &vpar)Returns parameter values.Definition TLinearFitter.cxx:1341; TLinearFitter::FixParametervoid FixParameter",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinear2_8C.html:1987,Safety,avoid,avoid,1987,"[1]=4.000000+-1.000000; par[2]=0.999884+-0.000125; par[3]=2.000070+-0.000123; par[4]=2.999910+-0.000127; par[5]=0.199920+-0.000130; chisquare=145.602523231220914; ; #include ""TLinearFitter.h""; #include ""TF1.h""; #include ""TRandom.h""; ; void fitLinear2(); {; int n=100;; int i;; TRandom randNum;; TLinearFitter *lf=new TLinearFitter(5);; ; //The predefined ""hypN"" functions are the fastest to fit; lf->SetFormula(""hyp5"");; ; double *x=new double[n*10*5];; double *y=new double[n*10];; double *e=new double[n*10];; ; //Create the points and put them into the fitter; for (i=0; i<n; i++){; x[0 + i*5] = randNum.Uniform(-10, 10);; x[1 + i*5] = randNum.Uniform(-10, 10);; x[2 + i*5] = randNum.Uniform(-10, 10);; x[3 + i*5] = randNum.Uniform(-10, 10);; x[4 + i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //To avoid copying the data into the fitter, the following function can be used:; lf->AssignData(n, 5, x, y, e);; //A different way to put the points into the fitter would be to use; //the AddPoint function for each point. This way the points are copied and stored; //inside the fitter; ; //Perform the fitting and look at the results; lf->Eval();; TVectorD params;; TVectorD errors;; lf->GetParameters(params);; lf->GetErrors(errors);; for (int i=0; i<6; i++); printf(""par[%d]=%f+-%f\n"", i, params(i), errors(i));; double chisquare=lf->GetChisquare();; printf(""chisquare=%f\n"", chisquare);; ; ; //Now suppose you want to add some more points and see if the parameters will change; for (i=n; i<n*2; i++) {; x[0+i*5] = randNum.Uniform(-10, 10);; x[1+i*5] = randNum.Uniform(-10, 10);; x[2+i*5] = randNum.Uniform(-10, 10);; x[3+i*5] = randNum.Uniform(-10, 10);; x[4+i*5] = randNum.Uniform(-10, 10);; e[i] = 0.01;; y[i] = 4*x[0+i*5] + x[1+i*5] + 2*x[2+i*5] + 3*x[3+i*5] + 0.2*x[4+i*5] + randNum.Gaus()*e[i];; }; ; //Assign the data the same way as before; lf->AssignData(n*2, 5, x, y, e);; lf->Eval();; lf-",MatchSource.WIKI,doc/master/fitLinear2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear2_8C.html
https://root.cern/doc/master/fitLinearRobust_8C.html:522,Availability,robust,robust,522,". ROOT: tutorials/fit/fitLinearRobust.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitLinearRobust.C File ReferenceTutorials  Fit Tutorials. Detailed Description; This tutorial shows how the least trimmed squares regression, included in the TLinearFitter class, can be used for fitting in cases when the data contains outliers. ; Here the fitting is done via the TGraph::Fit function with option ""rob"": If you want to use the linear fitter directly for computing the robust fitting coefficients, just use the TLinearFitter::EvalRobust function instead of TLinearFitter::Eval. ; Ordinary least squares:; ****************************************; Minimizer is Linear / Migrad; Chi2 = 606758; NDf = 246; p0 = 15.724 +/- 0.0887641 ; p1 = -0.835912 +/- 0.14096 ; p2 = -3.40616 +/- 0.0607296 ; p3 = 4.82569 +/- 0.0602628 ; Resistant Least trimmed squares fit:; ****************************************; Minimizer is Linear / Robust (h=0.75); Chi2 = 634792; NDf = 246; p0 = 1.00953; p1 = 1.71148; p2 = 2.97937; p3 = 4.07752; ; #include ""TRandom.h""; #include ""TGraphErrors.h""; #include ""TF1.h""; #include ""TCanvas.h""; #include ""TLegend.h""; ; void fitLinearRobust(); {; //First generate a dataset, where 20% of points are spoiled by large; //errors; int npoints = 250;; int fraction = int(0.8*npoints);; double *x = new double[npoints];; double *y = new double[npoints];; double *e = new double[npoints];; TRandom r;; int i;; for (i=0; i<fraction; i++){; //the good part of the sample; x[i]=r.Uniform(-2, 2);; e[i]=1;; y[i]=1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + e[i]*r.Gaus();; }; for (i=fraction; i<npoints; i++){; //the bad part of the sample; x[i]=r.Uniform(-1, 1);; e[i]=1;; y[i] = 1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + r.Landau(10, 5);; }; ; TGraphErrors *grr = new TGraphErrors(npoints, x, y, nullptr, e);; grr->SetMinimum(-30);; grr->SetMaximum(80);; TF1 *ffit1 = new TF1(""ffit1"", ""pol3"", -5, 5);; TF1 *ffit2 = new TF1(""ffit2"", ""pol3",MatchSource.WIKI,doc/master/fitLinearRobust_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html
https://root.cern/doc/master/fitLinearRobust_8C.html:1287,Availability,error,errors,1287," squares regression, included in the TLinearFitter class, can be used for fitting in cases when the data contains outliers. ; Here the fitting is done via the TGraph::Fit function with option ""rob"": If you want to use the linear fitter directly for computing the robust fitting coefficients, just use the TLinearFitter::EvalRobust function instead of TLinearFitter::Eval. ; Ordinary least squares:; ****************************************; Minimizer is Linear / Migrad; Chi2 = 606758; NDf = 246; p0 = 15.724 +/- 0.0887641 ; p1 = -0.835912 +/- 0.14096 ; p2 = -3.40616 +/- 0.0607296 ; p3 = 4.82569 +/- 0.0602628 ; Resistant Least trimmed squares fit:; ****************************************; Minimizer is Linear / Robust (h=0.75); Chi2 = 634792; NDf = 246; p0 = 1.00953; p1 = 1.71148; p2 = 2.97937; p3 = 4.07752; ; #include ""TRandom.h""; #include ""TGraphErrors.h""; #include ""TF1.h""; #include ""TCanvas.h""; #include ""TLegend.h""; ; void fitLinearRobust(); {; //First generate a dataset, where 20% of points are spoiled by large; //errors; int npoints = 250;; int fraction = int(0.8*npoints);; double *x = new double[npoints];; double *y = new double[npoints];; double *e = new double[npoints];; TRandom r;; int i;; for (i=0; i<fraction; i++){; //the good part of the sample; x[i]=r.Uniform(-2, 2);; e[i]=1;; y[i]=1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + e[i]*r.Gaus();; }; for (i=fraction; i<npoints; i++){; //the bad part of the sample; x[i]=r.Uniform(-1, 1);; e[i]=1;; y[i] = 1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + r.Landau(10, 5);; }; ; TGraphErrors *grr = new TGraphErrors(npoints, x, y, nullptr, e);; grr->SetMinimum(-30);; grr->SetMaximum(80);; TF1 *ffit1 = new TF1(""ffit1"", ""pol3"", -5, 5);; TF1 *ffit2 = new TF1(""ffit2"", ""pol3"", -5, 5);; ffit1->SetLineColor(kBlue);; ffit2->SetLineColor(kRed);; TCanvas *myc = new TCanvas(""myc"", ""Linear and robust linear fitting"");; myc->SetGrid();; grr->Draw(""ap"");; //first, let's try to see the result sof ordinary least-squares fit:; printf(""Ordi",MatchSource.WIKI,doc/master/fitLinearRobust_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html
https://root.cern/doc/master/fitLinearRobust_8C.html:2116,Availability,robust,robust,2116,"; #include ""TLegend.h""; ; void fitLinearRobust(); {; //First generate a dataset, where 20% of points are spoiled by large; //errors; int npoints = 250;; int fraction = int(0.8*npoints);; double *x = new double[npoints];; double *y = new double[npoints];; double *e = new double[npoints];; TRandom r;; int i;; for (i=0; i<fraction; i++){; //the good part of the sample; x[i]=r.Uniform(-2, 2);; e[i]=1;; y[i]=1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + e[i]*r.Gaus();; }; for (i=fraction; i<npoints; i++){; //the bad part of the sample; x[i]=r.Uniform(-1, 1);; e[i]=1;; y[i] = 1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + r.Landau(10, 5);; }; ; TGraphErrors *grr = new TGraphErrors(npoints, x, y, nullptr, e);; grr->SetMinimum(-30);; grr->SetMaximum(80);; TF1 *ffit1 = new TF1(""ffit1"", ""pol3"", -5, 5);; TF1 *ffit2 = new TF1(""ffit2"", ""pol3"", -5, 5);; ffit1->SetLineColor(kBlue);; ffit2->SetLineColor(kRed);; TCanvas *myc = new TCanvas(""myc"", ""Linear and robust linear fitting"");; myc->SetGrid();; grr->Draw(""ap"");; //first, let's try to see the result sof ordinary least-squares fit:; printf(""Ordinary least squares:\n"");; grr->Fit(ffit1);; //the fitted function doesn't really follow the pattern of the data; //and the coefficients are far from the real ones; ; printf(""Resistant Least trimmed squares fit:\n"");; //Now let's try the resistant regression; //The option ""rob=0.75"" means that we want to use robust fitting and; //we know that at least 75% of data is good points (at least 50% of points; //should be good to use this algorithm). If you don't specify any number; //and just use ""rob"" for the option, default value of (npoints+nparameters+1)/2; //will be taken; grr->Fit(ffit2, ""+rob=0.75"");; //; TLegend *leg = new TLegend(0.6, 0.8, 0.89, 0.89);; leg->AddEntry(ffit1, ""Ordinary least squares"", ""l"");; leg->AddEntry(ffit2, ""LTS regression"", ""l"");; leg->Draw();; ; delete [] x;; delete [] y;; delete [] e;; ; }; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBl",MatchSource.WIKI,doc/master/fitLinearRobust_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html
https://root.cern/doc/master/fitLinearRobust_8C.html:2568,Availability,robust,robust,2568,".Gaus();; }; for (i=fraction; i<npoints; i++){; //the bad part of the sample; x[i]=r.Uniform(-1, 1);; e[i]=1;; y[i] = 1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + r.Landau(10, 5);; }; ; TGraphErrors *grr = new TGraphErrors(npoints, x, y, nullptr, e);; grr->SetMinimum(-30);; grr->SetMaximum(80);; TF1 *ffit1 = new TF1(""ffit1"", ""pol3"", -5, 5);; TF1 *ffit2 = new TF1(""ffit2"", ""pol3"", -5, 5);; ffit1->SetLineColor(kBlue);; ffit2->SetLineColor(kRed);; TCanvas *myc = new TCanvas(""myc"", ""Linear and robust linear fitting"");; myc->SetGrid();; grr->Draw(""ap"");; //first, let's try to see the result sof ordinary least-squares fit:; printf(""Ordinary least squares:\n"");; grr->Fit(ffit1);; //the fitted function doesn't really follow the pattern of the data; //and the coefficients are far from the real ones; ; printf(""Resistant Least trimmed squares fit:\n"");; //Now let's try the resistant regression; //The option ""rob=0.75"" means that we want to use robust fitting and; //we know that at least 75% of data is good points (at least 50% of points; //should be good to use this algorithm). If you don't specify any number; //and just use ""rob"" for the option, default value of (npoints+nparameters+1)/2; //will be taken; grr->Fit(ffit2, ""+rob=0.75"");; //; TLegend *leg = new TLegend(0.6, 0.8, 0.89, 0.89);; leg->AddEntry(ffit1, ""Ordinary least squares"", ""l"");; leg->AddEntry(ffit2, ""LTS regression"", ""l"");; leg->Draw();; ; delete [] x;; delete [] y;; delete [] e;; ; }; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF1.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TRandom.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasTh",MatchSource.WIKI,doc/master/fitLinearRobust_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html
https://root.cern/doc/master/fitLinearRobust_8C.html:3750,Availability,error,error,3750,"number; //and just use ""rob"" for the option, default value of (npoints+nparameters+1)/2; //will be taken; grr->Fit(ffit2, ""+rob=0.75"");; //; TLegend *leg = new TLegend(0.6, 0.8, 0.89, 0.89);; leg->AddEntry(ffit1, ""Ordinary least squares"", ""l"");; leg->AddEntry(ffit2, ""LTS regression"", ""l"");; leg->Draw();; ; delete [] x;; delete [] y;; delete [] e;; ; }; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF1.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TRandom.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Set the maximum of the graph.Definition TGraph.cxx:2324; TGraph::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Axis_t xmin=0, Axis_t xmax=0)Fit this graph with function with name fname.Definition TGraph.cxx:1254; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Set the minimum of the graph.Definition TGraph.cxx:2333; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; int; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C",MatchSource.WIKI,doc/master/fitLinearRobust_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html
https://root.cern/doc/master/fitLinear_8C.html:2271,Availability,error,errors,2271,"tting 3 TGraphErrors with linear functions"");; myc->SetGrid();; ; //Generate points along a 3rd degree polynomial:; makePoints(n, x, y, e, 3);; TGraphErrors *gre3 = new TGraphErrors(n, x, y, nullptr, e);; gre3->Draw(""a*"");; //Fit the graph with the predefined ""pol3"" function; gre3->Fit(""pol3"");; //Access the fit results; TF1 *f3 = gre3->GetFunction(""pol3"");; f3->SetLineWidth(1);; ; //Generate points along a sin(x)+sin(2x) function; makePoints(n, x, y, e, 2);; TGraphErrors *gre2=new TGraphErrors(n, x, y, nullptr, e);; gre2->Draw(""*same"");; gre2->SetMarkerColor(kBlue);; gre2->SetLineColor(kBlue);; //The fitting function can be predefined and passed to the Fit function; //The ""++"" mean that the linear fitter should be used, and the following; //formula is equivalent to ""[0]*sin(x) + [1]*sin(2*x)""; //A function, defined this way, is in no way different from any other TF1,; //it can be evaluated, drawn, you can get its parameters, etc.; //The fit result (parameter values, parameter errors, chisquare, etc) are; //written into the fitting function.; TF1 *f2 = new TF1(""f2"", ""sin(x) ++ sin(2*x)"", -2, 2);; gre2->Fit(f2);; f2 = gre2->GetFunction(""f2"");; f2->SetLineColor(kBlue);; f2->SetLineWidth(1);; ; //Generate points along a -2+exp(-x) function; makePoints(n, x, y, e, 4);; TGraphErrors *gre4=new TGraphErrors(n, x, y, nullptr, e);; gre4->Draw(""*same"");; gre4->SetMarkerColor(kRed);; gre4->SetLineColor(kRed);; //If you don't want to define the function, you can just pass the string; //with the formula:; gre4->Fit(""1 ++ exp(-x)"");; //Access the fit results:; TF1 *f4 = gre4->GetFunction(""1 ++ exp(-x)"");; f4->SetName(""f4"");; f4->SetLineColor(kRed);; f4->SetLineWidth(1);; ; TLegend *leg = new TLegend(0.3, 0.7, 0.65, 0.9);; leg->AddEntry(gre3, "" -7 + 2*x*x + x*x*x"", ""p"");; leg->AddEntry(gre2, ""sin(x) + sin(2*x)"", ""p"");; leg->AddEntry(gre4, ""-2 + exp(-x)"", ""p"");; leg->Draw();; ; }; ; void makePoints(int n, double *x, double *y, double *e, int p); {; int i;; TRandom r;; ; if (p==2) {;",MatchSource.WIKI,doc/master/fitLinear_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear_8C.html
https://root.cern/doc/master/fitLinear_8C.html:4664,Availability,error,error,4664,"s()*0.1;; e[i] = 0.1;; }; }; }; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TMath.h; TRandom.h; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::GetFunctionTF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TGraph.cxx:1416; TGraph::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Axis_t xmin=0, Axis_t xmax=0)Fit this graph with function with name fname.Definition TGraph.cxx:1254; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t",MatchSource.WIKI,doc/master/fitLinear_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear_8C.html
https://root.cern/doc/master/fitLinear_8C.html:5807,Energy Efficiency,power,power,5807,"2VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TMath.h; TRandom.h; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::GetFunctionTF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TGraph.cxx:1416; TGraph::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Axis_t xmin=0, Axis_t xmax=0)Fit this graph with function with name fname.Definition TGraph.cxx:1254; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TLegendThis class displays a legend box (TPaveText) containing several legend entries.Definition TLegend.h:23; TNamed::SetNamevirtual void SetName(const char *name)Set the name of the TNamed.Definition TNamed.cxx:140; TPad::SetGridvoid SetGrid(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:335; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; leglegDefinition legend1.C:34; TMath::ExpDouble_t Exp(Double_t x)Returns the base-e exponential function of x, which is e raised to the power x.Definition TMath.h:709; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; AuthorAnna Kreshuk ; Definition in file fitLinear.C. tutorialsfitfitLinear.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fitLinear_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitLinear_8C.html
https://root.cern/doc/master/fitMultiGraph_8C.html:295,Availability,error,errors,295,". ROOT: tutorials/fit/fitMultiGraph.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitMultiGraph.C File ReferenceTutorials  Fit Tutorials. Detailed Description; fitting a parabola to a multigraph of 3 partly overlapping graphs with different errors . ; ****************************************; Minimizer is Minuit2 / Migrad; Chi2 = 95.1374; NDf = 87; Edm = 8.90994e-21; NCalls = 55; p0 = 3.21134 +/- 0.428055 ; p1 = 1.87952 +/- 0.248404 ; p2 = 1.00914 +/- 0.0349228 ; ; #include ""TMultiGraph.h""; #include ""TRandom.h""; #include ""TF1.h""; #include ""TGraphErrors.h""; #include ""TCanvas.h""; #include ""TMath.h""; ; void fitMultiGraph(); {; int n = 30;; double *xvalues1 = new double[n];; double *xvalues2 = new double[n];; double *xvalues3 = new double[n];; double *yvalues1 = new double[n];; double *yvalues2 = new double[n];; double *yvalues3 = new double[n];; double *evalues1 = new double[n];; double *evalues2 = new double[n];; double *evalues3 = new double[n];; ; //generate the data for the graphs; TRandom r;; int i;; for (i=0; i<n; i++) {; xvalues1[i] = r.Uniform(0.1, 5);; xvalues2[i] = r.Uniform(3, 8);; xvalues3[i] = r.Uniform(9, 15);; yvalues1[i] = 3 + 2*xvalues1[i] + xvalues1[i]*xvalues1[i] + r.Gaus();; yvalues2[i] = 3 + 2*xvalues2[i] + xvalues2[i]*xvalues2[i] + r.Gaus()*10;; evalues1[i] = 1;; evalues2[i] = 10;; evalues3[i] = 20;; yvalues3[i] = 3 + 2*xvalues3[i] + xvalues3[i]*xvalues3[i] + r.Gaus()*20;; }; ; //create the graphs and set their drawing options; TGraphErrors *gr1 = new TGraphErrors(n, xvalues1, yvalues1, nullptr, evalues1);; TGraphErrors *gr2 = new TGraphErrors(n, xvalues2, yvalues2, nullptr, evalues2);; TGraphErrors *gr3 = new TGraphErrors(n, xvalues3, yvalues3, nullptr, evalues3);; gr1->SetLineColor(kRed);; gr2->SetLineColor(kBlue);; gr2->SetMarkerStyle(24);; gr2->SetMarkerSize(0.3);; gr3->SetLineColor(kGreen);; gr3->SetMarkerStyle(24);; gr3->SetMarkerSize(0.3);; ; //add the graphs to the multigraph; TMultiGrap",MatchSource.WIKI,doc/master/fitMultiGraph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitMultiGraph_8C.html
https://root.cern/doc/master/fitMultiGraph_8C.html:5164,Availability,error,error,5164,"; kRed@ kRedDefinition Rtypes.h:66; kGreen@ kGreenDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF1.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TMath.h; TMultiGraph.h; TRandom.h; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TAttMarker::SetMarkerSizevirtual void SetMarkerSize(Size_t msize=1)Set the marker size.Definition TAttMarker.h:45; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Axis_t xmin=0, Axis_t xmax=0)Fit this graph with function with name fname.Definition TGraph.cxx:1254; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TMultiGraph::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Axis_t xmin=0, Axis_t xmax=0)Fit this graph with function with name fname.Definition TMultiGraph.cxx:526; TMultiGraph::Addvirtual void Add(TGraph *graph, Option_t *chopt="""")Add a new graph to the list of graphs.Definition TMultiGraph.cxx:419; TMultiGraph::GetFunctionTF1 * GetFunction(const char *name) constReturn pointer to function with name.Definition TMultiGraph.cxx:1086; TMultiGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this multigraph with its current attributes.Definition TMultiGraph.cxx:508; TPad::SetGridvo",MatchSource.WIKI,doc/master/fitMultiGraph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitMultiGraph_8C.html
https://root.cern/doc/master/fitMultiGraph_8C.html:2263,Security,access,access,2263,"+ 2*xvalues3[i] + xvalues3[i]*xvalues3[i] + r.Gaus()*20;; }; ; //create the graphs and set their drawing options; TGraphErrors *gr1 = new TGraphErrors(n, xvalues1, yvalues1, nullptr, evalues1);; TGraphErrors *gr2 = new TGraphErrors(n, xvalues2, yvalues2, nullptr, evalues2);; TGraphErrors *gr3 = new TGraphErrors(n, xvalues3, yvalues3, nullptr, evalues3);; gr1->SetLineColor(kRed);; gr2->SetLineColor(kBlue);; gr2->SetMarkerStyle(24);; gr2->SetMarkerSize(0.3);; gr3->SetLineColor(kGreen);; gr3->SetMarkerStyle(24);; gr3->SetMarkerSize(0.3);; ; //add the graphs to the multigraph; TMultiGraph *mg=new TMultiGraph(""mg"",; ""TMultiGraph of 3 TGraphErrors"");; mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; ; TCanvas *myc = new TCanvas(""myc"",; ""Fitting a MultiGraph of 3 TGraphErrors"");; myc->SetGrid();; ; mg->Draw(""ap"");; ; //fit; mg->Fit(""pol2"", ""F"");; ; //access to the fit function; TF1 *fpol = mg->GetFunction(""pol2"");; fpol->SetLineWidth(1);; ; }; ; void fitminuit(); {; int n = 30;; double *xvalues1 = new double[n];; double *xvalues2 = new double[n];; double *xvalues3 = new double[n];; double *yvalues1 = new double[n];; double *yvalues2 = new double[n];; double *yvalues3 = new double[n];; double *evalues1 = new double[n];; double *evalues2 = new double[n];; double *evalues3 = new double[n];; double *xtotal = new double[n*3];; double *ytotal = new double[n*3];; double *etotal = new double[n*3];; ; TRandom r;; int i;; for (i=0; i<n; i++) {; xvalues1[i] = r.Uniform(-3, -1);; xvalues2[i] = r.Uniform(-1, 1);; xvalues3[i] = r.Uniform(1, 3);; yvalues1[i] = TMath::Gaus(xvalues1[i], 0, 1);; yvalues2[i] = TMath::Gaus(xvalues2[i], 0, 1);; evalues1[i] = 0.00001;; evalues2[i] = 0.00001;; evalues3[i] = 0.00001;; yvalues3[i] = TMath::Gaus(xvalues3[i], 0, 1);; }; for (i=0; i<n; i++); {xtotal[i]=xvalues1[i]; ytotal[i]=yvalues1[i]; etotal[i]=0.00001;}; for (i=n; i<2*n; i++); {xtotal[i] = xvalues2[i-n]; ytotal[i]=yvalues2[i-n]; etotal[i]=0.00001;}; for (i=2*n; i<3*n; i++); {xtotal[i] = xvalues3[i-2*n",MatchSource.WIKI,doc/master/fitMultiGraph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitMultiGraph_8C.html
https://root.cern/doc/master/fitNormSum_8C.html:2857,Availability,avail,available,2857,"..........; // 1) :; TF1NormSum *fnorm_exp_cb = new TF1NormSum(f_cb, f_exp, nsig, nbkg);; // 4) :; ; TF1 *f_sum = new TF1(""fsum"", *fnorm_exp_cb, -5., 5., fnorm_exp_cb->GetNpar());; ; // III.:; f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; f_sum->SetParName(1, ""NBackground"");; f_sum->SetParName(0, ""NSignal"");; for (int i = 2; i < f_sum->GetNpar(); ++i); f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; ; // GENERATE HISTOGRAM TO FIT ..............................................................; TStopwatch w;; w.Start();; TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; h_sum->FillRandom(""fsum"", nEvents);; printf(""Time to generate %d events: "", nEvents);; w.Print();; ; // need to scale histogram with width since we are fitting a density; h_sum->Sumw2();; h_sum->Scale(1., ""width"");; ; // fit - use Minuit2 if available; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; new TCanvas(""Fit"", ""Fit"", 800, 1000);; // do a least-square fit of the spectrum; auto result = h_sum->Fit(""fsum"", ""SQ"");; result->Print();; h_sum->Draw();; printf(""Time to fit using ROOT TF1Normsum: "");; w.Print();; ; // test if parameters are fine; std::vector<double> pref = {nsig, nbkg, signal_mean};; for (unsigned int i = 0; i < pref.size(); ++i) {; if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; }; ; gStyle->SetOptStat(0);; // add parameters; auto t1 = new TLatex(; -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; auto t2 = new TLatex(; -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; t1->Draw();; t2->Draw();; }; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msg",MatchSource.WIKI,doc/master/fitNormSum_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C.html
https://root.cern/doc/master/fitNormSum_8C.html:4015,Availability,error,error,4015,"rum; auto result = h_sum->Fit(""fsum"", ""SQ"");; result->Print();; h_sum->Draw();; printf(""Time to fit using ROOT TF1Normsum: "");; w.Print();; ; // test if parameters are fine; std::vector<double> pref = {nsig, nbkg, signal_mean};; for (unsigned int i = 0; i < pref.size(); ++i) {; if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; }; ; gStyle->SetOptStat(0);; // add parameters; auto t1 = new TLatex(; -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; auto t2 = new TLatex(; -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; t1->Draw();; t2->Draw();; }; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH1.h; TLatex.h; TMath.h; TStopwatch.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::Math::MinimizerOptions::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)Set the default Minimizer type and corresponding algorithms.Definition MinimizerOptions.cxx:43; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1Norm",MatchSource.WIKI,doc/master/fitNormSum_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C.html
https://root.cern/doc/master/fitNormSum_8C.html:3152,Testability,test,test,3152,"->GetParameters().data());; f_sum->SetParName(1, ""NBackground"");; f_sum->SetParName(0, ""NSignal"");; for (int i = 2; i < f_sum->GetNpar(); ++i); f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; ; // GENERATE HISTOGRAM TO FIT ..............................................................; TStopwatch w;; w.Start();; TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; h_sum->FillRandom(""fsum"", nEvents);; printf(""Time to generate %d events: "", nEvents);; w.Print();; ; // need to scale histogram with width since we are fitting a density; h_sum->Sumw2();; h_sum->Scale(1., ""width"");; ; // fit - use Minuit2 if available; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; new TCanvas(""Fit"", ""Fit"", 800, 1000);; // do a least-square fit of the spectrum; auto result = h_sum->Fit(""fsum"", ""SQ"");; result->Print();; h_sum->Draw();; printf(""Time to fit using ROOT TF1Normsum: "");; w.Print();; ; // test if parameters are fine; std::vector<double> pref = {nsig, nbkg, signal_mean};; for (unsigned int i = 0; i < pref.size(); ++i) {; if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; }; ; gStyle->SetOptStat(0);; // add parameters; auto t1 = new TLatex(; -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; auto t2 = new TLatex(; -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; t1->Draw();; t2->Draw();; }; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t Option_t TPoint TPoint const char GetTextMagnitu",MatchSource.WIKI,doc/master/fitNormSum_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C.html
https://root.cern/doc/master/fitNormSum_8C.html:3381,Testability,test,testFitNormSum,3381,"; TStopwatch w;; w.Start();; TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; h_sum->FillRandom(""fsum"", nEvents);; printf(""Time to generate %d events: "", nEvents);; w.Print();; ; // need to scale histogram with width since we are fitting a density; h_sum->Sumw2();; h_sum->Scale(1., ""width"");; ; // fit - use Minuit2 if available; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; new TCanvas(""Fit"", ""Fit"", 800, 1000);; // do a least-square fit of the spectrum; auto result = h_sum->Fit(""fsum"", ""SQ"");; result->Print();; h_sum->Draw();; printf(""Time to fit using ROOT TF1Normsum: "");; w.Print();; ; // test if parameters are fine; std::vector<double> pref = {nsig, nbkg, signal_mean};; for (unsigned int i = 0; i < pref.size(); ++i) {; if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; }; ; gStyle->SetOptStat(0);; // add parameters; auto t1 = new TLatex(; -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; auto t2 = new TLatex(; -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; t1->Draw();; t2->Draw();; }; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH1.h; TLatex.h; TMath.h; TStopwatch",MatchSource.WIKI,doc/master/fitNormSum_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C.html
https://root.cern/doc/master/fitNormSum_8C_source.html:2737,Availability,avail,available,2737," nbkg);; 52 // 4) :; 53 ; 54 TF1 *f_sum = new TF1(""fsum"", *fnorm_exp_cb, -5., 5., fnorm_exp_cb->GetNpar());; 55 ; 56 // III.:; 57 f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; 58 f_sum->SetParName(1, ""NBackground"");; 59 f_sum->SetParName(0, ""NSignal"");; 60 for (int i = 2; i < f_sum->GetNpar(); ++i); 61 f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; 62 ; 63 // GENERATE HISTOGRAM TO FIT ..............................................................; 64 TStopwatch w;; 65 w.Start();; 66 TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; 67 h_sum->FillRandom(""fsum"", nEvents);; 68 printf(""Time to generate %d events: "", nEvents);; 69 w.Print();; 70 ; 71 // need to scale histogram with width since we are fitting a density; 72 h_sum->Sumw2();; 73 h_sum->Scale(1., ""width"");; 74 ; 75 // fit - use Minuit2 if available; 76 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; 77 new TCanvas(""Fit"", ""Fit"", 800, 1000);; 78 // do a least-square fit of the spectrum; 79 auto result = h_sum->Fit(""fsum"", ""SQ"");; 80 result->Print();; 81 h_sum->Draw();; 82 printf(""Time to fit using ROOT TF1Normsum: "");; 83 w.Print();; 84 ; 85 // test if parameters are fine; 86 std::vector<double> pref = {nsig, nbkg, signal_mean};; 87 for (unsigned int i = 0; i < pref.size(); ++i) {; 88 if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); 89 Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; 90 (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; 91 }; 92 ; 93 gStyle->SetOptStat(0);; 94 // add parameters; 95 auto t1 = new TLatex(; 96 -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; 97 auto t2 = new TLatex(; 98 -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; 99 t1->Draw();; 100 t2->Draw();; 101}; MinimizerOptio",MatchSource.WIKI,doc/master/fitNormSum_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C_source.html
https://root.cern/doc/master/fitNormSum_8C_source.html:3974,Availability,error,error,3974,"81 h_sum->Draw();; 82 printf(""Time to fit using ROOT TF1Normsum: "");; 83 w.Print();; 84 ; 85 // test if parameters are fine; 86 std::vector<double> pref = {nsig, nbkg, signal_mean};; 87 for (unsigned int i = 0; i < pref.size(); ++i) {; 88 if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); 89 Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; 90 (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; 91 }; 92 ; 93 gStyle->SetOptStat(0);; 94 // add parameters; 95 auto t1 = new TLatex(; 96 -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; 97 auto t2 = new TLatex(; 98 -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; 99 t1->Draw();; 100 t2->Draw();; 101}; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH1.h; TLatex.h; TMath.h; TStopwatch.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; ROOT::Math::MinimizerOptions::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)Set the default Minimizer type and corresponding algorithms.Definition MinimizerOptions.cxx:43; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1NormSumClass adding two functions: c1*f1+c2*f2.Definition TF1NormSum.h:19; TF1NormSum::GetParNameconst char * GetParName(Int_t ipar) constDefinition TF1NormSum.h:66; TF1Norm",MatchSource.WIKI,doc/master/fitNormSum_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C_source.html
https://root.cern/doc/master/fitNormSum_8C_source.html:3062,Testability,test,test,3062,"rName(0, ""NSignal"");; 60 for (int i = 2; i < f_sum->GetNpar(); ++i); 61 f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; 62 ; 63 // GENERATE HISTOGRAM TO FIT ..............................................................; 64 TStopwatch w;; 65 w.Start();; 66 TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; 67 h_sum->FillRandom(""fsum"", nEvents);; 68 printf(""Time to generate %d events: "", nEvents);; 69 w.Print();; 70 ; 71 // need to scale histogram with width since we are fitting a density; 72 h_sum->Sumw2();; 73 h_sum->Scale(1., ""width"");; 74 ; 75 // fit - use Minuit2 if available; 76 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; 77 new TCanvas(""Fit"", ""Fit"", 800, 1000);; 78 // do a least-square fit of the spectrum; 79 auto result = h_sum->Fit(""fsum"", ""SQ"");; 80 result->Print();; 81 h_sum->Draw();; 82 printf(""Time to fit using ROOT TF1Normsum: "");; 83 w.Print();; 84 ; 85 // test if parameters are fine; 86 std::vector<double> pref = {nsig, nbkg, signal_mean};; 87 for (unsigned int i = 0; i < pref.size(); ++i) {; 88 if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); 89 Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; 90 (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; 91 }; 92 ; 93 gStyle->SetOptStat(0);; 94 // add parameters; 95 auto t1 = new TLatex(; 96 -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; 97 auto t2 = new TLatex(; 98 -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; 99 t1->Draw();; 100 t2->Draw();; 101}; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t",MatchSource.WIKI,doc/master/fitNormSum_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C_source.html
https://root.cern/doc/master/fitNormSum_8C_source.html:3303,Testability,test,testFitNormSum,3303,"g + CrystalBall function"", nBins, -5., 5.);; 67 h_sum->FillRandom(""fsum"", nEvents);; 68 printf(""Time to generate %d events: "", nEvents);; 69 w.Print();; 70 ; 71 // need to scale histogram with width since we are fitting a density; 72 h_sum->Sumw2();; 73 h_sum->Scale(1., ""width"");; 74 ; 75 // fit - use Minuit2 if available; 76 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; 77 new TCanvas(""Fit"", ""Fit"", 800, 1000);; 78 // do a least-square fit of the spectrum; 79 auto result = h_sum->Fit(""fsum"", ""SQ"");; 80 result->Print();; 81 h_sum->Draw();; 82 printf(""Time to fit using ROOT TF1Normsum: "");; 83 w.Print();; 84 ; 85 // test if parameters are fine; 86 std::vector<double> pref = {nsig, nbkg, signal_mean};; 87 for (unsigned int i = 0; i < pref.size(); ++i) {; 88 if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); 89 Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; 90 (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; 91 }; 92 ; 93 gStyle->SetOptStat(0);; 94 // add parameters; 95 auto t1 = new TLatex(; 96 -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; 97 auto t2 = new TLatex(; 98 -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; 99 t1->Draw();; 100 t2->Draw();; 101}; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1NormSum.h; TF1.h; TFitResult.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; TH1.h; T",MatchSource.WIKI,doc/master/fitNormSum_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8C_source.html
https://root.cern/doc/master/fitNormSum_8py.html:2967,Availability,avail,available,2967,"meter_values.data()); # Note: in the C++ tutorial, the parameter value sync is done in one line with:; # ```C++; # f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; # ```; # However, TF1NormSum::GetParameters() returns an std::vector by value, which; # doesn't survive long enough in Python. That's why we have to explicitly; # assign it to a variable first and can't use a temporary.; ; f_sum.SetParName(1, ""NBackground""); f_sum.SetParName(0, ""NSignal""); for i in range(2, f_sum.GetNpar()):; f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); ; # GENERATE HISTOGRAM TO FIT ..............................................................; w = ROOT.TStopwatch(); w.Start(); h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); h_sum.FillRandom(""fsum"", nEvents); print(""Time to generate {0} events: "".format(nEvents)); w.Print(); ; # need to scale histogram with width since we are fitting a density; h_sum.Sumw2(); h_sum.Scale(1.0, ""width""); ; # fit - use Minuit2 if available; ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); # do a least-square fit of the spectrum; result = h_sum.Fit(""fsum"", ""SQ""); result.Print(); h_sum.Draw(); print(""Time to fit using ROOT TF1Normsum: ""); w.Print(); ; # test if parameters are fine; for i, pref in enumerate([nsig, nbkg, signal_mean]):; if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; ROOT.Error(; ""testFitNormSum"",; ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); ),; ); ; ROOT.gStyle.SetOptStat(0); # add parameters; t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); t1.Draw(); t2.Draw(); ; c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t",MatchSource.WIKI,doc/master/fitNormSum_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py.html
https://root.cern/doc/master/fitNormSum_8py.html:2310,Modifiability,variab,variable,2310,"using ROOT TF1Normsum: ; ; import ROOT; ; nsig = 50000; nbkg = 1000000; nEvents = nsig + nbkg; nBins = 1000; ; signal_mean = 3.0; f_cb = ROOT.TF1(""MyCrystalBall"", ""crystalball"", -5.0, 5.0); f_exp = ROOT.TF1(""MyExponential"", ""expo"", -5.0, 5.0); ; # I.:; f_exp.SetParameters(1.0, -0.3); f_cb.SetParameters(1, signal_mean, 0.3, 2, 1.5); ; # CONSTRUCTION OF THE TF1NORMSUM OBJECT ........................................; # 1) :; fnorm_exp_cb = ROOT.TF1NormSum(f_cb, f_exp, nsig, nbkg); # 4) :; ; f_sum = ROOT.TF1(""fsum"", fnorm_exp_cb, -5.0, 5.0, fnorm_exp_cb.GetNpar()); ; # III.:; parameter_values = fnorm_exp_cb.GetParameters(); f_sum.SetParameters(parameter_values.data()); # Note: in the C++ tutorial, the parameter value sync is done in one line with:; # ```C++; # f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; # ```; # However, TF1NormSum::GetParameters() returns an std::vector by value, which; # doesn't survive long enough in Python. That's why we have to explicitly; # assign it to a variable first and can't use a temporary.; ; f_sum.SetParName(1, ""NBackground""); f_sum.SetParName(0, ""NSignal""); for i in range(2, f_sum.GetNpar()):; f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); ; # GENERATE HISTOGRAM TO FIT ..............................................................; w = ROOT.TStopwatch(); w.Start(); h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); h_sum.FillRandom(""fsum"", nEvents); print(""Time to generate {0} events: "".format(nEvents)); w.Print(); ; # need to scale histogram with width since we are fitting a density; h_sum.Sumw2(); h_sum.Scale(1.0, ""width""); ; # fit - use Minuit2 if available; ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); # do a least-square fit of the spectrum; result = h_sum.Fit(""fsum"", ""SQ""); result.Print(); h_sum.Draw(); print(""Time to fit using ROOT TF1Normsum: ""); w.Print(); ; # test if parameters are fine; for i, pref in enumerate([nsi",MatchSource.WIKI,doc/master/fitNormSum_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py.html
https://root.cern/doc/master/fitNormSum_8py.html:3247,Testability,test,test,3247,"tly; # assign it to a variable first and can't use a temporary.; ; f_sum.SetParName(1, ""NBackground""); f_sum.SetParName(0, ""NSignal""); for i in range(2, f_sum.GetNpar()):; f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); ; # GENERATE HISTOGRAM TO FIT ..............................................................; w = ROOT.TStopwatch(); w.Start(); h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); h_sum.FillRandom(""fsum"", nEvents); print(""Time to generate {0} events: "".format(nEvents)); w.Print(); ; # need to scale histogram with width since we are fitting a density; h_sum.Sumw2(); h_sum.Scale(1.0, ""width""); ; # fit - use Minuit2 if available; ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); # do a least-square fit of the spectrum; result = h_sum.Fit(""fsum"", ""SQ""); result.Print(); h_sum.Draw(); print(""Time to fit using ROOT TF1Normsum: ""); w.Print(); ; # test if parameters are fine; for i, pref in enumerate([nsig, nbkg, signal_mean]):; if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; ROOT.Error(; ""testFitNormSum"",; ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); ),; ); ; ROOT.gStyle.SetOptStat(0); # add parameters; t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); t1.Draw(); t2.Draw(); ; c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetS",MatchSource.WIKI,doc/master/fitNormSum_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py.html
https://root.cern/doc/master/fitNormSum_8py.html:3434,Testability,test,testFitNormSum,3434,"m.SetParName(i, fnorm_exp_cb.GetParName(i)); ; # GENERATE HISTOGRAM TO FIT ..............................................................; w = ROOT.TStopwatch(); w.Start(); h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); h_sum.FillRandom(""fsum"", nEvents); print(""Time to generate {0} events: "".format(nEvents)); w.Print(); ; # need to scale histogram with width since we are fitting a density; h_sum.Sumw2(); h_sum.Scale(1.0, ""width""); ; # fit - use Minuit2 if available; ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); # do a least-square fit of the spectrum; result = h_sum.Fit(""fsum"", ""SQ""); result.Print(); h_sum.Draw(); print(""Time to fit using ROOT TF1Normsum: ""); w.Print(); ; # test if parameters are fine; for i, pref in enumerate([nsig, nbkg, signal_mean]):; if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; ROOT.Error(; ""testFitNormSum"",; ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); ),; ); ; ROOT.gStyle.SetOptStat(0); # add parameters; t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); t1.Draw(); t2.Draw(); ; c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const ",MatchSource.WIKI,doc/master/fitNormSum_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py.html
https://root.cern/doc/master/fitNormSum_8py_source.html:2806,Availability,avail,available,2806,"e parameter value sync is done in one line with:; 49# ```C++; 50# f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; 51# ```; 52# However, TF1NormSum::GetParameters() returns an std::vector by value, which; 53# doesn't survive long enough in Python. That's why we have to explicitly; 54# assign it to a variable first and can't use a temporary.; 55 ; 56f_sum.SetParName(1, ""NBackground""); 57f_sum.SetParName(0, ""NSignal""); 58for i in range(2, f_sum.GetNpar()):; 59 f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); 60 ; 61# GENERATE HISTOGRAM TO FIT ..............................................................; 62w = ROOT.TStopwatch(); 63w.Start(); 64h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); 65h_sum.FillRandom(""fsum"", nEvents); 66print(""Time to generate {0} events: "".format(nEvents)); 67w.Print(); 68 ; 69# need to scale histogram with width since we are fitting a density; 70h_sum.Sumw2(); 71h_sum.Scale(1.0, ""width""); 72 ; 73# fit - use Minuit2 if available; 74ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); 75c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); 76# do a least-square fit of the spectrum; 77result = h_sum.Fit(""fsum"", ""SQ""); 78result.Print(); 79h_sum.Draw(); 80print(""Time to fit using ROOT TF1Normsum: ""); 81w.Print(); 82 ; 83# test if parameters are fine; 84for i, pref in enumerate([nsig, nbkg, signal_mean]):; 85 if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; 86 ROOT.Error(; 87 ""testFitNormSum"",; 88 ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; 89 f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); 90 ),; 91 ); 92 ; 93ROOT.gStyle.SetOptStat(0); 94# add parameters; 95t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); 96t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); 97t1.Draw(); 98t2.Dr",MatchSource.WIKI,doc/master/fitNormSum_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py_source.html
https://root.cern/doc/master/fitNormSum_8py_source.html:2106,Modifiability,variab,variable,2106," = 1000000; 27nEvents = nsig + nbkg; 28nBins = 1000; 29 ; 30signal_mean = 3.0; 31f_cb = ROOT.TF1(""MyCrystalBall"", ""crystalball"", -5.0, 5.0); 32f_exp = ROOT.TF1(""MyExponential"", ""expo"", -5.0, 5.0); 33 ; 34# I.:; 35f_exp.SetParameters(1.0, -0.3); 36f_cb.SetParameters(1, signal_mean, 0.3, 2, 1.5); 37 ; 38# CONSTRUCTION OF THE TF1NORMSUM OBJECT ........................................; 39# 1) :; 40fnorm_exp_cb = ROOT.TF1NormSum(f_cb, f_exp, nsig, nbkg); 41# 4) :; 42 ; 43f_sum = ROOT.TF1(""fsum"", fnorm_exp_cb, -5.0, 5.0, fnorm_exp_cb.GetNpar()); 44 ; 45# III.:; 46parameter_values = fnorm_exp_cb.GetParameters(); 47f_sum.SetParameters(parameter_values.data()); 48# Note: in the C++ tutorial, the parameter value sync is done in one line with:; 49# ```C++; 50# f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; 51# ```; 52# However, TF1NormSum::GetParameters() returns an std::vector by value, which; 53# doesn't survive long enough in Python. That's why we have to explicitly; 54# assign it to a variable first and can't use a temporary.; 55 ; 56f_sum.SetParName(1, ""NBackground""); 57f_sum.SetParName(0, ""NSignal""); 58for i in range(2, f_sum.GetNpar()):; 59 f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); 60 ; 61# GENERATE HISTOGRAM TO FIT ..............................................................; 62w = ROOT.TStopwatch(); 63w.Start(); 64h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); 65h_sum.FillRandom(""fsum"", nEvents); 66print(""Time to generate {0} events: "".format(nEvents)); 67w.Print(); 68 ; 69# need to scale histogram with width since we are fitting a density; 70h_sum.Sumw2(); 71h_sum.Scale(1.0, ""width""); 72 ; 73# fit - use Minuit2 if available; 74ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); 75c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); 76# do a least-square fit of the spectrum; 77result = h_sum.Fit(""fsum"", ""SQ""); 78result.Print(); 79h_sum.Draw(); 80print(""Time to fit using ROOT TF1Normsum: ""); 81w.Print(); 82",MatchSource.WIKI,doc/master/fitNormSum_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py_source.html
https://root.cern/doc/master/fitNormSum_8py_source.html:3107,Testability,test,test,3107," 55 ; 56f_sum.SetParName(1, ""NBackground""); 57f_sum.SetParName(0, ""NSignal""); 58for i in range(2, f_sum.GetNpar()):; 59 f_sum.SetParName(i, fnorm_exp_cb.GetParName(i)); 60 ; 61# GENERATE HISTOGRAM TO FIT ..............................................................; 62w = ROOT.TStopwatch(); 63w.Start(); 64h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); 65h_sum.FillRandom(""fsum"", nEvents); 66print(""Time to generate {0} events: "".format(nEvents)); 67w.Print(); 68 ; 69# need to scale histogram with width since we are fitting a density; 70h_sum.Sumw2(); 71h_sum.Scale(1.0, ""width""); 72 ; 73# fit - use Minuit2 if available; 74ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); 75c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); 76# do a least-square fit of the spectrum; 77result = h_sum.Fit(""fsum"", ""SQ""); 78result.Print(); 79h_sum.Draw(); 80print(""Time to fit using ROOT TF1Normsum: ""); 81w.Print(); 82 ; 83# test if parameters are fine; 84for i, pref in enumerate([nsig, nbkg, signal_mean]):; 85 if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; 86 ROOT.Error(; 87 ""testFitNormSum"",; 88 ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; 89 f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); 90 ),; 91 ); 92 ; 93ROOT.gStyle.SetOptStat(0); 94# add parameters; 95t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); 96t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); 97t1.Draw(); 98t2.Draw(); 99 ; 100c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValue",MatchSource.WIKI,doc/master/fitNormSum_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py_source.html
https://root.cern/doc/master/fitNormSum_8py_source.html:3305,Testability,test,testFitNormSum,3305,"HISTOGRAM TO FIT ..............................................................; 62w = ROOT.TStopwatch(); 63w.Start(); 64h_sum = ROOT.TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5.0, 5.0); 65h_sum.FillRandom(""fsum"", nEvents); 66print(""Time to generate {0} events: "".format(nEvents)); 67w.Print(); 68 ; 69# need to scale histogram with width since we are fitting a density; 70h_sum.Sumw2(); 71h_sum.Scale(1.0, ""width""); 72 ; 73# fit - use Minuit2 if available; 74ROOT.Math.MinimizerOptions.SetDefaultMinimizer(""Minuit2""); 75c1 = ROOT.TCanvas(""Fit"", ""Fit"", 800, 1000); 76# do a least-square fit of the spectrum; 77result = h_sum.Fit(""fsum"", ""SQ""); 78result.Print(); 79h_sum.Draw(); 80print(""Time to fit using ROOT TF1Normsum: ""); 81w.Print(); 82 ; 83# test if parameters are fine; 84for i, pref in enumerate([nsig, nbkg, signal_mean]):; 85 if not ROOT.TMath.AreEqualAbs(pref, f_sum.GetParameter(i), f_sum.GetParError(i) * 10.0):; 86 ROOT.Error(; 87 ""testFitNormSum"",; 88 ""Difference found in fitted {0} - difference is {1:.2f} sigma"".format(; 89 f_sum.GetParName(i), (f_sum.GetParameter(i) - pref) / f_sum.GetParError(i); 90 ),; 91 ); 92 ; 93ROOT.gStyle.SetOptStat(0); 94# add parameters; 95t1 = ROOT.TLatex(-2.5, 300000, ""NSignal = {0:g} #pm {1:g}"".format(f_sum.GetParameter(0), f_sum.GetParError(0))); 96t2 = ROOT.TLatex(-2.5, 270000, ""Nbackgr = {0:g} #pm {1:g}"".format(f_sum.GetParameter(1), f_sum.GetParError(1))); 97t1.Draw(); 98t2.Draw(); 99 ; 100c1.SaveAs(""fitNormSum.png""); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h",MatchSource.WIKI,doc/master/fitNormSum_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitNormSum_8py_source.html
https://root.cern/doc/master/fitpanel__playback_8C.html:4477,Integrability,interface,interface,4477,"tSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; fsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize fsDefinition TGWin32VirtualXProxy.cxx:102; TRecorder.h; TSystemFile.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TRecorderClass provides direct recorder/replayer interface for a user.Definition TRecorder.h:266; TRecorder::kReplaying@ kReplayingDefinition TRecorder.h:296; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; FileStat_tDefinition TSystem.h:122; AuthorDavid Gonzalez Maline ; Definition in file fitpanel_playback.C. tutorialsfitfitpanel_playback.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/fitpanel__playback_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitpanel__playback_8C.html
https://root.cern/doc/master/fitpanel__playback_8C.html:237,Testability,test,test,237,". ROOT: tutorials/fit/fitpanel_playback.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitpanel_playback.C File ReferenceTutorials  Fit Tutorials. Detailed Description; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; This implies trying the Set Parameters dialog and the Advanced one.; At every operation, a png file will be saved. These files will be later on compared with some references values, to have an estimation of the goodness of the test.; ; #include ""TSystem.h""; #include ""TSystemFile.h""; #include ""TRecorder.h""; #include ""Riostream.h""; ; int file_size(const char *filename); {; FileStat_t fs;; gSystem->GetPathInfo(filename, fs);; return (int)fs.fSize;; }; ; void fitpanel_playback(); {; auto * r = new TRecorder();; r->Replay(""http://root.cern/files/fitpanel_playback.root"");; ; // wait for the recorder to finish the replay; while (r->GetState() == TRecorder::kReplaying) {; gSystem->ProcessEvents();; gSystem->Sleep(1);; }; ; int Step_Err = 100;; int Step1_Ref = 15691;; int Step2_Ref = 15691;; int Step3_Ref = 17632;; int Step4_Ref = 12305;; int Step5_Ref = 11668;; ; int Step1_Size = file_size(""Step1.png"");; int Step2_Size = file_size(""Step2.png"");; int Step3_Size = file_size(""Step3.png"");; int Step4_Size = file_size(""Step4.png"");; int Step5_Size = file_size(""Step5.png"");; ; ; std::cout << ""**********************************************************************"" << std::endl;; std::cout << ""* Report of fitpanel_playback.C *"" << std::endl;; std::cout << ""**********************************************************************"" << std::endl;; ; if (TMath::Abs(Step1_Ref-Step1_Size) <= Step_Err) {; std::cout << ""Step1: ............................................................ OK"" << std::endl;; } else {; std::cout << ""Step1: ........................................................ FAILED"" <<",MatchSource.WIKI,doc/master/fitpanel__playback_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitpanel__playback_8C.html
https://root.cern/doc/master/fitpanel__playback_8C.html:626,Testability,test,test,626,". ROOT: tutorials/fit/fitpanel_playback.C File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. fitpanel_playback.C File ReferenceTutorials  Fit Tutorials. Detailed Description; This file will test all the transient frames (aka Dialog windows) displayed in the fitpanel, as the rest of the functionality is tried automatically with the UnitTest.C unit. ; This implies trying the Set Parameters dialog and the Advanced one.; At every operation, a png file will be saved. These files will be later on compared with some references values, to have an estimation of the goodness of the test.; ; #include ""TSystem.h""; #include ""TSystemFile.h""; #include ""TRecorder.h""; #include ""Riostream.h""; ; int file_size(const char *filename); {; FileStat_t fs;; gSystem->GetPathInfo(filename, fs);; return (int)fs.fSize;; }; ; void fitpanel_playback(); {; auto * r = new TRecorder();; r->Replay(""http://root.cern/files/fitpanel_playback.root"");; ; // wait for the recorder to finish the replay; while (r->GetState() == TRecorder::kReplaying) {; gSystem->ProcessEvents();; gSystem->Sleep(1);; }; ; int Step_Err = 100;; int Step1_Ref = 15691;; int Step2_Ref = 15691;; int Step3_Ref = 17632;; int Step4_Ref = 12305;; int Step5_Ref = 11668;; ; int Step1_Size = file_size(""Step1.png"");; int Step2_Size = file_size(""Step2.png"");; int Step3_Size = file_size(""Step3.png"");; int Step4_Size = file_size(""Step4.png"");; int Step5_Size = file_size(""Step5.png"");; ; ; std::cout << ""**********************************************************************"" << std::endl;; std::cout << ""* Report of fitpanel_playback.C *"" << std::endl;; std::cout << ""**********************************************************************"" << std::endl;; ; if (TMath::Abs(Step1_Ref-Step1_Size) <= Step_Err) {; std::cout << ""Step1: ............................................................ OK"" << std::endl;; } else {; std::cout << ""Step1: ........................................................ FAILED"" <<",MatchSource.WIKI,doc/master/fitpanel__playback_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/fitpanel__playback_8C.html
https://root.cern/doc/master/FitResult_8cxx_source.html:1981,Availability,error,errors,1981,"nclude <iostream>; 36#include <iomanip>; 37 ; 38namespace ROOT {; 39 ; 40 namespace Fit {; 41 ; 42 ; 43const int gInitialResultStatus = -99; // use this special convention to flag it when printing result; 44 ; 45FitResult::FitResult() :; 46 fValid(false), fNormalized(false), fNFree(0), fNdf(0), fNCalls(0),; 47 fStatus(-1), fCovStatus(0), fVal(0), fEdm(-1), fChi2(-1); 48{; 49 // Default constructor implementation.; 50}; 51 ; 52FitResult::FitResult(const FitConfig & fconfig) :; 53 fValid(false),; 54 fNormalized(false),; 55 fNFree(0),; 56 fNdf(0),; 57 fNCalls(0),; 58 fStatus(gInitialResultStatus),; 59 fCovStatus(0),; 60 fVal(0),; 61 fEdm(-1),; 62 fChi2(-1),; 63 fFitFunc(nullptr),; 64 fParams(std::vector<double>( fconfig.NPar() ) ),; 65 fErrors(std::vector<double>( fconfig.NPar() ) ),; 66 fParNames(std::vector<std::string> ( fconfig.NPar() ) ); 67{; 68 // create a Fit result from a fit config (i.e. with initial parameter values; 69 // and errors equal to step values; 70 // The model function is NULL in this case; 71 ; 72 // set minimizer type and algorithm; 73 fMinimType = fconfig.MinimizerType();; 74 // append algorithm name for minimizer that support it; 75 if ( (fMinimType.find(""Fumili"") == std::string::npos) &&; 76 (fMinimType.find(""GSLMultiFit"") == std::string::npos); 77 ) {; 78 if (!fconfig.MinimizerAlgoType().empty()) fMinimType += "" / "" + fconfig.MinimizerAlgoType();; 79 }; 80 ; 81 // get parameter values and errors (step sizes); 82 unsigned int npar = fconfig.NPar();; 83 for (unsigned int i = 0; i < npar; ++i ) {; 84 const ParameterSettings & par = fconfig.ParSettings(i);; 85 fParams[i] = par.Value();; 86 fErrors[i] = par.StepSize();; 87 fParNames[i] = par.Name();; 88 if (par.IsFixed() ) fFixedParams[i] = true;; 89 else fNFree++;; 90 if (par.IsBound() ) {; 91 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 92 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;;",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:2469,Availability,error,errors,2469,"itResult::FitResult(const FitConfig & fconfig) :; 53 fValid(false),; 54 fNormalized(false),; 55 fNFree(0),; 56 fNdf(0),; 57 fNCalls(0),; 58 fStatus(gInitialResultStatus),; 59 fCovStatus(0),; 60 fVal(0),; 61 fEdm(-1),; 62 fChi2(-1),; 63 fFitFunc(nullptr),; 64 fParams(std::vector<double>( fconfig.NPar() ) ),; 65 fErrors(std::vector<double>( fconfig.NPar() ) ),; 66 fParNames(std::vector<std::string> ( fconfig.NPar() ) ); 67{; 68 // create a Fit result from a fit config (i.e. with initial parameter values; 69 // and errors equal to step values; 70 // The model function is NULL in this case; 71 ; 72 // set minimizer type and algorithm; 73 fMinimType = fconfig.MinimizerType();; 74 // append algorithm name for minimizer that support it; 75 if ( (fMinimType.find(""Fumili"") == std::string::npos) &&; 76 (fMinimType.find(""GSLMultiFit"") == std::string::npos); 77 ) {; 78 if (!fconfig.MinimizerAlgoType().empty()) fMinimType += "" / "" + fconfig.MinimizerAlgoType();; 79 }; 80 ; 81 // get parameter values and errors (step sizes); 82 unsigned int npar = fconfig.NPar();; 83 for (unsigned int i = 0; i < npar; ++i ) {; 84 const ParameterSettings & par = fconfig.ParSettings(i);; 85 fParams[i] = par.Value();; 86 fErrors[i] = par.StepSize();; 87 fParNames[i] = par.Name();; 88 if (par.IsFixed() ) fFixedParams[i] = true;; 89 else fNFree++;; 90 if (par.IsBound() ) {; 91 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 92 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 93 fBoundParams[i] = fParamBounds.size();; 94 fParamBounds.push_back(std::make_pair(lower,upper));; 95 }; 96 }; 97 std::cout << ""create fit result from config - nfree "" << fNFree << std::endl;; 98}; 99 ; 100void FitResult::FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & func,; 101 bool isValid, unsigned int sizeOfData, int fitType, const ROOT::M",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:6704,Availability,error,error,6704,"ed int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are se",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:6747,Availability,error,error,6747,"ed int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are se",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:6767,Availability,error,error,6767,"ed int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are se",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:7322,Availability,error,errors,7322,"== 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are set separately when calling Fitter::CalculateMinosErrors(); 211 ; 212 // globalCC; 213 fGlobalCC.reserve(npar);; 214 for (unsigned int i = 0; i < npar; ++i) {; 215 double globcc = min->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimType = fconfig.MinimizerName();; 232 ; 233 const unsigned int npar = fParams.size();; 234 if (min->NDim() != npar ) {; 235 MATH_ERROR_MSG(""FitResult::Update"",""Wrong minimizer status "");; 236 return false;; 237 }; 238 if (min->X() == nullptr ) {; 239 MATH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "")",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:8860,Availability,error,errors,8860,"n->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimType = fconfig.MinimizerName();; 232 ; 233 const unsigned int npar = fParams.size();; 234 if (min->NDim() != npar ) {; 235 MATH_ERROR_MSG(""FitResult::Update"",""Wrong minimizer status "");; 236 return false;; 237 }; 238 if (min->X() == nullptr ) {; 239 MATH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "");; 240 return false;; 241 }; 242 if (fNFree != min->NFree() ) {; 243 MATH_ERROR_MSG(""FitResult::Update"",""Configuration has changed "");; 244 return false;; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 // copy parameter value and errors; 259 std::copy(min->X(), min->X() + npar, fParams.begin());; 260 ; 261 ; 262 // set parameters in fit model function; 263 if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:9283,Availability,error,error,9283,"TH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "");; 240 return false;; 241 }; 242 if (fNFree != min->NFree() ) {; 243 MATH_ERROR_MSG(""FitResult::Update"",""Configuration has changed "");; 244 return false;; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 // copy parameter value and errors; 259 std::copy(min->X(), min->X() + npar, fParams.begin());; 260 ; 261 ; 262 // set parameters in fit model function; 263 if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279 fCovMatrix[l++] = min->CovMatrix(i,j);; 280 }; 281 }; 282 ; 283 // update global CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:9988,Availability,error,errors,9988," if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279 fCovMatrix[l++] = min->CovMatrix(i,j);; 280 }; 281 }; 282 ; 283 // update global CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332do",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:10817,Availability,error,error,10817,"bal CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11066,Availability,error,error,11066,"302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11117,Availability,error,error,11117,"302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11132,Availability,error,error,11132,"302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11452,Availability,error,error,11452,"15 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11503,Availability,error,error,11503,"15 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11518,Availability,error,error,11518,"15 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:11854,Availability,error,error,11854,"ind(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.find(ipar) != fFixedParams.end();; 367}; 368 ; 369bool FitResult::ParameterBounds(unsigned int ipar, double & lower, double & upper) const {; 370 std::map<unsigned int, unsigned int>::const_iterator itr = fBoundParams.find(ipar);; 371 if (itr == fBoundParams.end() ) {; 372 lower = -std::numeric_limits<Double_t>::infinity();; 373 upper = std::numeric_limits<Double_t>::infinity();; 374 return false;; 375 }; 376 ass",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:13507,Availability,error,errors,13507,");; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.find(ipar) != fFixedParams.end();; 367}; 368 ; 369bool FitResult::ParameterBounds(unsigned int ipar, double & lower, double & upper) const {; 370 std::map<unsigned int, unsigned int>::const_iterator itr = fBoundParams.find(ipar);; 371 if (itr == fBoundParams.end() ) {; 372 lower = -std::numeric_limits<Double_t>::infinity();; 373 upper = std::numeric_limits<Double_t>::infinity();; 374 return false;; 375 }; 376 assert(itr->second < fParamBounds.size() );; 377 lower = fParamBounds[itr->second].first;; 378 upper = fParamBounds[itr->second].second;; 379 return true;; 380}; 381 ; 382std::string FitResult::ParName(unsigned int ipar) const {; 383 // return parameter name; 384 if (fFitFunc) return fFitFunc->ParameterName(ipar);; 385 else if (ipar < fParNames.size() ) return fParNames[ipar];; 386 return ""param_"" + ROOT::Math::Util::ToString(ipar);; 387}; 388 ; 389void FitResult::Print(std::ostream & os, bool doCovMatrix) const {; 390 // print the result in the given stream; 391 // need to add also minos errors , globalCC, etc..; 392 unsigned int npar = fParams.size();; 393 if (npar == 0) {; 394 os << ""<Empty FitResult>\n"";; 395 return;; 396 }; 397 os << ""****************************************\n"";; 398 if (!fValid) {; 399 if (fStatus != gInitialResultStatus) {; 400 os << "" Invalid FitResult"";; 401 os << "" (status = "" << fStatus << "" )"";; 402 }; 403 else {; 404 os << "" FitResult before fitting"";; 405 }; 406 os << ""\n****************************************\n"";; 407 }; 408 ; 409 //os << "" FitResult \n\n"";; 410 os << ""Minimizer is "" << fMinimType << std::endl;; 411 const unsigned int nw = 25; // spacing for text; 412 const unsigned int nn = 12; // spacing for numbers; 413 const std::ios_base::fmtflags prFmt = os.setf(std::ios::left,std::ios::adjustfield); // set left alignment; 414 ; 415 if (fVal != fChi2 || fChi2 < 0); 416 os << std::left << std::setw(nw) << ""MinFCN"" << "" = ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:18705,Availability,error,errors,18705,"d::left << GetParameterName(i) << ""\t"";; 493 for (unsigned int j = 0; j < npar; ++j) {; 494 if (!IsParameterFixed(j) ) {; 495 os.precision(kPrec); os.width(kWidth); os << std::right << std::setw(matw) << Correlation(i,j);; 496 }; 497 }; 498 os << std::endl;; 499 }; 500 }; 501 // restore alignment and precision; 502 os.setf(prevFmt, std::ios::adjustfield);; 503 os.precision(prevPrec);; 504}; 505 ; 506void FitResult::GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double * x, double * ci, double cl, bool norm ) const {; 507 // stride1 stride in coordinate stride2 stride in dimension space; 508 // i.e. i-th point in k-dimension is x[ stride1 * i + stride2 * k]; 509 // compute the confidence interval of the fit on the given data points; 510 // the dimension of the data points must match the dimension of the fit function; 511 // confidence intervals are returned in array ci; 512 ; 513 if (!fFitFunc) {; 514 // check if model function exists; 515 MATH_ERROR_MSG(""FitResult::GetConfidenceIntervals"",""Cannot compute Confidence Intervals without fit model function"");; 516 return;; 517 }; 518 assert(fFitFunc);; 519 ; 520 // use student quantile in case of normalized errors; 521 double corrFactor = 1;; 522 if (fChi2 <= 0 || fNdf == 0) norm = false;; 523 if (norm); 524 corrFactor = TMath::StudentQuantile(0.5 + cl/2, fNdf) * std::sqrt( fChi2/fNdf );; 525 else; 526 // correction to apply to the errors given a CL different than 1 sigma (cl=0.683); 527 corrFactor = ROOT::Math::normal_quantile(0.5 + cl/2, 1);; 528 ; 529 ; 530 ; 531 unsigned int ndim = fFitFunc->NDim();; 532 unsigned int npar = fFitFunc->NPar();; 533 ; 534 std::vector<double> xpoint(ndim);; 535 std::vector<double> grad(npar);; 536 std::vector<double> vsum(npar);; 537 ; 538 // loop on the points; 539 for (unsigned int ipoint = 0; ipoint < n; ++ipoint) {; 540 ; 541 for (unsigned int kdim = 0; kdim < ndim; ++kdim) {; 542 unsigned int i = ipoint * stride1 + kdim * stride2;; 543 assert",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:18934,Availability,error,errors,18934,"tConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double * x, double * ci, double cl, bool norm ) const {; 507 // stride1 stride in coordinate stride2 stride in dimension space; 508 // i.e. i-th point in k-dimension is x[ stride1 * i + stride2 * k]; 509 // compute the confidence interval of the fit on the given data points; 510 // the dimension of the data points must match the dimension of the fit function; 511 // confidence intervals are returned in array ci; 512 ; 513 if (!fFitFunc) {; 514 // check if model function exists; 515 MATH_ERROR_MSG(""FitResult::GetConfidenceIntervals"",""Cannot compute Confidence Intervals without fit model function"");; 516 return;; 517 }; 518 assert(fFitFunc);; 519 ; 520 // use student quantile in case of normalized errors; 521 double corrFactor = 1;; 522 if (fChi2 <= 0 || fNdf == 0) norm = false;; 523 if (norm); 524 corrFactor = TMath::StudentQuantile(0.5 + cl/2, fNdf) * std::sqrt( fChi2/fNdf );; 525 else; 526 // correction to apply to the errors given a CL different than 1 sigma (cl=0.683); 527 corrFactor = ROOT::Math::normal_quantile(0.5 + cl/2, 1);; 528 ; 529 ; 530 ; 531 unsigned int ndim = fFitFunc->NDim();; 532 unsigned int npar = fFitFunc->NPar();; 533 ; 534 std::vector<double> xpoint(ndim);; 535 std::vector<double> grad(npar);; 536 std::vector<double> vsum(npar);; 537 ; 538 // loop on the points; 539 for (unsigned int ipoint = 0; ipoint < n; ++ipoint) {; 540 ; 541 for (unsigned int kdim = 0; kdim < ndim; ++kdim) {; 542 unsigned int i = ipoint * stride1 + kdim * stride2;; 543 assert(i < ndim*n);; 544 xpoint[kdim] = x[i];; 545 }; 546 ; 547 // calculate gradient of fitted function w.r.t the parameters; 548 ROOT::Math::RichardsonDerivator d;; 549 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 550 if (!IsParameterFixed(ipar)) {; 551 ROOT::Math::OneDimParamFunctionAdapter<const ROOT::Math::IParamMultiFunction &> fadapter(*fFitFunc,&xpoint.front(),&fParams.front(),ipar);; 552 d.SetFunction(fadapt",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:19972,Availability,error,error,19972,"erent than 1 sigma (cl=0.683); 527 corrFactor = ROOT::Math::normal_quantile(0.5 + cl/2, 1);; 528 ; 529 ; 530 ; 531 unsigned int ndim = fFitFunc->NDim();; 532 unsigned int npar = fFitFunc->NPar();; 533 ; 534 std::vector<double> xpoint(ndim);; 535 std::vector<double> grad(npar);; 536 std::vector<double> vsum(npar);; 537 ; 538 // loop on the points; 539 for (unsigned int ipoint = 0; ipoint < n; ++ipoint) {; 540 ; 541 for (unsigned int kdim = 0; kdim < ndim; ++kdim) {; 542 unsigned int i = ipoint * stride1 + kdim * stride2;; 543 assert(i < ndim*n);; 544 xpoint[kdim] = x[i];; 545 }; 546 ; 547 // calculate gradient of fitted function w.r.t the parameters; 548 ROOT::Math::RichardsonDerivator d;; 549 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 550 if (!IsParameterFixed(ipar)) {; 551 ROOT::Math::OneDimParamFunctionAdapter<const ROOT::Math::IParamMultiFunction &> fadapter(*fFitFunc,&xpoint.front(),&fParams.front(),ipar);; 552 d.SetFunction(fadapter);; 553 // compute step size as a small fraction of the error; 554 // (see numerical recipes in C 5.7.8) 1.E-5 is ~ (eps)^1/3; 555 if ( fErrors[ipar] > 0 ); 556 d.SetStepSize( std::max( fErrors[ipar]*1.E-5, 1.E-15) );; 557 else; 558 d.SetStepSize( std::min(std::max(fParams[ipar]*1.E-5, 1.E-15), 0.0001 ) );; 559 ; 560 grad[ipar] = d(fParams[ipar] ); // evaluate df/dp; 561 }; 562 else; 563 grad[ipar] = 0.; // for fixed parameters; 564 }; 565 ; 566 // multiply covariance matrix with gradient; 567 vsum.assign(npar,0.0);; 568 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 569 for (unsigned int jpar = 0; jpar < npar; ++jpar) {; 570 vsum[ipar] += CovMatrix(ipar,jpar) * grad[jpar];; 571 }; 572 }; 573 // multiply gradient by vsum; 574 double r2 = 0;; 575 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 576 r2 += grad[ipar] * vsum[ipar];; 577 }; 578 double r = std::sqrt(r2);; 579 ci[ipoint] = r * corrFactor;; 580 }; 581}; 582 ; 583void FitResult::GetConfidenceIntervals(const BinData & data, double * ci, double cl, bool norm ) ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:23812,Availability,avail,available,23812," = dynamic_cast<Chi2GradFunction*>(f);; 624// if (chi2gradfunc) return &(chi2gradfunc->Data());; 625// PoissonLLGradFunction * pllgradfunc = dynamic_cast<PoissonLLFunction*>(f);; 626// if (pllgradfunc) return &(pllgradfunc->Data());; 627// MATH_WARN_MSG(""FitResult::GetFitBinData"",""Cannot return fit bin data set if objective function is not of a known type"");; 628// return nullptr;; 629// }; 630 ; 631const BinData * FitResult::FittedBinData() const {; 632 return dynamic_cast<const BinData*> ( fFitData.get() );; 633}; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contou",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:24362,Availability,error,error,24362,"////////////////////////////////////////////////////////////////////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 68",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:24400,Availability,error,error,24400,"///////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namesp",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:24775,Availability,avail,available,24775,"sy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namespace ROOT; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; FitConfig.h; FitResult.h; IParamFunction.h; Minimizer.h; OneDimFunctionAdapter.h; ProbFuncMathCore.h; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; RichardsonDerivator.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; npOption_t Option_t TPoint",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:24857,Availability,error,error,24857,"sy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namespace ROOT; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; FitConfig.h; FitResult.h; IParamFunction.h; Minimizer.h; OneDimFunctionAdapter.h; ProbFuncMathCore.h; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; RichardsonDerivator.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; npOption_t Option_t TPoint",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:25071,Availability,error,error,25071,"sy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namespace ROOT; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; FitConfig.h; FitResult.h; IParamFunction.h; Minimizer.h; OneDimFunctionAdapter.h; ProbFuncMathCore.h; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; RichardsonDerivator.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; npOption_t Option_t TPoint",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:25252,Availability,error,error,25252,"sy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namespace ROOT; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; FitConfig.h; FitResult.h; IParamFunction.h; Minimizer.h; OneDimFunctionAdapter.h; ProbFuncMathCore.h; QuantFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; RichardsonDerivator.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; npOption_t Option_t TPoint",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:27263,Availability,error,error,27263,"tPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResult::fGlobalCCstd::vector< d",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:29610,Availability,error,error,29610,"onfig, bool isValid, unsigned int ncalls=0)Update the fit result with a new minimization status To be run only if same fit is performed with sam...Definition FitResult.cxx:224; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn BinData used in the fit (return a nullptr in case a different fit is done or the data are not ...Definition FitResult.cxx:631; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitR",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:29675,Availability,error,errorDefinition,29675,"atus To be run only if same fit is performed with sam...Definition FitResult.cxx:224; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn BinData used in the fit (return a nullptr in case a different fit is done or the data are not ...Definition FitResult.cxx:631; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitResult.h:179; ROOT::Fit::FitResult::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j)",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:30538,Availability,error,error,30538,"t.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitResult.h:179; ROOT::Fit::FitResult::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) constretrieve covariance matrix elementDefinition FitResult.h:215; ROOT::Fit::FitResult::GetConfidenceIntervalsvoid GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) constget confidence intervals for an array of n points x.Definition FitResult.cxx:506; ROOT::Fit::FitResult::fCovStatusint fCovStatuscovariance matrix status codeDefinition FitResult.h:349; ROOT::Fit::FitResult::Scanbool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)scan likelihood value of parameter and fill the given graph.Definition FitResult.cxx:639; ROOT::Fit::FitResult::FitResultFitResult()Default constructor for an empty (non valid) fit result.Definition FitResult.cxx:45; ROOT::Fit::FitResult::fFitDatastd::shared_ptr< FitDa",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:32357,Availability,error,errors,32357,"it::FitResult::FitResultFitResult()Default constructor for an empty (non valid) fit result.Definition FitResult.cxx:45; ROOT::Fit::FitResult::fFitDatastd::shared_ptr< FitData > fFitData! data set used in the fitDefinition FitResult.h:356; ROOT::Fit::FitResult::GetParameterNamestd::string GetParameterName(unsigned int ipar) constget name of parameter (deprecated)Definition FitResult.h:327; ROOT::Fit::FitResult::ParameterBoundsbool ParameterBounds(unsigned int ipar, double &lower, double &upper) constretrieve parameter bounds - return false if parameter is not boundDefinition FitResult.cxx:369; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:32716,Availability,error,error,32716,"stget name of parameter (deprecated)Definition FitResult.h:327; ROOT::Fit::FitResult::ParameterBoundsbool ParameterBounds(unsigned int ipar, double &lower, double &upper) constretrieve parameter bounds - return false if parameter is not boundDefinition FitResult.cxx:369; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::HasMinosErrorbool HasMinosError(unsigned int i) constquery if parameter i has the Minos errorDefinition FitResult.cxx:325; ROOT::Fit::FitResult::fParamBoundsstd::vector< std::pair< double, double > > fParamBoundsparameter boundsDefinition FitResult.h:359; ROOT::Fit::FitResult::fStatusint fStatusmini",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:32781,Availability,error,errorDefinition,32781,"eterBoundsbool ParameterBounds(unsigned int ipar, double &lower, double &upper) constretrieve parameter bounds - return false if parameter is not boundDefinition FitResult.cxx:369; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::HasMinosErrorbool HasMinosError(unsigned int i) constquery if parameter i has the Minos errorDefinition FitResult.cxx:325; ROOT::Fit::FitResult::fParamBoundsstd::vector< std::pair< double, double > > fParamBoundsparameter boundsDefinition FitResult.h:359; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; ROOT::Fit::FitResult::fChi2double fChi2fit chi2",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:32901,Availability,error,error,32901,"turn false if parameter is not boundDefinition FitResult.cxx:369; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::HasMinosErrorbool HasMinosError(unsigned int i) constquery if parameter i has the Minos errorDefinition FitResult.cxx:325; ROOT::Fit::FitResult::fParamBoundsstd::vector< std::pair< double, double > > fParamBoundsparameter boundsDefinition FitResult.h:359; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; ROOT::Fit::FitResult::fChi2double fChi2fit chi2 value (different than fval in case of chi2 fits)Definition FitResult.h:352; ROOT::Fit::FitResult::fFitFuncstd::sh",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:33461,Availability,error,errorDefinition,33461,"unning Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::HasMinosErrorbool HasMinosError(unsigned int i) constquery if parameter i has the Minos errorDefinition FitResult.cxx:325; ROOT::Fit::FitResult::fParamBoundsstd::vector< std::pair< double, double > > fParamBoundsparameter boundsDefinition FitResult.h:359; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; ROOT::Fit::FitResult::fChi2double fChi2fit chi2 value (different than fval in case of chi2 fits)Definition FitResult.h:352; ROOT::Fit::FitResult::fFitFuncstd::shared_ptr< IModelFunction > fFitFunc! model function resulting from the fit.Definition FitResult.h:355; ROOT::Fit::FitResult::fFixedParamsstd::map< unsigned int, bool > fFixedParamslist of fixed parametersDefinition FitResult.h:357; ROOT::Fit::FitResult::fMinimTypestd::string fMinimTypestring indicating type of minimizerDefinition FitResult.h:365; ROOT::Fit::FitResult::Correlationdouble Correlation(unsigned int i, unsigned int j) constretrieve correlation elementsDefinition FitResult.h:225; ROOT::Fit::FitResult::Indexint Index(cons",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:34826,Availability,error,errors,34826,"efinition FitResult.h:352; ROOT::Fit::FitResult::fFitFuncstd::shared_ptr< IModelFunction > fFitFunc! model function resulting from the fit.Definition FitResult.h:355; ROOT::Fit::FitResult::fFixedParamsstd::map< unsigned int, bool > fFixedParamslist of fixed parametersDefinition FitResult.h:357; ROOT::Fit::FitResult::fMinimTypestd::string fMinimTypestring indicating type of minimizerDefinition FitResult.h:365; ROOT::Fit::FitResult::Correlationdouble Correlation(unsigned int i, unsigned int j) constretrieve correlation elementsDefinition FitResult.h:225; ROOT::Fit::FitResult::Indexint Index(const std::string &name) constget index for parameter name (return -1 if not found)Definition FitResult.cxx:351; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitResult::ParNamestd::string ParName(unsigned int i) constname of the parameterDefinition FitResult.cxx:382; ROOT::Fit::FitResult::NormalizeErrorsvoid NormalizeErrors()normalize errors using chi2/ndf for chi2 fitsDefinition FitResult.cxx:298; ROOT::Fit::FitResult::fNormalizedbool fNormalizedflag for indicating is errors are normalizedDefinition FitResult.h:344; ROOT::Fit::FitResult::IsParameterBoundbool IsParameterBound(unsigned int ipar) constquery if a parameter is boundDefinition FitResult.cxx:361; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to s",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:34963,Availability,error,errors,34963,"om the fit.Definition FitResult.h:355; ROOT::Fit::FitResult::fFixedParamsstd::map< unsigned int, bool > fFixedParamslist of fixed parametersDefinition FitResult.h:357; ROOT::Fit::FitResult::fMinimTypestd::string fMinimTypestring indicating type of minimizerDefinition FitResult.h:365; ROOT::Fit::FitResult::Correlationdouble Correlation(unsigned int i, unsigned int j) constretrieve correlation elementsDefinition FitResult.h:225; ROOT::Fit::FitResult::Indexint Index(const std::string &name) constget index for parameter name (return -1 if not found)Definition FitResult.cxx:351; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitResult::ParNamestd::string ParName(unsigned int i) constname of the parameterDefinition FitResult.cxx:382; ROOT::Fit::FitResult::NormalizeErrorsvoid NormalizeErrors()normalize errors using chi2/ndf for chi2 fitsDefinition FitResult.cxx:298; ROOT::Fit::FitResult::fNormalizedbool fNormalizedflag for indicating is errors are normalizedDefinition FitResult.h:344; ROOT::Fit::FitResult::IsParameterBoundbool IsParameterBound(unsigned int ipar) constquery if a parameter is boundDefinition FitResult.cxx:361; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::IsFixedbool IsFixed() constcheck if is fixedDefinition P",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:35435,Availability,error,errorsDefinition,35435,"it::FitResult::Indexint Index(const std::string &name) constget index for parameter name (return -1 if not found)Definition FitResult.cxx:351; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitResult::ParNamestd::string ParName(unsigned int i) constname of the parameterDefinition FitResult.cxx:382; ROOT::Fit::FitResult::NormalizeErrorsvoid NormalizeErrors()normalize errors using chi2/ndf for chi2 fitsDefinition FitResult.cxx:298; ROOT::Fit::FitResult::fNormalizedbool fNormalizedflag for indicating is errors are normalizedDefinition FitResult.h:344; ROOT::Fit::FitResult::IsParameterBoundbool IsParameterBound(unsigned int ipar) constquery if a parameter is boundDefinition FitResult.cxx:361; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::IsFixedbool IsFixed() constcheck if is fixedDefinition ParameterSettings.h:98; ROOT::Fit::ParameterSettings::HasUpperLimitbool HasUpperLimit() constcheck if parameter has upper limitDefinition ParameterSettings.h:102; ROOT::Fit::ParameterSettings::LowerLimitdouble LowerLimit() constreturn lower limit valueDefinition ParameterSettings.h:94; ROOT::Fit::ParameterSettings::Nameconst std::string & Name() constreturn nameDefinition ParameterSettings.h:108; ROOT::Fit::ParameterSettings::HasLowerL",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:4371,Deployability,configurat,configuration,4371,"t result from config - nfree "" << fNFree << std::endl;; 98}; 99 ; 100void FitResult::FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & func,; 101 bool isValid, unsigned int sizeOfData, int fitType, const ROOT::Math::IMultiGenFunction * chi2func, unsigned int ncalls ); 102{; 103 // Fill the FitResult after minimization using result from Minimizers; 104 ; 105 // minimizer must exist; 106 assert(min);; 107 ; 108 fValid = isValid;; 109 fNFree= min->NFree();; 110 fNCalls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:7834,Deployability,update,update,7834,"t; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are set separately when calling Fitter::CalculateMinosErrors(); 211 ; 212 // globalCC; 213 fGlobalCC.reserve(npar);; 214 for (unsigned int i = 0; i < npar; ++i) {; 215 double globcc = min->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimType = fconfig.MinimizerName();; 232 ; 233 const unsigned int npar = fParams.size();; 234 if (min->NDim() != npar ) {; 235 MATH_ERROR_MSG(""FitResult::Update"",""Wrong minimizer status "");; 236 return false;; 237 }; 238 if (min->X() == nullptr ) {; 239 MATH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "");; 240 return false;; 241 }; 242 if (fNFree != min->NFree() ) {; 243 MATH_ERROR_MSG(""FitResult::Update"",""Configuration has changed "");; 244 return false;; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 /",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:8547,Deployability,update,update,8547,"n->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimType = fconfig.MinimizerName();; 232 ; 233 const unsigned int npar = fParams.size();; 234 if (min->NDim() != npar ) {; 235 MATH_ERROR_MSG(""FitResult::Update"",""Wrong minimizer status "");; 236 return false;; 237 }; 238 if (min->X() == nullptr ) {; 239 MATH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "");; 240 return false;; 241 }; 242 if (fNFree != min->NFree() ) {; 243 MATH_ERROR_MSG(""FitResult::Update"",""Configuration has changed "");; 244 return false;; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 // copy parameter value and errors; 259 std::copy(min->X(), min->X() + npar, fParams.begin());; 260 ; 261 ; 262 // set parameters in fit model function; 263 if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:8707,Deployability,update,update,8707,"n->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimType = fconfig.MinimizerName();; 232 ; 233 const unsigned int npar = fParams.size();; 234 if (min->NDim() != npar ) {; 235 MATH_ERROR_MSG(""FitResult::Update"",""Wrong minimizer status "");; 236 return false;; 237 }; 238 if (min->X() == nullptr ) {; 239 MATH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "");; 240 return false;; 241 }; 242 if (fNFree != min->NFree() ) {; 243 MATH_ERROR_MSG(""FitResult::Update"",""Configuration has changed "");; 244 return false;; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 // copy parameter value and errors; 259 std::copy(min->X(), min->X() + npar, fParams.begin());; 260 ; 261 ; 262 // set parameters in fit model function; 263 if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:9276,Deployability,update,update,9276,"TH_ERROR_MSG(""FitResult::Update"",""Invalid minimizer status "");; 240 return false;; 241 }; 242 if (fNFree != min->NFree() ) {; 243 MATH_ERROR_MSG(""FitResult::Update"",""Configuration has changed "");; 244 return false;; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 // copy parameter value and errors; 259 std::copy(min->X(), min->X() + npar, fParams.begin());; 260 ; 261 ; 262 // set parameters in fit model function; 263 if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279 fCovMatrix[l++] = min->CovMatrix(i,j);; 280 }; 281 }; 282 ; 283 // update global CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:9583,Deployability,update,update,9583,"; 245 }; 246 ; 247 fValid = isValid;; 248 // update minimum value; 249 fVal = min->MinValue();; 250 fEdm = min->Edm();; 251 fStatus = min->Status();; 252 fCovStatus = min->CovMatrixStatus();; 253 ; 254 // update number of function calls; 255 if ( min->NCalls() > 0) fNCalls = min->NCalls();; 256 else fNCalls = ncalls;; 257 ; 258 // copy parameter value and errors; 259 std::copy(min->X(), min->X() + npar, fParams.begin());; 260 ; 261 ; 262 // set parameters in fit model function; 263 if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279 fCovMatrix[l++] = min->CovMatrix(i,j);; 280 }; 281 }; 282 ; 283 // update global CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fN",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:27343,Deployability,configurat,configuration,27343,"reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free param",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:37138,Integrability,wrap,wrap,37138,"ttings::LowerLimitdouble LowerLimit() constreturn lower limit valueDefinition ParameterSettings.h:94; ROOT::Fit::ParameterSettings::Nameconst std::string & Name() constreturn nameDefinition ParameterSettings.h:108; ROOT::Fit::ParameterSettings::HasLowerLimitbool HasLowerLimit() constcheck if parameter has lower limitDefinition ParameterSettings.h:100; ROOT::Fit::ParameterSettings::Valuedouble Value() constreturn parameter valueDefinition ParameterSettings.h:90; ROOT::Fit::ParameterSettings::StepSizedouble StepSize() constreturn step sizeDefinition ParameterSettings.h:92; ROOT::Fit::ParameterSettings::UpperLimitdouble UpperLimit() constreturn upper limit valueDefinition ParameterSettings.h:96; ROOT::Fit::ParameterSettings::IsBoundbool IsBound() constcheck if is boundDefinition ParameterSettings.h:104; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::OneDimParamFunctionAdapterOneDimParamFunctionAdapter class to wrap a multi-dim parametric function in one dimensional one.Definition OneDimFunctionAdapter.h:213; ROOT::Math::RichardsonDerivatorUser class for calculating the derivatives of a function.Definition RichardsonDerivator.h:55; double; ROOT::Math::chisquared_cdf_cdouble chisquared_cdf_c(double x, double r, double x0=0)Complement of the cumulative distribution function of the distribution with degrees of freedom (upp...Definition ProbFuncMathCore.cxx:57; ROOT::Math::normal_quantiledouble normal_quantile(double z, double sigma)Inverse ( ) of the cumulative distribution function of the lower tail of the normal (Gaussian) distri...Definition QuantFuncMathCore.cxx:134; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Fit::gInitialResultStatusconst int gInitial",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:1927,Modifiability,config,config,1927,"ath.h""; 30#include ""Math/RichardsonDerivator.h""; 31#include ""Math/Error.h""; 32 ; 33#include <cassert>; 34#include <cmath>; 35#include <iostream>; 36#include <iomanip>; 37 ; 38namespace ROOT {; 39 ; 40 namespace Fit {; 41 ; 42 ; 43const int gInitialResultStatus = -99; // use this special convention to flag it when printing result; 44 ; 45FitResult::FitResult() :; 46 fValid(false), fNormalized(false), fNFree(0), fNdf(0), fNCalls(0),; 47 fStatus(-1), fCovStatus(0), fVal(0), fEdm(-1), fChi2(-1); 48{; 49 // Default constructor implementation.; 50}; 51 ; 52FitResult::FitResult(const FitConfig & fconfig) :; 53 fValid(false),; 54 fNormalized(false),; 55 fNFree(0),; 56 fNdf(0),; 57 fNCalls(0),; 58 fStatus(gInitialResultStatus),; 59 fCovStatus(0),; 60 fVal(0),; 61 fEdm(-1),; 62 fChi2(-1),; 63 fFitFunc(nullptr),; 64 fParams(std::vector<double>( fconfig.NPar() ) ),; 65 fErrors(std::vector<double>( fconfig.NPar() ) ),; 66 fParNames(std::vector<std::string> ( fconfig.NPar() ) ); 67{; 68 // create a Fit result from a fit config (i.e. with initial parameter values; 69 // and errors equal to step values; 70 // The model function is NULL in this case; 71 ; 72 // set minimizer type and algorithm; 73 fMinimType = fconfig.MinimizerType();; 74 // append algorithm name for minimizer that support it; 75 if ( (fMinimType.find(""Fumili"") == std::string::npos) &&; 76 (fMinimType.find(""GSLMultiFit"") == std::string::npos); 77 ) {; 78 if (!fconfig.MinimizerAlgoType().empty()) fMinimType += "" / "" + fconfig.MinimizerAlgoType();; 79 }; 80 ; 81 // get parameter values and errors (step sizes); 82 unsigned int npar = fconfig.NPar();; 83 for (unsigned int i = 0; i < npar; ++i ) {; 84 const ParameterSettings & par = fconfig.ParSettings(i);; 85 fParams[i] = par.Value();; 86 fErrors[i] = par.StepSize();; 87 fParNames[i] = par.Name();; 88 if (par.IsFixed() ) fFixedParams[i] = true;; 89 else fNFree++;; 90 if (par.IsBound() ) {; 91 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limit",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:3186,Modifiability,config,config,3186,"g.NPar();; 83 for (unsigned int i = 0; i < npar; ++i ) {; 84 const ParameterSettings & par = fconfig.ParSettings(i);; 85 fParams[i] = par.Value();; 86 fErrors[i] = par.StepSize();; 87 fParNames[i] = par.Name();; 88 if (par.IsFixed() ) fFixedParams[i] = true;; 89 else fNFree++;; 90 if (par.IsBound() ) {; 91 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 92 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 93 fBoundParams[i] = fParamBounds.size();; 94 fParamBounds.push_back(std::make_pair(lower,upper));; 95 }; 96 }; 97 std::cout << ""create fit result from config - nfree "" << fNFree << std::endl;; 98}; 99 ; 100void FitResult::FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & func,; 101 bool isValid, unsigned int sizeOfData, int fitType, const ROOT::Math::IMultiGenFunction * chi2func, unsigned int ncalls ); 102{; 103 // Fill the FitResult after minimization using result from Minimizers; 104 ; 105 // minimizer must exist; 106 assert(min);; 107 ; 108 fValid = isValid;; 109 fNFree= min->NFree();; 110 fNCalls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:4371,Modifiability,config,configuration,4371,"t result from config - nfree "" << fNFree << std::endl;; 98}; 99 ; 100void FitResult::FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & func,; 101 bool isValid, unsigned int sizeOfData, int fitType, const ROOT::Math::IMultiGenFunction * chi2func, unsigned int ncalls ); 102{; 103 // Fill the FitResult after minimization using result from Minimizers; 104 ; 105 // minimizer must exist; 106 assert(min);; 107 ; 108 fValid = isValid;; 109 fNFree= min->NFree();; 110 fNCalls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:27343,Modifiability,config,configuration,27343,"reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TMath.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free param",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:28693,Performance,perform,performed,28693,"finition FitConfig.h:192; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free parameters (total parameters are in size of parameter vector)Definition FitResult.h:345; ROOT::Fit::FitResult::Updatebool Update(const std::shared_ptr< ROOT::Math::Minimizer > &min, const ROOT::Fit::FitConfig &fconfig, bool isValid, unsigned int ncalls=0)Update the fit result with a new minimization status To be run only if same fit is performed with sam...Definition FitResult.cxx:224; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn BinData used in the fit (return a nullptr in case a different fit is done or the data are not ...Definition FitResult.cxx:631; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperErro",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:4775,Safety,avoid,avoid,4775,"ls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; 154 }; 155 ; 156 ; 157 // check for fixed or limited parameters; 158 unsigned int nfree = 0;; 159 if (!fParamBounds.empty()) fParamBounds.clear();; 160 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_l",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:3641,Testability,assert,assert,3641,"g.NPar();; 83 for (unsigned int i = 0; i < npar; ++i ) {; 84 const ParameterSettings & par = fconfig.ParSettings(i);; 85 fParams[i] = par.Value();; 86 fErrors[i] = par.StepSize();; 87 fParNames[i] = par.Name();; 88 if (par.IsFixed() ) fFixedParams[i] = true;; 89 else fNFree++;; 90 if (par.IsBound() ) {; 91 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 92 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 93 fBoundParams[i] = fParamBounds.size();; 94 fParamBounds.push_back(std::make_pair(lower,upper));; 95 }; 96 }; 97 std::cout << ""create fit result from config - nfree "" << fNFree << std::endl;; 98}; 99 ; 100void FitResult::FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & func,; 101 bool isValid, unsigned int sizeOfData, int fitType, const ROOT::Math::IMultiGenFunction * chi2func, unsigned int ncalls ); 102{; 103 // Fill the FitResult after minimization using result from Minimizers; 104 ; 105 // minimizer must exist; 106 assert(min);; 107 ; 108 fValid = isValid;; 109 fNFree= min->NFree();; 110 fNCalls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:4882,Testability,assert,assert,4882,"ls = min->NCalls();; 111 fStatus = min->Status();; 112 fCovStatus= min->CovMatrixStatus();; 113 fVal = min->MinValue();; 114 fEdm = min->Edm();; 115 ; 116 fMinimizer= min;; 117 fFitFunc = func;; 118 ; 119 fMinimType = fconfig.MinimizerName();; 120 ; 121 // replace ncalls if minimizer does not support it (they are taken then from the FitMethodFunction); 122 if (fNCalls == 0) fNCalls = ncalls;; 123 ; 124 const unsigned int npar = min->NDim();; 125 if (npar == 0) return;; 126 ; 127 if (min->X() ); 128 fParams = std::vector<double>(min->X(), min->X() + npar);; 129 else {; 130 // case minimizer does not provide minimum values (it failed) take from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; 154 }; 155 ; 156 ; 157 // check for fixed or limited parameters; 158 unsigned int nfree = 0;; 159 if (!fParamBounds.empty()) fParamBounds.clear();; 160 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_l",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:12911,Testability,assert,assert,12911,"os error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.find(ipar) != fFixedParams.end();; 367}; 368 ; 369bool FitResult::ParameterBounds(unsigned int ipar, double & lower, double & upper) const {; 370 std::map<unsigned int, unsigned int>::const_iterator itr = fBoundParams.find(ipar);; 371 if (itr == fBoundParams.end() ) {; 372 lower = -std::numeric_limits<Double_t>::infinity();; 373 upper = std::numeric_limits<Double_t>::infinity();; 374 return false;; 375 }; 376 assert(itr->second < fParamBounds.size() );; 377 lower = fParamBounds[itr->second].first;; 378 upper = fParamBounds[itr->second].second;; 379 return true;; 380}; 381 ; 382std::string FitResult::ParName(unsigned int ipar) const {; 383 // return parameter name; 384 if (fFitFunc) return fFitFunc->ParameterName(ipar);; 385 else if (ipar < fParNames.size() ) return fParNames[ipar];; 386 return ""param_"" + ROOT::Math::Util::ToString(ipar);; 387}; 388 ; 389void FitResult::Print(std::ostream & os, bool doCovMatrix) const {; 390 // print the result in the given stream; 391 // need to add also minos errors , globalCC, etc..; 392 unsigned int npar = fParams.size();; 393 if (npar == 0) {; 394 os << ""<Empty FitResult>\n"";; 395 return;; 396 }; 397 os << ""****************************************\n"";; 398 if (!fValid) {; 399 if (fStatus != gInitialResultStatus) {; 400 os << "" Invalid FitResult"";; 401 os << "" (status = "" << fStatus << "" )"";; 40",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:18630,Testability,assert,assert,18630,"d::left << GetParameterName(i) << ""\t"";; 493 for (unsigned int j = 0; j < npar; ++j) {; 494 if (!IsParameterFixed(j) ) {; 495 os.precision(kPrec); os.width(kWidth); os << std::right << std::setw(matw) << Correlation(i,j);; 496 }; 497 }; 498 os << std::endl;; 499 }; 500 }; 501 // restore alignment and precision; 502 os.setf(prevFmt, std::ios::adjustfield);; 503 os.precision(prevPrec);; 504}; 505 ; 506void FitResult::GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double * x, double * ci, double cl, bool norm ) const {; 507 // stride1 stride in coordinate stride2 stride in dimension space; 508 // i.e. i-th point in k-dimension is x[ stride1 * i + stride2 * k]; 509 // compute the confidence interval of the fit on the given data points; 510 // the dimension of the data points must match the dimension of the fit function; 511 // confidence intervals are returned in array ci; 512 ; 513 if (!fFitFunc) {; 514 // check if model function exists; 515 MATH_ERROR_MSG(""FitResult::GetConfidenceIntervals"",""Cannot compute Confidence Intervals without fit model function"");; 516 return;; 517 }; 518 assert(fFitFunc);; 519 ; 520 // use student quantile in case of normalized errors; 521 double corrFactor = 1;; 522 if (fChi2 <= 0 || fNdf == 0) norm = false;; 523 if (norm); 524 corrFactor = TMath::StudentQuantile(0.5 + cl/2, fNdf) * std::sqrt( fChi2/fNdf );; 525 else; 526 // correction to apply to the errors given a CL different than 1 sigma (cl=0.683); 527 corrFactor = ROOT::Math::normal_quantile(0.5 + cl/2, 1);; 528 ; 529 ; 530 ; 531 unsigned int ndim = fFitFunc->NDim();; 532 unsigned int npar = fFitFunc->NPar();; 533 ; 534 std::vector<double> xpoint(ndim);; 535 std::vector<double> grad(npar);; 536 std::vector<double> vsum(npar);; 537 ; 538 // loop on the points; 539 for (unsigned int ipoint = 0; ipoint < n; ++ipoint) {; 540 ; 541 for (unsigned int kdim = 0; kdim < ndim; ++kdim) {; 542 unsigned int i = ipoint * stride1 + kdim * stride2;; 543 assert",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:19487,Testability,assert,assert,19487,"s must match the dimension of the fit function; 511 // confidence intervals are returned in array ci; 512 ; 513 if (!fFitFunc) {; 514 // check if model function exists; 515 MATH_ERROR_MSG(""FitResult::GetConfidenceIntervals"",""Cannot compute Confidence Intervals without fit model function"");; 516 return;; 517 }; 518 assert(fFitFunc);; 519 ; 520 // use student quantile in case of normalized errors; 521 double corrFactor = 1;; 522 if (fChi2 <= 0 || fNdf == 0) norm = false;; 523 if (norm); 524 corrFactor = TMath::StudentQuantile(0.5 + cl/2, fNdf) * std::sqrt( fChi2/fNdf );; 525 else; 526 // correction to apply to the errors given a CL different than 1 sigma (cl=0.683); 527 corrFactor = ROOT::Math::normal_quantile(0.5 + cl/2, 1);; 528 ; 529 ; 530 ; 531 unsigned int ndim = fFitFunc->NDim();; 532 unsigned int npar = fFitFunc->NPar();; 533 ; 534 std::vector<double> xpoint(ndim);; 535 std::vector<double> grad(npar);; 536 std::vector<double> vsum(npar);; 537 ; 538 // loop on the points; 539 for (unsigned int ipoint = 0; ipoint < n; ++ipoint) {; 540 ; 541 for (unsigned int kdim = 0; kdim < ndim; ++kdim) {; 542 unsigned int i = ipoint * stride1 + kdim * stride2;; 543 assert(i < ndim*n);; 544 xpoint[kdim] = x[i];; 545 }; 546 ; 547 // calculate gradient of fitted function w.r.t the parameters; 548 ROOT::Math::RichardsonDerivator d;; 549 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 550 if (!IsParameterFixed(ipar)) {; 551 ROOT::Math::OneDimParamFunctionAdapter<const ROOT::Math::IParamMultiFunction &> fadapter(*fFitFunc,&xpoint.front(),&fParams.front(),ipar);; 552 d.SetFunction(fadapter);; 553 // compute step size as a small fraction of the error; 554 // (see numerical recipes in C 5.7.8) 1.E-5 is ~ (eps)^1/3; 555 if ( fErrors[ipar] > 0 ); 556 d.SetStepSize( std::max( fErrors[ipar]*1.E-5, 1.E-15) );; 557 else; 558 d.SetStepSize( std::min(std::max(fParams[ipar]*1.E-5, 1.E-15), 0.0001 ) );; 559 ; 560 grad[ipar] = d(fParams[ipar] ); // evaluate df/dp; 561 }; 562 else; 563 grad[ip",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:5310,Usability,clear,clear,5310," from configuration; 131 fParams.resize(npar);; 132 for (unsigned int i = 0; i < npar; ++i ) {; 133 fParams[i] = ( fconfig.ParSettings(i).Value() );; 134 }; 135 }; 136 ; 137 if (sizeOfData > min->NFree() ) fNdf = sizeOfData - min->NFree();; 138 ; 139 ; 140 // set right parameters in function (in case minimizer did not do before); 141 // do also when fit is not valid; 142 if (func ) {; 143 // I think we can avoid cloning the model function; 144 //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; 145 //assert(fFitFunc);; 146 fFitFunc->SetParameters(&fParams.front());; 147 }; 148 else {; 149 // when no fFitFunc is present take parameters from FitConfig; 150 fParNames.resize( npar );; 151 for (unsigned int i = 0; i < npar; ++i ) {; 152 fParNames[i] = fconfig.ParSettings(i).Name();; 153 }; 154 }; 155 ; 156 ; 157 // check for fixed or limited parameters; 158 unsigned int nfree = 0;; 159 if (!fParamBounds.empty()) fParamBounds.clear();; 160 for (unsigned int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:6788,Usability,clear,clear,6788,"ed int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are se",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:6876,Usability,clear,clear,6876," (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are set separately when calling Fitter::CalculateMinosErrors(); 211 ; 212 // globalCC; 213 fGlobalCC.reserve(npar);; 214 for (unsigned int i = 0; i < npar; ++i) {; 215 double globcc = min->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:6924,Usability,clear,clear,6924,"mizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are set separately when calling Fitter::CalculateMinosErrors(); 211 ; 212 // globalCC; 213 fGlobalCC.reserve(npar);; 214 for (unsigned int i = 0; i < npar; ++i) {; 215 double globcc = min->GlobalCC(i);; 216 if (globcc < 0) break; // it is not supported by that minimizer; 217 fGlobalCC.push_back(globcc);; 218 }; 219 ; 220 }; 221 ; 222}; 223 ; 224bool FitResult::Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls) {; 225 // update fit result with new status from minimizer; 226 // ncalls if it is not zero is used instead of value from minimizer; 227 ; 228 fMinimizer = min;; 229 ; 230 // in case minimizer changes; 231 fMinimTy",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8cxx_source.html:9783,Usability,clear,clear,9783," if (fFitFunc) fFitFunc->SetParameters(&fParams.front());; 264 ; 265 if (min->Errors() != nullptr) {; 266 ; 267 if (fErrors.size() != npar) fErrors.resize(npar);; 268 ; 269 std::copy(min->Errors(), min->Errors() + npar, fErrors.begin() ) ;; 270 ; 271 if (fCovStatus != 0) {; 272 ; 273 // update error matrix; 274 unsigned int r = npar * ( npar + 1 )/2;; 275 if (fCovMatrix.size() != r) fCovMatrix.resize(r);; 276 unsigned int l = 0;; 277 for (unsigned int i = 0; i < npar; ++i) {; 278 for (unsigned int j = 0; j <= i; ++j); 279 fCovMatrix[l++] = min->CovMatrix(i,j);; 280 }; 281 }; 282 ; 283 // update global CC; 284 if (fGlobalCC.size() != npar) fGlobalCC.resize(npar);; 285 for (unsigned int i = 0; i < npar; ++i) {; 286 double globcc = min->GlobalCC(i);; 287 if (globcc < 0) {; 288 fGlobalCC.clear();; 289 break; // it is not supported by that minimizer; 290 }; 291 fGlobalCC[i] = globcc;; 292 }; 293 ; 294 }; 295 return true;; 296}; 297 ; 298void FitResult::NormalizeErrors() {; 299 // normalize errors and covariance matrix according to chi2 value; 300 if (fNdf == 0 || fChi2 <= 0) return;; 301 double s2 = fChi2/fNdf;; 302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332do",MatchSource.WIKI,doc/master/FitResult_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html
https://root.cern/doc/master/FitResult_8h_source.html:1164,Availability,error,error,1164,". ROOT: math/mathcore/inc/Fit/FitResult.h Source File. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. FitResult.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Wed Aug 30 11:05:34 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class FitResult; 12 ; 13#ifndef ROOT_Fit_FitResult; 14#define ROOT_Fit_FitResult; 15 ; 16#include ""Math/IFunctionfwd.h""; 17#include ""Math/IParamFunctionfwd.h""; 18 ; 19#include <vector>; 20#include <map>; 21#include <string>; 22#include <cmath>; 23#include <memory>; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 class Minimizer;; 29 }; 30 ; 31 ; 32 namespace Fit {; 33 ; 34 class FitConfig;; 35 class FitData;; 36 class BinData;; 37 ; 38//___________________________________________________________________________________; 39/**; 40 class containing the result of the fit and all the related information; 41 (fitted parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a M",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:3126,Availability,error,error,3126,"sult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same configuration; 85 Note that in this case MINOS is not re-run. If one wants to run also MINOS; 86 a new result must be created; 87 */; 88 bool Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls = 0);; 89 ; 90 /** minimization quantities **/; 91 ; 92 /// minimizer type; 93 const std::string & MinimizerType() const { return fMinimType; }; 94 ; 95 /**; 96 True if fit successful, otherwise false.; 97 A fit is considered successful if the minimizer succeeded in finding the; 98 minimum. It could happen that subsequent operations like error analysis (e.g. Minos); 99 failed. In that case the status can be still true if the original minimization algorithm; 100 succeeded in finding the minimum.; 101 One can query in that case the minimizer return status using Status().; 102 It is responsibility to the Minimizer class to tag a found minimum as valid or not; 103 and to produce also a status code.; 104 */; 105 bool IsValid() const { return fValid; }; 106 ; 107 /// True if a fit result does not exist (even invalid) with parameter values; 108 bool IsEmpty() const { return (fParams.empty()); }; 109 ; 110 /// Return value of the objective function (chi2 or likelihood) used in the fit; 111 double MinFcnValue() const { return fVal; }; 112 ; 113 ///Number of function calls to find minimum; 114 unsigned int NCalls() const { return fNCalls; }; 115 ; 116 ///Expected distance from minimum; 117 double Edm() const { return fEdm; }; 118 ; 119 /// get total number of parameters; 120 unsigned int NTotalParameters() const {",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:5047,Availability,avail,available,5047,"s() const { return fStatus; }; 129 ; 130 ///covariance matrix status code; 131 /// using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate; 132 ; 133 int CovMatrixStatus() const { return fCovStatus; }; 134 ; 135 /** fitting quantities **/; 136 ; 137 /// Return pointer to model (fit) function with fitted parameter values.; 138 /// Pointer is managed internally. I must not be deleted; 139 const IModelFunction * FittedFunction() const {; 140 return fFitFunc.get();; 141 }; 142 ; 143 /// return BinData used in the fit (return a nullptr in case a different fit is done; 144 /// or the data are not available; 145 /// Pointer is managed internally, it must not be deleted; 146 const BinData * FittedBinData() const;; 147 ; 148 ; 149 /// Return the Chi2 value after fitting; 150 /// In case of unbinned fits (or not defined one, see the documentation of Fitter::FitFCN) return -1; 151 /// In case of binned likelihood fits (Poisson Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:5720,Availability,error,errors,5720,"s() const { return fStatus; }; 129 ; 130 ///covariance matrix status code; 131 /// using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate; 132 ; 133 int CovMatrixStatus() const { return fCovStatus; }; 134 ; 135 /** fitting quantities **/; 136 ; 137 /// Return pointer to model (fit) function with fitted parameter values.; 138 /// Pointer is managed internally. I must not be deleted; 139 const IModelFunction * FittedFunction() const {; 140 return fFitFunc.get();; 141 }; 142 ; 143 /// return BinData used in the fit (return a nullptr in case a different fit is done; 144 /// or the data are not available; 145 /// Pointer is managed internally, it must not be deleted; 146 const BinData * FittedBinData() const;; 147 ; 148 ; 149 /// Return the Chi2 value after fitting; 150 /// In case of unbinned fits (or not defined one, see the documentation of Fitter::FitFCN) return -1; 151 /// In case of binned likelihood fits (Poisson Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:5834,Availability,error,errors,5834,"s() const { return fStatus; }; 129 ; 130 ///covariance matrix status code; 131 /// using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate; 132 ; 133 int CovMatrixStatus() const { return fCovStatus; }; 134 ; 135 /** fitting quantities **/; 136 ; 137 /// Return pointer to model (fit) function with fitted parameter values.; 138 /// Pointer is managed internally. I must not be deleted; 139 const IModelFunction * FittedFunction() const {; 140 return fFitFunc.get();; 141 }; 142 ; 143 /// return BinData used in the fit (return a nullptr in case a different fit is done; 144 /// or the data are not available; 145 /// Pointer is managed internally, it must not be deleted; 146 const BinData * FittedBinData() const;; 147 ; 148 ; 149 /// Return the Chi2 value after fitting; 150 /// In case of unbinned fits (or not defined one, see the documentation of Fitter::FitFCN) return -1; 151 /// In case of binned likelihood fits (Poisson Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:6429,Availability,error,error,6429,"n Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176 /// parameter error by index; 177 // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; 178 // inherits from TObject. Use instead ParError (or Errors()[i] ); 179 double Error(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(do",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:6725,Availability,error,error,6725,"ctor); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176 /// parameter error by index; 177 // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; 178 // inherits from TObject. Use instead ParError (or Errors()[i] ); 179 double Error(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the p",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:6958,Availability,error,errors,6958,"n &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176 /// parameter error by index; 177 // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; 178 // inherits from TObject. Use instead ParError (or Errors()[i] ); 179 double Error(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty())",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:7461,Availability,error,error,7461,"n &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176 /// parameter error by index; 177 // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; 178 // inherits from TObject. Use instead ParError (or Errors()[i] ); 179 double Error(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty())",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:7541,Availability,error,error,7541,"n &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176 /// parameter error by index; 177 // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; 178 // inherits from TObject. Use instead ParError (or Errors()[i] ); 179 double Error(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty())",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:7606,Availability,error,error,7606,"ror(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-val",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:7685,Availability,error,error,7685,"ror(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-val",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:7750,Availability,error,error,7750,"size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 228 double tmp = CovMatrix(i,i)*CovMatrix(j,j);; 229 return ( tmp > 0) ? CovMatrix(i,j)/ std::sqrt(tmp) : 0;; 230 }; 231 ; 232 /// fill covariance matrix elements using a generic matr",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:8206,Availability,avail,available,8206,"he FitResult class; 197 void SetChi2AndNdf(double chi2, unsigned int npoints);; 198 ; 199 /// query if parameter i has the Minos error; 200 bool HasMinosError(unsigned int i) const;; 201 ; 202 /// lower Minos error. If Minos has not run for parameter i return the parabolic error; 203 double LowerError(unsigned int i) const;; 204 ; 205 /// upper Minos error. If Minos has not run for parameter i return the parabolic error; 206 double UpperError(unsigned int i) const;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 228 double tmp = CovMatrix(i,i)*CovMatrix(j,j);; 229 return ( tmp > 0) ? CovMatrix(i,j)/ std::sqrt(tmp) : 0;; 230 }; 231 ; 232 /// fill covariance matrix elements using a generic matrix class implementing operator(i,j); 233 /// the matrix must be previously allocates with right size (npar * npar); 234 template<class Matrix>; 235 void GetCovarianceMatrix(Matrix & mat) const {; 236 unsigned int npar = fErrors.size();; 237 if (fCovMatrix.size() != npar*(npar+1)/2 ) return; // do nothing; 238 for (unsigned int i = 0; i< npar; ++i) {; 239 for (unsigned int j = 0; j<=i; ++j) {; 240 mat(i,j) = fCovMatrix[j + i*(i+1)/2 ];; 241 if (i != j) mat(j,i) = mat(i,j);; 242 }; 243 }; 244 }; 245 ; 246 /// fill a co",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:8591,Availability,avail,available,8591,"nst;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 228 double tmp = CovMatrix(i,i)*CovMatrix(j,j);; 229 return ( tmp > 0) ? CovMatrix(i,j)/ std::sqrt(tmp) : 0;; 230 }; 231 ; 232 /// fill covariance matrix elements using a generic matrix class implementing operator(i,j); 233 /// the matrix must be previously allocates with right size (npar * npar); 234 template<class Matrix>; 235 void GetCovarianceMatrix(Matrix & mat) const {; 236 unsigned int npar = fErrors.size();; 237 if (fCovMatrix.size() != npar*(npar+1)/2 ) return; // do nothing; 238 for (unsigned int i = 0; i< npar; ++i) {; 239 for (unsigned int j = 0; j<=i; ++j) {; 240 mat(i,j) = fCovMatrix[j + i*(i+1)/2 ];; 241 if (i != j) mat(j,i) = mat(i,j);; 242 }; 243 }; 244 }; 245 ; 246 /// fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); 247 /// the matrix must be previously allocates with right size (npar * npar); 248 template<class Matrix>; 249 void GetCorrelationMatrix(Matrix & mat) const {; 250 unsigned int npar = fErrors.size();; 251 if (fCovMatrix.size() != npar*(npar+1)/2) return; // do nothing; 252 for (unsigned int i = 0; i< npar; ++i) {; 253 for (unsigned int j = 0; j<=i; ++j) {; 254 double tm",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:12260,Availability,error,errors,12260,"ool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin = 0, double xmax = 0);; 294 ; 295 /**; 296 create contour of two parameters around the minimum; 297 pass as option confidence level: default is a value of 0.683; 298 */; 299 bool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel = 0.683);; 300 ; 301 /// get index for parameter name (return -1 if not found); 302 int Index(const std::string & name) const;; 303 ; 304 ///normalize errors using chi2/ndf for chi2 fits; 305 void NormalizeErrors();; 306 ; 307 /// flag to check if errors are normalized; 308 bool NormalizedErrors() const { return fNormalized; }; 309 ; 310 /// print the result and optionally covariance matrix and correlations; 311 void Print(std::ostream & os, bool covmat = false) const;; 312 ; 313 ///print error matrix and correlations; 314 void PrintCovMatrix(std::ostream & os) const;; 315 ; 316 /// query if a parameter is bound; 317 bool IsParameterBound(unsigned int ipar) const;; 318 ; 319 /// query if a parameter is fixed; 320 bool IsParameterFixed(unsigned int ipar) const;; 321 ; 322 /// retrieve parameter bounds - return false if parameter is not bound; 323 bool ParameterBounds(unsigned int ipar, double &lower, double &upper) const;; 324 ; 325 ; 326 /// get name of parameter (deprecated); 327 std::string GetParameterName(unsigned int ipar) const {; 328 return ParName(ipar);; 329 }; 330 ; 331 ; 332protected:; 333 ; 334 ; 335 /// Return pointer non const pointer to model (fit) function with fitted parameter values.; 336 /// used by Fitter class; 337 std::shared_ptr<IModelFunction> ModelFunction() { return fFitFunc; }; 338 void SetModelFunction(const std::shared_ptr<IModelFunction> & func) { fFitFunc = func; }; 339 ; 340 friend class Fitter;; 341 ; 342 ; 343 bool fValid; ///< flag for indicating valid fit; 344 bool fNormalized; ///< flag for indicating is errors are normalized; 345 unsigned int fNFre",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:12357,Availability,error,errors,12357,"ool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin = 0, double xmax = 0);; 294 ; 295 /**; 296 create contour of two parameters around the minimum; 297 pass as option confidence level: default is a value of 0.683; 298 */; 299 bool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel = 0.683);; 300 ; 301 /// get index for parameter name (return -1 if not found); 302 int Index(const std::string & name) const;; 303 ; 304 ///normalize errors using chi2/ndf for chi2 fits; 305 void NormalizeErrors();; 306 ; 307 /// flag to check if errors are normalized; 308 bool NormalizedErrors() const { return fNormalized; }; 309 ; 310 /// print the result and optionally covariance matrix and correlations; 311 void Print(std::ostream & os, bool covmat = false) const;; 312 ; 313 ///print error matrix and correlations; 314 void PrintCovMatrix(std::ostream & os) const;; 315 ; 316 /// query if a parameter is bound; 317 bool IsParameterBound(unsigned int ipar) const;; 318 ; 319 /// query if a parameter is fixed; 320 bool IsParameterFixed(unsigned int ipar) const;; 321 ; 322 /// retrieve parameter bounds - return false if parameter is not bound; 323 bool ParameterBounds(unsigned int ipar, double &lower, double &upper) const;; 324 ; 325 ; 326 /// get name of parameter (deprecated); 327 std::string GetParameterName(unsigned int ipar) const {; 328 return ParName(ipar);; 329 }; 330 ; 331 ; 332protected:; 333 ; 334 ; 335 /// Return pointer non const pointer to model (fit) function with fitted parameter values.; 336 /// used by Fitter class; 337 std::shared_ptr<IModelFunction> ModelFunction() { return fFitFunc; }; 338 void SetModelFunction(const std::shared_ptr<IModelFunction> & func) { fFitFunc = func; }; 339 ; 340 friend class Fitter;; 341 ; 342 ; 343 bool fValid; ///< flag for indicating valid fit; 344 bool fNormalized; ///< flag for indicating is errors are normalized; 345 unsigned int fNFre",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:12603,Availability,error,error,12603,"ool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin = 0, double xmax = 0);; 294 ; 295 /**; 296 create contour of two parameters around the minimum; 297 pass as option confidence level: default is a value of 0.683; 298 */; 299 bool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel = 0.683);; 300 ; 301 /// get index for parameter name (return -1 if not found); 302 int Index(const std::string & name) const;; 303 ; 304 ///normalize errors using chi2/ndf for chi2 fits; 305 void NormalizeErrors();; 306 ; 307 /// flag to check if errors are normalized; 308 bool NormalizedErrors() const { return fNormalized; }; 309 ; 310 /// print the result and optionally covariance matrix and correlations; 311 void Print(std::ostream & os, bool covmat = false) const;; 312 ; 313 ///print error matrix and correlations; 314 void PrintCovMatrix(std::ostream & os) const;; 315 ; 316 /// query if a parameter is bound; 317 bool IsParameterBound(unsigned int ipar) const;; 318 ; 319 /// query if a parameter is fixed; 320 bool IsParameterFixed(unsigned int ipar) const;; 321 ; 322 /// retrieve parameter bounds - return false if parameter is not bound; 323 bool ParameterBounds(unsigned int ipar, double &lower, double &upper) const;; 324 ; 325 ; 326 /// get name of parameter (deprecated); 327 std::string GetParameterName(unsigned int ipar) const {; 328 return ParName(ipar);; 329 }; 330 ; 331 ; 332protected:; 333 ; 334 ; 335 /// Return pointer non const pointer to model (fit) function with fitted parameter values.; 336 /// used by Fitter class; 337 std::shared_ptr<IModelFunction> ModelFunction() { return fFitFunc; }; 338 void SetModelFunction(const std::shared_ptr<IModelFunction> & func) { fFitFunc = func; }; 339 ; 340 friend class Fitter;; 341 ; 342 ; 343 bool fValid; ///< flag for indicating valid fit; 344 bool fNormalized; ///< flag for indicating is errors are normalized; 345 unsigned int fNFre",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:13676,Availability,error,errors,13676," bounds - return false if parameter is not bound; 323 bool ParameterBounds(unsigned int ipar, double &lower, double &upper) const;; 324 ; 325 ; 326 /// get name of parameter (deprecated); 327 std::string GetParameterName(unsigned int ipar) const {; 328 return ParName(ipar);; 329 }; 330 ; 331 ; 332protected:; 333 ; 334 ; 335 /// Return pointer non const pointer to model (fit) function with fitted parameter values.; 336 /// used by Fitter class; 337 std::shared_ptr<IModelFunction> ModelFunction() { return fFitFunc; }; 338 void SetModelFunction(const std::shared_ptr<IModelFunction> & func) { fFitFunc = func; }; 339 ; 340 friend class Fitter;; 341 ; 342 ; 343 bool fValid; ///< flag for indicating valid fit; 344 bool fNormalized; ///< flag for indicating is errors are normalized; 345 unsigned int fNFree; ///< number of fit free parameters (total parameters are in size of parameter vector); 346 unsigned int fNdf; ///< number of degree of freedom; 347 unsigned int fNCalls; ///< number of function calls; 348 int fStatus; ///< minimizer status code; 349 int fCovStatus; ///< covariance matrix status code; 350 double fVal; ///< minimum function value; 351 double fEdm; ///< expected distance from minimum; 352 double fChi2; ///< fit chi2 value (different than fval in case of chi2 fits); 353 std::shared_ptr<ROOT::Math::Minimizer> fMinimizer; ///<! minimizer object used for fitting; 354 std::shared_ptr<ROOT::Math::IMultiGenFunction> fObjFunc; ///<! objective function used for fitting; 355 std::shared_ptr<IModelFunction> fFitFunc; ///<! model function resulting from the fit.; 356 std::shared_ptr<FitData> fFitData; ///<! data set used in the fit; 357 std::map<unsigned int, bool> fFixedParams; ///< list of fixed parameters; 358 std::map<unsigned int, unsigned int> fBoundParams; ///< list of limited parameters; 359 std::vector<std::pair<double,double> > fParamBounds; ///< parameter bounds; 360 std::vector<double> fParams; ///< parameter values. Size is total number of parameters; 361 s",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:14947,Availability,error,errors,14947,"::Math::Minimizer> fMinimizer; ///<! minimizer object used for fitting; 354 std::shared_ptr<ROOT::Math::IMultiGenFunction> fObjFunc; ///<! objective function used for fitting; 355 std::shared_ptr<IModelFunction> fFitFunc; ///<! model function resulting from the fit.; 356 std::shared_ptr<FitData> fFitData; ///<! data set used in the fit; 357 std::map<unsigned int, bool> fFixedParams; ///< list of fixed parameters; 358 std::map<unsigned int, unsigned int> fBoundParams; ///< list of limited parameters; 359 std::vector<std::pair<double,double> > fParamBounds; ///< parameter bounds; 360 std::vector<double> fParams; ///< parameter values. Size is total number of parameters; 361 std::vector<double> fErrors; ///< errors; 362 std::vector<double> fCovMatrix; ///< covariance matrix (size is npar*(npar+1)/2) where npar is total parameters; 363 std::vector<double> fGlobalCC; ///< global Correlation coefficient; 364 std::map<unsigned int, std::pair<double,double> > fMinosErrors; ///< map contains the two Minos errors; 365 std::string fMinimType; ///< string indicating type of minimizer; 366 std::vector<std::string> fParNames; ///< parameter names (only with FCN only fits, when fFitFunc=0); 367 ; 368};; 369 ; 370 ; 371 } // end namespace Fit; 372 ; 373} // end namespace ROOT; 374 ; 375 ; 376 ; 377 ; 378 ; 379#endif /* ROOT_Fit_FitResult */; IFunctionfwd.h; IParamFunctionfwd.h; f#define f(i)Definition RSha256.hxx:104; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter se",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:15244,Availability,error,errors,15244,"::Math::Minimizer> fMinimizer; ///<! minimizer object used for fitting; 354 std::shared_ptr<ROOT::Math::IMultiGenFunction> fObjFunc; ///<! objective function used for fitting; 355 std::shared_ptr<IModelFunction> fFitFunc; ///<! model function resulting from the fit.; 356 std::shared_ptr<FitData> fFitData; ///<! data set used in the fit; 357 std::map<unsigned int, bool> fFixedParams; ///< list of fixed parameters; 358 std::map<unsigned int, unsigned int> fBoundParams; ///< list of limited parameters; 359 std::vector<std::pair<double,double> > fParamBounds; ///< parameter bounds; 360 std::vector<double> fParams; ///< parameter values. Size is total number of parameters; 361 std::vector<double> fErrors; ///< errors; 362 std::vector<double> fCovMatrix; ///< covariance matrix (size is npar*(npar+1)/2) where npar is total parameters; 363 std::vector<double> fGlobalCC; ///< global Correlation coefficient; 364 std::map<unsigned int, std::pair<double,double> > fMinosErrors; ///< map contains the two Minos errors; 365 std::string fMinimType; ///< string indicating type of minimizer; 366 std::vector<std::string> fParNames; ///< parameter names (only with FCN only fits, when fFitFunc=0); 367 ; 368};; 369 ; 370 ; 371 } // end namespace Fit; 372 ; 373} // end namespace ROOT; 374 ; 375 ; 376 ; 377 ; 378 ; 379#endif /* ROOT_Fit_FitResult */; IFunctionfwd.h; IParamFunctionfwd.h; f#define f(i)Definition RSha256.hxx:104; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter se",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:16103,Availability,error,error,16103,"is total parameters; 363 std::vector<double> fGlobalCC; ///< global Correlation coefficient; 364 std::map<unsigned int, std::pair<double,double> > fMinosErrors; ///< map contains the two Minos errors; 365 std::string fMinimType; ///< string indicating type of minimizer; 366 std::vector<std::string> fParNames; ///< parameter names (only with FCN only fits, when fFitFunc=0); 367 ; 368};; 369 ; 370 ; 371 } // end namespace Fit; 372 ; 373} // end namespace ROOT; 374 ; 375 ; 376 ; 377 ; 378 ; 379#endif /* ROOT_Fit_FitResult */; IFunctionfwd.h; IParamFunctionfwd.h; f#define f(i)Definition RSha256.hxx:104; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::IsValidbool IsValid() constTrue if fit successful, otherwise false.Definition FitResult.h:105; ROOT::Fit::FitResult::IsEmptybool IsEmpty() constTrue if a fit result does not exist (even invalid) with parameter values.Definition FitResult.h:108; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free parameters (total parameters are in size of parameter vector)Definition FitResult.h:345; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:17403,Availability,error,error,17403,"mation (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::IsValidbool IsValid() constTrue if fit successful, otherwise false.Definition FitResult.h:105; ROOT::Fit::FitResult::IsEmptybool IsEmpty() constTrue if a fit result does not exist (even invalid) with parameter values.Definition FitResult.h:108; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free parameters (total parameters are in size of parameter vector)Definition FitResult.h:345; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn BinData used in the fit (return a nullptr in case a different fit is done or the data are not ...Definition FitResult.cxx:631; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::NormalizedErrors",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:17966,Availability,error,error,17966,"e in size of parameter vector)Definition FitResult.h:345; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn BinData used in the fit (return a nullptr in case a different fit is done or the data are not ...Definition FitResult.cxx:631; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::NormalizedErrorsbool NormalizedErrors() constflag to check if errors are normalizedDefinition FitResult.h:308; ROOT::Fit::FitResult::Errorsconst std::vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::GetErrorsconst double * GetErrors() constparameter errors (return const pointer)Definition FitResult.h:164; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fVali",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:18031,Availability,error,errorDefinition,18031,"sstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn BinData used in the fit (return a nullptr in case a different fit is done or the data are not ...Definition FitResult.cxx:631; ROOT::Fit::FitResult::ParErrordouble ParError(unsigned int i) constparameter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::NormalizedErrorsbool NormalizedErrors() constflag to check if errors are normalizedDefinition FitResult.h:308; ROOT::Fit::FitResult::Errorsconst std::vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::GetErrorsconst double * GetErrors() constparameter errors (return const pointer)Definition FitResult.h:164; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterF",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:18424,Availability,error,errors,18424,"ter error by indexDefinition FitResult.h:183; ROOT::Fit::FitResult::FillResultvoid FillResult(const std::shared_ptr< ROOT::Math::Minimizer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::NormalizedErrorsbool NormalizedErrors() constflag to check if errors are normalizedDefinition FitResult.h:308; ROOT::Fit::FitResult::Errorsconst std::vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::GetErrorsconst double * GetErrors() constparameter errors (return const pointer)Definition FitResult.h:164; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::GetParamsconst double * GetParams() constparameter values (return const pointer)Definition FitResult.h:169; ROOT::Fit::FitResult::IModelFunctionROOT::Math::",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:18555,Availability,error,errors,18555,"zer > &min, const FitConfig &fconfig, const std::shared_ptr< IModelFunction > &f, bool isValid, unsigned int sizeOfData=0, int fitType=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::NormalizedErrorsbool NormalizedErrors() constflag to check if errors are normalizedDefinition FitResult.h:308; ROOT::Fit::FitResult::Errorsconst std::vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::GetErrorsconst double * GetErrors() constparameter errors (return const pointer)Definition FitResult.h:164; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::GetParamsconst double * GetParams() constparameter values (return const pointer)Definition FitResult.h:169; ROOT::Fit::FitResult::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition FitResult.h:51; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter er",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:18682,Availability,error,errors,18682,"e=1, const ROOT::Math::IMultiGenFunction *chi2func=nullptr, unsigned int ncalls=0)Fill the fit result from a Minimizer instance after fitting Run also Minos if requested from the conf...Definition FitResult.cxx:100; ROOT::Fit::FitResult::UpperErrordouble UpperError(unsigned int i) constupper Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:339; ROOT::Fit::FitResult::fValdouble fValminimum function valueDefinition FitResult.h:350; ROOT::Fit::FitResult::fEdmdouble fEdmexpected distance from minimumDefinition FitResult.h:351; ROOT::Fit::FitResult::fErrorsstd::vector< double > fErrorserrorsDefinition FitResult.h:361; ROOT::Fit::FitResult::NormalizedErrorsbool NormalizedErrors() constflag to check if errors are normalizedDefinition FitResult.h:308; ROOT::Fit::FitResult::Errorsconst std::vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::GetErrorsconst double * GetErrors() constparameter errors (return const pointer)Definition FitResult.h:164; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::GetParamsconst double * GetParams() constparameter values (return const pointer)Definition FitResult.h:169; ROOT::Fit::FitResult::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition FitResult.h:51; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitResult.h:179; ROOT::Fit::FitResult::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) constretrieve",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:19532,Availability,error,error,19532,":vector< double > & Errors() constparameter errors (return st::vector)Definition FitResult.h:162; ROOT::Fit::FitResult::GetErrorsconst double * GetErrors() constparameter errors (return const pointer)Definition FitResult.h:164; ROOT::Fit::FitResult::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! minimizer object used for fittingDefinition FitResult.h:353; ROOT::Fit::FitResult::fValidbool fValidflag for indicating valid fitDefinition FitResult.h:343; ROOT::Fit::FitResult::IsParameterFixedbool IsParameterFixed(unsigned int ipar) constquery if a parameter is fixedDefinition FitResult.cxx:365; ROOT::Fit::FitResult::fNdfunsigned int fNdfnumber of degree of freedomDefinition FitResult.h:346; ROOT::Fit::FitResult::GetParamsconst double * GetParams() constparameter values (return const pointer)Definition FitResult.h:169; ROOT::Fit::FitResult::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition FitResult.h:51; ROOT::Fit::FitResult::Errordouble Error(unsigned int i) constparameter error by indexDefinition FitResult.h:179; ROOT::Fit::FitResult::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) constretrieve covariance matrix elementDefinition FitResult.h:215; ROOT::Fit::FitResult::GetConfidenceIntervalsvoid GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) constget confidence intervals for an array of n points x.Definition FitResult.cxx:506; ROOT::Fit::FitResult::Valuedouble Value(unsigned int i) constparameter value by indexDefinition FitResult.h:172; ROOT::Fit::FitResult::fCovStatusint fCovStatuscovariance matrix status codeDefinition FitResult.h:349; ROOT::Fit::FitResult::Scanbool Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin=0, double xmax=0)scan likelihood value of parameter and fill the given graph.Definition FitResult.cxx:639; ROOT::Fit::FitResult::Parametersconst std::vector< double > & Para",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:22017,Availability,error,errors,22017,"string GetParameterName(unsigned int ipar) constget name of parameter (deprecated)Definition FitResult.h:327; ROOT::Fit::FitResult::ParameterBoundsbool ParameterBounds(unsigned int ipar, double &lower, double &upper) constretrieve parameter bounds - return false if parameter is not boundDefinition FitResult.cxx:369; ROOT::Fit::FitResult::Ndfunsigned int Ndf() constNumber of degree of freedom.Definition FitResult.h:156; ROOT::Fit::FitResult::Chi2double Chi2() constReturn the Chi2 value after fitting In case of unbinned fits (or not defined one, see the documentati...Definition FitResult.h:153; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::~FitResultvirtual ~FitResult()Destructor.Definition FitResult.h:69; ROOT::Fit::FitResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:3",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:22376,Availability,error,error,22376,":FitResult::Ndfunsigned int Ndf() constNumber of degree of freedom.Definition FitResult.h:156; ROOT::Fit::FitResult::Chi2double Chi2() constReturn the Chi2 value after fitting In case of unbinned fits (or not defined one, see the documentati...Definition FitResult.h:153; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::~FitResultvirtual ~FitResult()Destructor.Definition FitResult.h:69; ROOT::Fit::FitResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::GetCorrelati",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:22441,Availability,error,errorDefinition,22441,"56; ROOT::Fit::FitResult::Chi2double Chi2() constReturn the Chi2 value after fitting In case of unbinned fits (or not defined one, see the documentati...Definition FitResult.h:153; ROOT::Fit::FitResult::fParamsstd::vector< double > fParamsparameter values. Size is total number of parametersDefinition FitResult.h:360; ROOT::Fit::FitResult::fCovMatrixstd::vector< double > fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::~FitResultvirtual ~FitResult()Destructor.Definition FitResult.h:69; ROOT::Fit::FitResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::GetCorrelationMatrixvoid GetCorrelationMatrix(Matrix &mat) constfill a correlation matrix elements using",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:22849,Availability,error,error,22849,"ze is npar*(npar+1)/2) where npar is total parametersDefinition FitResult.h:362; ROOT::Fit::FitResult::SetMinosErrorvoid SetMinosError(unsigned int i, double elow, double eup)set the Minos errors for parameter i (called by the Fitter class when running Minos)Definition FitResult.cxx:346; ROOT::Fit::FitResult::Printvoid Print(std::ostream &os, bool covmat=false) constprint the result and optionally covariance matrix and correlationsDefinition FitResult.cxx:389; ROOT::Fit::FitResult::LowerErrordouble LowerError(unsigned int i) constlower Minos error. If Minos has not run for parameter i return the parabolic errorDefinition FitResult.cxx:332; ROOT::Fit::FitResult::~FitResultvirtual ~FitResult()Destructor.Definition FitResult.h:69; ROOT::Fit::FitResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::GetCorrelationMatrixvoid GetCorrelationMatrix(Matrix &mat) constfill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,...Definition FitResult.h:249; ROOT::Fit::FitResult::HasMinosErrorbool HasMinosError(unsigned int i) constquery if parameter i has the Minos errorDefinition FitResult.cxx:325; ROOT::Fit::FitResult::fParamBoundsstd::vector< std::pair< double, double > > fParamBoundsparameter boundsDefinition FitResult.h:359; ROOT::Fit::FitResult::fStatusint fSt",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:23624,Availability,error,errorDefinition,23624,"itResult::ModelFunctionstd::shared_ptr< IModelFunction > ModelFunction()Return pointer non const pointer to model (fit) function with fitted parameter values.Definition FitResult.h:337; ROOT::Fit::FitResult::PrintCovMatrixvoid PrintCovMatrix(std::ostream &os) constprint error matrix and correlationsDefinition FitResult.cxx:447; ROOT::Fit::FitResult::fNCallsunsigned int fNCallsnumber of function callsDefinition FitResult.h:347; ROOT::Fit::FitResult::Contourbool Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel=0.683)create contour of two parameters around the minimum pass as option confidence level: default is a val...Definition FitResult.cxx:660; ROOT::Fit::FitResult::GetCorrelationMatrixvoid GetCorrelationMatrix(Matrix &mat) constfill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,...Definition FitResult.h:249; ROOT::Fit::FitResult::HasMinosErrorbool HasMinosError(unsigned int i) constquery if parameter i has the Minos errorDefinition FitResult.cxx:325; ROOT::Fit::FitResult::fParamBoundsstd::vector< std::pair< double, double > > fParamBoundsparameter boundsDefinition FitResult.h:359; ROOT::Fit::FitResult::fStatusint fStatusminimizer status codeDefinition FitResult.h:348; ROOT::Fit::FitResult::MinFcnValuedouble MinFcnValue() constReturn value of the objective function (chi2 or likelihood) used in the fit.Definition FitResult.h:111; ROOT::Fit::FitResult::NParunsigned int NPar() consttotal number of parameters (abbreviation)Definition FitResult.h:122; ROOT::Fit::FitResult::CovMatrixStatusint CovMatrixStatus() constcovariance matrix status code using Minuit convention : =0 not calculated, =1 approximated,...Definition FitResult.h:133; ROOT::Fit::FitResult::fChi2double fChi2fit chi2 value (different than fval in case of chi2 fits)Definition FitResult.h:352; ROOT::Fit::FitResult::Edmdouble Edm() constExpected distance from minimum.Definition FitResult.h:117; ROO",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:26019,Availability,error,errors,26019,"() constNumber of function calls to find minimum.Definition FitResult.h:114; ROOT::Fit::FitResult::Correlationdouble Correlation(unsigned int i, unsigned int j) constretrieve correlation elementsDefinition FitResult.h:225; ROOT::Fit::FitResult::fObjFuncstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunc! objective function used for fittingDefinition FitResult.h:354; ROOT::Fit::FitResult::NTotalParametersunsigned int NTotalParameters() constget total number of parametersDefinition FitResult.h:120; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitResult::ParNamestd::string ParName(unsigned int i) constname of the parameterDefinition FitResult.cxx:382; ROOT::Fit::FitResult::GetCovarianceMatrixvoid GetCovarianceMatrix(Matrix &mat) constfill covariance matrix elements using a generic matrix class implementing operator(i,...Definition FitResult.h:235; ROOT::Fit::FitResult::NormalizeErrorsvoid NormalizeErrors()normalize errors using chi2/ndf for chi2 fitsDefinition FitResult.cxx:298; ROOT::Fit::FitResult::SetModelFunctionvoid SetModelFunction(const std::shared_ptr< IModelFunction > &func)Definition FitResult.h:338; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::fNormalizedbool fNormalizedflag for indicating is errors are normalizedDefinition FitResult.h:344; ROOT::Fit::FitResult::IsParameterBoundbool IsParameterBound(unsigned int ipar) constquery if a parameter is boundDefinition FitResult.cxx:361; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitResult::Statusint Status() constminimizer status codeDefinition FitResult.h:128; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:26426,Availability,error,errors,26426,"TotalParametersunsigned int NTotalParameters() constget total number of parametersDefinition FitResult.h:120; ROOT::Fit::FitResult::Probdouble Prob() constp value of the fit (chi2 probability)Definition FitResult.cxx:320; ROOT::Fit::FitResult::ParNamestd::string ParName(unsigned int i) constname of the parameterDefinition FitResult.cxx:382; ROOT::Fit::FitResult::GetCovarianceMatrixvoid GetCovarianceMatrix(Matrix &mat) constfill covariance matrix elements using a generic matrix class implementing operator(i,...Definition FitResult.h:235; ROOT::Fit::FitResult::NormalizeErrorsvoid NormalizeErrors()normalize errors using chi2/ndf for chi2 fitsDefinition FitResult.cxx:298; ROOT::Fit::FitResult::SetModelFunctionvoid SetModelFunction(const std::shared_ptr< IModelFunction > &func)Definition FitResult.h:338; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::fNormalizedbool fNormalizedflag for indicating is errors are normalizedDefinition FitResult.h:344; ROOT::Fit::FitResult::IsParameterBoundbool IsParameterBound(unsigned int ipar) constquery if a parameter is boundDefinition FitResult.cxx:361; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitResult::Statusint Status() constminimizer status codeDefinition FitResult.h:128; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::FitResult::FittedFunctionco",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:27114,Availability,error,errorsDefinition,27114,"tion FitResult.cxx:298; ROOT::Fit::FitResult::SetModelFunctionvoid SetModelFunction(const std::shared_ptr< IModelFunction > &func)Definition FitResult.h:338; ROOT::Fit::FitResult::NFreeParametersunsigned int NFreeParameters() constget total number of free parametersDefinition FitResult.h:125; ROOT::Fit::FitResult::fNormalizedbool fNormalizedflag for indicating is errors are normalizedDefinition FitResult.h:344; ROOT::Fit::FitResult::IsParameterBoundbool IsParameterBound(unsigned int ipar) constquery if a parameter is boundDefinition FitResult.cxx:361; ROOT::Fit::FitResult::Parameterdouble Parameter(unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitResult::Statusint Status() constminimizer status codeDefinition FitResult.h:128; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::FitResult::FittedFunctionconst IModelFunction * FittedFunction() constfitting quantitiesDefinition FitResult.h:139; ROOT::Fit::FitResult::GlobalCCdouble GlobalCC(unsigned int i) constparameter global correlation coefficientDefinition FitResult.h:209; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; TMatrixT< Double_t >; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; xDouble_t x[n]D",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:2074,Deployability,configurat,configuration,2074,"parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a Minimizer instance after fitting; 76 Run also Minos if requested from the configuration; 77 */; 78 void FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same configuration; 85 Note that in this case MINOS is not re-run. If one wants to run also MINOS; 86 a new result must be created; 87 */; 88 bool Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls = 0);; 89 ; 90 /** minimization quantities **/; 91 ; 92 /// minimizer type; 93 const std::string & MinimizerType() const { return fMinimType; }; 94 ; 95 /**; 96 True if fit successful, otherwise false.; 97 A fit is considered successful if the minimizer succeeded in finding the; 98 minimum. It could happen that subsequent operations like error analysis (e.g.",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:2513,Deployability,configurat,configuration,2513,"parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a Minimizer instance after fitting; 76 Run also Minos if requested from the configuration; 77 */; 78 void FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same configuration; 85 Note that in this case MINOS is not re-run. If one wants to run also MINOS; 86 a new result must be created; 87 */; 88 bool Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls = 0);; 89 ; 90 /** minimization quantities **/; 91 ; 92 /// minimizer type; 93 const std::string & MinimizerType() const { return fMinimType; }; 94 ; 95 /**; 96 True if fit successful, otherwise false.; 97 A fit is considered successful if the minimizer succeeded in finding the; 98 minimum. It could happen that subsequent operations like error analysis (e.g.",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:16183,Deployability,configurat,configuration,16183,"inosErrors; ///< map contains the two Minos errors; 365 std::string fMinimType; ///< string indicating type of minimizer; 366 std::vector<std::string> fParNames; ///< parameter names (only with FCN only fits, when fFitFunc=0); 367 ; 368};; 369 ; 370 ; 371 } // end namespace Fit; 372 ; 373} // end namespace ROOT; 374 ; 375 ; 376 ; 377 ; 378 ; 379#endif /* ROOT_Fit_FitResult */; IFunctionfwd.h; IParamFunctionfwd.h; f#define f(i)Definition RSha256.hxx:104; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::IsValidbool IsValid() constTrue if fit successful, otherwise false.Definition FitResult.h:105; ROOT::Fit::FitResult::IsEmptybool IsEmpty() constTrue if a fit result does not exist (even invalid) with parameter values.Definition FitResult.h:108; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free parameters (total parameters are in size of parameter vector)Definition FitResult.h:345; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn B",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:8886,Energy Efficiency,allocate,allocates,8886,"nst;; 207 ; 208 /// parameter global correlation coefficient; 209 double GlobalCC(unsigned int i) const {; 210 return (i < fGlobalCC.size() ) ? fGlobalCC[i] : -1;; 211 }; 212 ; 213 ; 214 /// retrieve covariance matrix element; 215 double CovMatrix (unsigned int i, unsigned int j) const {; 216 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 217 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 218 if ( j < i ); 219 return fCovMatrix[j + i* (i+1) / 2];; 220 else; 221 return fCovMatrix[i + j* (j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 228 double tmp = CovMatrix(i,i)*CovMatrix(j,j);; 229 return ( tmp > 0) ? CovMatrix(i,j)/ std::sqrt(tmp) : 0;; 230 }; 231 ; 232 /// fill covariance matrix elements using a generic matrix class implementing operator(i,j); 233 /// the matrix must be previously allocates with right size (npar * npar); 234 template<class Matrix>; 235 void GetCovarianceMatrix(Matrix & mat) const {; 236 unsigned int npar = fErrors.size();; 237 if (fCovMatrix.size() != npar*(npar+1)/2 ) return; // do nothing; 238 for (unsigned int i = 0; i< npar; ++i) {; 239 for (unsigned int j = 0; j<=i; ++j) {; 240 mat(i,j) = fCovMatrix[j + i*(i+1)/2 ];; 241 if (i != j) mat(j,i) = mat(i,j);; 242 }; 243 }; 244 }; 245 ; 246 /// fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); 247 /// the matrix must be previously allocates with right size (npar * npar); 248 template<class Matrix>; 249 void GetCorrelationMatrix(Matrix & mat) const {; 250 unsigned int npar = fErrors.size();; 251 if (fCovMatrix.size() != npar*(npar+1)/2) return; // do nothing; 252 for (unsigned int i = 0; i< npar; ++i) {; 253 for (unsigned int j = 0; j<=i; ++j) {; 254 double tm",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:9464,Energy Efficiency,allocate,allocates,9464,"(j+1) / 2];; 222 }; 223 ; 224 /// retrieve correlation elements; 225 double Correlation(unsigned int i, unsigned int j ) const {; 226 if ( i >= fErrors.size() || j >= fErrors.size() ) return 0;; 227 if (fCovMatrix.empty()) return 0; // no matrix is available in case of non-valid fits; 228 double tmp = CovMatrix(i,i)*CovMatrix(j,j);; 229 return ( tmp > 0) ? CovMatrix(i,j)/ std::sqrt(tmp) : 0;; 230 }; 231 ; 232 /// fill covariance matrix elements using a generic matrix class implementing operator(i,j); 233 /// the matrix must be previously allocates with right size (npar * npar); 234 template<class Matrix>; 235 void GetCovarianceMatrix(Matrix & mat) const {; 236 unsigned int npar = fErrors.size();; 237 if (fCovMatrix.size() != npar*(npar+1)/2 ) return; // do nothing; 238 for (unsigned int i = 0; i< npar; ++i) {; 239 for (unsigned int j = 0; j<=i; ++j) {; 240 mat(i,j) = fCovMatrix[j + i*(i+1)/2 ];; 241 if (i != j) mat(j,i) = mat(i,j);; 242 }; 243 }; 244 }; 245 ; 246 /// fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); 247 /// the matrix must be previously allocates with right size (npar * npar); 248 template<class Matrix>; 249 void GetCorrelationMatrix(Matrix & mat) const {; 250 unsigned int npar = fErrors.size();; 251 if (fCovMatrix.size() != npar*(npar+1)/2) return; // do nothing; 252 for (unsigned int i = 0; i< npar; ++i) {; 253 for (unsigned int j = 0; j<=i; ++j) {; 254 double tmp = fCovMatrix[i * (i +3)/2 ] * fCovMatrix[ j * (j+3)/2 ];; 255 mat(i,j) = (tmp > 0) ? fCovMatrix[j + i*(i+1)/2 ] / std::sqrt(tmp) : 0;; 256 if (i != j) mat(j,i) = mat(i,j);; 257 }; 258 }; 259 }; 260 ; 261 /**; 262 get confidence intervals for an array of n points x.; 263 stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; 264 For 1-dim points : stride1=1, stride2=1; 265 for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; 266 for multi-dim points arranged as (x0,y0,.",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:1686,Modifiability,config,config,1686,"r class FitResult; 12 ; 13#ifndef ROOT_Fit_FitResult; 14#define ROOT_Fit_FitResult; 15 ; 16#include ""Math/IFunctionfwd.h""; 17#include ""Math/IParamFunctionfwd.h""; 18 ; 19#include <vector>; 20#include <map>; 21#include <string>; 22#include <cmath>; 23#include <memory>; 24 ; 25namespace ROOT {; 26 ; 27 namespace Math {; 28 class Minimizer;; 29 }; 30 ; 31 ; 32 namespace Fit {; 33 ; 34 class FitConfig;; 35 class FitData;; 36 class BinData;; 37 ; 38//___________________________________________________________________________________; 39/**; 40 class containing the result of the fit and all the related information; 41 (fitted parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a Minimizer instance after fitting; 76 Run also Minos if requested from the configuration; 77 */; 78 void FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same config",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:2074,Modifiability,config,configuration,2074,"parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a Minimizer instance after fitting; 76 Run also Minos if requested from the configuration; 77 */; 78 void FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same configuration; 85 Note that in this case MINOS is not re-run. If one wants to run also MINOS; 86 a new result must be created; 87 */; 88 bool Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls = 0);; 89 ; 90 /** minimization quantities **/; 91 ; 92 /// minimizer type; 93 const std::string & MinimizerType() const { return fMinimType; }; 94 ; 95 /**; 96 True if fit successful, otherwise false.; 97 A fit is considered successful if the minimizer succeeded in finding the; 98 minimum. It could happen that subsequent operations like error analysis (e.g.",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:2513,Modifiability,config,configuration,2513,"parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a Minimizer instance after fitting; 76 Run also Minos if requested from the configuration; 77 */; 78 void FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same configuration; 85 Note that in this case MINOS is not re-run. If one wants to run also MINOS; 86 a new result must be created; 87 */; 88 bool Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls = 0);; 89 ; 90 /** minimization quantities **/; 91 ; 92 /// minimizer type; 93 const std::string & MinimizerType() const { return fMinimType; }; 94 ; 95 /**; 96 True if fit successful, otherwise false.; 97 A fit is considered successful if the minimizer succeeded in finding the; 98 minimum. It could happen that subsequent operations like error analysis (e.g.",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:6543,Modifiability,inherit,inherits,6543,"n Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176 /// parameter error by index; 177 // (NOTE: this due to conflict with TObject::Error cannot used in derived class which; 178 // inherits from TObject. Use instead ParError (or Errors()[i] ); 179 double Error(unsigned int i) const {; 180 return (i < fErrors.size() ) ? fErrors[i] : 0;; 181 }; 182 /// parameter error by index; 183 double ParError(unsigned int i) const {; 184 return (i < fErrors.size() ) ? fErrors[i] : 0;; 185 }; 186 ; 187 /// name of the parameter; 188 std::string ParName(unsigned int i) const;; 189 ; 190 /// set the Minos errors for parameter i (called by the Fitter class when running Minos); 191 void SetMinosError(unsigned int i, double elow, double eup);; 192 ; 193 /// Set the chi2 and the ndf; 194 /// This function should be called when using an external FCN for fitting; 195 /// and one provides the chi2 and the number of fitting data points) to store; 196 /// and have them printed in the FitResult class; 197 void SetChi2AndNdf(do",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:16183,Modifiability,config,configuration,16183,"inosErrors; ///< map contains the two Minos errors; 365 std::string fMinimType; ///< string indicating type of minimizer; 366 std::vector<std::string> fParNames; ///< parameter names (only with FCN only fits, when fFitFunc=0); 367 ; 368};; 369 ; 370 ; 371 } // end namespace Fit; 372 ; 373} // end namespace ROOT; 374 ; 375 ; 376 ; 377 ; 378 ; 379#endif /* ROOT_Fit_FitResult */; IFunctionfwd.h; IParamFunctionfwd.h; f#define f(i)Definition RSha256.hxx:104; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitResult::fGlobalCCstd::vector< double > fGlobalCCglobal Correlation coefficientDefinition FitResult.h:363; ROOT::Fit::FitResult::IsValidbool IsValid() constTrue if fit successful, otherwise false.Definition FitResult.h:105; ROOT::Fit::FitResult::IsEmptybool IsEmpty() constTrue if a fit result does not exist (even invalid) with parameter values.Definition FitResult.h:108; ROOT::Fit::FitResult::fNFreeunsigned int fNFreenumber of fit free parameters (total parameters are in size of parameter vector)Definition FitResult.h:345; ROOT::Fit::FitResult::fBoundParamsstd::map< unsigned int, unsigned int > fBoundParamslist of limited parametersDefinition FitResult.h:358; ROOT::Fit::FitResult::FittedBinDataconst BinData * FittedBinData() constreturn B",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:2493,Performance,perform,performed,2493,"parameter values, error, covariance matrix and minimizer result information); 42 Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; 43 When the fit is valid, it is constructed from a Minimizer and a model function pointer; 44 ; 45 @ingroup FitMain; 46*/; 47class FitResult {; 48 ; 49public:; 50 ; 51 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 52 ; 53 /**; 54 Default constructor for an empty (non valid) fit result; 55 */; 56 FitResult ();; 57 ; 58 /**; 59 Constructor from a fit-config for a dummy fit; 60 (e.g. when only one fcn evaluation is done); 61 */; 62 FitResult (const FitConfig & fconfig);; 63 ; 64 // default copy constructor and assignment can be used; 65 ; 66 /**; 67 Destructor; 68 */; 69 virtual ~FitResult () {}; 70 ; 71 ; 72public:; 73 ; 74 /**; 75 Fill the fit result from a Minimizer instance after fitting; 76 Run also Minos if requested from the configuration; 77 */; 78 void FillResult(const std::shared_ptr<ROOT::Math::Minimizer> & min, const FitConfig & fconfig, const std::shared_ptr<IModelFunction> & f,; 79 bool isValid, unsigned int sizeOfData = 0, int fitType = 1, const ROOT::Math::IMultiGenFunction *chi2func = nullptr, unsigned int ncalls = 0);; 80 ; 81 ; 82 /**; 83 Update the fit result with a new minimization status; 84 To be run only if same fit is performed with same configuration; 85 Note that in this case MINOS is not re-run. If one wants to run also MINOS; 86 a new result must be created; 87 */; 88 bool Update(const std::shared_ptr<ROOT::Math::Minimizer> & min, const ROOT::Fit::FitConfig & fconfig, bool isValid, unsigned int ncalls = 0);; 89 ; 90 /** minimization quantities **/; 91 ; 92 /// minimizer type; 93 const std::string & MinimizerType() const { return fMinimType; }; 94 ; 95 /**; 96 True if fit successful, otherwise false.; 97 A fit is considered successful if the minimizer succeeded in finding the; 98 minimum. It could happen that subsequent operations like error analysis (e.g.",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:10694,Performance,perform,performed,10694,"249 void GetCorrelationMatrix(Matrix & mat) const {; 250 unsigned int npar = fErrors.size();; 251 if (fCovMatrix.size() != npar*(npar+1)/2) return; // do nothing; 252 for (unsigned int i = 0; i< npar; ++i) {; 253 for (unsigned int j = 0; j<=i; ++j) {; 254 double tmp = fCovMatrix[i * (i +3)/2 ] * fCovMatrix[ j * (j+3)/2 ];; 255 mat(i,j) = (tmp > 0) ? fCovMatrix[j + i*(i+1)/2 ] / std::sqrt(tmp) : 0;; 256 if (i != j) mat(j,i) = mat(i,j);; 257 }; 258 }; 259 }; 260 ; 261 /**; 262 get confidence intervals for an array of n points x.; 263 stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; 264 For 1-dim points : stride1=1, stride2=1; 265 for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; 266 for multi-dim points arranged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1; 267 ; 268 the confidence interval are returned in the array ci; 269 cl is the desired confidence interval value; 270 norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; 271 The intervals can be corrected optionally using the chi2/ndf value of the fit if a chi2 fit is performed.; 272 This has changed since ROOT 6.14, before the interval were corrected by default.; 273 */; 274 void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double * x, double * ci, double cl=0.95, bool norm = false ) const;; 275 ; 276 /**; 277 evaluate confidence interval for the point specified in the passed data sets; 278 the confidence interval are returned in the array ci; 279 cl is the desired confidence interval value.; 280 This method is maintained for backward compatibility and will be deprecated; 281 */; 282 void GetConfidenceIntervals(const BinData & data, double * ci, double cl=0.95, bool norm = false ) const;; 283 ; 284 /**; 285 evaluate confidence interval for the data set used in the last fit; 286 the confidence interval are returned as a vector of data points; 287 */",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:27679,Performance,perform,performing,27679,"unsigned int i) constparameter value by indexDefinition FitResult.h:174; ROOT::Fit::FitResult::Statusint Status() constminimizer status codeDefinition FitResult.h:128; ROOT::Fit::FitResult::fParNamesstd::vector< std::string > fParNamesparameter names (only with FCN only fits, when fFitFunc=0)Definition FitResult.h:366; ROOT::Fit::FitResult::fMinosErrorsstd::map< unsigned int, std::pair< double, double > > fMinosErrorsmap contains the two Minos errorsDefinition FitResult.h:364; ROOT::Fit::FitResult::SetChi2AndNdfvoid SetChi2AndNdf(double chi2, unsigned int npoints)Set the chi2 and the ndf This function should be called when using an external FCN for fitting and on...Definition FitResult.cxx:311; ROOT::Fit::FitResult::FittedFunctionconst IModelFunction * FittedFunction() constfitting quantitiesDefinition FitResult.h:139; ROOT::Fit::FitResult::GlobalCCdouble GlobalCC(unsigned int i) constparameter global correlation coefficientDefinition FitResult.h:209; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; TMatrixT< Double_t >; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Internal::UpdateDefinition TBranchProxyDirector.cxx:42. mathmathcoreincFitFitResult.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:4",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/FitResult_8h_source.html:5415,Testability,log,log-likelihood,5415,"s() const { return fStatus; }; 129 ; 130 ///covariance matrix status code; 131 /// using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate; 132 ; 133 int CovMatrixStatus() const { return fCovStatus; }; 134 ; 135 /** fitting quantities **/; 136 ; 137 /// Return pointer to model (fit) function with fitted parameter values.; 138 /// Pointer is managed internally. I must not be deleted; 139 const IModelFunction * FittedFunction() const {; 140 return fFitFunc.get();; 141 }; 142 ; 143 /// return BinData used in the fit (return a nullptr in case a different fit is done; 144 /// or the data are not available; 145 /// Pointer is managed internally, it must not be deleted; 146 const BinData * FittedBinData() const;; 147 ; 148 ; 149 /// Return the Chi2 value after fitting; 150 /// In case of unbinned fits (or not defined one, see the documentation of Fitter::FitFCN) return -1; 151 /// In case of binned likelihood fits (Poisson Likelihood) return the 2 * negative log-likelihood ratio; 152 /// using the definition of Baker-Cousins; 153 double Chi2() const { return fChi2; }; 154 ; 155 /// Number of degree of freedom; 156 unsigned int Ndf() const { return fNdf; }; 157 ; 158 /// p value of the fit (chi2 probability); 159 double Prob() const;; 160 ; 161 /// parameter errors (return st::vector); 162 const std::vector<double> & Errors() const { return fErrors; }; 163 /// parameter errors (return const pointer); 164 const double * GetErrors() const { return fErrors.empty() ? nullptr : &fErrors.front(); }; 165 ; 166 /// parameter values (return std::vector); 167 const std::vector<double> & Parameters() const { return fParams; }; 168 /// parameter values (return const pointer); 169 const double * GetParams() const { return &fParams.front(); }; 170 ; 171 /// parameter value by index; 172 double Value(unsigned int i) const { return fParams[i]; }; 173 /// parameter value by index; 174 double Parameter(unsigned int i) const { return fParams[i]; }; 175 ; 176",MatchSource.WIKI,doc/master/FitResult_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitResult_8h_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:1341,Availability,error,error,1341,"**************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class Fitter; 12 ; 13 ; 14#include ""Fit/Fitter.h""; 15#include ""Fit/Chi2FCN.h""; 16#include ""Fit/PoissonLikelihoodFCN.h""; 17#include ""Fit/LogLikelihoodFCN.h""; 18#include ""Math/Minimizer.h""; 19#include ""Math/MinimizerOptions.h""; 20#include ""Math/FitMethodFunction.h""; 21#include ""Fit/BasicFCN.h""; 22#include ""Fit/BinData.h""; 23#include ""Fit/UnBinData.h""; 24#include ""Fit/FcnAdapter.h""; 25#include ""Fit/FitConfig.h""; 26#include ""Fit/FitResult.h""; 27#include ""Math/Error.h""; 28 ; 29#include <memory>; 30 ; 31#include ""Math/IParamFunction.h""; 32 ; 33#include ""Math/MultiDimParamFunctionAdapter.h""; 34 ; 35// #include ""TMatrixDSym.h""; 36// for debugging; 37//#include ""TMatrixD.h""; 38// #include <iomanip>; 39 ; 40namespace ROOT {; 41 ; 42 namespace Fit {; 43 ; 44// use a static variable to get default minimizer options for error def; 45// to see if user has changed it later on. If it has not been changed we set; 46// for the likelihood method an error def of 0.5; 47// t.b.d : multiply likelihood by 2 so have same error def definition as chi2; 48 double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();; 49 ; 50 ; 51Fitter::Fitter(const std::shared_ptr<FitResult> & result) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_M",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:1466,Availability,error,error,1466,"***********************************************/; 10 ; 11// Implementation file for class Fitter; 12 ; 13 ; 14#include ""Fit/Fitter.h""; 15#include ""Fit/Chi2FCN.h""; 16#include ""Fit/PoissonLikelihoodFCN.h""; 17#include ""Fit/LogLikelihoodFCN.h""; 18#include ""Math/Minimizer.h""; 19#include ""Math/MinimizerOptions.h""; 20#include ""Math/FitMethodFunction.h""; 21#include ""Fit/BasicFCN.h""; 22#include ""Fit/BinData.h""; 23#include ""Fit/UnBinData.h""; 24#include ""Fit/FcnAdapter.h""; 25#include ""Fit/FitConfig.h""; 26#include ""Fit/FitResult.h""; 27#include ""Math/Error.h""; 28 ; 29#include <memory>; 30 ; 31#include ""Math/IParamFunction.h""; 32 ; 33#include ""Math/MultiDimParamFunctionAdapter.h""; 34 ; 35// #include ""TMatrixDSym.h""; 36// for debugging; 37//#include ""TMatrixD.h""; 38// #include <iomanip>; 39 ; 40namespace ROOT {; 41 ; 42 namespace Fit {; 43 ; 44// use a static variable to get default minimizer options for error def; 45// to see if user has changed it later on. If it has not been changed we set; 46// for the likelihood method an error def of 0.5; 47// t.b.d : multiply likelihood by 2 so have same error def definition as chi2; 48 double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();; 49 ; 50 ; 51Fitter::Fitter(const std::shared_ptr<FitResult> & result) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = fals",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:1535,Availability,error,error,1535,"th/MultiDimParamFunctionAdapter.h""; 34 ; 35// #include ""TMatrixDSym.h""; 36// for debugging; 37//#include ""TMatrixD.h""; 38// #include <iomanip>; 39 ; 40namespace ROOT {; 41 ; 42 namespace Fit {; 43 ; 44// use a static variable to get default minimizer options for error def; 45// to see if user has changed it later on. If it has not been changed we set; 46// for the likelihood method an error def of 0.5; 47// t.b.d : multiply likelihood by 2 so have same error def definition as chi2; 48 double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();; 49 ; 50 ; 51Fitter::Fitter(const std::shared_ptr<FitResult> & result) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:13368,Availability,error,error,13368,"turn DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, executionPolicy));; 347 }; 348 } else {; 349 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 350 if (gradFun) {; 351 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc>>(data, gradFun, executionPolicy));; 352 }; 353 }; 354 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:13672,Availability,error,errors,13672,"::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:17140,Availability,error,errors,17140,"function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.UseWeightCorrection();; 447 ; 448 if (!fFunc && !fFunc_v) {; 449 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"",""model function is not set"");; 450 return false;; 451 }; 452 ; 453 if (useWeight && fConfig.MinosErrors() ) {; 454 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"",""MINOS errors cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) :",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:17617,Availability,error,error,17617,"tended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.UseWeightCorrection();; 447 ; 448 if (!fFunc && !fFunc_v) {; 449 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"",""model function is not set"");; 450 return false;; 451 }; 452 ; 453 if (useWeight && fConfig.MinosErrors() ) {; 454 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"",""MINOS errors cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:20402,Availability,error,errors,20402,"""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 527}; 528 ; 529 ; 530bool Fitter::CalculateHessErrors() {; 531 // compute the Hesse errors according to configuration; 532 // set in the parameters and append value in fit result; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 55",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:20879,Availability,error,errors,20879,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:21679,Availability,error,errors,21679,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:22622,Availability,error,errors,22622,"er::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:22814,Availability,error,errors,22814,"tResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Mino",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:22932,Availability,error,errors,22932,"tResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Mino",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:23210,Availability,error,errors,23210,"tResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Mino",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:23392,Availability,error,errors,23392,"tResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Mino",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:23611,Availability,error,errors,23611,"Config; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:23986,Availability,error,error,23986,"e computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus(",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:24088,Availability,error,error,24088,"e computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus(",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:25267,Availability,error,error,25267,"ons; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus() & 8) != 0) {; 644 iparNewMin = i;; 645 }; 646 if (ret); 647 fResult->SetMinosError(index, elow, eup);; 648 ok |= ret;; 649 }; 650 ; 651 iparMax = iparNewMin;; 652 iter++; // to avoid infinite looping; 653 }; 654 while( iparNewMin > 0 && iter < 10);; 655 if (!ok) {; 656 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minos error calculation failed for all the selected parameters"");; 657 }; 658 ; 659 // update obj function in case it was an external one; 660 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 661 fResult->fObjFunc = fObjFunction;; 662 ; 663 // re-give a minimizer instance in case it has been changed; 664 // but maintain previous valid status. Do not set result to false if minos failed; 665 ok &= fResult->Update(fMinimizer, fConfig, fResult->IsValid());; 666 ; 667 return ok;; 668}; 669 ; 670 ; 671 ; 672// traits for distinguishing fit methods functions from generic objective functions; 673template<class Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:27694,Availability,down,downcast,27694," and set there the objective function; 695 // obj function must have been set before; 696 auto objFunction = ObjFunction();; 697 if (!objFunction) {; 698 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Objective function has not been set"");; 699 return false;; 700 }; 701 ; 702 // check configuration and objective function; 703 if ( fConfig.ParamsSettings().size() != objFunction->NDim() ) {; 704 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong function dimension or wrong size for FitConfig"");; 705 return false;; 706 }; 707 ; 708 // create first Minimizer; 709 // using an auto_Ptr will delete the previous existing one; 710 fMinimizer = std::shared_ptr<ROOT::Math::Minimizer> ( fConfig.CreateMinimizer() );; 711 if (fMinimizer == nullptr) {; 712 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Minimizer cannot be created"");; 713 return false;; 714 }; 715 ; 716 // in case of gradient function one needs to downcast the pointer; 717 if (fUseGradient) {; 718 const ROOT::Math::IMultiGradFunction * gradfcn = dynamic_cast<const ROOT::Math::IMultiGradFunction *> (objFunction );; 719 if (!gradfcn) {; 720 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong type of function - it does not provide gradient"");; 721 return false;; 722 }; 723 fMinimizer->SetFunction( *gradfcn);; 724 // set also Hessian if available; 725 if (Config().MinimizerType() == ""Minuit2"") {; 726 const ROOT::Math::FitMethodGradFunction *fitGradFcn =; 727 dynamic_cast<const ROOT::Math::FitMethodGradFunction *>(gradfcn);; 728 if (fitGradFcn && fitGradFcn->HasHessian()) {; 729 auto hessFcn = [=](std::span<const double> x, double *hess) {; 730 unsigned int ndim = x.size();; 731 unsigned int nh = ndim * (ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:28083,Availability,avail,available,28083," and set there the objective function; 695 // obj function must have been set before; 696 auto objFunction = ObjFunction();; 697 if (!objFunction) {; 698 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Objective function has not been set"");; 699 return false;; 700 }; 701 ; 702 // check configuration and objective function; 703 if ( fConfig.ParamsSettings().size() != objFunction->NDim() ) {; 704 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong function dimension or wrong size for FitConfig"");; 705 return false;; 706 }; 707 ; 708 // create first Minimizer; 709 // using an auto_Ptr will delete the previous existing one; 710 fMinimizer = std::shared_ptr<ROOT::Math::Minimizer> ( fConfig.CreateMinimizer() );; 711 if (fMinimizer == nullptr) {; 712 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Minimizer cannot be created"");; 713 return false;; 714 }; 715 ; 716 // in case of gradient function one needs to downcast the pointer; 717 if (fUseGradient) {; 718 const ROOT::Math::IMultiGradFunction * gradfcn = dynamic_cast<const ROOT::Math::IMultiGradFunction *> (objFunction );; 719 if (!gradfcn) {; 720 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong type of function - it does not provide gradient"");; 721 return false;; 722 }; 723 fMinimizer->SetFunction( *gradfcn);; 724 // set also Hessian if available; 725 if (Config().MinimizerType() == ""Minuit2"") {; 726 const ROOT::Math::FitMethodGradFunction *fitGradFcn =; 727 dynamic_cast<const ROOT::Math::FitMethodGradFunction *>(gradfcn);; 728 if (fitGradFcn && fitGradFcn->HasHessian()) {; 729 auto hessFcn = [=](std::span<const double> x, double *hess) {; 730 unsigned int ndim = x.size();; 731 unsigned int nh = ndim * (ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:29154,Availability,error,error,29154,"ethodGradFunction *fitGradFcn =; 727 dynamic_cast<const ROOT::Math::FitMethodGradFunction *>(gradfcn);; 728 if (fitGradFcn && fitGradFcn->HasHessian()) {; 729 auto hessFcn = [=](std::span<const double> x, double *hess) {; 730 unsigned int ndim = x.size();; 731 unsigned int nh = ndim * (ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (j != i); 740 hess[ndim * j + i] = h[index];; 741 }; 742 }; 743 return true;; 744 };; 745 ; 746 fMinimizer->SetHessianFunction(hessFcn);; 747 }; 748 }; 749 }; 750 else; 751 fMinimizer->SetFunction( *objFunction);; 752 ; 753 ; 754 fMinimizer->SetVariables(fConfig.ParamsSettings().begin(), fConfig.ParamsSettings().end() );; 755 ; 756 // if requested parabolic error do correct error analysis by the minimizer (call HESSE); 757 if (fConfig.ParabErrors()) fMinimizer->SetValidError(true);; 758 ; 759 return true;; 760 ; 761}; 762 ; 763bool Fitter::DoUpdateMinimizerOptions(bool canDifferentMinim ) {; 764 // update minimizer options when re-doing a Fit or computing Hesse or Minos errors; 765 ; 766 ; 767 // create a new minimizer if it is different type; 768 // minimizer type string stored in FitResult is ""minimizer name"" + "" / "" + minimizer algo; 769 std::string newMinimType = fConfig.MinimizerName();; 770 if (fMinimizer && fResult && newMinimType != fResult->MinimizerType()) {; 771 // if a different minimizer is allowed (e.g. when calling Hesse); 772 if (canDifferentMinim) {; 773 std::string msg = ""Using now "" + newMinimType;; 774 MATH_INFO_MSG(""Fitter::DoUpdateMinimizerOptions: "", msg.c_str());; 775 if (!DoInitMinimizer() ); 776 return false;; 777 }; 778 else {; 779 std::string msg = ""Cannot change minimizer. Continue using "" + fResult->MinimizerType();; 780 MATH",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:29171,Availability,error,error,29171,"ethodGradFunction *fitGradFcn =; 727 dynamic_cast<const ROOT::Math::FitMethodGradFunction *>(gradfcn);; 728 if (fitGradFcn && fitGradFcn->HasHessian()) {; 729 auto hessFcn = [=](std::span<const double> x, double *hess) {; 730 unsigned int ndim = x.size();; 731 unsigned int nh = ndim * (ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (j != i); 740 hess[ndim * j + i] = h[index];; 741 }; 742 }; 743 return true;; 744 };; 745 ; 746 fMinimizer->SetHessianFunction(hessFcn);; 747 }; 748 }; 749 }; 750 else; 751 fMinimizer->SetFunction( *objFunction);; 752 ; 753 ; 754 fMinimizer->SetVariables(fConfig.ParamsSettings().begin(), fConfig.ParamsSettings().end() );; 755 ; 756 // if requested parabolic error do correct error analysis by the minimizer (call HESSE); 757 if (fConfig.ParabErrors()) fMinimizer->SetValidError(true);; 758 ; 759 return true;; 760 ; 761}; 762 ; 763bool Fitter::DoUpdateMinimizerOptions(bool canDifferentMinim ) {; 764 // update minimizer options when re-doing a Fit or computing Hesse or Minos errors; 765 ; 766 ; 767 // create a new minimizer if it is different type; 768 // minimizer type string stored in FitResult is ""minimizer name"" + "" / "" + minimizer algo; 769 std::string newMinimType = fConfig.MinimizerName();; 770 if (fMinimizer && fResult && newMinimType != fResult->MinimizerType()) {; 771 // if a different minimizer is allowed (e.g. when calling Hesse); 772 if (canDifferentMinim) {; 773 std::string msg = ""Using now "" + newMinimType;; 774 MATH_INFO_MSG(""Fitter::DoUpdateMinimizerOptions: "", msg.c_str());; 775 if (!DoInitMinimizer() ); 776 return false;; 777 }; 778 else {; 779 std::string msg = ""Cannot change minimizer. Continue using "" + fResult->MinimizerType();; 780 MATH",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:29473,Availability,error,errors,29473,"ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (j != i); 740 hess[ndim * j + i] = h[index];; 741 }; 742 }; 743 return true;; 744 };; 745 ; 746 fMinimizer->SetHessianFunction(hessFcn);; 747 }; 748 }; 749 }; 750 else; 751 fMinimizer->SetFunction( *objFunction);; 752 ; 753 ; 754 fMinimizer->SetVariables(fConfig.ParamsSettings().begin(), fConfig.ParamsSettings().end() );; 755 ; 756 // if requested parabolic error do correct error analysis by the minimizer (call HESSE); 757 if (fConfig.ParabErrors()) fMinimizer->SetValidError(true);; 758 ; 759 return true;; 760 ; 761}; 762 ; 763bool Fitter::DoUpdateMinimizerOptions(bool canDifferentMinim ) {; 764 // update minimizer options when re-doing a Fit or computing Hesse or Minos errors; 765 ; 766 ; 767 // create a new minimizer if it is different type; 768 // minimizer type string stored in FitResult is ""minimizer name"" + "" / "" + minimizer algo; 769 std::string newMinimType = fConfig.MinimizerName();; 770 if (fMinimizer && fResult && newMinimType != fResult->MinimizerType()) {; 771 // if a different minimizer is allowed (e.g. when calling Hesse); 772 if (canDifferentMinim) {; 773 std::string msg = ""Using now "" + newMinimType;; 774 MATH_INFO_MSG(""Fitter::DoUpdateMinimizerOptions: "", msg.c_str());; 775 if (!DoInitMinimizer() ); 776 return false;; 777 }; 778 else {; 779 std::string msg = ""Cannot change minimizer. Continue using "" + fResult->MinimizerType();; 780 MATH_WARN_MSG(""Fitter::DoUpdateMinimizerOptions"",msg.c_str());; 781 }; 782 }; 783 ; 784 // create minimizer if it was not done before; 785 if (!fMinimizer) {; 786 if (!DoInitMinimizer()); 787 return false;; 788 }; 789 ; 790 // set new minimizer options (but not functions and parameters); 79",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:31071,Availability,error,error,31071,"ot done before; 785 if (!fMinimizer) {; 786 if (!DoInitMinimizer()); 787 return false;; 788 }; 789 ; 790 // set new minimizer options (but not functions and parameters); 791 fMinimizer->SetOptions(fConfig.MinimizerOptions());; 792 return true;; 793}; 794 ; 795bool Fitter::DoMinimization(const ROOT::Math::IMultiGenFunction * chi2func) {; 796 // perform the minimization (assume we have already initialized the minimizer); 797 ; 798 assert(fMinimizer );; 799 ; 800 bool isValid = fMinimizer->Minimize();; 801 ; 802 if (!fResult) fResult = std::make_unique<FitResult>();; 803 ; 804 fResult->FillResult(fMinimizer,fConfig, fFunc, isValid, fDataSize, fFitType, chi2func );; 805 ; 806 // if requested run Minos after minimization; 807 if (isValid && fConfig.MinosErrors()) {; 808 // minos error calculation will update also FitResult; 809 CalculateMinosErrors();; 810 }; 811 ; 812 // when possible get number of calls from FCN and set in fit result; 813 if (fResult->fNCalls == 0 && fFitType != ROOT::Math::FitMethodFunction::kUndefined) {; 814 fResult->fNCalls = GetNCallsFromFCN();; 815 }; 816 ; 817 // fill information in fit result; 818 // if using an external obj function clone it for storing in FitResult; 819 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:32078,Availability,error,errors,32078," if (isValid && fConfig.MinosErrors()) {; 808 // minos error calculation will update also FitResult; 809 CalculateMinosErrors();; 810 }; 811 ; 812 // when possible get number of calls from FCN and set in fit result; 813 if (fResult->fNCalls == 0 && fFitType != ROOT::Math::FitMethodFunction::kUndefined) {; 814 fResult->fNCalls = GetNCallsFromFCN();; 815 }; 816 ; 817 // fill information in fit result; 818 // if using an external obj function clone it for storing in FitResult; 819 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:35226,Availability,error,errors,35226,"radFunction*>(fObjFunction.get());; 880 if (fcn) ncalls = fcn->NCalls();; 881 }; 882 return ncalls;; 883}; 884 ; 885 ; 886bool Fitter::ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L) {; 887 // apply correction for weight square; 888 // Compute Hessian of the loglikelihood function using the sum of the weight squared; 889 // This method assumes:; 890 // - a fit has been done before and a covariance matrix exists; 891 // - the objective function is a likelihood function and Likelihood::UseSumOfWeightSquare(); 892 // has been called before; 893 ; 894 if (fMinimizer == nullptr) {; 895 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Must perform first a fit before applying the correction"");; 896 return false;; 897 }; 898 ; 899 unsigned int n = loglw2.NDim();; 900 // correct errors for weight squared; 901 std::vector<double> cov(n*n);; 902 bool ret = fMinimizer->GetCovMatrix(&cov[0] );; 903 if (!ret) {; 904 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Previous fit has no valid Covariance matrix"");; 905 return false;; 906 }; 907 // need to use new obj function computed with weight-square; 908 std::shared_ptr<ROOT::Math::IMultiGenFunction> objFunc(loglw2.Clone());; 909 fObjFunction.swap( objFunc );; 910 ; 911 // need to re-initialize the minimizer for the changes applied in the; 912 // objective functions; 913 if (!DoInitMinimizer()) return false;; 914 ; 915 //std::cout << ""Running Hesse ..."" << std::endl;; 916 ; 917 // run eventually before a minimization; 918 // ignore its error; 919 if (minimizeW2L) fMinimizer->Minimize();; 920 // run Hesse on the log-likelihood build using sum of weight squared; 921 ret = fMinimizer->Hesse();; 922 if (!ret) {; 923 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Error running Hesse on weight2 likelihood - cannot compute errors"");; 924 return false;; 925 }; 926 ; 927 if (fMinimizer->CovMatrixStatus() != 3) {; 928 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likeliho",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:35941,Availability,error,error,35941,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:36228,Availability,error,errors,36228,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:36432,Availability,error,errors,36432,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:36450,Availability,reliab,reliable,36450,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:37127,Availability,error,errors,37127,"R_MSG(""Fitter::ApplyWeightCorrection"",""Error running Hesse on weight2 likelihood - cannot compute errors"");; 924 return false;; 925 }; 926 ; 927 if (fMinimizer->CovMatrixStatus() != 3) {; 928 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not accurate, the errors may be not reliable"");; 929 if (fMinimizer->CovMatrixStatus() == 2); 930 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood was forced to be defined positive"");; 931 if (fMinimizer->CovMatrixStatus() <= 0); 932 // probably should have failed before; 933 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not valid !"");; 934 }; 935 ; 936 // get Hessian matrix from weight-square likelihood; 937 std::vector<double> hes(n*n);; 938 ret = fMinimizer->GetHessianMatrix(&hes[0] );; 939 if (!ret) {; 940 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Error retrieving Hesse on weight2 likelihood - cannot compute errors"");; 941 return false;; 942 }; 943 ; 944 ; 945 // perform product of matrix cov * hes * cov; 946 // since we do not want to add matrix dependence do product by hand; 947 // first do hes * cov; 948 std::vector<double> tmp(n*n);; 949 for (unsigned int i = 0; i < n; ++i) {; 950 for (unsigned int j = 0; j < n; ++j) {; 951 for (unsigned int k = 0; k < n; ++k); 952 tmp[i*n+j] += hes[i*n + k] * cov[k*n + j];; 953 }; 954 }; 955 // do multiplication now cov * tmp save result; 956 std::vector<double> newCov(n*n);; 957 for (unsigned int i = 0; i < n; ++i) {; 958 for (unsigned int j = 0; j < n; ++j) {; 959 for (unsigned int k = 0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:39206,Availability,avail,available,39206,"0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ; 971 // restore previous used objective function; 972 fObjFunction.swap( objFunc );; 973 ; 974 return true;; 975}; 976 ; 977 ; 978 ; 979void Fitter::ExamineFCN() {; 980 // return a pointer to the binned data used in the fit; 981 // works only for chi2 or binned likelihood fits; 982 // thus when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoo",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:39469,Availability,error,error,39469,"s when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoodFCN.h; MinimizerOptions.h; Minimizer.h; MultiDimParamFunctionAdapter.h; PoissonLikelihoodFCN.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefi",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:41583,Availability,error,errors,41583,"yle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; UnBinData.h; ROOT::Fit::BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix comp",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:41751,Availability,error,errors,41751,"BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:41908,Availability,error,errorsDefinition,41908,"T::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:42558,Availability,error,error,42558,"FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOpti",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:43722,Availability,error,errors,43722,"s() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition F",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:46542,Availability,error,error,46542,"nnedLikelihoodFit(bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::fObjFunctionstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunction! pointer to used objective functionDefinition Fitter.h:574; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error matrix for the weights for likelihood fits This method can be called on...Definition Fitter.cxx:886; ROOT::Fit::Fitter::ExamineFCNvoid ExamineFCN()look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN class...Definition Fitter.cxx:979; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted fun",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:47978,Availability,error,error,47978,"quareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::F",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:48503,Availability,error,error,48503,"taining on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::SetValuevoid SetValue(double val)set the valueDefinition ParameterSett",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:52544,Availability,error,error,52544,"tract class) for multi-dimensional functions providing a gradient calculation.Definition IFunction.h:168; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::IParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is ...Definition IParamFunction.h:161; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetErrorDefvoid SetErrorDef(double err)set error defDefinition MinimizerOptions.h:228; ROOT::Math::MinimizerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; ROOT::Math::MultiDimParamFunctionAdapterMultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimension...Definition MultiDimParamFunctionAdapter.h:41; ROOT::Math::MultiDimParamGradFunctionAdapterMultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a mu...Definition MultiDimParamFunctionAdapter.h:172; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Fit::gDefaultErrorDefdouble gDefaultErrorDefDefinition Fitter.cxx:48; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forw",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:1829,Deployability,configurat,configuration,1829,"th/MultiDimParamFunctionAdapter.h""; 34 ; 35// #include ""TMatrixDSym.h""; 36// for debugging; 37//#include ""TMatrixD.h""; 38// #include <iomanip>; 39 ; 40namespace ROOT {; 41 ; 42 namespace Fit {; 43 ; 44// use a static variable to get default minimizer options for error def; 45// to see if user has changed it later on. If it has not been changed we set; 46// for the likelihood method an error def of 0.5; 47// t.b.d : multiply likelihood by 2 so have same error def definition as chi2; 48 double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();; 49 ; 50 ; 51Fitter::Fitter(const std::shared_ptr<FitResult> & result) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:10538,Deployability,configurat,configuration,10538,"ive function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval = (*ObjFunction())(fResult->GetParams());; 303 // update fit result; 304 fResult->fVal = fcnval;; 305 fResult->fNCalls++;; 306 return true;; 307}; 308 ; 309bool Fitter::DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy); 310{; 311 ; 312 // perform a chi2 fit on a set of binned data; 313 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 314 assert(data);; 315 ; 316 // check function; 317 if (!fFunc && !fFunc_v) {; 318 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""model function is not set"");; 319 return false;; 320 } else {; 321 ; 322#ifdef DEBUG; 323 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[3].IsBound() << "" lower limit ""; 324 << Config().ParamsSettings()[3].LowerLimit() << "" upper limit ""; 325 << Config().ParamsSettings()[3].UpperLimit() << std::endl;; 326#endif; 327 ; 328 fBinFit = true;; 329 fDataSize = data->Size();; 330 // check if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 3",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:10719,Deployability,update,update,10719,"ive function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval = (*ObjFunction())(fResult->GetParams());; 303 // update fit result; 304 fResult->fVal = fcnval;; 305 fResult->fNCalls++;; 306 return true;; 307}; 308 ; 309bool Fitter::DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy); 310{; 311 ; 312 // perform a chi2 fit on a set of binned data; 313 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 314 assert(data);; 315 ; 316 // check function; 317 if (!fFunc && !fFunc_v) {; 318 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""model function is not set"");; 319 return false;; 320 } else {; 321 ; 322#ifdef DEBUG; 323 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[3].IsBound() << "" lower limit ""; 324 << Config().ParamsSettings()[3].LowerLimit() << "" upper limit ""; 325 << Config().ParamsSettings()[3].UpperLimit() << std::endl;; 326#endif; 327 ; 328 fBinFit = true;; 329 fDataSize = data->Size();; 330 // check if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 3",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:20422,Deployability,configurat,configuration,20422,"""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 527}; 528 ; 529 ; 530bool Fitter::CalculateHessErrors() {; 531 // compute the Hesse errors according to configuration; 532 // set in the parameters and append value in fit result; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 55",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:21307,Deployability,update,update,21307,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:21903,Deployability,update,update,21903,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:22119,Deployability,update,update,22119,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:22834,Deployability,configurat,configuration,22834,"tResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Mino",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:23706,Deployability,update,update,23706,"Config; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:25348,Deployability,update,update,25348,"ons; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus() & 8) != 0) {; 644 iparNewMin = i;; 645 }; 646 if (ret); 647 fResult->SetMinosError(index, elow, eup);; 648 ok |= ret;; 649 }; 650 ; 651 iparMax = iparNewMin;; 652 iter++; // to avoid infinite looping; 653 }; 654 while( iparNewMin > 0 && iter < 10);; 655 if (!ok) {; 656 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minos error calculation failed for all the selected parameters"");; 657 }; 658 ; 659 // update obj function in case it was an external one; 660 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 661 fResult->fObjFunc = fObjFunction;; 662 ; 663 // re-give a minimizer instance in case it has been changed; 664 // but maintain previous valid status. Do not set result to false if minos failed; 665 ok &= fResult->Update(fMinimizer, fConfig, fResult->IsValid());; 666 ; 667 return ok;; 668}; 669 ; 670 ; 671 ; 672// traits for distinguishing fit methods functions from generic objective functions; 673template<class Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:27076,Deployability,configurat,configuration,27076,"ass Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680struct ObjFuncTrait<ROOT::Math::FitMethodFunction> {; 681 static unsigned int NCalls(const ROOT::Math::FitMethodFunction & f ) { return f.NCalls(); }; 682 static int Type(const ROOT::Math::FitMethodFunction & f) { return f.Type(); }; 683 static bool IsGrad() { return false; }; 684};; 685template<>; 686struct ObjFuncTrait<ROOT::Math::FitMethodGradFunction> {; 687 static unsigned int NCalls(const ROOT::Math::FitMethodGradFunction & f ) { return f.NCalls(); }; 688 static int Type(const ROOT::Math::FitMethodGradFunction & f) { return f.Type(); }; 689 static bool IsGrad() { return true; }; 690};; 691 ; 692bool Fitter::DoInitMinimizer() {; 693 //initialize minimizer by creating it; 694 // and set there the objective function; 695 // obj function must have been set before; 696 auto objFunction = ObjFunction();; 697 if (!objFunction) {; 698 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Objective function has not been set"");; 699 return false;; 700 }; 701 ; 702 // check configuration and objective function; 703 if ( fConfig.ParamsSettings().size() != objFunction->NDim() ) {; 704 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong function dimension or wrong size for FitConfig"");; 705 return false;; 706 }; 707 ; 708 // create first Minimizer; 709 // using an auto_Ptr will delete the previous existing one; 710 fMinimizer = std::shared_ptr<ROOT::Math::Minimizer> ( fConfig.CreateMinimizer() );; 711 if (fMinimizer == nullptr) {; 712 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Minimizer cannot be created"");; 713 return false;; 714 }; 715 ; 716 // in case of gradient function one needs to downcast the pointer; 717 if (fUseGradient) {; 718 const ROOT::Math::IMultiGradFunction * gradfcn = dynamic_cast<const ROOT::Math::IMultiGradFunction *> (objFunction );; 719 if (!gradfcn) {; 72",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:29400,Deployability,update,update,29400,"ndim + 1) / 2;; 732 std::vector<double> h(nh);; 733 bool ret = fitGradFcn->Hessian(x.data(), h.data());; 734 if (!ret) return false;; 735 for (unsigned int i = 0; i < ndim; i++) {; 736 for (unsigned int j = 0; j <= i; j++) {; 737 unsigned int index = j + i * (i + 1) / 2; // formula for j < i; 738 hess[ndim * i + j] = h[index];; 739 if (j != i); 740 hess[ndim * j + i] = h[index];; 741 }; 742 }; 743 return true;; 744 };; 745 ; 746 fMinimizer->SetHessianFunction(hessFcn);; 747 }; 748 }; 749 }; 750 else; 751 fMinimizer->SetFunction( *objFunction);; 752 ; 753 ; 754 fMinimizer->SetVariables(fConfig.ParamsSettings().begin(), fConfig.ParamsSettings().end() );; 755 ; 756 // if requested parabolic error do correct error analysis by the minimizer (call HESSE); 757 if (fConfig.ParabErrors()) fMinimizer->SetValidError(true);; 758 ; 759 return true;; 760 ; 761}; 762 ; 763bool Fitter::DoUpdateMinimizerOptions(bool canDifferentMinim ) {; 764 // update minimizer options when re-doing a Fit or computing Hesse or Minos errors; 765 ; 766 ; 767 // create a new minimizer if it is different type; 768 // minimizer type string stored in FitResult is ""minimizer name"" + "" / "" + minimizer algo; 769 std::string newMinimType = fConfig.MinimizerName();; 770 if (fMinimizer && fResult && newMinimType != fResult->MinimizerType()) {; 771 // if a different minimizer is allowed (e.g. when calling Hesse); 772 if (canDifferentMinim) {; 773 std::string msg = ""Using now "" + newMinimType;; 774 MATH_INFO_MSG(""Fitter::DoUpdateMinimizerOptions: "", msg.c_str());; 775 if (!DoInitMinimizer() ); 776 return false;; 777 }; 778 else {; 779 std::string msg = ""Cannot change minimizer. Continue using "" + fResult->MinimizerType();; 780 MATH_WARN_MSG(""Fitter::DoUpdateMinimizerOptions"",msg.c_str());; 781 }; 782 }; 783 ; 784 // create minimizer if it was not done before; 785 if (!fMinimizer) {; 786 if (!DoInitMinimizer()); 787 return false;; 788 }; 789 ; 790 // set new minimizer options (but not functions and parameters); 79",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:31094,Deployability,update,update,31094,"ot done before; 785 if (!fMinimizer) {; 786 if (!DoInitMinimizer()); 787 return false;; 788 }; 789 ; 790 // set new minimizer options (but not functions and parameters); 791 fMinimizer->SetOptions(fConfig.MinimizerOptions());; 792 return true;; 793}; 794 ; 795bool Fitter::DoMinimization(const ROOT::Math::IMultiGenFunction * chi2func) {; 796 // perform the minimization (assume we have already initialized the minimizer); 797 ; 798 assert(fMinimizer );; 799 ; 800 bool isValid = fMinimizer->Minimize();; 801 ; 802 if (!fResult) fResult = std::make_unique<FitResult>();; 803 ; 804 fResult->FillResult(fMinimizer,fConfig, fFunc, isValid, fDataSize, fFitType, chi2func );; 805 ; 806 // if requested run Minos after minimization; 807 if (isValid && fConfig.MinosErrors()) {; 808 // minos error calculation will update also FitResult; 809 CalculateMinosErrors();; 810 }; 811 ; 812 // when possible get number of calls from FCN and set in fit result; 813 if (fResult->fNCalls == 0 && fFitType != ROOT::Math::FitMethodFunction::kUndefined) {; 814 fResult->fNCalls = GetNCallsFromFCN();; 815 }; 816 ; 817 // fill information in fit result; 818 // if using an external obj function clone it for storing in FitResult; 819 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:33516,Deployability,update,update,33516,"::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the fit configuration after a fit using the obtained result; 862 if (fResult->IsEmpty() || !fResult->IsValid() ) return;; 863 for (unsigned int i = 0; i < fConfig.NPar(); ++i) {; 864 ParameterSettings & par = fConfig.ParSettings(i);; 865 par.SetValue( fResult->Value(i) );; 866 if (fResult->Error(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:33531,Deployability,configurat,configuration,33531,"::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the fit configuration after a fit using the obtained result; 862 if (fResult->IsEmpty() || !fResult->IsValid() ) return;; 863 for (unsigned int i = 0; i < fConfig.NPar(); ++i) {; 864 ParameterSettings & par = fConfig.ParSettings(i);; 865 par.SetValue( fResult->Value(i) );; 866 if (fResult->Error(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:37845,Deployability,update,update,37845,"2 likelihood - cannot compute errors"");; 924 return false;; 925 }; 926 ; 927 if (fMinimizer->CovMatrixStatus() != 3) {; 928 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not accurate, the errors may be not reliable"");; 929 if (fMinimizer->CovMatrixStatus() == 2); 930 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood was forced to be defined positive"");; 931 if (fMinimizer->CovMatrixStatus() <= 0); 932 // probably should have failed before; 933 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not valid !"");; 934 }; 935 ; 936 // get Hessian matrix from weight-square likelihood; 937 std::vector<double> hes(n*n);; 938 ret = fMinimizer->GetHessianMatrix(&hes[0] );; 939 if (!ret) {; 940 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Error retrieving Hesse on weight2 likelihood - cannot compute errors"");; 941 return false;; 942 }; 943 ; 944 ; 945 // perform product of matrix cov * hes * cov; 946 // since we do not want to add matrix dependence do product by hand; 947 // first do hes * cov; 948 std::vector<double> tmp(n*n);; 949 for (unsigned int i = 0; i < n; ++i) {; 950 for (unsigned int j = 0; j < n; ++j) {; 951 for (unsigned int k = 0; k < n; ++k); 952 tmp[i*n+j] += hes[i*n + k] * cov[k*n + j];; 953 }; 954 }; 955 // do multiplication now cov * tmp save result; 956 std::vector<double> newCov(n*n);; 957 for (unsigned int i = 0; i < n; ++i) {; 958 for (unsigned int j = 0; j < n; ++j) {; 959 for (unsigned int k = 0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ; 971 // restore previous used objective function; 972 fObjFunction.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:41289,Deployability,configurat,configuration,41289,"gn GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; UnBinData.h; ROOT::Fit::BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally ste",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:42920,Deployability,configurat,configurationDefinition,42920,"s() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.c",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:46901,Deployability,configurat,configuration,46901," to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::fObjFunctionstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunction! pointer to used objective functionDefinition Fitter.h:574; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error matrix for the weights for likelihood fits This method can be called on...Definition Fitter.cxx:886; ROOT::Fit::Fitter::ExamineFCNvoid ExamineFCN()look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN class...Definition Fitter.cxx:979; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Defini",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:48673,Deployability,configurat,configuration,48673," result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::SetValuevoid SetValue(double val)set the valueDefinition ParameterSettings.h:120; ROOT::Fit::ParameterSettings::SetStepSizevoid SetStepSize(double err)set the step sizeDefinition ParameterSettings.h:122; ROOT::Math::BasicFitMethodFunctionF",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:3394,Energy Efficiency,adapt,adapter,3394,"delFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction(*gradFunc, true);; 93 return;; 94 }; 95 else {; 96 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 97 }; 98 }; 99 fUseGradient = false;; 100 //std::cout << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:4345,Energy Efficiency,adapt,adapter,4345,"ut << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction & func, bool useGradient); 125{; 126 //std::cout << ""set a 1d grad function"" << std::endl;; 127 fUseGradient = useGradient;; 128 // function is cloned when creating the adapter; 129 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamGradFunctionAdapter(func));; 130 ; 131 // creates the parameter settings; 132 fConfig.CreateParamsSettings(*fFunc);; 133 fFunc_v.reset();; 134}; 135 ; 136 ; 137bool Fitter::DoSetFCN(bool extFcn, const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 138 // Set the objective function for the fit. First parameter specifies if function object is managed external or internal.; 139 // In case of an internal function object we need to clone because it is a temporary one; 140 // if params is not NULL create the parameter settings; 141 fUseGradient = false;; 142 unsigned int npar = fcn.NDim();; 143 if (npar == 0) {; 144 MATH_ERROR_MSG(""Fitter::SetFCN"",""FCN function has zero parameters "");; 145 return false;; 146 }; 147 if (params != nullptr || fConfig.ParamsSettings().empty()); 148 fConfig.SetParamsSettings(npar, params);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:3394,Integrability,adapter,adapter,3394,"delFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction(*gradFunc, true);; 93 return;; 94 }; 95 else {; 96 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 97 }; 98 }; 99 fUseGradient = false;; 100 //std::cout << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:4345,Integrability,adapter,adapter,4345,"ut << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction & func, bool useGradient); 125{; 126 //std::cout << ""set a 1d grad function"" << std::endl;; 127 fUseGradient = useGradient;; 128 // function is cloned when creating the adapter; 129 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamGradFunctionAdapter(func));; 130 ; 131 // creates the parameter settings; 132 fConfig.CreateParamsSettings(*fFunc);; 133 fFunc_v.reset();; 134}; 135 ; 136 ; 137bool Fitter::DoSetFCN(bool extFcn, const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 138 // Set the objective function for the fit. First parameter specifies if function object is managed external or internal.; 139 // In case of an internal function object we need to clone because it is a temporary one; 140 // if params is not NULL create the parameter settings; 141 fUseGradient = false;; 142 unsigned int npar = fcn.NDim();; 143 if (npar == 0) {; 144 MATH_ERROR_MSG(""Fitter::SetFCN"",""FCN function has zero parameters "");; 145 return false;; 146 }; 147 if (params != nullptr || fConfig.ParamsSettings().empty()); 148 fConfig.SetParamsSettings(npar, params);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:5913,Integrability,interface,interface,5913,"ams is not NULL create the parameter settings; 141 fUseGradient = false;; 142 unsigned int npar = fcn.NDim();; 143 if (npar == 0) {; 144 MATH_ERROR_MSG(""Fitter::SetFCN"",""FCN function has zero parameters "");; 145 return false;; 146 }; 147 if (params != nullptr || fConfig.ParamsSettings().empty()); 148 fConfig.SetParamsSettings(npar, params);; 149 else {; 150 if ( fConfig.ParamsSettings().size() != npar) {; 151 MATH_ERROR_MSG(""Fitter::SetFCN"",""wrong fit parameter settings"");; 152 return false;; 153 }; 154 }; 155 fFitType = fitType;; 156 fBinFit = (fFitType == ROOT::Math::FitMethodFunction::kLeastSquare || fFitType == ROOT::Math::FitMethodFunction::kPoissonLikelihood);; 157 ; 158 fDataSize = dataSize;; 159 ; 160 // store external provided FCN without cloning it; 161 // it will be cloned in fObjFunc after the fit; 162 if (extFcn) {; 163 fExtObjFunction = &fcn;; 164 fObjFunction.reset();; 165 }; 166 else {; 167 // case FCN is built from Minuit interface so function object is created internally in Fitter class; 168 // and needs to be cloned and managed; 169 fExtObjFunction = nullptr;; 170 fObjFunction.reset(fcn.Clone());; 171 }; 172 ; 173 // in case a model function and data exists from a previous fit - reset shared-ptr; 174 if (fResult && fResult->FittedFunction() == nullptr && fFunc) fFunc.reset();; 175 if (fData) fData.reset();; 176 ; 177 return true;; 178}; 179bool Fitter::SetFCN(const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 180 // set the objective function for the fit; 181 return DoSetFCN(true, fcn, params, dataSize, fitType);; 182}; 183bool Fitter::SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params, unsigned int dataSize, int fitType) {; 184 // set the objective function for the fit and a model function; 185 if (!SetFCN(fcn, params, dataSize, fitType) ) return false;; 186 // need to set fFunc afterwards because SetFCN could reset fFunc; 187 fFunc = std::unique",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:37268,Integrability,depend,dependence,37268,"2 likelihood - cannot compute errors"");; 924 return false;; 925 }; 926 ; 927 if (fMinimizer->CovMatrixStatus() != 3) {; 928 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not accurate, the errors may be not reliable"");; 929 if (fMinimizer->CovMatrixStatus() == 2); 930 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood was forced to be defined positive"");; 931 if (fMinimizer->CovMatrixStatus() <= 0); 932 // probably should have failed before; 933 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not valid !"");; 934 }; 935 ; 936 // get Hessian matrix from weight-square likelihood; 937 std::vector<double> hes(n*n);; 938 ret = fMinimizer->GetHessianMatrix(&hes[0] );; 939 if (!ret) {; 940 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Error retrieving Hesse on weight2 likelihood - cannot compute errors"");; 941 return false;; 942 }; 943 ; 944 ; 945 // perform product of matrix cov * hes * cov; 946 // since we do not want to add matrix dependence do product by hand; 947 // first do hes * cov; 948 std::vector<double> tmp(n*n);; 949 for (unsigned int i = 0; i < n; ++i) {; 950 for (unsigned int j = 0; j < n; ++j) {; 951 for (unsigned int k = 0; k < n; ++k); 952 tmp[i*n+j] += hes[i*n + k] * cov[k*n + j];; 953 }; 954 }; 955 // do multiplication now cov * tmp save result; 956 std::vector<double> newCov(n*n);; 957 for (unsigned int i = 0; i < n; ++i) {; 958 for (unsigned int j = 0; j < n; ++j) {; 959 for (unsigned int k = 0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ; 971 // restore previous used objective function; 972 fObjFunction.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:39424,Integrability,message,messages,39424,"s when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoodFCN.h; MinimizerOptions.h; Minimizer.h; MultiDimParamFunctionAdapter.h; PoissonLikelihoodFCN.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefi",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:48392,Integrability,interface,interface,48392,"++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::ParameterSettingsClass, describing value, limits and step s",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:51748,Integrability,interface,interface,51748,MethodFunction::HasHessianvirtual bool HasHessian() constDefinition FitMethodFunction.h:76; ROOT::Math::BasicFitMethodFunction::NCallsvirtual unsigned int NCalls() constreturn the total number of function calls (override if needed)Definition FitMethodFunction.h:119; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IBaseFunctionMultiDimTempl::Clonevirtual IBaseFunctionMultiDimTempl< T > * Clone() const =0Clone a function.; ROOT::Math::IBaseFunctionMultiDimTempl::HasGradientvirtual bool HasGradient() constDefinition IFunction.h:90; ROOT::Math::IBaseFunctionMultiDimTempl::NDimvirtual unsigned int NDim() const =0Retrieve the dimension of the function.; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunction.h:168; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::IParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is ...Definition IParamFunction.h:161; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetErrorDefvoid SetErrorDef(double err)set error defDefinition MinimizerOptions.h:228; ROOT::Math::MinimizerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; ROOT::Math::MultiDimPa,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:52778,Integrability,wrap,wrap,52778," class) for one-dimensional parametric functions It is ...Definition IParamFunction.h:161; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetErrorDefvoid SetErrorDef(double err)set error defDefinition MinimizerOptions.h:228; ROOT::Math::MinimizerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; ROOT::Math::MultiDimParamFunctionAdapterMultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimension...Definition MultiDimParamFunctionAdapter.h:41; ROOT::Math::MultiDimParamGradFunctionAdapterMultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a mu...Definition MultiDimParamFunctionAdapter.h:172; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Fit::gDefaultErrorDefdouble gDefaultErrorDefDefinition Fitter.cxx:48; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EExecutionPolicyEExecutionPolicyDefinition EExecutionPolicy.hxx:5; ROOT::Fit::ObjFuncTrait< ROOT::Math::FitMethodFunction >::Typestatic int Type(const ROOT::Math::FitMethodFunction &f)De",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:52976,Integrability,wrap,wrap,52976,"ti-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::PrintLevelint PrintLevel() constnon-static methods for retrieving optionsDefinition MinimizerOptions.h:174; ROOT::Math::MinimizerOptions::SetErrorDefvoid SetErrorDef(double err)set error defDefinition MinimizerOptions.h:228; ROOT::Math::MinimizerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; ROOT::Math::MultiDimParamFunctionAdapterMultiDimParamFunctionAdapter class to wrap a one-dimensional parametric function in a multi dimension...Definition MultiDimParamFunctionAdapter.h:41; ROOT::Math::MultiDimParamGradFunctionAdapterMultiDimParamGradFunctionAdapter class to wrap a one-dimensional parametric gradient function in a mu...Definition MultiDimParamFunctionAdapter.h:172; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOT::Fit::gDefaultErrorDefdouble gDefaultErrorDefDefinition Fitter.cxx:48; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EExecutionPolicyEExecutionPolicyDefinition EExecutionPolicy.hxx:5; ROOT::Fit::ObjFuncTrait< ROOT::Math::FitMethodFunction >::Typestatic int Type(const ROOT::Math::FitMethodFunction &f)Definition Fitter.cxx:682; ROOT::Fit::ObjFuncTrait< ROOT::Math::FitMethodFunction >::IsGradstatic bool IsGrad()Definition Fitter.cxx:683; ROOT::Fit::ObjFuncTrait< ROOT::Math::FitMethodFunction >:",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:1295,Modifiability,variab,variable,1295,"**************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class Fitter; 12 ; 13 ; 14#include ""Fit/Fitter.h""; 15#include ""Fit/Chi2FCN.h""; 16#include ""Fit/PoissonLikelihoodFCN.h""; 17#include ""Fit/LogLikelihoodFCN.h""; 18#include ""Math/Minimizer.h""; 19#include ""Math/MinimizerOptions.h""; 20#include ""Math/FitMethodFunction.h""; 21#include ""Fit/BasicFCN.h""; 22#include ""Fit/BinData.h""; 23#include ""Fit/UnBinData.h""; 24#include ""Fit/FcnAdapter.h""; 25#include ""Fit/FitConfig.h""; 26#include ""Fit/FitResult.h""; 27#include ""Math/Error.h""; 28 ; 29#include <memory>; 30 ; 31#include ""Math/IParamFunction.h""; 32 ; 33#include ""Math/MultiDimParamFunctionAdapter.h""; 34 ; 35// #include ""TMatrixDSym.h""; 36// for debugging; 37//#include ""TMatrixD.h""; 38// #include <iomanip>; 39 ; 40namespace ROOT {; 41 ; 42 namespace Fit {; 43 ; 44// use a static variable to get default minimizer options for error def; 45// to see if user has changed it later on. If it has not been changed we set; 46// for the likelihood method an error def of 0.5; 47// t.b.d : multiply likelihood by 2 so have same error def definition as chi2; 48 double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();; 49 ; 50 ; 51Fitter::Fitter(const std::shared_ptr<FitResult> & result) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_M",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:1829,Modifiability,config,configuration,1829,"th/MultiDimParamFunctionAdapter.h""; 34 ; 35// #include ""TMatrixDSym.h""; 36// for debugging; 37//#include ""TMatrixD.h""; 38// #include <iomanip>; 39 ; 40namespace ROOT {; 41 ; 42 namespace Fit {; 43 ; 44// use a static variable to get default minimizer options for error def; 45// to see if user has changed it later on. If it has not been changed we set; 46// for the likelihood method an error def of 0.5; 47// t.b.d : multiply likelihood by 2 so have same error def definition as chi2; 48 double gDefaultErrorDef = ROOT::Math::MinimizerOptions::DefaultErrorDef();; 49 ; 50 ; 51Fitter::Fitter(const std::shared_ptr<FitResult> & result) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:3394,Modifiability,adapt,adapter,3394,"delFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction(*gradFunc, true);; 93 return;; 94 }; 95 else {; 96 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 97 }; 98 }; 99 fUseGradient = false;; 100 //std::cout << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:4345,Modifiability,adapt,adapter,4345,"ut << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction & func, bool useGradient); 125{; 126 //std::cout << ""set a 1d grad function"" << std::endl;; 127 fUseGradient = useGradient;; 128 // function is cloned when creating the adapter; 129 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamGradFunctionAdapter(func));; 130 ; 131 // creates the parameter settings; 132 fConfig.CreateParamsSettings(*fFunc);; 133 fFunc_v.reset();; 134}; 135 ; 136 ; 137bool Fitter::DoSetFCN(bool extFcn, const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 138 // Set the objective function for the fit. First parameter specifies if function object is managed external or internal.; 139 // In case of an internal function object we need to clone because it is a temporary one; 140 // if params is not NULL create the parameter settings; 141 fUseGradient = false;; 142 unsigned int npar = fcn.NDim();; 143 if (npar == 0) {; 144 MATH_ERROR_MSG(""Fitter::SetFCN"",""FCN function has zero parameters "");; 145 return false;; 146 }; 147 if (params != nullptr || fConfig.ParamsSettings().empty()); 148 fConfig.SetParamsSettings(npar, params);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:10538,Modifiability,config,configuration,10538,"ive function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval = (*ObjFunction())(fResult->GetParams());; 303 // update fit result; 304 fResult->fVal = fcnval;; 305 fResult->fNCalls++;; 306 return true;; 307}; 308 ; 309bool Fitter::DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy); 310{; 311 ; 312 // perform a chi2 fit on a set of binned data; 313 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 314 assert(data);; 315 ; 316 // check function; 317 if (!fFunc && !fFunc_v) {; 318 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""model function is not set"");; 319 return false;; 320 } else {; 321 ; 322#ifdef DEBUG; 323 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[3].IsBound() << "" lower limit ""; 324 << Config().ParamsSettings()[3].LowerLimit() << "" upper limit ""; 325 << Config().ParamsSettings()[3].UpperLimit() << std::endl;; 326#endif; 327 ; 328 fBinFit = true;; 329 fDataSize = data->Size();; 330 // check if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 3",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:12837,Modifiability,extend,extended,12837,"if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 336 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc>>(data, fFunc, executionPolicy));; 337 }; 338 } else {; 339 // use gradient; 340 if (fConfig.MinimizerOptions().PrintLevel() > 0); 341 MATH_INFO_MSG(""Fitter::DoLeastSquareFit"", ""use gradient from model function"");; 342 ; 343 if (fFunc_v) {; 344 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 345 if (gradFun) {; 346 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, executionPolicy));; 347 }; 348 } else {; 349 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 350 if (gradFun) {; 351 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc>>(data, gradFun, executionPolicy));; 352 }; 353 }; 354 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (use",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:12976,Modifiability,extend,extended,12976,"if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 336 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc>>(data, fFunc, executionPolicy));; 337 }; 338 } else {; 339 // use gradient; 340 if (fConfig.MinimizerOptions().PrintLevel() > 0); 341 MATH_INFO_MSG(""Fitter::DoLeastSquareFit"", ""use gradient from model function"");; 342 ; 343 if (fFunc_v) {; 344 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 345 if (gradFun) {; 346 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, executionPolicy));; 347 }; 348 } else {; 349 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 350 if (gradFun) {; 351 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc>>(data, gradFun, executionPolicy));; 352 }; 353 }; 354 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (use",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14177,Modifiability,extend,extended,14177,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14534,Modifiability,extend,extended,14534,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14843,Modifiability,extend,extended,14843,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14894,Modifiability,extend,extended,14894,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14968,Modifiability,extend,extended,14968,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:15028,Modifiability,extend,extended,15028,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:15049,Modifiability,extend,extended,15049,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:15610,Modifiability,extend,extended,15610,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16339,Modifiability,extend,extended,16339,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16593,Modifiability,extend,extended,16593,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18019,Modifiability,extend,extended,18019,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18270,Modifiability,extend,extended,18270,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18628,Modifiability,extend,extended,18628,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18765,Modifiability,extend,extended,18765,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18786,Modifiability,extend,extended,18786,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19212,Modifiability,extend,extended,19212,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19710,Modifiability,extend,extended,19710,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:20422,Modifiability,config,configuration,20422,"""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 527}; 528 ; 529 ; 530bool Fitter::CalculateHessErrors() {; 531 // compute the Hesse errors according to configuration; 532 // set in the parameters and append value in fit result; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 55",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:21001,Modifiability,config,configure,21001,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:22834,Modifiability,config,configuration,22834,"tResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType != ROOT::Math::FitMethodFunction::kUndefined ) {; 583 fResult->fNCalls = GetNCallsFromFCN();; 584 }; 585 ; 586 // set also new errors in FitConfig; 587 if (fConfig.UpdateAfterFit() && ret) DoUpdateFitConfig();; 588 ; 589 return ret;; 590}; 591 ; 592 ; 593bool Fitter::CalculateMinosErrors() {; 594 // compute the Minos errors according to configuration; 595 // set in the parameters and append value in fit result; 596 // normally Minos errors are computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Mino",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:27076,Modifiability,config,configuration,27076,"ass Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680struct ObjFuncTrait<ROOT::Math::FitMethodFunction> {; 681 static unsigned int NCalls(const ROOT::Math::FitMethodFunction & f ) { return f.NCalls(); }; 682 static int Type(const ROOT::Math::FitMethodFunction & f) { return f.Type(); }; 683 static bool IsGrad() { return false; }; 684};; 685template<>; 686struct ObjFuncTrait<ROOT::Math::FitMethodGradFunction> {; 687 static unsigned int NCalls(const ROOT::Math::FitMethodGradFunction & f ) { return f.NCalls(); }; 688 static int Type(const ROOT::Math::FitMethodGradFunction & f) { return f.Type(); }; 689 static bool IsGrad() { return true; }; 690};; 691 ; 692bool Fitter::DoInitMinimizer() {; 693 //initialize minimizer by creating it; 694 // and set there the objective function; 695 // obj function must have been set before; 696 auto objFunction = ObjFunction();; 697 if (!objFunction) {; 698 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Objective function has not been set"");; 699 return false;; 700 }; 701 ; 702 // check configuration and objective function; 703 if ( fConfig.ParamsSettings().size() != objFunction->NDim() ) {; 704 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""wrong function dimension or wrong size for FitConfig"");; 705 return false;; 706 }; 707 ; 708 // create first Minimizer; 709 // using an auto_Ptr will delete the previous existing one; 710 fMinimizer = std::shared_ptr<ROOT::Math::Minimizer> ( fConfig.CreateMinimizer() );; 711 if (fMinimizer == nullptr) {; 712 MATH_ERROR_MSG(""Fitter::DoInitMinimizer"",""Minimizer cannot be created"");; 713 return false;; 714 }; 715 ; 716 // in case of gradient function one needs to downcast the pointer; 717 if (fUseGradient) {; 718 const ROOT::Math::IMultiGradFunction * gradfcn = dynamic_cast<const ROOT::Math::IMultiGradFunction *> (objFunction );; 719 if (!gradfcn) {; 72",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:33531,Modifiability,config,configuration,33531,"::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the fit configuration after a fit using the obtained result; 862 if (fResult->IsEmpty() || !fResult->IsValid() ) return;; 863 for (unsigned int i = 0; i < fConfig.NPar(); ++i) {; 864 ParameterSettings & par = fConfig.ParSettings(i);; 865 par.SetValue( fResult->Value(i) );; 866 if (fResult->Error(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:39446,Modifiability,config,configured,39446,"s when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoodFCN.h; MinimizerOptions.h; Minimizer.h; MultiDimParamFunctionAdapter.h; PoissonLikelihoodFCN.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefi",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:41289,Modifiability,config,configuration,41289,"gn GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; UnBinData.h; ROOT::Fit::BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally ste",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:42920,Modifiability,config,configurationDefinition,42920,"s() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.c",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:44802,Modifiability,extend,extended,44802," a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)un-binned likelihood fitDefinition Fitter.cxx:440; ROOT::Fit::Fitter::ObjFunctionconst ROOT::Math::IBaseFunctionMultiDimTempl< double > * ObjFunction() constReturn pointer to the used objective function for fitting.Definition Fitter.h:544; ROOT::Fit::Fitter::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! pointer to used minimizerDefinition Fitter.h:570; ROOT::Fit::Fitter::DoWeightMinimizationbool DoWeightMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)Definition Fitter.cxx:845; ROOT::Fit::Fitter::DoBinnedLikelihoodFitbool DoBinnedLikelihoodFit(bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::fDatas",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:45521,Modifiability,extend,extended,45521," int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)un-binned likelihood fitDefinition Fitter.cxx:440; ROOT::Fit::Fitter::ObjFunctionconst ROOT::Math::IBaseFunctionMultiDimTempl< double > * ObjFunction() constReturn pointer to the used objective function for fitting.Definition Fitter.h:544; ROOT::Fit::Fitter::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! pointer to used minimizerDefinition Fitter.h:570; ROOT::Fit::Fitter::DoWeightMinimizationbool DoWeightMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)Definition Fitter.cxx:845; ROOT::Fit::Fitter::DoBinnedLikelihoodFitbool DoBinnedLikelihoodFit(bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::fObjFunctionstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunction! pointer to used objective functionDefinition Fitter.h:574; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error m",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:46901,Modifiability,config,configuration,46901," to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::fObjFunctionstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunction! pointer to used objective functionDefinition Fitter.h:574; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error matrix for the weights for likelihood fits This method can be called on...Definition Fitter.cxx:886; ROOT::Fit::Fitter::ExamineFCNvoid ExamineFCN()look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN class...Definition Fitter.cxx:979; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Defini",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:48673,Modifiability,config,configuration,48673," result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::SetValuevoid SetValue(double val)set the valueDefinition ParameterSettings.h:120; ROOT::Fit::ParameterSettings::SetStepSizevoid SetStepSize(double err)set the step sizeDefinition ParameterSettings.h:122; ROOT::Math::BasicFitMethodFunctionF",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:10118,Performance,perform,perform,10118,"0}; 241 ; 242bool Fitter::SetFCN(MinuitFCN_t fcn, int npar, const double *params, unsigned int dataSize, int fitType); 243{; 244 // set TMinuit style FCN type (global function pointer); 245 // create corresponding objective function from that function; 246 ; 247 if (npar == 0) {; 248 npar = fConfig.ParamsSettings().size();; 249 if (npar == 0) {; 250 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Fit Parameter settings have not been created "");; 251 return false;; 252 }; 253 }; 254 ; 255 ROOT::Fit::FcnAdapter newFcn(fcn, npar);; 256 return DoSetFCN(false,newFcn, params, dataSize, fitType);; 257}; 258 ; 259bool Fitter::FitFCN(MinuitFCN_t fcn, int npar, const double *params, unsigned int dataSize, int fitType); 260{; 261 // fit using Minuit style FCN type (global function pointer); 262 // create corresponding objective function from that function; 263 if (!SetFCN(fcn, npar, params, dataSize, fitType)); 264 return false;; 265 fUseGradient = false;; 266 return FitFCN();; 267}; 268 ; 269bool Fitter::FitFCN(); 270{; 271 // fit using the previously set FCN function; 272 ; 273 ; 274 if (!fExtObjFunction && !fObjFunction) {; 275 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:10922,Performance,perform,perform,10922,"ive function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval = (*ObjFunction())(fResult->GetParams());; 303 // update fit result; 304 fResult->fVal = fcnval;; 305 fResult->fNCalls++;; 306 return true;; 307}; 308 ; 309bool Fitter::DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy); 310{; 311 ; 312 // perform a chi2 fit on a set of binned data; 313 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 314 assert(data);; 315 ; 316 // check function; 317 if (!fFunc && !fFunc_v) {; 318 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""model function is not set"");; 319 return false;; 320 } else {; 321 ; 322#ifdef DEBUG; 323 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[3].IsBound() << "" lower limit ""; 324 << Config().ParamsSettings()[3].LowerLimit() << "" upper limit ""; 325 << Config().ParamsSettings()[3].UpperLimit() << std::endl;; 326#endif; 327 ; 328 fBinFit = true;; 329 fDataSize = data->Size();; 330 // check if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 3",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:12908,Performance,perform,perform,12908,"if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 336 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc>>(data, fFunc, executionPolicy));; 337 }; 338 } else {; 339 // use gradient; 340 if (fConfig.MinimizerOptions().PrintLevel() > 0); 341 MATH_INFO_MSG(""Fitter::DoLeastSquareFit"", ""use gradient from model function"");; 342 ; 343 if (fFunc_v) {; 344 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 345 if (gradFun) {; 346 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, executionPolicy));; 347 }; 348 } else {; 349 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 350 if (gradFun) {; 351 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc>>(data, gradFun, executionPolicy));; 352 }; 353 }; 354 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (use",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16660,Performance,perform,perform,16660,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:20041,Performance,perform,perform,20041,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:24065,Performance,perform,perform,24065,"e computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus(",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:30632,Performance,perform,perform,30632,"erType()) {; 771 // if a different minimizer is allowed (e.g. when calling Hesse); 772 if (canDifferentMinim) {; 773 std::string msg = ""Using now "" + newMinimType;; 774 MATH_INFO_MSG(""Fitter::DoUpdateMinimizerOptions: "", msg.c_str());; 775 if (!DoInitMinimizer() ); 776 return false;; 777 }; 778 else {; 779 std::string msg = ""Cannot change minimizer. Continue using "" + fResult->MinimizerType();; 780 MATH_WARN_MSG(""Fitter::DoUpdateMinimizerOptions"",msg.c_str());; 781 }; 782 }; 783 ; 784 // create minimizer if it was not done before; 785 if (!fMinimizer) {; 786 if (!DoInitMinimizer()); 787 return false;; 788 }; 789 ; 790 // set new minimizer options (but not functions and parameters); 791 fMinimizer->SetOptions(fConfig.MinimizerOptions());; 792 return true;; 793}; 794 ; 795bool Fitter::DoMinimization(const ROOT::Math::IMultiGenFunction * chi2func) {; 796 // perform the minimization (assume we have already initialized the minimizer); 797 ; 798 assert(fMinimizer );; 799 ; 800 bool isValid = fMinimizer->Minimize();; 801 ; 802 if (!fResult) fResult = std::make_unique<FitResult>();; 803 ; 804 fResult->FillResult(fMinimizer,fConfig, fFunc, isValid, fDataSize, fFitType, chi2func );; 805 ; 806 // if requested run Minos after minimization; 807 if (isValid && fConfig.MinosErrors()) {; 808 // minos error calculation will update also FitResult; 809 CalculateMinosErrors();; 810 }; 811 ; 812 // when possible get number of calls from FCN and set in fit result; 813 if (fResult->fNCalls == 0 && fFitType != ROOT::Math::FitMethodFunction::kUndefined) {; 814 fResult->fNCalls = GetNCallsFromFCN();; 815 }; 816 ; 817 // fill information in fit result; 818 // if using an external obj function clone it for storing in FitResult; 819 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:32354,Performance,perform,perform,32354,"nction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:32795,Performance,perform,perform,32795,"nction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc "" << fFitFitResType << "" typeid: "" << typeid(*fObjFunction).name() << "" use gradient "" << fUseGradient << std::endl;; 825#endif; 826 ; 827 if (fConfig.NormalizeErrors() && fFitType == ROOT::Math::FitMethodFunction::kLeastSquare ); 828 fResult->NormalizeErrors();; 829 ; 830 // set also new parameter values and errors in FitConfig; 831 if (fConfig.UpdateAfterFit() && isValid) DoUpdateFitConfig();; 832 ; 833 return isValid;; 834}; 835template<class ObjFunc_t>; 836bool Fitter::DoMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:35087,Performance,perform,perform,35087,"r(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else {; 879 const ROOT::Math::FitMethodGradFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodGradFunction*>(fObjFunction.get());; 880 if (fcn) ncalls = fcn->NCalls();; 881 }; 882 return ncalls;; 883}; 884 ; 885 ; 886bool Fitter::ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L) {; 887 // apply correction for weight square; 888 // Compute Hessian of the loglikelihood function using the sum of the weight squared; 889 // This method assumes:; 890 // - a fit has been done before and a covariance matrix exists; 891 // - the objective function is a likelihood function and Likelihood::UseSumOfWeightSquare(); 892 // has been called before; 893 ; 894 if (fMinimizer == nullptr) {; 895 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Must perform first a fit before applying the correction"");; 896 return false;; 897 }; 898 ; 899 unsigned int n = loglw2.NDim();; 900 // correct errors for weight squared; 901 std::vector<double> cov(n*n);; 902 bool ret = fMinimizer->GetCovMatrix(&cov[0] );; 903 if (!ret) {; 904 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Previous fit has no valid Covariance matrix"");; 905 return false;; 906 }; 907 // need to use new obj function computed with weight-square; 908 std::shared_ptr<ROOT::Math::IMultiGenFunction> objFunc(loglw2.Clone());; 909 fObjFunction.swap( objFunc );; 910 ; 911 // need to re-initialize the minimizer for the changes applied in the; 912 // objective functions; 913 if (!DoInitMinimizer()) return false;; 914 ; 9",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:37183,Performance,perform,perform,37183,"e on weight2 likelihood - cannot compute errors"");; 924 return false;; 925 }; 926 ; 927 if (fMinimizer->CovMatrixStatus() != 3) {; 928 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not accurate, the errors may be not reliable"");; 929 if (fMinimizer->CovMatrixStatus() == 2); 930 MATH_WARN_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood was forced to be defined positive"");; 931 if (fMinimizer->CovMatrixStatus() <= 0); 932 // probably should have failed before; 933 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Covariance matrix for weighted likelihood is not valid !"");; 934 }; 935 ; 936 // get Hessian matrix from weight-square likelihood; 937 std::vector<double> hes(n*n);; 938 ret = fMinimizer->GetHessianMatrix(&hes[0] );; 939 if (!ret) {; 940 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Error retrieving Hesse on weight2 likelihood - cannot compute errors"");; 941 return false;; 942 }; 943 ; 944 ; 945 // perform product of matrix cov * hes * cov; 946 // since we do not want to add matrix dependence do product by hand; 947 // first do hes * cov; 948 std::vector<double> tmp(n*n);; 949 for (unsigned int i = 0; i < n; ++i) {; 950 for (unsigned int j = 0; j < n; ++j) {; 951 for (unsigned int k = 0; k < n; ++k); 952 tmp[i*n+j] += hes[i*n + k] * cov[k*n + j];; 953 }; 954 }; 955 // do multiplication now cov * tmp save result; 956 std::vector<double> newCov(n*n);; 957 for (unsigned int i = 0; i < n; ++i) {; 958 for (unsigned int j = 0; j < n; ++j) {; 959 for (unsigned int k = 0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ; 971 // restore previous used objective function; 972 f",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:41608,Performance,perform,performed,41608,"yle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; UnBinData.h; ROOT::Fit::BasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the dat...Definition BasicFCN.h:40; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::FcnAdapterDefinition FcnAdapter.h:27; ROOT::Fit::FitConfig::MinosParamsconst std::vector< unsigned int > & MinosParams() constreturn vector of parameter indices for which the Minos Error will be computedDefinition FitConfig.h:218; ROOT::Fit::FitConfig::UpdateAfterFitbool UpdateAfterFit() constUpdate configuration after a fit using the FitResult.Definition FitConfig.h:211; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::ParabErrorsbool ParabErrors() constdo analysis for parabolic errorsDefinition FitConfig.h:205; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::MinimizerNamestd::string MinimizerName() constreturn Minimizer full name (type / algorithm)Definition FitConfig.cxx:239; ROOT::Fit::FitConfig::UseWeightCorrectionbool UseWeightCorrection() constApply Weight correction for error matrix comp",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:47967,Performance,perform,perform,47967,"quareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::F",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:48492,Performance,perform,perform,48492,"taining on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Fit::ParameterSettings::SetValuevoid SetValue(double val)set the valueDefinition ParameterSett",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:24017,Safety,avoid,avoid,24017,"e computed just after the minimization; 597 // (in DoMinimization) aftewr minimizing if the; 598 // FitConfig::MinosErrors() flag is set; 599 ; 600 if (!fMinimizer) {; 601 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minimizer does not exist - cannot calculate Minos errors"");; 602 return false;; 603 }; 604 ; 605 if (!fResult || fResult->IsEmpty() ) {; 606 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Invalid Fit Result - cannot calculate Minos errors"");; 607 return false;; 608 }; 609 ; 610 if (fFitType == ROOT::Math::FitMethodFunction::kLogLikelihood && fConfig.UseWeightCorrection() ) {; 611 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Computation of MINOS errors not implemented for weighted likelihood fits"");; 612 return false;; 613 }; 614 ; 615 // update minimizer (but cannot re-create in this case). Must use an existing one; 616 if (!DoUpdateMinimizerOptions(false)) {; 617 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 618 return false;; 619 }; 620 ; 621 // set flag to compute Minos error to false in FitConfig to avoid that; 622 // following minimizaiton calls perform unwanted Minos error calculations; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus(",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:25121,Safety,avoid,avoid,25121,"ons; 623 /// fConfig.SetMinosErrors(false);; 624 ; 625 ; 626 const std::vector<unsigned int> & ipars = fConfig.MinosParams();; 627 unsigned int n = (!ipars.empty()) ? ipars.size() : fResult->Parameters().size();; 628 bool ok = false;; 629 ; 630 int iparNewMin = 0;; 631 int iparMax = n;; 632 int iter = 0;; 633 // rerun minos for the parameters run before a new Minimum has been found; 634 do {; 635 if (iparNewMin > 0); 636 MATH_INFO_MSG(""Fitter::CalculateMinosErrors"",""Run again Minos for some parameters because a new Minimum has been found"");; 637 iparNewMin = 0;; 638 for (int i = 0; i < iparMax; ++i) {; 639 double elow, eup;; 640 unsigned int index = (!ipars.empty()) ? ipars[i] : i;; 641 bool ret = fMinimizer->GetMinosError(index, elow, eup);; 642 // flags case when a new minimum has been found; 643 if ((fMinimizer->MinosStatus() & 8) != 0) {; 644 iparNewMin = i;; 645 }; 646 if (ret); 647 fResult->SetMinosError(index, elow, eup);; 648 ok |= ret;; 649 }; 650 ; 651 iparMax = iparNewMin;; 652 iter++; // to avoid infinite looping; 653 }; 654 while( iparNewMin > 0 && iter < 10);; 655 if (!ok) {; 656 MATH_ERROR_MSG(""Fitter::CalculateMinosErrors"",""Minos error calculation failed for all the selected parameters"");; 657 }; 658 ; 659 // update obj function in case it was an external one; 660 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 661 fResult->fObjFunc = fObjFunction;; 662 ; 663 // re-give a minimizer instance in case it has been changed; 664 // but maintain previous valid status. Do not set result to false if minos failed; 665 ok &= fResult->Update(fMinimizer, fConfig, fResult->IsValid());; 666 ; 667 return ok;; 668}; 669 ; 670 ; 671 ; 672// traits for distinguishing fit methods functions from generic objective functions; 673template<class Func>; 674struct ObjFuncTrait {; 675 static unsigned int NCalls(const Func & ) { return 0; }; 676 static int Type(const Func & ) { return -1; }; 677 static bool IsGrad() { return false; }; 678};; 679template<>; 680",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:43568,Security,access,access,43568,"r matrix computation.Definition FitConfig.h:214; ROOT::Fit::FitConfig::ParamsSettingsconst std::vector< ROOT::Fit::ParameterSettings > & ParamsSettings() constget the vector of parameter settings (const method)Definition FitConfig.h:86; ROOT::Fit::FitConfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)S",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:2681,Testability,assert,assert,2681,"esult) :; 52 fResult(result); 53{; 54 if (result->fFitFunc) SetFunction(*fResult->fFitFunc); // this will create also the configuration; 55 if (result->fObjFunc) fObjFunction = fResult->fObjFunc;; 56 if (result->fFitData) fData = fResult->fFitData;; 57}; 58 ; 59void Fitter::SetFunction(const IModelFunction & func, bool useGradient); 60{; 61 ; 62 fUseGradient = useGradient;; 63 if (fUseGradient) {; 64 const IGradModelFunction * gradFunc = dynamic_cast<const IGradModelFunction*>(&func);; 65 if (gradFunc) {; 66 SetFunction(*gradFunc, true);; 67 return;; 68 }; 69 else {; 70 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 71 }; 72 }; 73 fUseGradient = false;; 74 ; 75 // set the fit model function (clone the given one and keep a copy ); 76 //std::cout << ""set a non-grad function"" << std::endl;; 77 ; 78 fFunc = std::shared_ptr<IModelFunction>(dynamic_cast<IModelFunction *>(func.Clone() ) );; 79 assert(fFunc);; 80 ; 81 // creates the parameter settings; 82 fConfig.CreateParamsSettings(*fFunc);; 83 fFunc_v.reset();; 84}; 85 ; 86void Fitter::SetFunction(const IModel1DFunction & func, bool useGradient); 87{; 88 fUseGradient = useGradient;; 89 if (fUseGradient) {; 90 const IGradModel1DFunction * gradFunc = dynamic_cast<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction(*gradFunc, true);; 93 return;; 94 }; 95 else {; 96 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 97 }; 98 }; 99 fUseGradient = false;; 100 //std::cout << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:3977,Testability,assert,assert,3977,"st<const IGradModel1DFunction*>(&func);; 91 if (gradFunc) {; 92 SetFunction(*gradFunc, true);; 93 return;; 94 }; 95 else {; 96 MATH_WARN_MSG(""Fitter::SetFunction"",""Requested function does not provide gradient - use it as non-gradient function "");; 97 }; 98 }; 99 fUseGradient = false;; 100 //std::cout << ""set a 1d function"" << std::endl;; 101 ; 102 // function is cloned when creating the adapter; 103 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamFunctionAdapter(func));; 104 ; 105 // creates the parameter settings; 106 fConfig.CreateParamsSettings(*fFunc);; 107 fFunc_v.reset();; 108}; 109 ; 110void Fitter::SetFunction(const IGradModelFunction & func, bool useGradient); 111{; 112 fUseGradient = useGradient;; 113 //std::cout << ""set a grad function"" << std::endl;; 114 // set the fit model function (clone the given one and keep a copy ); 115 fFunc = std::shared_ptr<IModelFunction>( dynamic_cast<IGradModelFunction *> ( func.Clone() ) );; 116 assert(fFunc);; 117 ; 118 // creates the parameter settings; 119 fConfig.CreateParamsSettings(*fFunc);; 120 fFunc_v.reset();; 121}; 122 ; 123 ; 124void Fitter::SetFunction(const IGradModel1DFunction & func, bool useGradient); 125{; 126 //std::cout << ""set a 1d grad function"" << std::endl;; 127 fUseGradient = useGradient;; 128 // function is cloned when creating the adapter; 129 fFunc = std::shared_ptr<IModelFunction>(new ROOT::Math::MultiDimParamGradFunctionAdapter(func));; 130 ; 131 // creates the parameter settings; 132 fConfig.CreateParamsSettings(*fFunc);; 133 fFunc_v.reset();; 134}; 135 ; 136 ; 137bool Fitter::DoSetFCN(bool extFcn, const ROOT::Math::IMultiGenFunction & fcn, const double * params, unsigned int dataSize, int fitType) {; 138 // Set the objective function for the fit. First parameter specifies if function object is managed external or internal.; 139 // In case of an internal function object we need to clone because it is a temporary one; 140 // if params is not NULL create the parameter settings",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:11050,Testability,assert,assert,11050,"ive function has not been set"");; 276 return false;; 277 }; 278 // look if FCN is of a known type and we can get retrieve the model function and data objects; 279 if (!fFunc || !fData); 280 ExamineFCN();; 281 // init the minimizer; 282 if (!DoInitMinimizer()); 283 return false;; 284 // perform the minimization; 285 return DoMinimization();; 286}; 287 ; 288bool Fitter::EvalFCN(); 289{; 290 // evaluate the FCN using the stored values in fConfig; 291 ; 292 if (fFunc && fResult->FittedFunction() == nullptr); 293 fFunc.reset();; 294 ; 295 if (!ObjFunction()) {; 296 MATH_ERROR_MSG(""Fitter::FitFCN"", ""Objective function has not been set"");; 297 return false;; 298 }; 299 // create a Fit result from the fit configuration; 300 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig);; 301 // evaluate one time the FCN; 302 double fcnval = (*ObjFunction())(fResult->GetParams());; 303 // update fit result; 304 fResult->fVal = fcnval;; 305 fResult->fNCalls++;; 306 return true;; 307}; 308 ; 309bool Fitter::DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy); 310{; 311 ; 312 // perform a chi2 fit on a set of binned data; 313 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 314 assert(data);; 315 ; 316 // check function; 317 if (!fFunc && !fFunc_v) {; 318 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""model function is not set"");; 319 return false;; 320 } else {; 321 ; 322#ifdef DEBUG; 323 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[3].IsBound() << "" lower limit ""; 324 << Config().ParamsSettings()[3].LowerLimit() << "" upper limit ""; 325 << Config().ParamsSettings()[3].UpperLimit() << std::endl;; 326#endif; 327 ; 328 fBinFit = true;; 329 fDataSize = data->Size();; 330 // check if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 3",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:13102,Testability,assert,assert,13102,"if fFunc provides gradient; 331 if (!fUseGradient) {; 332 // do minimization without using the gradient; 333 if (fFunc_v) {; 334 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, executionPolicy));; 335 } else {; 336 return DoMinimization(std::make_unique<Chi2FCN<BaseFunc>>(data, fFunc, executionPolicy));; 337 }; 338 } else {; 339 // use gradient; 340 if (fConfig.MinimizerOptions().PrintLevel() > 0); 341 MATH_INFO_MSG(""Fitter::DoLeastSquareFit"", ""use gradient from model function"");; 342 ; 343 if (fFunc_v) {; 344 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 345 if (gradFun) {; 346 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, executionPolicy));; 347 }; 348 } else {; 349 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 350 if (gradFun) {; 351 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc>>(data, gradFun, executionPolicy));; 352 }; 353 }; 354 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (use",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:13358,Testability,log,logl,13358,"turn DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, executionPolicy));; 347 }; 348 } else {; 349 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 350 if (gradFun) {; 351 return DoMinimization(std::make_unique<Chi2FCN<BaseGradFunc>>(data, gradFun, executionPolicy));; 352 }; 353 }; 354 MATH_ERROR_MSG(""Fitter::DoLeastSquareFit"", ""wrong type of function - it does not provide gradient"");; 355 }; 356 }; 357 return false;; 358}; 359 ; 360bool Fitter::DoBinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy); 361{; 362 // perform a likelihood fit on a set of binned data; 363 // The fit is extended (Poisson logl_ by default; 364 ; 365 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 366 assert(data);; 367 ; 368 bool useWeight = fConfig.UseWeightCorrection();; 369 ; 370 // check function; 371 if (!fFunc && !fFunc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14077,Testability,log,logl,14077,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14262,Testability,log,logl,14262,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14302,Testability,log,logl,14302,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14454,Testability,log,logl,14454,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14619,Testability,log,logl,14619,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:14659,Testability,log,logl,14659,"unc_v) {; 372 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""model function is not set"");; 373 return false;; 374 }; 375 ; 376 // logl fit (error should be 0.5) set if different than default values (of 1); 377 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef) {; 378 fConfig.MinimizerOptions().SetErrorDef(0.5);; 379 }; 380 ; 381 if (useWeight && fConfig.MinosErrors()) {; 382 MATH_INFO_MSG(""Fitter::DoBinnedLikelihoodFit"", ""MINOS errors cannot be computed in weighted likelihood fits"");; 383 fConfig.SetMinosErrors(false);; 384 }; 385 ; 386 fBinFit = true;; 387 fDataSize = data->Size();; 388 ; 389 if (!fUseGradient) {; 390 // do minimization without using the gradient; 391 if (fFunc_v) {; 392 // create a chi2 function to be used for the equivalent chi-square; 393 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 394 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 395 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 396 } else {; 397 // create a chi2 function to be used for the equivalent chi-square; 398 Chi2FCN<BaseFunc> chi2(data, fFunc);; 399 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 400 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 401 }; 402 } else {; 403 if (fConfig.MinimizerOptions().PrintLevel() > 0); 404 MATH_INFO_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);;",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:15506,Testability,log,logl,15506,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:15719,Testability,log,logl,15719,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:15759,Testability,log,logl,15759,"O_MSG(""Fitter::DoLikelihoodFit"", ""use gradient from model function"");; 405 // not-extended is not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::d",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16253,Testability,log,logl,16253,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16448,Testability,log,logl,16448,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16488,Testability,log,logl,16488,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:16806,Testability,assert,assert,16806,"not implemented in this case; 406 if (!extended) {; 407 MATH_WARN_MSG(""Fitter::DoBinnedLikelihoodFit"",; 408 ""Not-extended binned fit with gradient not yet supported - do an extended fit"");; 409 extended = true;; 410 }; 411 if (fFunc_v) {; 412 // create a chi2 function to be used for the equivalent chi-square; 413 Chi2FCN<BaseFunc, IModelFunction_v> chi2(data, fFunc_v);; 414 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 415 if (!gradFun) {; 416 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 417 return false;; 418 }; 419 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 420 // do minimization; 421 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 422 } else {; 423 // create a chi2 function to be used for the equivalent chi-square; 424 Chi2FCN<BaseFunc> chi2(data, fFunc);; 425 // check if fFunc provides gradient; 426 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 427 if (!gradFun) {; 428 MATH_ERROR_MSG(""Fitter::DoBinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 429 return false;; 430 }; 431 // use gradient for minimization; 432 auto logl = std::make_unique<PoissonLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 433 // do minimization; 434 return (useWeight) ? DoWeightMinimization(std::move(logl),&chi2) : DoMinimization(std::move(logl),&chi2);; 435 }; 436 }; 437 return false;; 438}; 439 ; 440bool Fitter::DoUnbinnedLikelihoodFit(bool extended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:17607,Testability,log,logl,17607,"tended, const ROOT::EExecutionPolicy &executionPolicy) {; 441 // perform a likelihood fit on a set of unbinned data; 442 ; 443 std::shared_ptr<UnBinData> data = std::dynamic_pointer_cast<UnBinData>(fData);; 444 assert(data);; 445 ; 446 bool useWeight = fConfig.UseWeightCorrection();; 447 ; 448 if (!fFunc && !fFunc_v) {; 449 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"",""model function is not set"");; 450 return false;; 451 }; 452 ; 453 if (useWeight && fConfig.MinosErrors() ) {; 454 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"",""MINOS errors cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:17923,Testability,log,logl,17923,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18128,Testability,log,logl,18128,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18162,Testability,log,logl,18162,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18194,Testability,log,logl,18194,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18355,Testability,log,logl,18355,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:18389,Testability,log,logl,18389,"s cannot be computed in weighted likelihood fits"");; 455 fConfig.SetMinosErrors(false);; 456 }; 457 ; 458 ; 459 fBinFit = false;; 460 fDataSize = data->Size();; 461 ; 462#ifdef DEBUG; 463 int ipar = 0;; 464 std::cout << ""Fitter ParamSettings "" << Config().ParamsSettings()[ipar].IsBound() << "" lower limit "" << Config().ParamsSettings()[ipar].LowerLimit() << "" upper limit "" << Config().ParamsSettings()[ipar].UpperLimit() << std::endl;; 465#endif; 466 ; 467 // logl fit (error should be 0.5) set if different than default values (of 1); 468 if (fConfig.MinimizerOptions().ErrorDef() == gDefaultErrorDef ) {; 469 fConfig.MinimizerOptions().SetErrorDef(0.5);; 470 }; 471 ; 472 if (!fUseGradient) {; 473 // do minimization without using the gradient; 474 if (fFunc_v ){; 475 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc, IModelFunction_v>>(data, fFunc_v, useWeight, extended, executionPolicy);; 476 // do minimization; 477 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 478 } else {; 479 auto logl = std::make_unique<LogLikelihoodFCN<BaseFunc>>(data, fFunc, useWeight, extended, executionPolicy);; 480 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikeli",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19112,Testability,log,logl,19112,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19297,Testability,log,logl,19297,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19331,Testability,log,logl,19331,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19628,Testability,log,logl,19628,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19795,Testability,log,logl,19795,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:19829,Testability,log,logl,19829,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:20013,Testability,assert,assert,20013,"ht) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 481 }; 482 } else {; 483 // use gradient : check if fFunc provides gradient; 484 if (fConfig.MinimizerOptions().PrintLevel() > 0); 485 MATH_INFO_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""use gradient from model function"");; 486 if (extended) {; 487 MATH_WARN_MSG(""Fitter::DoUnbinnedLikelihoodFit"",; 488 ""Extended unbinned fit with gradient not yet supported - do a not-extended fit"");; 489 extended = false;; 490 }; 491 if (fFunc_v) {; 492 std::shared_ptr<IGradModelFunction_v> gradFun = std::dynamic_pointer_cast<IGradModelFunction_v>(fFunc_v);; 493 if (!gradFun) {; 494 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 495 return false;; 496 }; 497 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc, IModelFunction_v>>(data, gradFun, useWeight, extended, executionPolicy);; 498 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 499 } else {; 500 std::shared_ptr<IGradModelFunction> gradFun = std::dynamic_pointer_cast<IGradModelFunction>(fFunc);; 501 if (!gradFun) {; 502 MATH_ERROR_MSG(""Fitter::DoUnbinnedLikelihoodFit"", ""wrong type of function - it does not provide gradient"");; 503 return false;; 504 }; 505 auto logl = std::make_unique<LogLikelihoodFCN<BaseGradFunc>>(data, gradFun, useWeight, extended, executionPolicy);; 506 return (useWeight) ? DoWeightMinimization(std::move(logl)) : DoMinimization(std::move(logl));; 507 }; 508 }; 509 return false;; 510}; 511 ; 512 ; 513bool Fitter::DoLinearFit( ) {; 514 ; 515 std::shared_ptr<BinData> data = std::dynamic_pointer_cast<BinData>(fData);; 516 assert(data);; 517 ; 518 // perform a linear fit on a set of binned data; 519 std::string prevminimizer = fConfig.MinimizerType();; 520 fConfig.SetMinimizer(""Linear"");; 521 ; 522 fBinFit = true;; 523 ; 524 bool ret = DoLeastSquareFit();; 525 fConfig.SetMinimizer(prevminimizer.c_str());; 526 return ret;; 5",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:21694,Testability,assert,assert,21694,"ult; 533 if (!ObjFunction()) {; 534 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Objective function has not been set"");; 535 return false;; 536 }; 537 ; 538 // need a special treatment in case of weighted likelihood fit; 539 // (not yet implemented); 540 if (fFitType == 2 && fConfig.UseWeightCorrection() ) {; 541 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Re-computation of Hesse errors not implemented for weighted likelihood fits"");; 542 MATH_INFO_MSG(""Fitter::CalculateHessErrors"",""Do the Fit using configure option FitConfig::SetParabErrors()"");; 543 return false;; 544 }; 545 ; 546 // a fit Result pointer must exist when a minimizer exists; 547 if (fMinimizer && !fResult ) {; 548 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""FitResult has not been created"");; 549 return false;; 550 }; 551 ; 552 // update minimizer (recreate if not done or if name has changed; 553 if (!DoUpdateMinimizerOptions()) {; 554 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"",""Error re-initializing the minimizer"");; 555 return false;; 556 }; 557 ; 558 if (!fMinimizer ) {; 559 // this should not happen; 560 MATH_ERROR_MSG(""Fitter::CalculateHessErrors"", ""Need to do a fit before calculating the errors"");; 561 assert(false);; 562 return false;; 563 }; 564 ; 565 //run Hesse; 566 bool ret = fMinimizer->Hesse();; 567 if (!ret) MATH_WARN_MSG(""Fitter::CalculateHessErrors"",""Error when calculating Hessian"");; 568 ; 569 // update minimizer results with what comes out from Hesse; 570 // in case is empty - create from a FitConfig; 571 if (fResult->IsEmpty() ); 572 fResult = std::make_unique<ROOT::Fit::FitResult>(fConfig );; 573 ; 574 // update obj function in case it was an external one; 575 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 576 fResult->fObjFunc = fObjFunction;; 577 ; 578 // re-give a minimizer instance in case it has been changed; 579 ret |= fResult->Update(fMinimizer, fConfig, ret);; 580 ; 581 // when possible get ncalls from FCN and set in fit result; 582 if (fFitType",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:30719,Testability,assert,assert,30719,"erType()) {; 771 // if a different minimizer is allowed (e.g. when calling Hesse); 772 if (canDifferentMinim) {; 773 std::string msg = ""Using now "" + newMinimType;; 774 MATH_INFO_MSG(""Fitter::DoUpdateMinimizerOptions: "", msg.c_str());; 775 if (!DoInitMinimizer() ); 776 return false;; 777 }; 778 else {; 779 std::string msg = ""Cannot change minimizer. Continue using "" + fResult->MinimizerType();; 780 MATH_WARN_MSG(""Fitter::DoUpdateMinimizerOptions"",msg.c_str());; 781 }; 782 }; 783 ; 784 // create minimizer if it was not done before; 785 if (!fMinimizer) {; 786 if (!DoInitMinimizer()); 787 return false;; 788 }; 789 ; 790 // set new minimizer options (but not functions and parameters); 791 fMinimizer->SetOptions(fConfig.MinimizerOptions());; 792 return true;; 793}; 794 ; 795bool Fitter::DoMinimization(const ROOT::Math::IMultiGenFunction * chi2func) {; 796 // perform the minimization (assume we have already initialized the minimizer); 797 ; 798 assert(fMinimizer );; 799 ; 800 bool isValid = fMinimizer->Minimize();; 801 ; 802 if (!fResult) fResult = std::make_unique<FitResult>();; 803 ; 804 fResult->FillResult(fMinimizer,fConfig, fFunc, isValid, fDataSize, fFitType, chi2func );; 805 ; 806 // if requested run Minos after minimization; 807 if (isValid && fConfig.MinosErrors()) {; 808 // minos error calculation will update also FitResult; 809 CalculateMinosErrors();; 810 }; 811 ; 812 // when possible get number of calls from FCN and set in fit result; 813 if (fResult->fNCalls == 0 && fFitType != ROOT::Math::FitMethodFunction::kUndefined) {; 814 fResult->fNCalls = GetNCallsFromFCN();; 815 }; 816 ; 817 // fill information in fit result; 818 // if using an external obj function clone it for storing in FitResult; 819 if (fExtObjFunction) fObjFunction.reset(fExtObjFunction->Clone());; 820 fResult->fObjFunc = fObjFunction;; 821 fResult->fFitData = fData;; 822 ; 823#ifdef DEBUG; 824 std::cout << ""ROOT::Fit::Fitter::DoMinimization : ncalls = "" << fResult->fNCalls << "" type of objfunc",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:32961,Testability,log,logL,32961,"::IMultiGenFunction * chi2func) {; 837 // perform the minimization initializing the minimizer starting from a given obj function; 838 fFitType = objFunc->Type();; 839 fExtObjFunction = nullptr;; 840 fObjFunction = std::move(objFunc);; 841 if (!DoInitMinimizer()) return false;; 842 return DoMinimization(chi2func);; 843}; 844template<class ObjFunc_t>; 845bool Fitter::DoWeightMinimization(std::unique_ptr<ObjFunc_t> objFunc, const ROOT::Math::IMultiGenFunction * chi2func) {; 846 // perform the minimization initializing the minimizer starting from a given obj function; 847 // and apply afterwards the correction for weights. This applies only for logL fitting; 848 this->fFitType = objFunc->Type();; 849 fExtObjFunction = nullptr;; 850 // need to use a temporary shared pointer to the objective function since we cannot use the unique pointer when it has been moved; 851 std::shared_ptr<ObjFunc_t> sObjFunc{ std::move(objFunc)};; 852 fObjFunction = sObjFunc;; 853 if (!DoInitMinimizer()) return false;; 854 if (!DoMinimization(chi2func)) return false;; 855 sObjFunc->UseSumOfWeightSquare();; 856 return ApplyWeightCorrection(*sObjFunc);; 857}; 858 ; 859 ; 860void Fitter::DoUpdateFitConfig() {; 861 // update the fit configuration after a fit using the obtained result; 862 if (fResult->IsEmpty() || !fResult->IsValid() ) return;; 863 for (unsigned int i = 0; i < fConfig.NPar(); ++i) {; 864 ParameterSettings & par = fConfig.ParSettings(i);; 865 par.SetValue( fResult->Value(i) );; 866 if (fResult->Error(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else ",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:34705,Testability,log,loglikelihood,34705,"r(i) > 0) par.SetStepSize( fResult->Error(i) );; 867 }; 868}; 869 ; 870int Fitter::GetNCallsFromFCN() {; 871 // retrieve ncalls from the fit method functions; 872 // this function is called when minimizer does not provide a way of returning the number of function calls; 873 int ncalls = 0;; 874 if (!fUseGradient) {; 875 const ROOT::Math::FitMethodFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodFunction *>(fObjFunction.get());; 876 if (fcn) ncalls = fcn->NCalls();; 877 }; 878 else {; 879 const ROOT::Math::FitMethodGradFunction * fcn = dynamic_cast<const ROOT::Math::FitMethodGradFunction*>(fObjFunction.get());; 880 if (fcn) ncalls = fcn->NCalls();; 881 }; 882 return ncalls;; 883}; 884 ; 885 ; 886bool Fitter::ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L) {; 887 // apply correction for weight square; 888 // Compute Hessian of the loglikelihood function using the sum of the weight squared; 889 // This method assumes:; 890 // - a fit has been done before and a covariance matrix exists; 891 // - the objective function is a likelihood function and Likelihood::UseSumOfWeightSquare(); 892 // has been called before; 893 ; 894 if (fMinimizer == nullptr) {; 895 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Must perform first a fit before applying the correction"");; 896 return false;; 897 }; 898 ; 899 unsigned int n = loglw2.NDim();; 900 // correct errors for weight squared; 901 std::vector<double> cov(n*n);; 902 bool ret = fMinimizer->GetCovMatrix(&cov[0] );; 903 if (!ret) {; 904 MATH_ERROR_MSG(""Fitter::ApplyWeightCorrection"",""Previous fit has no valid Covariance matrix"");; 905 return false;; 906 }; 907 // need to use new obj function computed with weight-square; 908 std::shared_ptr<ROOT::Math::IMultiGenFunction> objFunc(loglw2.Clone());; 909 fObjFunction.swap( objFunc );; 910 ; 911 // need to re-initialize the minimizer for the changes applied in the; 912 // objective functions; 913 if (!DoInitMinimizer()) return false;; 914 ; 9",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:36018,Testability,log,log-likelihood,36018,,MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:39478,Usability,simpl,simply,39478,"s when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoodFCN.h; MinimizerOptions.h; Minimizer.h; MultiDimParamFunctionAdapter.h; PoissonLikelihoodFCN.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefi",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8cxx_source.html:43833,Usability,simpl,simple,43833,"nfig::CreateMinimizerROOT::Math::Minimizer * CreateMinimizer()create a new minimizer according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false",MatchSource.WIKI,doc/master/Fitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html
https://root.cern/doc/master/Fitter_8h.html:441,Integrability,depend,dependency,441,". ROOT: math/mathcore/inc/Fit/Fitter.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs ; Fitter.h File Reference. #include ""Fit/BinData.h""; #include ""Fit/UnBinData.h""; #include ""Fit/FitConfig.h""; #include ""ROOT/EExecutionPolicy.hxx""; #include ""Fit/FitResult.h""; #include ""Math/IParamFunction.h""; #include <memory>; #include ""Math/WrappedFunction.h"". Include dependency graph for Fitter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class ROOT::Fit::Fitter; Fitter class, entry point for performing all type of fits. More...; . Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; ; namespace ROOT::Fit; Namespace for the fitting classes. ; ; namespace ROOT::Math; . Typedefs; typedef BasicFitMethodFunction< ROOT::Math::IMultiGenFunction >ROOT::Math::FitMethodFunction; ; typedef BasicFitMethodFunction< ROOT::Math::IMultiGradFunction >ROOT::Math::FitMethodGradFunction; . mathmathcoreincFitFitter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/Fitter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h.html
https://root.cern/doc/master/Fitter_8h.html:781,Performance,perform,performing,781,". ROOT: math/mathcore/inc/Fit/Fitter.h File Reference. ; ROOT ; . master. Reference Guide ; . . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs ; Fitter.h File Reference. #include ""Fit/BinData.h""; #include ""Fit/UnBinData.h""; #include ""Fit/FitConfig.h""; #include ""ROOT/EExecutionPolicy.hxx""; #include ""Fit/FitResult.h""; #include ""Math/IParamFunction.h""; #include <memory>; #include ""Math/WrappedFunction.h"". Include dependency graph for Fitter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class ROOT::Fit::Fitter; Fitter class, entry point for performing all type of fits. More...; . Namespaces; namespace ROOT; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; ; namespace ROOT::Fit; Namespace for the fitting classes. ; ; namespace ROOT::Math; . Typedefs; typedef BasicFitMethodFunction< ROOT::Math::IMultiGenFunction >ROOT::Math::FitMethodFunction; ; typedef BasicFitMethodFunction< ROOT::Math::IMultiGradFunction >ROOT::Math::FitMethodGradFunction; . mathmathcoreincFitFitter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8 ; . ",MatchSource.WIKI,doc/master/Fitter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h.html
https://root.cern/doc/master/Fitter_8h_source.html:2386,Availability,error,errors,2386,"Math::IMultiGenFunction> FitMethodFunction;; 44 typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;; 45 ; 46 }; 47 ; 48 /**; 49 Namespace for the fitting classes; 50 @ingroup Fit; 51 */; 52 ; 53 namespace Fit {; 54 ; 55/**; 56 @defgroup FitMain User Fitting classes; 57 ; 58 Main Classes used for fitting a given data set; 59 @ingroup Fit; 60*/; 61 ; 62 ; 63//___________________________________________________________________________________; 64/**; 65 Fitter class, entry point for performing all type of fits.; 66 Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; 67 The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); 68 The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; 69 The configuration of the fit (parameters, options, etc...) are specified in the; 70 ROOT::Math::FitConfig class.; 71 After fitting the config of the fit will be modified to have the new values the resulting; 72 parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; 73 initial parameters by calling FitConfig.SetUpdateAfterFit(false);; 74 ; 75 @ingroup FitMain; 76*/; 77class Fitter {; 78 ; 79public:; 80 ; 81 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 82 template <class T>; 83 using IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>;; 84#ifdef R__HAS_VECCORE; 85 typedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; 92 typedef ROOT::Math::IParamFunction IModel1DFunction;; 93 typedef ROOT::Math::IParamGradFunction IGradModel1DFunction;; 94 ; 95 typedef ROOT::Math::IMultiGenFuncti",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16148,Availability,error,error,16148," NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binn",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16379,Availability,error,error,16379," NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binn",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16540,Availability,error,error,16540,"& func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed t",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16682,Availability,error,error,16682,"& func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed t",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:18572,Availability,error,error,18572," class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-likelihood function implemented using the; 464 sum of weight squared; 465 When using FitConfig.SetWeightCorrection() this correction is applied; 466 automatically when doing a likelihood fit (binned or unbinned); 467 */; 468 bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L=false);; 469 ; 470 /// Set number of fit points when using an external FCN function; 471 /// This function can be called after Fit to set the correct number of Ndf in FitResult; 472 void SetNumberOfFitPoints(unsigned int npoints) {; 473 if (fExtObjFunction) fDataSize = npoints;; 474 if (!fResult->IsEmpty()) fResult->SetChi2AndNdf(-1,npoints);; 475 }; 476 ; 477 /// Set the type of fit when using an external FCN; 478 /// possible types are : 1 (least-square), 2 (unbinned-likelihood), 3 (binned-likelihood); 479 /// Note that in case of binned likelihood fit ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:22645,Availability,error,error,22645,"<Data> & data) {; 521 fData = std::static_pointer_cast<Data>(data);; 522 }; 523 ; 524 /// Set the input data for the fit (Copying the given data object); 525 template <class Data>; 526 void SetData(const Data & data) {; 527 auto dataClone = std::make_shared<Data>(data);; 528 SetData(dataClone);; 529 }; 530 ; 531 /// look at the user provided FCN and get data and model function is; 532 /// they derive from ROOT::Fit FCN classes; 533 void ExamineFCN();; 534 ; 535 ; 536 /// internal functions to get data set and model function from FCN; 537 /// useful for fits done with customized FCN classes; 538 template <class ObjFuncType>; 539 bool GetDataFromFCN();; 540 ; 541 /// Return pointer to the used objective function for fitting.; 542 /// If using an external function (e.g. given in SetFCN), return the cached pointer,; 543 /// otherwise use the one stored as shared ptr and managed by the Fitter class; 544 const ROOT::Math::IBaseFunctionMultiDimTempl<double> * ObjFunction() const {; 545 // need to specify here full return type since when using the typedef (IMultiGenFunction); 546 // there is an error when using the class in Python (see issue #12391); 547 return (fExtObjFunction) ? fExtObjFunction : fObjFunction.get();; 548 }; 549 ; 550private:; 551 ; 552 bool fUseGradient = false; ///< flag to indicate if using gradient or not; 553 ; 554 bool fBinFit = false; ///< flag to indicate if fit is binned; 555 ///< in case of false the fit is unbinned or undefined); 556 ///< flag it is used to compute chi2 for binned likelihood fit; 557 ; 558 int fFitType = 0; ///< type of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood); 559 ; 560 int fDataSize = 0; ///< size of data sets (need for Fumili or LM fitters); 561 ; 562 FitConfig fConfig; ///< fitter configuration (options and parameter settings); 563 ; 564 std::shared_ptr<IModelFunction_v> fFunc_v; ///<! copy of the fitted function containing on output the fit result; 565 ; 566 std::shared_ptr<IModelFunction> fFunc;",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:28646,Availability,error,error,28646,"ualXProxy.cxx:174; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; UnBinData.h; WrappedFunction.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::L",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:35541,Availability,error,error,35541,"t::Fitter::LinearFitbool LinearFit(const std::shared_ptr< BinData > &data)Do a linear fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:254; ROOT::Fit::Fitter::fObjFunctionstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunction! pointer to used objective functionDefinition Fitter.h:574; ROOT::Fit::Fitter::SetFitTypevoid SetFitType(int type)Set the type of fit when using an external FCN possible types are : 1 (least-square),...Definition Fitter.h:481; ROOT::Fit::Fitter::~Fittervirtual ~Fitter()Destructor.Definition Fitter.h:117; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit.Definition Fitter.h:165; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error matrix for the weights for likelihood fits This method can be called on...Definition Fitter.cxx:886; ROOT::Fit::Fitter::BaseGradFuncROOT::Math::IMultiGradFunction BaseGradFuncDefinition Fitter.h:96; ROOT::Fit::Fitter::ExamineFCNvoid ExamineFCN()look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN class...Definition Fitter.cxx:979; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetDatavoid SetData(const std::shared_ptr< Data > &data)Set the input data for the fit using a shared ptr (No Copying)Definition Fitter.h:520; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition Fitter.h:81;",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:38210,Availability,error,error,38210,"ntaining on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::IGradModelFunction_vROOT::Math::IParamMultiGradFunction IGradModelFunction_vDefinition Fitter.h:89; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< BinData > &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:212; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted functi",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:39372,Availability,error,error,39372,")=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const doubl",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:2129,Deployability,configurat,configuration,2129,"fwd file; 40 template<class FunctionType> class BasicFitMethodFunction;; 41 ; 42 // define the normal and gradient function; 43 typedef BasicFitMethodFunction<ROOT::Math::IMultiGenFunction> FitMethodFunction;; 44 typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;; 45 ; 46 }; 47 ; 48 /**; 49 Namespace for the fitting classes; 50 @ingroup Fit; 51 */; 52 ; 53 namespace Fit {; 54 ; 55/**; 56 @defgroup FitMain User Fitting classes; 57 ; 58 Main Classes used for fitting a given data set; 59 @ingroup Fit; 60*/; 61 ; 62 ; 63//___________________________________________________________________________________; 64/**; 65 Fitter class, entry point for performing all type of fits.; 66 Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; 67 The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); 68 The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; 69 The configuration of the fit (parameters, options, etc...) are specified in the; 70 ROOT::Math::FitConfig class.; 71 After fitting the config of the fit will be modified to have the new values the resulting; 72 parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; 73 initial parameters by calling FitConfig.SetUpdateAfterFit(false);; 74 ; 75 @ingroup FitMain; 76*/; 77class Fitter {; 78 ; 79public:; 80 ; 81 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 82 template <class T>; 83 using IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>;; 84#ifdef R__HAS_VECCORE; 85 typedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16983,Deployability,configurat,configuration,16983, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:17112,Deployability,configurat,configuration,17112, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:21158,Deployability,update,update,21158,"/ un-binned likelihood fit; 494 bool DoUnbinnedLikelihoodFit( bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 495 /// linear least square fit; 496 bool DoLinearFit();; 497 /// Set Objective function; 498 bool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize,; 499 int fitType);; 500 ; 501 // initialize the minimizer; 502 bool DoInitMinimizer();; 503 /// do minimization; 504 template<class ObjFunc_t>; 505 bool DoMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 506 // do minimization for weighted likelihood fits; 507 template<class ObjFunc_t>; 508 bool DoWeightMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 509 // do minimization after having set the objective function; 510 bool DoMinimization(const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 511 // update config after fit; 512 void DoUpdateFitConfig();; 513 // update minimizer options for re-fitting; 514 bool DoUpdateMinimizerOptions(bool canDifferentMinim = true);; 515 // get function calls from the FCN; 516 int GetNCallsFromFCN();; 517 ; 518 /// Set the input data for the fit using a shared ptr (No Copying); 519 template <class Data>; 520 void SetData(const std::shared_ptr<Data> & data) {; 521 fData = std::static_pointer_cast<Data>(data);; 522 }; 523 ; 524 /// Set the input data for the fit (Copying the given data object); 525 template <class Data>; 526 void SetData(const Data & data) {; 527 auto dataClone = std::make_shared<Data>(data);; 528 SetData(dataClone);; 529 }; 530 ; 531 /// look at the user provided FCN and get data and model function is; 532 /// they derive from ROOT::Fit FCN classes; 533 void ExamineFCN();; 534 ; 535 ; 536 /// internal functions to get data set and model function from FCN; 537 /// useful for fits done with customized FCN classes; 538 template <class Obj",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:21221,Deployability,update,update,21221,"ool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 495 /// linear least square fit; 496 bool DoLinearFit();; 497 /// Set Objective function; 498 bool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize,; 499 int fitType);; 500 ; 501 // initialize the minimizer; 502 bool DoInitMinimizer();; 503 /// do minimization; 504 template<class ObjFunc_t>; 505 bool DoMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 506 // do minimization for weighted likelihood fits; 507 template<class ObjFunc_t>; 508 bool DoWeightMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 509 // do minimization after having set the objective function; 510 bool DoMinimization(const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 511 // update config after fit; 512 void DoUpdateFitConfig();; 513 // update minimizer options for re-fitting; 514 bool DoUpdateMinimizerOptions(bool canDifferentMinim = true);; 515 // get function calls from the FCN; 516 int GetNCallsFromFCN();; 517 ; 518 /// Set the input data for the fit using a shared ptr (No Copying); 519 template <class Data>; 520 void SetData(const std::shared_ptr<Data> & data) {; 521 fData = std::static_pointer_cast<Data>(data);; 522 }; 523 ; 524 /// Set the input data for the fit (Copying the given data object); 525 template <class Data>; 526 void SetData(const Data & data) {; 527 auto dataClone = std::make_shared<Data>(data);; 528 SetData(dataClone);; 529 }; 530 ; 531 /// look at the user provided FCN and get data and model function is; 532 /// they derive from ROOT::Fit FCN classes; 533 void ExamineFCN();; 534 ; 535 ; 536 /// internal functions to get data set and model function from FCN; 537 /// useful for fits done with customized FCN classes; 538 template <class ObjFuncType>; 539 bool GetDataFromFCN();; 540 ; 541 /// Return poi",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:23321,Deployability,configurat,configuration,23321,,MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:28726,Deployability,configurat,configuration,28726,"n GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; UnBinData.h; WrappedFunction.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool Le",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:33606,Deployability,configurat,configuration,33606,"Sequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::GetFCNROOT::Math::IMultiGenFunction * GetFCN() constreturn pointer to last used objective function (is NULL in case fit is not yet done) This pointer wil...Definition Fitter.h:455; ROOT::Fit::Fitter::IGradModel1DFunctionROOT::Math::IParamGradFunction IGradModel1DFunctionDefinition Fitter.h:93; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::GetMinimizerROOT::Math::Minimizer * GetMinimizer() constreturn pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guarantee...Definition Fitter.h:444; ROOT::Fit::Fitter::BaseFuncROOT::Math::IMultiGenFunction BaseFuncDefinition Fitter.h:95; ROOT::Fit::Fitter::ConfigFitConfig & Config()access to the configuration (non const method)Definition Fitter.h:427; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::SetNumberOfFitPointsvoid SetNumberOfFitPoints(unsigned int npoints)Set number of fit points when using an external FCN function This function can be called after Fit to...Definition Fitter.h:472; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::MinuitFCN_tvoid(* MinuitFCN_t)(int &npar, double *gin, double &f, double *u, int flag)fit using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters ...Definition Fitter.h:339; ROOT::Fit::Fitter::IsBinFitbool IsBinFit() constquery if fit is binned.Definition Fitter.h:433; ROOT::Fit::Fitter::LinearFitbool LinearFit(const std::shared_ptr< BinData > &data)Do a linear fit using a shar",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:35998,Deployability,configurat,configuration,35998,"1; ROOT::Fit::Fitter::~Fittervirtual ~Fitter()Destructor.Definition Fitter.h:117; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit.Definition Fitter.h:165; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error matrix for the weights for likelihood fits This method can be called on...Definition Fitter.cxx:886; ROOT::Fit::Fitter::BaseGradFuncROOT::Math::IMultiGradFunction BaseGradFuncDefinition Fitter.h:96; ROOT::Fit::Fitter::ExamineFCNvoid ExamineFCN()look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN class...Definition Fitter.cxx:979; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetDatavoid SetData(const std::shared_ptr< Data > &data)Set the input data for the fit using a shared ptr (No Copying)Definition Fitter.h:520; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition Fitter.h:81; ROOT::Fit::Fitter::IModel1DFunctionROOT::Math::IParamFunction IModel1DFunctionDefinition Fitter.h:92; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const BinData &data, bool extended=true, const ROOT::EExecu",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:39542,Deployability,configurat,configuration,39542,"ion Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT:",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:4578,Integrability,interface,interface,4578,"94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value ||; 142 std::is_same<Function, int>::value),; 143 Function>::type>; 144 bool Fit(const Data &data, const Function &func,; 145 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential); 146 {; 147 SetFunction(func);; 148 return Fit(data, executionPolicy);; 149 }; 150 ; 151 /**; 152 Fit a binned data set using a least square fit.; 153 Note that the provided input data are copied in the Fitter class.; 154 Use the next func",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8872,Integrability,interface,interface,8872," SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that the function dimension (i.e. the number of parameter) is needed in this case; 263 For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..); 264 */; 265 template <class Function>; 266 bool FitFCN(unsigned int npar, Function & fcn, const double * params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 267 ; 268 /**; 269 Set a generic FCN function as a C++ callable object implementing; 270 double () (const double *); 271 Note that the function dimension (i.e. the number of parameter) is needed in this case; 272 For the options see documentation for following methods Fit",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:10570,Integrability,interface,interface,10570,"{; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that the function dimension (i.e. the number of parameter) is needed in this case; 263 For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..); 264 */; 265 template <class Function>; 266 bool FitFCN(unsigned int npar, Function & fcn, const double * params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 267 ; 268 /**; 269 Set a generic FCN function as a C++ callable object implementing; 270 double () (const double *); 271 Note that the function dimension (i.e. the number of parameter) is needed in this case; 272 For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..); 273 */; 274 template <class Function>; 275 bool SetFCN(unsigned int npar, Function & fcn, const double * params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 276 ; 277 /**; 278 Fit using the given FCN function represented by a multi-dimensional function interface; 279 (ROOT::Math::IMultiGenFunction).; 280 Give optionally the initial parameter values, data size to have the fit Ndf correctly; 281 set in the FitResult and flag specifying the type of fit. The fitType can be:; 282 0 undefined, 1 least square fit, 2 unbinned likelihood fit, 3 binned likelihood fit; 283 Note that if the parameters values are not given (params=0) the; 284 current parameter settings are used. The parameter settings can be created before; 285 by using the FitConfig::SetParamsSetting. If they have not been created they are created; 286 automatically when the params pointer is not zero.; 287 Note that passing a params != 0 will set the parameter settings to the new value AND also the; 288 step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ); 289 */; 290 bool FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = n",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:11563,Integrability,interface,interface,11563,"t fitType = 0);; 276 ; 277 /**; 278 Fit using the given FCN function represented by a multi-dimensional function interface; 279 (ROOT::Math::IMultiGenFunction).; 280 Give optionally the initial parameter values, data size to have the fit Ndf correctly; 281 set in the FitResult and flag specifying the type of fit. The fitType can be:; 282 0 undefined, 1 least square fit, 2 unbinned likelihood fit, 3 binned likelihood fit; 283 Note that if the parameters values are not given (params=0) the; 284 current parameter settings are used. The parameter settings can be created before; 285 by using the FitConfig::SetParamsSetting. If they have not been created they are created; 286 automatically when the params pointer is not zero.; 287 Note that passing a params != 0 will set the parameter settings to the new value AND also the; 288 step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ); 289 */; 290 bool FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 291 ; 292 /**; 293 Fit using a FitMethodFunction interface. Same as method above, but now extra information; 294 can be taken from the function class; 295 */; 296 bool FitFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 297 ; 298 /**; 299 Set the FCN function represented by a multi-dimensional function interface; 300 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 301 See also note above for the initial parameters for FitFCN; 302 */; 303 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 304 ; 305 /**; 306 Set the FCN function represented by a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:11850,Integrability,interface,interface,11850,".; 287 Note that passing a params != 0 will set the parameter settings to the new value AND also the; 288 step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ); 289 */; 290 bool FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 291 ; 292 /**; 293 Fit using a FitMethodFunction interface. Same as method above, but now extra information; 294 can be taken from the function class; 295 */; 296 bool FitFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 297 ; 298 /**; 299 Set the FCN function represented by a multi-dimensional function interface; 300 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 301 See also note above for the initial parameters for FitFCN; 302 */; 303 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 304 ; 305 /**; 306 Set the FCN function represented by a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:12227,Integrability,interface,interface,12227,".; 287 Note that passing a params != 0 will set the parameter settings to the new value AND also the; 288 step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ); 289 */; 290 bool FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 291 ; 292 /**; 293 Fit using a FitMethodFunction interface. Same as method above, but now extra information; 294 can be taken from the function class; 295 */; 296 bool FitFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 297 ; 298 /**; 299 Set the FCN function represented by a multi-dimensional function interface; 300 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 301 See also note above for the initial parameters for FitFCN; 302 */; 303 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 304 ; 305 /**; 306 Set the FCN function represented by a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
