id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/Fitter_8h_source.html:12390,Integrability,interface,interface,12390,".; 287 Note that passing a params != 0 will set the parameter settings to the new value AND also the; 288 step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ); 289 */; 290 bool FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 291 ; 292 /**; 293 Fit using a FitMethodFunction interface. Same as method above, but now extra information; 294 can be taken from the function class; 295 */; 296 bool FitFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 297 ; 298 /**; 299 Set the FCN function represented by a multi-dimensional function interface; 300 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 301 See also note above for the initial parameters for FitFCN; 302 */; 303 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 304 ; 305 /**; 306 Set the FCN function represented by a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:12788,Integrability,interface,interface,12788,".; 287 Note that passing a params != 0 will set the parameter settings to the new value AND also the; 288 step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ); 289 */; 290 bool FitFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 291 ; 292 /**; 293 Fit using a FitMethodFunction interface. Same as method above, but now extra information; 294 can be taken from the function class; 295 */; 296 bool FitFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 297 ; 298 /**; 299 Set the FCN function represented by a multi-dimensional function interface; 300 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 301 See also note above for the initial parameters for FitFCN; 302 */; 303 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 304 ; 305 /**; 306 Set the FCN function represented by a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:13044,Integrability,interface,interface,13044,"rameters; 301 See also note above for the initial parameters for FitFCN; 302 */; 303 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 304 ; 305 /**; 306 Set the FCN function represented by a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 326 ; 327 /**; 328 Set the objective function (FCN) using a FitMethodGradFunction interface.; 329 Same as method above, but now extra information can be taken from the function class; 330 */; 331 bool SetFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn,",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:13333,Integrability,interface,interface,13333,"a multi-dimensional function interface; 307 (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; 308 See also note above for the initial parameters for FitFCN; 309 With this interface we pass in addition a ModelFunction that will be attached to the FitResult and; 310 used to compute confidence interval of the fit; 311 */; 312 bool SetFCN(const ROOT::Math::IMultiGenFunction &fcn, const IModelFunction & func, const double *params = nullptr,; 313 unsigned int dataSize = 0, int fitType = 0);; 314 ; 315 /**; 316 Set the objective function (FCN) using a FitMethodFunction interface.; 317 Same as method above, but now extra information can be taken from the function class; 318 */; 319 bool SetFCN(const ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 326 ; 327 /**; 328 Set the objective function (FCN) using a FitMethodGradFunction interface.; 329 Same as method above, but now extra information can be taken from the function class; 330 */; 331 bool SetFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter setti",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:13610,Integrability,interface,interface,13610,"nst ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 326 ; 327 /**; 328 Set the objective function (FCN) using a FitMethodGradFunction interface.; 329 Same as method above, but now extra information can be taken from the function class; 330 */; 331 bool SetFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 345 For the options same consideration as in the previous method; 346 */; 347 bool SetFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted fun",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:14102,Integrability,interface,interface,14102,"nst ROOT::Math::FitMethodFunction & fcn, const double *params = nullptr);; 320 ; 321 /**; 322 Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; 323 can be taken from the function class; 324 */; 325 bool FitFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 326 ; 327 /**; 328 Set the objective function (FCN) using a FitMethodGradFunction interface.; 329 Same as method above, but now extra information can be taken from the function class; 330 */; 331 bool SetFCN(const ROOT::Math::FitMethodGradFunction & fcn, const double *params = nullptr);; 332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 345 For the options same consideration as in the previous method; 346 */; 347 bool SetFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted fun",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:14782,Integrability,interface,interface,14782,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:14977,Integrability,interface,interface,14977,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:15493,Integrability,interface,interface,15493,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:15688,Integrability,interface,interface,15688,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:15862,Integrability,interface,interface,15862,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:34309,Integrability,interface,interface,34309,":Fit::Fitter::GetMinimizerROOT::Math::Minimizer * GetMinimizer() constreturn pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guarantee...Definition Fitter.h:444; ROOT::Fit::Fitter::BaseFuncROOT::Math::IMultiGenFunction BaseFuncDefinition Fitter.h:95; ROOT::Fit::Fitter::ConfigFitConfig & Config()access to the configuration (non const method)Definition Fitter.h:427; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::SetNumberOfFitPointsvoid SetNumberOfFitPoints(unsigned int npoints)Set number of fit points when using an external FCN function This function can be called after Fit to...Definition Fitter.h:472; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::MinuitFCN_tvoid(* MinuitFCN_t)(int &npar, double *gin, double &f, double *u, int flag)fit using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters ...Definition Fitter.h:339; ROOT::Fit::Fitter::IsBinFitbool IsBinFit() constquery if fit is binned.Definition Fitter.h:433; ROOT::Fit::Fitter::LinearFitbool LinearFit(const std::shared_ptr< BinData > &data)Do a linear fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:254; ROOT::Fit::Fitter::fObjFunctionstd::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunction! pointer to used objective functionDefinition Fitter.h:574; ROOT::Fit::Fitter::SetFitTypevoid SetFitType(int type)Set the type of fit when using an external FCN possible types are : 1 (least-square),...Definition Fitter.h:481; ROOT::Fit::Fitter::~Fittervirtual ~Fitter()Destructor.Definition Fitter.h:117; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fi",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:39261,Integrability,interface,interface,39261,"lculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:40019,Integrability,interface,interface,40019,"EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:195; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit copying the input data ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:40428,Integrability,interface,interface,40428,"ors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:195; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit copying the input data Default is NOT extended.Definition Fitter.h:221; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Def",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:41960,Integrability,interface,interface,41960,"efault is NOT extended.Definition Fitter.h:221; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Math::BasicFitMethodFunctionFitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) ...Definition FitMethodFunction.h:38; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunction.h:168; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::IParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is ...Definition IParamFunction.h:161; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; MathNamespace for new Math classes and functions.; ROOT::Math::FitMethodFunct",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:42493,Integrability,interface,interface,42493,"nd likelihood used in the fit) ...Definition FitMethodFunction.h:38; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunction.h:168; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::IParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is ...Definition IParamFunction.h:161; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; MathNamespace for new Math classes and functions.; ROOT::Math::FitMethodFunctionBasicFitMethodFunction< ROOT::Math::IMultiGenFunction > FitMethodFunctionDefinition Fitter.h:43; ROOT::Math::FitMethodGradFunctionBasicFitMethodFunction< ROOT::Math::IMultiGradFunction > FitMethodGradFunctionDefinition Fitter.h:44; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EExecutionPolicyEExecutionPolicyDefinition EExecutionPolicy.hxx:5; ROOT::EExecutionPolicy::kSequential@ kSequential. mathmathcoreincFitFitter.h. ROOT master - Referenc",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:42624,Integrability,wrap,wrap,42624,"BaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunction.h:168; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::IParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is ...Definition IParamFunction.h:161; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::IParametricGradFunctionOneDimInterface (abstract class) for parametric one-dimensional gradient functions providing in addition to...Definition IParamFunction.h:330; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; RooFit::MinimizerRooCmdArg Minimizer(const char *type, const char *alg=nullptr)Definition RooGlobalFunc.cxx:751; MathNamespace for new Math classes and functions.; ROOT::Math::FitMethodFunctionBasicFitMethodFunction< ROOT::Math::IMultiGenFunction > FitMethodFunctionDefinition Fitter.h:43; ROOT::Math::FitMethodGradFunctionBasicFitMethodFunction< ROOT::Math::IMultiGradFunction > FitMethodGradFunctionDefinition Fitter.h:44; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::EExecutionPolicyEExecutionPolicyDefinition EExecutionPolicy.hxx:5; ROOT::EExecutionPolicy::kSequential@ kSequential. mathmathcoreincFitFitter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:39 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:2129,Modifiability,config,configuration,2129,"fwd file; 40 template<class FunctionType> class BasicFitMethodFunction;; 41 ; 42 // define the normal and gradient function; 43 typedef BasicFitMethodFunction<ROOT::Math::IMultiGenFunction> FitMethodFunction;; 44 typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;; 45 ; 46 }; 47 ; 48 /**; 49 Namespace for the fitting classes; 50 @ingroup Fit; 51 */; 52 ; 53 namespace Fit {; 54 ; 55/**; 56 @defgroup FitMain User Fitting classes; 57 ; 58 Main Classes used for fitting a given data set; 59 @ingroup Fit; 60*/; 61 ; 62 ; 63//___________________________________________________________________________________; 64/**; 65 Fitter class, entry point for performing all type of fits.; 66 Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; 67 The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); 68 The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; 69 The configuration of the fit (parameters, options, etc...) are specified in the; 70 ROOT::Math::FitConfig class.; 71 After fitting the config of the fit will be modified to have the new values the resulting; 72 parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; 73 initial parameters by calling FitConfig.SetUpdateAfterFit(false);; 74 ; 75 @ingroup FitMain; 76*/; 77class Fitter {; 78 ; 79public:; 80 ; 81 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 82 template <class T>; 83 using IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>;; 84#ifdef R__HAS_VECCORE; 85 typedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:2260,Modifiability,config,config,2260,"Math::IMultiGenFunction> FitMethodFunction;; 44 typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;; 45 ; 46 }; 47 ; 48 /**; 49 Namespace for the fitting classes; 50 @ingroup Fit; 51 */; 52 ; 53 namespace Fit {; 54 ; 55/**; 56 @defgroup FitMain User Fitting classes; 57 ; 58 Main Classes used for fitting a given data set; 59 @ingroup Fit; 60*/; 61 ; 62 ; 63//___________________________________________________________________________________; 64/**; 65 Fitter class, entry point for performing all type of fits.; 66 Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; 67 The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); 68 The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; 69 The configuration of the fit (parameters, options, etc...) are specified in the; 70 ROOT::Math::FitConfig class.; 71 After fitting the config of the fit will be modified to have the new values the resulting; 72 parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; 73 initial parameters by calling FitConfig.SetUpdateAfterFit(false);; 74 ; 75 @ingroup FitMain; 76*/; 77class Fitter {; 78 ; 79public:; 80 ; 81 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 82 template <class T>; 83 using IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>;; 84#ifdef R__HAS_VECCORE; 85 typedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; 92 typedef ROOT::Math::IParamFunction IModel1DFunction;; 93 typedef ROOT::Math::IParamGradFunction IGradModel1DFunction;; 94 ; 95 typedef ROOT::Math::IMultiGenFuncti",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:3666,Modifiability,extend,extend,3666," 83 using IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>;; 84#ifdef R__HAS_VECCORE; 85 typedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; 92 typedef ROOT::Math::IParamFunction IModel1DFunction;; 93 typedef ROOT::Math::IParamGradFunction IGradModel1DFunction;; 94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object ar",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:4454,Modifiability,extend,extended,4454,"94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value ||; 142 std::is_same<Function, int>::value),; 143 Function>::type>; 144 bool Fit(const Data &data, const Function &func,; 145 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential); 146 {; 147 SetFunction(func);; 148 return Fit(data, executionPolicy);; 149 }; 150 ; 151 /**; 152 Fit a binned data set using a least square fit.; 153 Note that the provided input data are copied in the Fitter class.; 154 Use the next func",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:6709,Modifiability,extend,extended,6709,"ExecutionPolicy::kSequential) {; 166 return LeastSquareFit(data, executionPolicy);; 167 }; 168 ; 169 /**; 170 Fit a binned data set using a least square fit copying the input data.; 171 */; 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bo",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:6846,Modifiability,extend,extended,6846,"ExecutionPolicy::kSequential) {; 166 return LeastSquareFit(data, executionPolicy);; 167 }; 168 ; 169 /**; 170 Fit a binned data set using a least square fit copying the input data.; 171 */; 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bo",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7103,Modifiability,extend,extended,7103,"ionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7240,Modifiability,extend,extended,7240,"ionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7357,Modifiability,extend,extended,7357,"Data> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7425,Modifiability,extend,extended,7425," /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBin",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7588,Modifiability,extend,extended,7588," /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBin",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7728,Modifiability,extend,extended,7728,"e, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(exten",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7813,Modifiability,extend,extended,7813,"ata, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7976,Modifiability,extend,extended,7976,"ata, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8093,Modifiability,extend,extended,8093,"ata, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8163,Modifiability,extend,extended,8163,"ata, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8324,Modifiability,extend,extended,8324,"ata, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8471,Modifiability,extend,extended,8471,"fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8558,Modifiability,extend,extended,8558,"fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:8719,Modifiability,extend,extended,8719,"fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPolicy);; 216 }; 217 /**; 218 Un-binned Likelihood fit copying the input data; 219 Default is NOT extended; 220 */; 221 bool LikelihoodFit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 222 SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:9059,Modifiability,extend,extended,9059," SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that the function dimension (i.e. the number of parameter) is needed in this case; 263 For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..); 264 */; 265 template <class Function>; 266 bool FitFCN(unsigned int npar, Function & fcn, const double * params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 267 ; 268 /**; 269 Set a generic FCN function as a C++ callable object implementing; 270 double () (const double *); 271 Note that the function dimension (i.e. the number of parameter) is needed in this case; 272 For the options see documentation for following methods Fit",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:9127,Modifiability,extend,extended,9127," SetData(data);; 223 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 224 }; 225 /**; 226 Un-binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 227 Default is NOT extended; 228 */; 229 bool LikelihoodFit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 230 SetData(data);; 231 return DoUnbinnedLikelihoodFit(extended, executionPolicy);; 232 }; 233 ; 234 /**; 235 Likelihood fit given a data set (Binned or Un-binned) using any generic model function.; 236 This interface copies the input data and the model function object; 237 */; 238 template < class Data , class Function>; 239 bool LikelihoodFit( const Data & data, const Function & func, bool extended) {; 240 SetFunction(func);; 241 return LikelihoodFit(data, extended);; 242 }; 243 ; 244 /**; 245 Do a linear fit copying the input data; 246 */; 247 bool LinearFit(const BinData & data) {; 248 SetData(data);; 249 return DoLinearFit();; 250 }; 251 /**; 252 Do a linear fit using a `shared_ptr` for NOT copying the input data; 253 */; 254 bool LinearFit(const std::shared_ptr<BinData> & data) {; 255 SetData(data);; 256 return DoLinearFit();; 257 }; 258 ; 259 /**; 260 Fit using the a generic FCN function as a C++ callable object implementing; 261 double () (const double *); 262 Note that the function dimension (i.e. the number of parameter) is needed in this case; 263 For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..); 264 */; 265 template <class Function>; 266 bool FitFCN(unsigned int npar, Function & fcn, const double * params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 267 ; 268 /**; 269 Set a generic FCN function as a C++ callable object implementing; 270 double () (const double *); 271 Note that the function dimension (i.e. the number of parameter) is needed in this case; 272 For the options see documentation for following methods Fit",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16983,Modifiability,config,configuration,16983, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:17112,Modifiability,config,configuration,17112, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:20051,Modifiability,extend,extended,20051,"number of fit points when using an external FCN function; 471 /// This function can be called after Fit to set the correct number of Ndf in FitResult; 472 void SetNumberOfFitPoints(unsigned int npoints) {; 473 if (fExtObjFunction) fDataSize = npoints;; 474 if (!fResult->IsEmpty()) fResult->SetChi2AndNdf(-1,npoints);; 475 }; 476 ; 477 /// Set the type of fit when using an external FCN; 478 /// possible types are : 1 (least-square), 2 (unbinned-likelihood), 3 (binned-likelihood); 479 /// Note that in case of binned likelihood fit the chi2 will be computed as 2 * MinFCN(); 480 /// Note this function should be called before fitting to have effect on th FitResult; 481 void SetFitType(int type) {; 482 if (fExtObjFunction) fFitType = type;; 483 }; 484 ; 485 ; 486protected:; 487 ; 488 ; 489 /// least square fit; 490 bool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 491 /// binned likelihood fit; 492 bool DoBinnedLikelihoodFit(bool extended = true, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 493 /// un-binned likelihood fit; 494 bool DoUnbinnedLikelihoodFit( bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 495 /// linear least square fit; 496 bool DoLinearFit();; 497 /// Set Objective function; 498 bool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize,; 499 int fitType);; 500 ; 501 // initialize the minimizer; 502 bool DoInitMinimizer();; 503 /// do minimization; 504 template<class ObjFunc_t>; 505 bool DoMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 506 // do minimization for weighted likelihood fits; 507 template<class ObjFunc_t>; 508 bool DoWeightMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 509 // do minimization after having set the objectiv",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:20228,Modifiability,extend,extended,20228,"nts(unsigned int npoints) {; 473 if (fExtObjFunction) fDataSize = npoints;; 474 if (!fResult->IsEmpty()) fResult->SetChi2AndNdf(-1,npoints);; 475 }; 476 ; 477 /// Set the type of fit when using an external FCN; 478 /// possible types are : 1 (least-square), 2 (unbinned-likelihood), 3 (binned-likelihood); 479 /// Note that in case of binned likelihood fit the chi2 will be computed as 2 * MinFCN(); 480 /// Note this function should be called before fitting to have effect on th FitResult; 481 void SetFitType(int type) {; 482 if (fExtObjFunction) fFitType = type;; 483 }; 484 ; 485 ; 486protected:; 487 ; 488 ; 489 /// least square fit; 490 bool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 491 /// binned likelihood fit; 492 bool DoBinnedLikelihoodFit(bool extended = true, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 493 /// un-binned likelihood fit; 494 bool DoUnbinnedLikelihoodFit( bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 495 /// linear least square fit; 496 bool DoLinearFit();; 497 /// Set Objective function; 498 bool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize,; 499 int fitType);; 500 ; 501 // initialize the minimizer; 502 bool DoInitMinimizer();; 503 /// do minimization; 504 template<class ObjFunc_t>; 505 bool DoMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 506 // do minimization for weighted likelihood fits; 507 template<class ObjFunc_t>; 508 bool DoWeightMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 509 // do minimization after having set the objective function; 510 bool DoMinimization(const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 511 // update config after fit; 512 void DoUpdateFitConfig();; 513 // update minim",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:21165,Modifiability,config,config,21165,"nned likelihood fit; 494 bool DoUnbinnedLikelihoodFit( bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential);; 495 /// linear least square fit; 496 bool DoLinearFit();; 497 /// Set Objective function; 498 bool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize,; 499 int fitType);; 500 ; 501 // initialize the minimizer; 502 bool DoInitMinimizer();; 503 /// do minimization; 504 template<class ObjFunc_t>; 505 bool DoMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 506 // do minimization for weighted likelihood fits; 507 template<class ObjFunc_t>; 508 bool DoWeightMinimization(std::unique_ptr<ObjFunc_t> f, const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 509 // do minimization after having set the objective function; 510 bool DoMinimization(const ROOT::Math::IMultiGenFunction * chifunc = nullptr);; 511 // update config after fit; 512 void DoUpdateFitConfig();; 513 // update minimizer options for re-fitting; 514 bool DoUpdateMinimizerOptions(bool canDifferentMinim = true);; 515 // get function calls from the FCN; 516 int GetNCallsFromFCN();; 517 ; 518 /// Set the input data for the fit using a shared ptr (No Copying); 519 template <class Data>; 520 void SetData(const std::shared_ptr<Data> & data) {; 521 fData = std::static_pointer_cast<Data>(data);; 522 }; 523 ; 524 /// Set the input data for the fit (Copying the given data object); 525 template <class Data>; 526 void SetData(const Data & data) {; 527 auto dataClone = std::make_shared<Data>(data);; 528 SetData(dataClone);; 529 }; 530 ; 531 /// look at the user provided FCN and get data and model function is; 532 /// they derive from ROOT::Fit FCN classes; 533 void ExamineFCN();; 534 ; 535 ; 536 /// internal functions to get data set and model function from FCN; 537 /// useful for fits done with customized FCN classes; 538 template <class ObjFuncTyp",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:23321,Modifiability,config,configuration,23321,,MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:28726,Modifiability,config,configuration,28726,"n GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; UnBinData.h; WrappedFunction.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool Le",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:29378,Modifiability,extend,extended,29378,"n TGWin32VirtualXProxy.cxx:249; UnBinData.h; WrappedFunction.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit NOT copying the input data.Definition Fitter.h:179; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::operator=Fitter & operator=(const Fitter &)=deleteAssignment operator (disabled, class is not copyable); ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously s",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:31120,Modifiability,extend,extended,31120,"fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::operator=Fitter & operator=(const Fitter &)=deleteAssignment operator (disabled, class is not copyable); ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM fitters)Definition Fitter.h:560; ROOT::Fit::Fitter::DoUnbinnedLikelihoodFitbool DoUnbinnedLikelihoodFit(bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)un-binned likelihood fitDefinition Fitter.cxx:440; ROOT::Fit::Fitter::SetDatavoid SetData(const Data &data)Set the input data for the fit (Copying the given data object)Definition Fitter.h:526; ROOT::Fit::Fitter::ObjFunctionconst ROOT::Math::IBaseFunctionMultiDimTempl< double > * ObjFunction() constReturn pointer to the used objective function for fitting.Definition Fitter.h:544; ROOT::Fit::Fitter::IModelFunction_vROOT::Math::IParamMultiFunction IModelFunction_vDefinition Fitter.h:88; ROOT::Fit::Fitter::Fitbool Fit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit.Definition Fitter.h:157; ROOT::Fit::Fitter::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! pointer to used minimizerDefinition Fitter.h:570; ROOT::Fit::Fitter::DoWeightMinimizationbool DoWeightMinimization(std::unique_ptr< ObjFunc_t > f, const ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:32319,Modifiability,extend,extended,32319,"Data &data)Set the input data for the fit (Copying the given data object)Definition Fitter.h:526; ROOT::Fit::Fitter::ObjFunctionconst ROOT::Math::IBaseFunctionMultiDimTempl< double > * ObjFunction() constReturn pointer to the used objective function for fitting.Definition Fitter.h:544; ROOT::Fit::Fitter::IModelFunction_vROOT::Math::IParamMultiFunction IModelFunction_vDefinition Fitter.h:88; ROOT::Fit::Fitter::Fitbool Fit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit.Definition Fitter.h:157; ROOT::Fit::Fitter::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! pointer to used minimizerDefinition Fitter.h:570; ROOT::Fit::Fitter::DoWeightMinimizationbool DoWeightMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)Definition Fitter.cxx:845; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const Data &data, const Function &func, bool extended)Likelihood fit given a data set (Binned or Un-binned) using any generic model function.Definition Fitter.h:239; ROOT::Fit::Fitter::DoBinnedLikelihoodFitbool DoBinnedLikelihoodFit(bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::GetFCNROOT::Math::IMultiGenFunction * GetFCN() constreturn pointer to last used objective function (is NULL in case fit is not yet done) This pointer wil...Definition Fitter.h:455; ROOT::Fit::Fitter::IGradModel1DFunctionROOT::Math::IParamGradFunction IGradModel1DFunctionDefinition Fitter.h:93; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::GetMinimizerROOT::Math::Minimizer * GetMin",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:32512,Modifiability,extend,extended,32512,"used objective function for fitting.Definition Fitter.h:544; ROOT::Fit::Fitter::IModelFunction_vROOT::Math::IParamMultiFunction IModelFunction_vDefinition Fitter.h:88; ROOT::Fit::Fitter::Fitbool Fit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit.Definition Fitter.h:157; ROOT::Fit::Fitter::fMinimizerstd::shared_ptr< ROOT::Math::Minimizer > fMinimizer! pointer to used minimizerDefinition Fitter.h:570; ROOT::Fit::Fitter::DoWeightMinimizationbool DoWeightMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)Definition Fitter.cxx:845; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const Data &data, const Function &func, bool extended)Likelihood fit given a data set (Binned or Un-binned) using any generic model function.Definition Fitter.h:239; ROOT::Fit::Fitter::DoBinnedLikelihoodFitbool DoBinnedLikelihoodFit(bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::GetFCNROOT::Math::IMultiGenFunction * GetFCN() constreturn pointer to last used objective function (is NULL in case fit is not yet done) This pointer wil...Definition Fitter.h:455; ROOT::Fit::Fitter::IGradModel1DFunctionROOT::Math::IParamGradFunction IGradModel1DFunctionDefinition Fitter.h:93; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::GetMinimizerROOT::Math::Minimizer * GetMinimizer() constreturn pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guarantee...Definition Fitter.h:444; ROOT::Fit::Fitter::BaseFuncROOT::Math::IMultiGenFunction BaseFuncDefinition Fitter.",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:33606,Modifiability,config,configuration,33606,"Sequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::GetFCNROOT::Math::IMultiGenFunction * GetFCN() constreturn pointer to last used objective function (is NULL in case fit is not yet done) This pointer wil...Definition Fitter.h:455; ROOT::Fit::Fitter::IGradModel1DFunctionROOT::Math::IParamGradFunction IGradModel1DFunctionDefinition Fitter.h:93; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::GetMinimizerROOT::Math::Minimizer * GetMinimizer() constreturn pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guarantee...Definition Fitter.h:444; ROOT::Fit::Fitter::BaseFuncROOT::Math::IMultiGenFunction BaseFuncDefinition Fitter.h:95; ROOT::Fit::Fitter::ConfigFitConfig & Config()access to the configuration (non const method)Definition Fitter.h:427; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::SetNumberOfFitPointsvoid SetNumberOfFitPoints(unsigned int npoints)Set number of fit points when using an external FCN function This function can be called after Fit to...Definition Fitter.h:472; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::MinuitFCN_tvoid(* MinuitFCN_t)(int &npar, double *gin, double &f, double *u, int flag)fit using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters ...Definition Fitter.h:339; ROOT::Fit::Fitter::IsBinFitbool IsBinFit() constquery if fit is binned.Definition Fitter.h:433; ROOT::Fit::Fitter::LinearFitbool LinearFit(const std::shared_ptr< BinData > &data)Do a linear fit using a shar",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:35998,Modifiability,config,configuration,35998,"1; ROOT::Fit::Fitter::~Fittervirtual ~Fitter()Destructor.Definition Fitter.h:117; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit.Definition Fitter.h:165; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::ApplyWeightCorrectionbool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction &loglw2, bool minimizeW2L=false)apply correction in the error matrix for the weights for likelihood fits This method can be called on...Definition Fitter.cxx:886; ROOT::Fit::Fitter::BaseGradFuncROOT::Math::IMultiGradFunction BaseGradFuncDefinition Fitter.h:96; ROOT::Fit::Fitter::ExamineFCNvoid ExamineFCN()look at the user provided FCN and get data and model function is they derive from ROOT::Fit FCN class...Definition Fitter.cxx:979; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetDatavoid SetData(const std::shared_ptr< Data > &data)Set the input data for the fit using a shared ptr (No Copying)Definition Fitter.h:520; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition Fitter.h:81; ROOT::Fit::Fitter::IModel1DFunctionROOT::Math::IParamFunction IModel1DFunctionDefinition Fitter.h:92; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const BinData &data, bool extended=true, const ROOT::EExecu",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:36946,Modifiability,extend,extended,36946,"constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::Fitter::SetDatavoid SetData(const std::shared_ptr< Data > &data)Set the input data for the fit using a shared ptr (No Copying)Definition Fitter.h:520; ROOT::Fit::Fitter::DoLeastSquareFitbool DoLeastSquareFit(const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)least square fitDefinition Fitter.cxx:309; ROOT::Fit::Fitter::IModelFunctionROOT::Math::IParamMultiFunction IModelFunctionDefinition Fitter.h:81; ROOT::Fit::Fitter::IModel1DFunctionROOT::Math::IParamFunction IModel1DFunctionDefinition Fitter.h:92; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const BinData &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit copying the input data.Definition Fitter.h:203; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::IGradModelFunction_vROOT::Math::IParamMultiGradFunction IGradModelFunction_vDefinition Fitter.h:89; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< BinData > &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:212; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done wi",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:37487,Modifiability,extend,extended,37487,"del1DFunctionROOT::Math::IParamFunction IModel1DFunctionDefinition Fitter.h:92; ROOT::Fit::Fitter::SetFCNbool SetFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Set a generic FCN function as a C++ callable object implementing double () (const double *) Note that...Definition Fitter.h:656; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const BinData &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit copying the input data.Definition Fitter.h:203; ROOT::Fit::Fitter::fFunc_vstd::shared_ptr< IModelFunction_v > fFunc_v! copy of the fitted function containing on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::IGradModelFunction_vROOT::Math::IParamMultiGradFunction IGradModelFunction_vDefinition Fitter.h:89; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< BinData > &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:212; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDiff",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:38905,Modifiability,extend,extended,38905,"eful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:39542,Modifiability,config,configuration,39542,"ion Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT:",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:40518,Modifiability,extend,extended,40518,"ions and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:195; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit copying the input data Default is NOT extended.Definition Fitter.h:221; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Math::BasicFitMethodFunctionFitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) ...Definition FitMethodFunction.h:38; ROOT::M",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:40787,Modifiability,extend,extended,40787," Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:195; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit copying the input data Default is NOT extended.Definition Fitter.h:221; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Math::BasicFitMethodFunctionFitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) ...Definition FitMethodFunction.h:38; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunct",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:40948,Modifiability,extend,extended,40948," Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:195; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit copying the input data Default is NOT extended.Definition Fitter.h:221; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Math::BasicFitMethodFunctionFitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) ...Definition FitMethodFunction.h:38; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IGradientFunctionMultiDimTemplInterface (abstract class) for multi-dimensional functions providing a gradient calculation.Definition IFunct",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:1834,Performance,perform,performing,1834,"***********************************************************/; 10 ; 11// Header file for class Fitter; 12 ; 13#ifndef ROOT_Fit_Fitter; 14#define ROOT_Fit_Fitter; 15 ; 16/**; 17@defgroup Fit Fitting and Parameter Estimation; 18 ; 19Classes used for fitting (regression analysis) and estimation of parameter values given a data sample.; 20 ; 21@ingroup MathCore; 22 ; 23*/; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/UnBinData.h""; 27#include ""Fit/FitConfig.h""; 28#include ""ROOT/EExecutionPolicy.hxx""; 29#include ""Fit/FitResult.h""; 30#include ""Math/IParamFunction.h""; 31#include <memory>; 32 ; 33namespace ROOT {; 34 ; 35 ; 36 namespace Math {; 37 class Minimizer;; 38 ; 39 // should maybe put this in a FitMethodFunctionfwd file; 40 template<class FunctionType> class BasicFitMethodFunction;; 41 ; 42 // define the normal and gradient function; 43 typedef BasicFitMethodFunction<ROOT::Math::IMultiGenFunction> FitMethodFunction;; 44 typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;; 45 ; 46 }; 47 ; 48 /**; 49 Namespace for the fitting classes; 50 @ingroup Fit; 51 */; 52 ; 53 namespace Fit {; 54 ; 55/**; 56 @defgroup FitMain User Fitting classes; 57 ; 58 Main Classes used for fitting a given data set; 59 @ingroup Fit; 60*/; 61 ; 62 ; 63//___________________________________________________________________________________; 64/**; 65 Fitter class, entry point for performing all type of fits.; 66 Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; 67 The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); 68 The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; 69 The configuration of the fit (parameters, options, etc...) are specified in the; 70 ROOT::Math::FitConfig class.; 71 After fitting the config of the fit will be modified to have the new values the resulting; 72 parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; 7",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:1876,Performance,perform,performed,1876,"ude ""ROOT/EExecutionPolicy.hxx""; 29#include ""Fit/FitResult.h""; 30#include ""Math/IParamFunction.h""; 31#include <memory>; 32 ; 33namespace ROOT {; 34 ; 35 ; 36 namespace Math {; 37 class Minimizer;; 38 ; 39 // should maybe put this in a FitMethodFunctionfwd file; 40 template<class FunctionType> class BasicFitMethodFunction;; 41 ; 42 // define the normal and gradient function; 43 typedef BasicFitMethodFunction<ROOT::Math::IMultiGenFunction> FitMethodFunction;; 44 typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;; 45 ; 46 }; 47 ; 48 /**; 49 Namespace for the fitting classes; 50 @ingroup Fit; 51 */; 52 ; 53 namespace Fit {; 54 ; 55/**; 56 @defgroup FitMain User Fitting classes; 57 ; 58 Main Classes used for fitting a given data set; 59 @ingroup Fit; 60*/; 61 ; 62 ; 63//___________________________________________________________________________________; 64/**; 65 Fitter class, entry point for performing all type of fits.; 66 Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; 67 The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); 68 The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; 69 The configuration of the fit (parameters, options, etc...) are specified in the; 70 ROOT::Math::FitConfig class.; 71 After fitting the config of the fit will be modified to have the new values the resulting; 72 parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; 73 initial parameters by calling FitConfig.SetUpdateAfterFit(false);; 74 ; 75 @ingroup FitMain; 76*/; 77class Fitter {; 78 ; 79public:; 80 ; 81 typedef ROOT::Math::IParamMultiFunction IModelFunction;; 82 template <class T>; 83 using IModelFunctionTempl = ROOT::Math::IParamMultiFunctionTempl<T>;; 84#ifdef R__HAS_VECCORE; 85 typedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:4385,Performance,perform,performed,4385,"94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value ||; 142 std::is_same<Function, int>::value),; 143 Function>::type>; 144 bool Fit(const Data &data, const Function &func,; 145 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential); 146 {; 147 SetFunction(func);; 148 return Fit(data, executionPolicy);; 149 }; 150 ; 151 /**; 152 Fit a binned data set using a least square fit.; 153 Note that the provided input data are copied in the Fitter class.; 154 Use the next func",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16137,Performance,perform,perform,16137," NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binn",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16529,Performance,perform,perform,16529,"& func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed t",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:17735,Performance,perform,performing,17735,The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-l,MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:18271,Performance,perform,performing,18271,"of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-likelihood function implemented using the; 464 sum of weight squared; 465 When using FitConfig.SetWeightCorrection() this correction is applied; 466 automatically when doing a likelihood fit (binned or unbinned); 467 */; 468 bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L=false);; 469 ; 470 /// Set number of fit points when using an external FCN function; 471 /// This function can be called after Fit to set the correct number of Ndf in FitResult; 472 void SetNumberOfFitPoints(unsigned int n",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:22348,Performance,cache,cached,22348,"<Data> & data) {; 521 fData = std::static_pointer_cast<Data>(data);; 522 }; 523 ; 524 /// Set the input data for the fit (Copying the given data object); 525 template <class Data>; 526 void SetData(const Data & data) {; 527 auto dataClone = std::make_shared<Data>(data);; 528 SetData(dataClone);; 529 }; 530 ; 531 /// look at the user provided FCN and get data and model function is; 532 /// they derive from ROOT::Fit FCN classes; 533 void ExamineFCN();; 534 ; 535 ; 536 /// internal functions to get data set and model function from FCN; 537 /// useful for fits done with customized FCN classes; 538 template <class ObjFuncType>; 539 bool GetDataFromFCN();; 540 ; 541 /// Return pointer to the used objective function for fitting.; 542 /// If using an external function (e.g. given in SetFCN), return the cached pointer,; 543 /// otherwise use the one stored as shared ptr and managed by the Fitter class; 544 const ROOT::Math::IBaseFunctionMultiDimTempl<double> * ObjFunction() const {; 545 // need to specify here full return type since when using the typedef (IMultiGenFunction); 546 // there is an error when using the class in Python (see issue #12391); 547 return (fExtObjFunction) ? fExtObjFunction : fObjFunction.get();; 548 }; 549 ; 550private:; 551 ; 552 bool fUseGradient = false; ///< flag to indicate if using gradient or not; 553 ; 554 bool fBinFit = false; ///< flag to indicate if fit is binned; 555 ///< in case of false the fit is unbinned or undefined); 556 ///< flag it is used to compute chi2 for binned likelihood fit; 557 ; 558 int fFitType = 0; ///< type of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood); 559 ; 560 int fDataSize = 0; ///< size of data sets (need for Fumili or LM fitters); 561 ; 562 FitConfig fConfig; ///< fitter configuration (options and parameter settings); 563 ; 564 std::shared_ptr<IModelFunction_v> fFunc_v; ///<! copy of the fitted function containing on output the fit result; 565 ; 566 std::shared_ptr<IModelFunction> fFunc;",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:29228,Performance,perform,performing,29228,"onst char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; UnBinData.h; WrappedFunction.h; FunctionDouble_t(* Function)(Double_t)Definition Functor.C:4; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit NOT copying the input data.Definition Fitter.h:179; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:38199,Performance,perform,perform,38199,"ntaining on output the fit resultDefinition Fitter.h:564; ROOT::Fit::Fitter::IGradModelFunction_vROOT::Math::IParamMultiGradFunction IGradModelFunction_vDefinition Fitter.h:89; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< BinData > &data, bool extended=true, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:212; ROOT::Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted functi",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:38809,Performance,perform,performed,38809,"Fit::Fitter::fResultstd::shared_ptr< ROOT::Fit::FitResult > fResult! pointer to the object containing the result of the fitDefinition Fitter.h:568; ROOT::Fit::Fitter::GetDataFromFCNbool GetDataFromFCN()internal functions to get data set and model function from FCN useful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:1",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:39361,Performance,perform,perform,39361,")=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const doubl",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:3722,Safety,avoid,avoid,3722,"pedef ROOT::Math::IParametricFunctionMultiDimTempl<ROOT::Double_v> IModelFunction_v;; 86 typedef ROOT::Math::IParamMultiGradFunctionTempl<ROOT::Double_v> IGradModelFunction_v;; 87#else; 88 typedef ROOT::Math::IParamMultiFunction IModelFunction_v;; 89 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction_v;; 90#endif; 91 typedef ROOT::Math::IParamMultiGradFunction IGradModelFunction;; 92 typedef ROOT::Math::IParamFunction IModel1DFunction;; 93 typedef ROOT::Math::IParamGradFunction IGradModel1DFunction;; 94 ; 95 typedef ROOT::Math::IMultiGenFunction BaseFunc;; 96 typedef ROOT::Math::IMultiGradFunction BaseGradFunc;; 97 ; 98 ; 99 /**; 100 Default constructor; 101 */; 102 Fitter () {}; 103 ; 104 /**; 105 Constructor from a result; 106 */; 107 Fitter (const std::shared_ptr<FitResult> & result);; 108 ; 109 ; 110 /**; 111 Destructor.; 112 Make it virtual in case users derive from Fitter class to extend it by adding new methods.; 113 This is needed to avoid a warning seen when doing from Python; 114 (see ROOT issue [#12391](https://github.com/root-project/root/issues/12391) ).; 115 Note that the Fitter class does not provide virtual functions to be re-implemented by derived classes.; 116 */; 117 virtual ~Fitter () {}; 118 ; 119 /**; 120 Copy constructor (disabled, class is not copyable); 121 */; 122 Fitter(const Fitter &) = delete;; 123 ; 124 /**; 125 Assignment operator (disabled, class is not copyable); 126 */; 127 Fitter & operator = (const Fitter &) = delete;; 128 ; 129 ; 130public:; 131 ; 132 /**; 133 fit a data set using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:5338,Safety,avoid,avoid,5338,"using any generic model function; 134 If data set is binned a least square fit is performed; 135 If data set is unbinned a maximum likelihood fit (not extended) is done; 136 Pre-requisite on the function:; 137 it must implement the 1D or multidimensional parametric function interface.; 138 Note that both the input data and the function object are copied by the Fitter.; 139 */; 140 template <class Data, class Function,; 141 class cond = typename std::enable_if<!(std::is_same<Function, ROOT::EExecutionPolicy>::value ||; 142 std::is_same<Function, int>::value),; 143 Function>::type>; 144 bool Fit(const Data &data, const Function &func,; 145 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential); 146 {; 147 SetFunction(func);; 148 return Fit(data, executionPolicy);; 149 }; 150 ; 151 /**; 152 Fit a binned data set using a least square fit.; 153 Note that the provided input data are copied in the Fitter class.; 154 Use the next function (passing a `shared_ptr` to the BinData class if you want to avoid; 155 copying.; 156 */; 157 bool Fit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 158 return LeastSquareFit(data, executionPolicy);; 159 }; 160 ; 161 /**; 162 Fit a binned data set using a least square fit.; 163 Pass the input data using a `shared_ptr` for NOT copying the input data.; 164 */; 165 bool Fit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 166 return LeastSquareFit(data, executionPolicy);; 167 }; 168 ; 169 /**; 170 Fit a binned data set using a least square fit copying the input data.; 171 */; 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:7005,Safety,avoid,avoid,7005," 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bool extended = true,; 213 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 214 SetData(data);; 215 return DoBinnedLikelihoodFit(extended, executionPol",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16965,Security,access,access,16965, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:17098,Security,access,access,17098, 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the Hessian calculations is used; 404 otherwise an error (false) is returned.; 405 A new FitResult with the Hessian result will be produced; 406 */; 407 bool CalculateHessErrors();; 408 ; 409 /**; 410 perform an error analysis on the result using MINOS; 411 To be called only after fitting and when a minimizer supporting MINOS is used; 412 otherwise an error (false) is returned.; 413 The result will be appended in the fit result class; 414 Optionally a vector of parameter indices can be passed for selecting; 415 the parameters to analyse using FitConfig::SetMinosErrors; 416 */; 417 bool CalculateMinosErrors();; 418 ; 419 /**; 420 access to the fit configuration (const method); 421 */; 422 const FitConfig & Config() const { return fConfig; }; 423 ; 424 /**; 425 access to the configuration (non const method); 426 */; 427 FitConfig & Config() { return fConfig; }; 428 ; 429 /**; 430 query if fit is binned. In cse of false the fit can be unbinned; 431 or is not defined (like in case of fitting through a ROOT::Fit::Fitter::FitFCN); 432 */; 433 bool IsBinFit() const { return fBinFit; }; 434 ; 435 /**; 436 return pointer to last used minimizer; 437 (is NULL in case fit is not yet done); 438 This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone.; 439 To be used only after fitting.; 440 The pointer should not be stored and will be invalided after performing a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(),MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:33592,Security,access,access,33592,"Sequential)binned likelihood fitDefinition Fitter.cxx:360; ROOT::Fit::Fitter::fFitTypeint fFitTypetype of fit (0 undefined, 1 least square, 2 likelihood, 3 binned likelihood)Definition Fitter.h:558; ROOT::Fit::Fitter::GetFCNROOT::Math::IMultiGenFunction * GetFCN() constreturn pointer to last used objective function (is NULL in case fit is not yet done) This pointer wil...Definition Fitter.h:455; ROOT::Fit::Fitter::IGradModel1DFunctionROOT::Math::IParamGradFunction IGradModel1DFunctionDefinition Fitter.h:93; ROOT::Fit::Fitter::fDatastd::shared_ptr< ROOT::Fit::FitData > fData! pointer to the fit data (binned or unbinned data)Definition Fitter.h:572; ROOT::Fit::Fitter::GetMinimizerROOT::Math::Minimizer * GetMinimizer() constreturn pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guarantee...Definition Fitter.h:444; ROOT::Fit::Fitter::BaseFuncROOT::Math::IMultiGenFunction BaseFuncDefinition Fitter.h:95; ROOT::Fit::Fitter::ConfigFitConfig & Config()access to the configuration (non const method)Definition Fitter.h:427; ROOT::Fit::Fitter::fUseGradientbool fUseGradientflag to indicate if using gradient or notDefinition Fitter.h:552; ROOT::Fit::Fitter::SetNumberOfFitPointsvoid SetNumberOfFitPoints(unsigned int npoints)Set number of fit points when using an external FCN function This function can be called after Fit to...Definition Fitter.h:472; ROOT::Fit::Fitter::fBinFitbool fBinFitflag to indicate if fit is binned in case of false the fit is unbinned or undefined) flag it is used ...Definition Fitter.h:554; ROOT::Fit::Fitter::MinuitFCN_tvoid(* MinuitFCN_t)(int &npar, double *gin, double &f, double *u, int flag)fit using user provided FCN with Minuit-like interface If npar = 0 it is assumed that the parameters ...Definition Fitter.h:339; ROOT::Fit::Fitter::IsBinFitbool IsBinFit() constquery if fit is binned.Definition Fitter.h:433; ROOT::Fit::Fitter::LinearFitbool LinearFit(const std::shared_ptr< BinData > &data)Do a linear fit using a shar",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:6593,Testability,log,log-likelihood,6593,"::EExecutionPolicy::kSequential) {; 158 return LeastSquareFit(data, executionPolicy);; 159 }; 160 ; 161 /**; 162 Fit a binned data set using a least square fit.; 163 Pass the input data using a `shared_ptr` for NOT copying the input data.; 164 */; 165 bool Fit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 166 return LeastSquareFit(data, executionPolicy);; 167 }; 168 ; 169 /**; 170 Fit a binned data set using a least square fit copying the input data.; 171 */; 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const RO",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:6940,Testability,log,log-likelihood,6940,"ExecutionPolicy::kSequential) {; 166 return LeastSquareFit(data, executionPolicy);; 167 }; 168 ; 169 /**; 170 Fit a binned data set using a least square fit copying the input data.; 171 */; 172 bool LeastSquareFit(const BinData & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 173 SetData(data);; 174 return DoLeastSquareFit(executionPolicy);; 175 }; 176 /**; 177 Fit a binned data set using a least square fit NOT copying the input data.; 178 */; 179 bool LeastSquareFit(const std::shared_ptr<BinData> & data, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 180 SetData(data);; 181 return DoLeastSquareFit(executionPolicy);; 182 }; 183 ; 184 /**; 185 Fit an un-binned data set using the negative log-likelihood method.; 186 This function copies the input data.; 187 */; 188 bool Fit(const UnBinData & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 189 return LikelihoodFit(data, extended, executionPolicy);; 190 }; 191 /**; 192 Fit an un-binned data set using the negative log-likelihood method.; 193 This function uses a `shared_ptr` to avoid copying the input data.; 194 */; 195 bool Fit(const std::shared_ptr<UnBinData> & data, bool extended = false, const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 196 return LikelihoodFit(data, extended, executionPolicy);; 197 }; 198 ; 199 /**; 200 Binned Likelihood fit copying the input data.; 201 Default is extended.; 202 */; 203 bool LikelihoodFit(const BinData &data, bool extended = true,; 204 const ROOT::EExecutionPolicy &executionPolicy = ROOT::EExecutionPolicy::kSequential) {; 205 SetData(data);; 206 return DoBinnedLikelihoodFit(extended, executionPolicy);; 207 }; 208 /**; 209 Binned Likelihood fit using a `shared_ptr` for NOT copying the input data.; 210 Default is extended.; 211 */; 212 bool LikelihoodFit(const std::shared_ptr<BinData> &data, bo",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:16057,Testability,assert,assert,16057,"par = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IModel1DFunction & func, bool useGradient = false);; 380 ; 381 /**; 382 Set the fitted function (model function) from a parametric gradient function interface; 383 */; 384 void SetFunction(const IGradModelFunction & func, bool useGradient = true);; 385 /**; 386 Set the fitted function from 1D gradient parametric function interface; 387 */; 388 void SetFunction(const IGradModel1DFunction & func, bool useGradient = true);; 389 ; 390 ; 391 /**; 392 get fit result; 393 */; 394 const FitResult & Result() const {; 395 assert( fResult.get() );; 396 return *fResult;; 397 }; 398 ; 399 ; 400 /**; 401 perform an error analysis on the result using the Hessian; 402 Errors are obtained from the inverse of the Hessian matrix; 403 To be called only after fitting and when a minimizer supporting the H",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:18709,Testability,log,log-likelihood,18709,"forming a new fitting.; 441 In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; 442 obtained calling again GetMinimizer(); 443 */; 444 ROOT::Math::Minimizer * GetMinimizer() const { return fMinimizer.get(); }; 445 ; 446 /**; 447 return pointer to last used objective function; 448 (is NULL in case fit is not yet done); 449 This pointer will be valid as far as the fitter class; 450 has not been deleted. To be used after the fitting.; 451 The pointer should not be stored and will be invalided after performing a new fitting.; 452 In this case a new instance of the function pointer will be re-created and can be; 453 obtained calling again GetFCN(); 454 */; 455 ROOT::Math::IMultiGenFunction * GetFCN() const {; 456 return fObjFunction.get();; 457 }; 458 ; 459 ; 460 /**; 461 apply correction in the error matrix for the weights for likelihood fits; 462 This method can be called only after a fit. The; 463 passed function (loglw2) is a log-likelihood function implemented using the; 464 sum of weight squared; 465 When using FitConfig.SetWeightCorrection() this correction is applied; 466 automatically when doing a likelihood fit (binned or unbinned); 467 */; 468 bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction & loglw2, bool minimizeW2L=false);; 469 ; 470 /// Set number of fit points when using an external FCN function; 471 /// This function can be called after Fit to set the correct number of Ndf in FitResult; 472 void SetNumberOfFitPoints(unsigned int npoints) {; 473 if (fExtObjFunction) fDataSize = npoints;; 474 if (!fResult->IsEmpty()) fResult->SetChi2AndNdf(-1,npoints);; 475 }; 476 ; 477 /// Set the type of fit when using an external FCN; 478 /// possible types are : 1 (least-square), 2 (unbinned-likelihood), 3 (binned-likelihood); 479 /// Note that in case of binned likelihood fit the chi2 will be computed as 2 * MinFCN(); 480 /// Note this function should be called before fitting to have effect on th FitResult; 481 void SetFitT",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:25439,Testability,assert,assert,25439," (objfunc) {; 587 fFunc = objfunc->ModelFunctionPtr();; 588 fData = objfunc->DataPtr();; 589 return true;; 590 }; 591 else {; 592 return false;; 593 }; 594}; 595 ; 596#ifdef R__HAS_VECCORE; 597template <class NotCompileIfScalarBackend>; 598void Fitter::SetFunction(const IModelFunction_v &func, bool useGradient); 599{; 600 fUseGradient = useGradient;; 601 if (fUseGradient) {; 602 const IGradModelFunction_v *gradFunc = dynamic_cast<const IGradModelFunction_v *>(&func);; 603 if (gradFunc) {; 604 SetFunction(*gradFunc, true);; 605 return;; 606 } else {; 607 MATH_WARN_MSG(""Fitter::SetFunction"",; 608 ""Requested function does not provide gradient - use it as non-gradient function "");; 609 }; 610 }; 611 ; 612 // set the fit model function (clone the given one and keep a copy ); 613 // std::cout << ""set a non-grad function"" << std::endl;; 614 fUseGradient = false;; 615 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IModelFunction_v *>(func.Clone()));; 616 assert(fFunc_v);; 617 ; 618 // creates the parameter settings; 619 fConfig.CreateParamsSettings(*fFunc_v);; 620 fFunc.reset();; 621}; 622 ; 623template <class NotCompileIfScalarBackend>; 624void Fitter::SetFunction(const IGradModelFunction_v &func, bool useGradient); 625{; 626 fUseGradient = useGradient;; 627 ; 628 // set the fit model function (clone the given one and keep a copy ); 629 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IGradModelFunction_v *>(func.Clone()));; 630 assert(fFunc_v);; 631 ; 632 // creates the parameter settings; 633 fConfig.CreateParamsSettings(*fFunc_v);; 634 fFunc.reset();; 635}; 636#endif; 637 ; 638 } // end namespace Fit; 639 ; 640} // end namespace ROOT; 641 ; 642// implementation of inline methods; 643 ; 644 ; 645 ; 646#include ""Math/WrappedFunction.h""; 647 ; 648template<class Function>; 649bool ROOT::Fit::Fitter::FitFCN(unsigned int npar, Function & f, const double * par, unsigned int datasize,int fitType) {; 650 ROOT::Math::WrappedMultiFunction<Function &> wf(f,npar);; ",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:25932,Testability,assert,assert,25932," 604 SetFunction(*gradFunc, true);; 605 return;; 606 } else {; 607 MATH_WARN_MSG(""Fitter::SetFunction"",; 608 ""Requested function does not provide gradient - use it as non-gradient function "");; 609 }; 610 }; 611 ; 612 // set the fit model function (clone the given one and keep a copy ); 613 // std::cout << ""set a non-grad function"" << std::endl;; 614 fUseGradient = false;; 615 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IModelFunction_v *>(func.Clone()));; 616 assert(fFunc_v);; 617 ; 618 // creates the parameter settings; 619 fConfig.CreateParamsSettings(*fFunc_v);; 620 fFunc.reset();; 621}; 622 ; 623template <class NotCompileIfScalarBackend>; 624void Fitter::SetFunction(const IGradModelFunction_v &func, bool useGradient); 625{; 626 fUseGradient = useGradient;; 627 ; 628 // set the fit model function (clone the given one and keep a copy ); 629 fFunc_v = std::shared_ptr<IModelFunction_v>(dynamic_cast<IGradModelFunction_v *>(func.Clone()));; 630 assert(fFunc_v);; 631 ; 632 // creates the parameter settings; 633 fConfig.CreateParamsSettings(*fFunc_v);; 634 fFunc.reset();; 635}; 636#endif; 637 ; 638 } // end namespace Fit; 639 ; 640} // end namespace ROOT; 641 ; 642// implementation of inline methods; 643 ; 644 ; 645 ; 646#include ""Math/WrappedFunction.h""; 647 ; 648template<class Function>; 649bool ROOT::Fit::Fitter::FitFCN(unsigned int npar, Function & f, const double * par, unsigned int datasize,int fitType) {; 650 ROOT::Math::WrappedMultiFunction<Function &> wf(f,npar);; 651 if (!DoSetFCN(false, wf, par, datasize, fitType)); 652 return false;; 653 return FitFCN();; 654}; 655template<class Function>; 656bool ROOT::Fit::Fitter::SetFCN(unsigned int npar, Function & f, const double * par, unsigned int datasize,int fitType) {; 657 ROOT::Math::WrappedMultiFunction<Function &> wf(f,npar);; 658 return DoSetFCN(false, wf, par, datasize, fitType);; 659}; 660 ; 661 ; 662 ; 663 ; 664#endif /* ROOT_Fit_Fitter */; BinData.h; EExecutionPolicy.hxx; MATH_WARN_MSG#define M",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:39048,Testability,log,log-likelihood,39048,"eful for fits done with customized F...Definition Fitter.h:584; ROOT::Fit::Fitter::IGradModelFunctionROOT::Math::IParamMultiGradFunction IGradModelFunctionDefinition Fitter.h:91; ROOT::Fit::Fitter::CalculateMinosErrorsbool CalculateMinosErrors()perform an error analysis on the result using MINOS To be called only after fitting and when a minimi...Definition Fitter.cxx:593; ROOT::Fit::Fitter::FitterFitter(const Fitter &)=deleteCopy constructor (disabled, class is not copyable); ROOT::Fit::Fitter::DoUpdateMinimizerOptionsbool DoUpdateMinimizerOptions(bool canDifferentMinim=true)Definition Fitter.cxx:763; ROOT::Fit::Fitter::Fitbool Fit(const Data &data, const Function &func, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)fit a data set using any generic model function If data set is binned a least square fit is performed...Definition Fitter.h:144; ROOT::Fit::Fitter::Fitbool Fit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:188; ROOT::Fit::Fitter::SetFunctionvoid SetFunction(const IModelFunction &func, bool useGradient=false)Set the fitted function (model function) from a parametric function interface.Definition Fitter.cxx:59; ROOT::Fit::Fitter::CalculateHessErrorsbool CalculateHessErrors()perform an error analysis on the result using the Hessian Errors are obtained from the inverse of the...Definition Fitter.cxx:530; ROOT::Fit::Fitter::fConfigFitConfig fConfigfitter configuration (options and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:40661,Testability,log,log-likelihood,40661,"ions and parameter settings)Definition Fitter.h:562; ROOT::Fit::Fitter::FitterFitter()Default constructor.Definition Fitter.h:102; ROOT::Fit::Fitter::fFuncstd::shared_ptr< IModelFunction > fFunc! copy of the fitted function containing on output the fit resultDefinition Fitter.h:566; ROOT::Fit::Fitter::SetFCNbool SetFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Set the objective function (FCN) using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const BinData &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit copying the input data.Definition Fitter.h:172; ROOT::Fit::Fitter::FitFCNbool FitFCN(const ROOT::Math::FitMethodGradFunction &fcn, const double *params=nullptr)Fit using a FitMethodGradFunction interface.; ROOT::Fit::Fitter::Fitbool Fit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit an un-binned data set using the negative log-likelihood method.Definition Fitter.h:195; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const UnBinData &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit copying the input data Default is NOT extended.Definition Fitter.h:221; ROOT::Fit::Fitter::DoLinearFitbool DoLinearFit()linear least square fitDefinition Fitter.cxx:513; ROOT::Fit::Fitter::DoInitMinimizerbool DoInitMinimizer()Definition Fitter.cxx:692; ROOT::Fit::Fitter::GetNCallsFromFCNint GetNCallsFromFCN()Definition Fitter.cxx:870; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Math::BasicFitMethodFunctionFitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) ...Definition FitMethodFunction.h:38; ROOT::M",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:14570,Usability,simpl,simple,14570,"332 ; 333 ; 334 /**; 335 fit using user provided FCN with Minuit-like interface; 336 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 337 For the options same consideration as in the previous method; 338 */; 339 typedef void (* MinuitFCN_t )(int &npar, double *gin, double &f, double *u, int flag);; 340 bool FitFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 341 ; 342 /**; 343 set objective function using user provided FCN with Minuit-like interface; 344 If npar = 0 it is assumed that the parameters are specified in the parameter settings created before; 345 For the options same consideration as in the previous method; 346 */; 347 bool SetFCN( MinuitFCN_t fcn, int npar = 0, const double *params = nullptr, unsigned int dataSize = 0, int fitType = 0);; 348 ; 349 /**; 350 Perform a fit with the previously set FCN function. Require SetFCN before; 351 */; 352 bool FitFCN();; 353 ; 354 /**; 355 Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN; 356 */; 357 bool EvalFCN();; 358 ; 359 ; 360 ; 361 /**; 362 Set the fitted function (model function) from a parametric function interface; 363 */; 364 void SetFunction(const IModelFunction & func, bool useGradient = false);; 365 ; 366 /**; 367 Set the fitted function (model function) from a vectorized parametric function interface; 368 */; 369#ifdef R__HAS_VECCORE; 370 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 371 void SetFunction(const IModelFunction_v &func, bool useGradient = false);; 372 ; 373 template <class NotCompileIfScalarBackend = std::enable_if<!(std::is_same<double, ROOT::Double_v>::value)>>; 374 void SetFunction(const IGradModelFunction_v &func, bool useGradient = true);; 375#endif; 376 /**; 377 Set the fitted function from a parametric 1D function interface; 378 */; 379 void SetFunction(const IM",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/Fitter_8h_source.html:30027,Usability,simpl,simple,30027,"finition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit NOT copying the input data.Definition Fitter.h:179; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::operator=Fitter & operator=(const Fitter &)=deleteAssignment operator (disabled, class is not copyable); ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM",MatchSource.WIKI,doc/master/Fitter_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html
https://root.cern/doc/master/FitUtil_8cxx.html:705,Integrability,depend,dependency,705,". ROOT: math/mathcore/src/FitUtil.cxx File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Functions ; FitUtil.cxx File Reference. #include ""Fit/FitUtil.h""; #include ""Fit/BinData.h""; #include ""Fit/UnBinData.h""; #include ""Math/IFunctionfwd.h""; #include ""Math/IParamFunction.h""; #include ""Math/Integrator.h""; #include ""Math/IntegratorMultiDim.h""; #include ""Math/WrappedFunction.h""; #include ""Math/OneDimFunctionAdapter.h""; #include ""Math/RichardsonDerivator.h""; #include ""Math/Error.h""; #include ""Math/Util.h""; #include <limits>; #include <cmath>; #include <cassert>; #include <algorithm>; #include <numeric>; #include ""TROOT.h"". Include dependency graph for FitUtil.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Fit::FitUtil::ParamDerivFunc< GradFunc >;  ; class  ROOT::Fit::FitUtil::SimpleGradientCalculator;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Fit;  Namespace for the fitting classes. ;  ; namespace  ROOT::Fit::FitUtil;  namespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ;  . Functions; template<class GFunc > ; void ROOT::Fit::FitUtil::CalculateGradientIntegral (const GFunc &gfunc, const double *x1, const double *x2, const double *p, double *g);  ; bool ROOT::Fit::FitUtil::CheckInfNaNValue (double &rval);  ; double ROOT::Fit::FitUtil::CorrectValue (double rval);  . mathmathcoresrcFitUtil.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/FitUtil_8cxx.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/FitUtil_8cxx.html
https://root.cern/doc/master/foam__demopers_8C.html:593,Performance,load,load,593,". ROOT: tutorials/foam/foam_demopers.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. foam_demopers.C File ReferenceTutorials » FOAM tutorials. Detailed Description; This simple macro demonstrates persistency of FOAM object. ; First run macro foam_demo.C to create file foam_demo.root with FOAM object.; Next type root -l foam_demopers.C from shell command line; ; #include ""Riostream.h""; #include ""TFile.h""; #include ""TFoam.h""; #include ""TROOT.h""; #include ""TSystem.h""; #include ""TFoamIntegrand.h""; ; ; Int_t foam_demopers(); {; ; // need to load the foam_demo tutorial for the definition of the function; TString macroName = gROOT->GetTutorialDir();; macroName.Append(""/foam/foam_demo.C"");; gROOT->ProcessLine(TString::Format("".L %s+"",macroName.Data()));; ; //******************************************; cout<<""====================== TestVector ================================""<<endl;; TFile fileA(""foam_demo.root"");; fileA.cd();; cout<<""------------------------------------------------------------------""<<endl;; fileA.ls();; cout<<""------------------------------------------------------------------""<<endl;; fileA.Map();; cout<<""------------------------------------------------------------------""<<endl;; fileA.ShowStreamerInfo();; cout<<""------------------------------------------------------------------""<<endl;; fileA.GetListOfKeys()->Print();; cout<<""------------------------------------------------------------------""<<endl;; //*******************************************; TFoam *FoamX = (TFoam*)fileA.Get(""FoamX"");; //*******************************************; // FoamX->PrintCells();; FoamX->CheckAll(1);; ; //N.B. the integrand functions need to be reset; // because cannot be made persistent; TFoamIntegrand * rho = (TFoamIntegrand*) gROOT->ProcessLine(""return new TFDISTR();"");; FoamX->SetRho(rho);; ; Double_t MCvect[2]; // 2-dim vector generated in the MC run; ; for(long loop=0; loop<50000; loop++){; FoamX->MakeEvent(); // generat",MatchSource.WIKI,doc/master/foam__demopers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/foam__demopers_8C.html
https://root.cern/doc/master/foam__demopers_8C.html:221,Usability,simpl,simple,221,". ROOT: tutorials/foam/foam_demopers.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. foam_demopers.C File ReferenceTutorials » FOAM tutorials. Detailed Description; This simple macro demonstrates persistency of FOAM object. ; First run macro foam_demo.C to create file foam_demo.root with FOAM object.; Next type root -l foam_demopers.C from shell command line; ; #include ""Riostream.h""; #include ""TFile.h""; #include ""TFoam.h""; #include ""TROOT.h""; #include ""TSystem.h""; #include ""TFoamIntegrand.h""; ; ; Int_t foam_demopers(); {; ; // need to load the foam_demo tutorial for the definition of the function; TString macroName = gROOT->GetTutorialDir();; macroName.Append(""/foam/foam_demo.C"");; gROOT->ProcessLine(TString::Format("".L %s+"",macroName.Data()));; ; //******************************************; cout<<""====================== TestVector ================================""<<endl;; TFile fileA(""foam_demo.root"");; fileA.cd();; cout<<""------------------------------------------------------------------""<<endl;; fileA.ls();; cout<<""------------------------------------------------------------------""<<endl;; fileA.Map();; cout<<""------------------------------------------------------------------""<<endl;; fileA.ShowStreamerInfo();; cout<<""------------------------------------------------------------------""<<endl;; fileA.GetListOfKeys()->Print();; cout<<""------------------------------------------------------------------""<<endl;; //*******************************************; TFoam *FoamX = (TFoam*)fileA.Get(""FoamX"");; //*******************************************; // FoamX->PrintCells();; FoamX->CheckAll(1);; ; //N.B. the integrand functions need to be reset; // because cannot be made persistent; TFoamIntegrand * rho = (TFoamIntegrand*) gROOT->ProcessLine(""return new TFDISTR();"");; FoamX->SetRho(rho);; ; Double_t MCvect[2]; // 2-dim vector generated in the MC run; ; for(long loop=0; loop<50000; loop++){; FoamX->MakeEvent(); // generat",MatchSource.WIKI,doc/master/foam__demopers_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/foam__demopers_8C.html
https://root.cern/doc/master/foam__demo_8C.html:1475,Testability,test,testing,1475,"LSE)Load a shared library.Definition TSystem.cxx:1857; ; ; #include ""Riostream.h""; #include ""TFile.h""; #include ""TFoam.h""; #include ""TH1.h""; #include ""TMath.h""; #include ""TFoamIntegrand.h""; #include ""TRandom3.h""; ; class TFDISTR: public TFoamIntegrand {; public:; TFDISTR(){};; Double_t Density(int nDim, Double_t *Xarg){; // Integrand for mFOAM; Double_t Fun1,Fun2,R1,R2;; Double_t pos1=1e0/3e0;; Double_t pos2=2e0/3e0;; Double_t Gam1= 0.100e0; // as in JPC; Double_t Gam2= 0.100e0; // as in JPC; Double_t sPi = sqrt(TMath::Pi());; Double_t xn1=1e0;; Double_t xn2=1e0;; int i;; R1=0;; R2=0;; for(i = 0 ; i<nDim ; i++){; R1=R1+(Xarg[i] -pos1)*(Xarg[i] -pos1);; R2=R2+(Xarg[i] -pos2)*(Xarg[i] -pos2);; xn1=xn1*Gam1*sPi;; xn2=xn2*Gam2*sPi;; }; R1 = sqrt(R1);; R2 = sqrt(R2);; Fun1 = exp(-(R1*R1)/(Gam1*Gam1))/xn1; // Gaussian delta-like profile; Fun2 = exp(-(R2*R2)/(Gam2*Gam2))/xn2; // Gaussian delta-like profile; return 0.5e0*(Fun1+ Fun2);; }; ClassDef(TFDISTR,1) //Class of testing functions for FOAM; };; ClassImp(TFDISTR); ; Int_t foam_demo(); {; TFile RootFile(""foam_demo.root"",""RECREATE"",""histograms"");; long loop;; Double_t MCresult,MCerror,MCwt;; //-----------------------------------------; long NevTot = 50000; // Total MC statistics; Int_t kDim = 2; // total dimension; Int_t nCells = 500; // Number of Cells; Int_t nSampl = 200; // Number of MC events per cell in build-up; Int_t nBin = 8; // Number of bins in build-up; Int_t OptRej = 1; // Wted events for OptRej=0; wt=1 for OptRej=1 (default); Int_t OptDrive = 2; // (D=2) Option, type of Drive =0,1,2 for TrueVol,Sigma,WtMax; Int_t EvPerBin = 25; // Maximum events (equiv.) per bin in buid-up; Int_t Chat = 1; // Chat level; //-----------------------------------------; TRandom *PseRan = new TRandom3(); // Create random number generator; TFoam *FoamX = new TFoam(""FoamX""); // Create Simulator; TFoamIntegrand *rho= new TFDISTR();; PseRan->SetSeed(4357);; //-----------------------------------------; cout<<""***** Demonstration Progra",MatchSource.WIKI,doc/master/foam__demo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/foam__demo_8C.html
https://root.cern/doc/master/formula1_8C.html:450,Modifiability,variab,variable,450,". ROOT: tutorials/graphics/formula1.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. formula1.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Display interpreted functions. . ; void formula1() {; TCanvas *c1 = new TCanvas(""c1"",""Example with Formula"",200,10,700,500);; //; // We create a formula object and compute the value of this formula; // for two different values of the x variable.; //; auto form1 = new TFormula(""form1"",""sqrt(abs(x))"");; form1->Eval(2);; form1->Eval(-45);; //; // Create a one dimensional function and draw it; //; auto fun1 = new TF1(""fun1"",""abs(sin(x)/x)"",0,10);; c1->SetGridx();; c1->SetGridy();; fun1->Draw();; c1->Update();; //; // Before leaving this demo, we print the list of objects known to ROOT; //; if (gObjectTable) gObjectTable->Print();; }; gObjectTableR__EXTERN TObjectTable * gObjectTableDefinition TObjectTable.h:82; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TFormulaThe Formula class.Definition TFormula.h:89; TObjectTable::Printvoid Print(Option_t *option="""") const overridePrint the object table.Definition TObjectTable.cxx:120; c1return c1Definition legend1.C:41; formula1Definition formula1.py:1; AuthorRene Brun ; Definition in file formula1.C. tutorialsgraphicsformula1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/formula1_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/formula1_8C.html
https://root.cern/doc/master/formula1_8py.html:494,Modifiability,variab,variable,494,". ROOT: tutorials/pyroot/formula1.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; formula1.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; TF1 example. . ; from ROOT import TCanvas, TFormula, TF1; from ROOT import gROOT, gObjectTable; ; c1 = TCanvas( 'c1', 'Example with Formula', 200, 10, 700, 500 ); ; # We create a formula object and compute the value of this formula; # for two different values of the x variable.; form1 = TFormula( 'form1', 'sqrt(abs(x))' ); form1.Eval( 2 ); form1.Eval( -45 ); ; # Create a one dimensional function and draw it; fun1 = TF1( 'fun1', 'abs(sin(x)/x)', 0, 10 ); c1.SetGridx(); c1.SetGridy(); fun1.Draw(); c1.Update(); ; # Before leaving this demo, we print the list of objects known to ROOT; #; if ( gObjectTable ):; gObjectTable.Print(); TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TFormulaThe Formula class.Definition TFormula.h:89; AuthorWim Lavrijsen ; Definition in file formula1.py. tutorialspyrootformula1.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/formula1_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/formula1_8py.html
https://root.cern/doc/master/Functor_8h_source.html:966,Integrability,wrap,wrap,966,". ROOT: math/mathcore/inc/Math/Functor.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functor.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Mon Nov 13 15:58:13 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for Functor classes.; 12// designed is inspired by the Loki Functor; 13 ; 14#ifndef ROOT_Math_Functor; 15#define ROOT_Math_Functor; 16 ; 17#include ""Math/IFunction.h""; 18 ; 19// #ifndef Root_Math_StaticCheck; 20// #include ""Math/StaticCheck.h""; 21// #endif; 22 ; 23#include <memory>; 24#include <functional>; 25#include <vector>; 26 ; 27namespace ROOT {; 28 ; 29namespace Math {; 30 ; 31/**; 32 Documentation for class Functor class.; 33 It is used to wrap in a very simple and convenient way multi-dimensional function objects.; 34 It can wrap all the following types:; 35 <ul>; 36 <li> any C++ callable object implementation double operator()( const double * ); 37 <li> a free C function of type double ()(const double * ); 38 <li> an std::function of type std::function<double (double const *)>; 39 <li> a member function with the correct signature like Foo::Eval(const double * ).; 40 In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); 41 </ul>; 42 The function dimension is required when constructing the functor.; 43 ; 44 @ingroup GenFunc; 45 ; 46 */; 47class Functor : public IBaseFunctionMultiDim {; 48 ; 49public:; 50 ; 51 /// Default constructor.; 52 Functor () {}; 53 ; 54 /// Construct from a pointer to member function (multi-dim type).; 55 template <class PtrObj, typename MemFn>; 56 Functor(const PtrObj& p, MemFn memFn, unsigned int dim ); 57 : fDim{dim}, fFunc{std::bind(memFn, p, std::placeholders::_1)}; 58 {}; 59 ; 60 /// Cons",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/Functor_8h_source.html:1054,Integrability,wrap,wrap,1054,"or: L. Moneta Mon Nov 13 15:58:13 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for Functor classes.; 12// designed is inspired by the Loki Functor; 13 ; 14#ifndef ROOT_Math_Functor; 15#define ROOT_Math_Functor; 16 ; 17#include ""Math/IFunction.h""; 18 ; 19// #ifndef Root_Math_StaticCheck; 20// #include ""Math/StaticCheck.h""; 21// #endif; 22 ; 23#include <memory>; 24#include <functional>; 25#include <vector>; 26 ; 27namespace ROOT {; 28 ; 29namespace Math {; 30 ; 31/**; 32 Documentation for class Functor class.; 33 It is used to wrap in a very simple and convenient way multi-dimensional function objects.; 34 It can wrap all the following types:; 35 <ul>; 36 <li> any C++ callable object implementation double operator()( const double * ); 37 <li> a free C function of type double ()(const double * ); 38 <li> an std::function of type std::function<double (double const *)>; 39 <li> a member function with the correct signature like Foo::Eval(const double * ).; 40 In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); 41 </ul>; 42 The function dimension is required when constructing the functor.; 43 ; 44 @ingroup GenFunc; 45 ; 46 */; 47class Functor : public IBaseFunctionMultiDim {; 48 ; 49public:; 50 ; 51 /// Default constructor.; 52 Functor () {}; 53 ; 54 /// Construct from a pointer to member function (multi-dim type).; 55 template <class PtrObj, typename MemFn>; 56 Functor(const PtrObj& p, MemFn memFn, unsigned int dim ); 57 : fDim{dim}, fFunc{std::bind(memFn, p, std::placeholders::_1)}; 58 {}; 59 ; 60 /// Construct from a callable object of multi-dimension; 61 /// with the right signature (implementing `double operator()(const double *x)`).; 62 Functor(std::function<double(double const *)> const& f, unsigned int dim ) : fDim",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/Functor_8h_source.html:2740,Integrability,wrap,wrap,2740,"(const PtrObj& p, MemFn memFn, unsigned int dim ); 57 : fDim{dim}, fFunc{std::bind(memFn, p, std::placeholders::_1)}; 58 {}; 59 ; 60 /// Construct from a callable object of multi-dimension; 61 /// with the right signature (implementing `double operator()(const double *x)`).; 62 Functor(std::function<double(double const *)> const& f, unsigned int dim ) : fDim{dim}, fFunc{f} {}; 63 ; 64 // clone of the function handler (use copy-ctor); 65 Functor * Clone() const override { return new Functor(*this); }; 66 ; 67 // for multi-dimensional functions; 68 unsigned int NDim() const override { return fDim; }; 69 ; 70private :; 71 ; 72 inline double DoEval (const double * x) const override {; 73 return fFunc(x);; 74 }; 75 ; 76 unsigned int fDim;; 77 std::function<double(double const *)> fFunc;; 78};; 79 ; 80/**; 81 Functor1D class for one-dimensional functions.; 82 It is used to wrap in a very simple and convenient way:; 83 <ul>; 84 <li> any C++ callable object implementation double operator()( double ); 85 <li> a free C function of type double ()(double ); 86 <li> a member function with the correct signature like Foo::Eval(double ).; 87 In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); 88 </ul>; 89 ; 90 ; 91 @ingroup GenFunc; 92 ; 93 */; 94 ; 95class Functor1D : public IBaseFunctionOneDim {; 96 ; 97public:; 98 ; 99 /// Default constructor.; 100 Functor1D() = default;; 101 ; 102 /// Construct from a callable object with the right signature; 103 /// implementing `double operator() (double x)`.; 104 Functor1D(std::function<double(double)> const& f) : fFunc{f} {}; 105 ; 106 // Construct from a pointer to member function (1D type).; 107 template <class PtrObj, typename MemFn>; 108 Functor1D(const PtrObj& p, MemFn memFn) : fFunc{std::bind(memFn, p, std::placeholders::_1)} {}; 109 ; 110 // Clone of the function handler (use copy-ctor).; 111 Functor1D * Clone() const override { return new Functor1D(*this); }; 112 ; 113private :; 114 ; 115 inli",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/Functor_8h_source.html:4086,Integrability,wrap,wrap,4086,"9 ; 90 ; 91 @ingroup GenFunc; 92 ; 93 */; 94 ; 95class Functor1D : public IBaseFunctionOneDim {; 96 ; 97public:; 98 ; 99 /// Default constructor.; 100 Functor1D() = default;; 101 ; 102 /// Construct from a callable object with the right signature; 103 /// implementing `double operator() (double x)`.; 104 Functor1D(std::function<double(double)> const& f) : fFunc{f} {}; 105 ; 106 // Construct from a pointer to member function (1D type).; 107 template <class PtrObj, typename MemFn>; 108 Functor1D(const PtrObj& p, MemFn memFn) : fFunc{std::bind(memFn, p, std::placeholders::_1)} {}; 109 ; 110 // Clone of the function handler (use copy-ctor).; 111 Functor1D * Clone() const override { return new Functor1D(*this); }; 112 ; 113private :; 114 ; 115 inline double DoEval (double x) const override {; 116 return fFunc(x);; 117 }; 118 ; 119 std::function<double(double)> fFunc;; 120};; 121 ; 122/**; 123 GradFunctor class for Multidimensional gradient functions.; 124 It is used to wrap in a very C++ callable object to make gradient functions.; 125 It can be constructed in three different way:; 126 <ol>; 127 <li> from an object implementing both; 128 double operator()( const double * ) for the function evaluation and; 129 double Derivative(const double *, int icoord) for the partial derivatives; 130 <li>from an object implementing any member function like Foo::XXX(const double *) for the function evaluation; 131 and any member function like Foo::XXX(const double *, int icoord) for the partial derivatives; 132 <li>from two function objects implementing; 133 double operator()( const double * ) for the function evaluation and another function object implementing; 134 double operator() (const double *, int icoord) for the partial derivatives; 135 <li>from two function objects; 136 </ol>; 137 The function dimension is required when constructing the functor.; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142class GradFunctor : public IGradientFunctionMultiDim {; 143 ; 144 ; 145public:; 146 ; 1",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/Functor_8h_source.html:9485,Integrability,wrap,wrap,9485,"23 }; 224 ; 225private :; 226 ; 227 inline double DoEval (const double * x) const override {; 228 return fFunc(x);; 229 }; 230 ; 231 inline double DoDerivative (const double * x, unsigned int icoord ) const override {; 232 if(fDerivFunc) {; 233 return fDerivFunc(x, icoord);; 234 }; 235 // Get the component from the gradient if not derivative function is; 236 // specified.; 237 std::vector<double> gradBuffer(fDim);; 238 std::fill(gradBuffer.begin(), gradBuffer.end(), 0.0);; 239 fGradFunc(x, gradBuffer.data());; 240 return gradBuffer[icoord];; 241 }; 242 ; 243 unsigned int fDim;; 244 std::function<double(const double *)> fFunc;; 245 std::function<double(double const *, unsigned int)> fDerivFunc;; 246 std::function<void(const double *, double*)> fGradFunc;; 247};; 248 ; 249 ; 250//_______________________________________________________________________________________________; 251/**; 252 GradFunctor1D class for one-dimensional gradient functions.; 253 It is used to wrap in a very C++ callable object to make a 1D gradient functions.; 254 It can be constructed in three different way:; 255 <ol>; 256 <li> from an object implementing both; 257 double operator()( double ) for the function evaluation and; 258 double Derivative(double ) for the partial derivatives; 259 <li>from an object implementing any member function like Foo::XXX(double ) for the function evaluation; 260 and any other member function like Foo::YYY(double ) for the derivative.; 261 <li>from an 2 function objects implementing; 262 double operator()( double ) . One object provides the function evaluation, the other the derivative.; 263 </ol>; 264 ; 265 @ingroup GenFunc; 266 ; 267 */; 268 ; 269class GradFunctor1D : public IGradientFunctionOneDim {; 270 ; 271public:; 272 ; 273 /// Default constructor.; 274 GradFunctor1D() = default;; 275 ; 276 /// Construct from an object with the right signature,; 277 /// implementing both `operator() (double x)` and `Derivative(double x)`.; 278 template <typename Func>; 279 Gr",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/Functor_8h_source.html:981,Usability,simpl,simple,981,". ROOT: math/mathcore/inc/Math/Functor.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functor.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Mon Nov 13 15:58:13 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for Functor classes.; 12// designed is inspired by the Loki Functor; 13 ; 14#ifndef ROOT_Math_Functor; 15#define ROOT_Math_Functor; 16 ; 17#include ""Math/IFunction.h""; 18 ; 19// #ifndef Root_Math_StaticCheck; 20// #include ""Math/StaticCheck.h""; 21// #endif; 22 ; 23#include <memory>; 24#include <functional>; 25#include <vector>; 26 ; 27namespace ROOT {; 28 ; 29namespace Math {; 30 ; 31/**; 32 Documentation for class Functor class.; 33 It is used to wrap in a very simple and convenient way multi-dimensional function objects.; 34 It can wrap all the following types:; 35 <ul>; 36 <li> any C++ callable object implementation double operator()( const double * ); 37 <li> a free C function of type double ()(const double * ); 38 <li> an std::function of type std::function<double (double const *)>; 39 <li> a member function with the correct signature like Foo::Eval(const double * ).; 40 In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); 41 </ul>; 42 The function dimension is required when constructing the functor.; 43 ; 44 @ingroup GenFunc; 45 ; 46 */; 47class Functor : public IBaseFunctionMultiDim {; 48 ; 49public:; 50 ; 51 /// Default constructor.; 52 Functor () {}; 53 ; 54 /// Construct from a pointer to member function (multi-dim type).; 55 template <class PtrObj, typename MemFn>; 56 Functor(const PtrObj& p, MemFn memFn, unsigned int dim ); 57 : fDim{dim}, fFunc{std::bind(memFn, p, std::placeholders::_1)}; 58 {}; 59 ; 60 /// Cons",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/Functor_8h_source.html:2755,Usability,simpl,simple,2755,"(const PtrObj& p, MemFn memFn, unsigned int dim ); 57 : fDim{dim}, fFunc{std::bind(memFn, p, std::placeholders::_1)}; 58 {}; 59 ; 60 /// Construct from a callable object of multi-dimension; 61 /// with the right signature (implementing `double operator()(const double *x)`).; 62 Functor(std::function<double(double const *)> const& f, unsigned int dim ) : fDim{dim}, fFunc{f} {}; 63 ; 64 // clone of the function handler (use copy-ctor); 65 Functor * Clone() const override { return new Functor(*this); }; 66 ; 67 // for multi-dimensional functions; 68 unsigned int NDim() const override { return fDim; }; 69 ; 70private :; 71 ; 72 inline double DoEval (const double * x) const override {; 73 return fFunc(x);; 74 }; 75 ; 76 unsigned int fDim;; 77 std::function<double(double const *)> fFunc;; 78};; 79 ; 80/**; 81 Functor1D class for one-dimensional functions.; 82 It is used to wrap in a very simple and convenient way:; 83 <ul>; 84 <li> any C++ callable object implementation double operator()( double ); 85 <li> a free C function of type double ()(double ); 86 <li> a member function with the correct signature like Foo::Eval(double ).; 87 In this case one pass the object pointer and a pointer to the member function (&Foo::Eval); 88 </ul>; 89 ; 90 ; 91 @ingroup GenFunc; 92 ; 93 */; 94 ; 95class Functor1D : public IBaseFunctionOneDim {; 96 ; 97public:; 98 ; 99 /// Default constructor.; 100 Functor1D() = default;; 101 ; 102 /// Construct from a callable object with the right signature; 103 /// implementing `double operator() (double x)`.; 104 Functor1D(std::function<double(double)> const& f) : fFunc{f} {}; 105 ; 106 // Construct from a pointer to member function (1D type).; 107 template <class PtrObj, typename MemFn>; 108 Functor1D(const PtrObj& p, MemFn memFn) : fFunc{std::bind(memFn, p, std::placeholders::_1)} {}; 109 ; 110 // Clone of the function handler (use copy-ctor).; 111 Functor1D * Clone() const override { return new Functor1D(*this); }; 112 ; 113private :; 114 ; 115 inli",MatchSource.WIKI,doc/master/Functor_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Functor_8h_source.html
https://root.cern/doc/master/gaxis2_8C.html:858,Testability,log,logarithmic,858,". ROOT: tutorials/graphics/gaxis2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis2.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Example illustrating how to draw TGaxis with labels defined by a function. . ; void gaxis2(){; gStyle->SetOptStat(0);; ; TH2F *h2 = new TH2F(""h"",""Axes"",100,0,10,100,-2,2);; h2->Draw();; ; TF1 *f1 = new TF1(""f1"",""-x"",-10,10);; TGaxis *A1 = new TGaxis(0,2,10,2,""f1"",510,""-"");; A1->SetTitle(""axis with decreasing values"");; A1->Draw();; ; TF1 *f2 = new TF1(""f2"",""exp(x)"",0,2);; TGaxis *A2 = new TGaxis(1,1,9,1,""f2"");; A2->SetTitle(""exponential axis"");; A2->SetLabelSize(0.03);; A2->SetTitleSize(0.03);; A2->SetTitleOffset(1.2);; A2->Draw();; ; TF1 *f3 = new TF1(""f3"",""log10(x)"",1,1000);; TGaxis *A3 = new TGaxis(2,-2,2,0,""f3"",505,""G"");; A3->SetTitle(""logarithmic axis"");; A3->SetLabelSize(0.03);; A3->SetTitleSize(0.03);; A3->SetTitleOffset(1.2);; A3->Draw();; }; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TF11-Dim function classDefinition TF1.h:233; TGaxisThe axis painter class.Definition TGaxis.h:24; TGaxis::SetTitleOffsetvoid SetTitleOffset(Float_t titleoffset=1)Definition TGaxis.h:128; TGaxis::SetTitleSizevoid SetTitleSize(Float_t titlesize)Definition TGaxis.h:129; TGaxis::SetTitlevirtual void SetTitle(const char *title="""")Change the title of the axis.Definition TGaxis.cxx:2942; TGaxis::SetLabelSizevoid SetLabelSize(Float_t labelsize)Definition TGaxis.h:107; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; f1TF1 * f1Definition legend1.C:11; AuthorOlivier Couet ; Definition in file gaxis2.C. tutorialsgraphicsgaxis2.C. ROOT master - ",MatchSource.WIKI,doc/master/gaxis2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gaxis2_8C.html
https://root.cern/doc/master/gaxis_8C.html:1272,Safety,avoid,avoid,1272,". ROOT: tutorials/graphics/gaxis.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gaxis.C File ReferenceTutorials » Graphics tutorials. Detailed Description; Simple example illustrating how to draw TGaxis objects in various formats. . ; void gaxis(){; auto c1 = new TCanvas(""c1"",""Examples of TGaxis"",10,10,700,500);; c1->Range(-10,-1,10,1);; ; auto axis1 = new TGaxis(-4.5,-0.2,5.5,-0.2,-6,8,510,"""");; axis1->Draw();; ; auto axis2 = new TGaxis(-4.5,0.2,5.5,0.2,0.001,10000,510,""G"");; axis2->Draw();; ; auto axis3 = new TGaxis(-9,-0.8,-9,0.8,-8,8,50510,"""");; axis3->SetTitle(""axis3"");; axis3->SetTitleOffset(0.5);; axis3->Draw();; ; auto axis4 = new TGaxis(-7,-0.8,-7,0.8,1,10000,50510,""G"");; axis4->SetTitle(""axis4"");; axis4->Draw();; ; auto axis5 = new TGaxis(-4.5,-0.6,5.5,-0.6,1.2,1.32,80506,""-+"");; axis5->SetLabelSize(0.03);; axis5->SetTextFont(72);; axis5->Draw();; ; auto axis6 = new TGaxis(-4.5,0.5,5.5,0.5,100,900,50510,""-"");; axis6->Draw();; ; auto axis7 = new TGaxis(-5.5,0.85,5.5,0.85,0,4.3e-6,510,"""");; axis7->Draw();; ; auto axis8 = new TGaxis(8,-0.8,8,0.8,0,9000,50510,""+L"");; axis8->Draw();; ; // One can make a vertical axis going top->bottom. However the two x values should be; // slightly different to avoid labels overlapping.; auto axis9 = new TGaxis(6.5,0.8,6.499,-0.8,0,90,50510,""-"");; axis9->Draw();; }; TCanvasThe Canvas class.Definition TCanvas.h:23; TGaxisThe axis painter class.Definition TGaxis.h:24; c1return c1Definition legend1.C:41; AuthorsRene Brun, Olivier Couet ; Definition in file gaxis.C. tutorialsgraphicsgaxis.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gaxis_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gaxis_8C.html
https://root.cern/doc/master/GenAlgoOptions_8cxx_source.html:3676,Deployability,configurat,configuration,3676,"return gOpts[algoname];; 64 return *opt;; 65 }; 66 ; 67 void GenAlgoOptions::PrintAllDefault(std::ostream & os) {; 68 const OptionsMap & gOpts = GenAlgoOptUtil::gAlgoOptions;; 69 for ( OptionsMap::const_iterator pos = gOpts.begin();; 70 pos != gOpts.end(); ++pos) {; 71 os << ""Default specific options for algorithm "" << pos->first << "" : "" << std::endl;; 72 (pos->second).Print(os);; 73 }; 74 }; 75 ; 76 } // end namespace Math; 77 ; 78} // end namespace ROOT; 79 ; GenAlgoOptions.h; ROOT::Math::GenAlgoOptionsclass implementing generic options for a numerical algorithm Just store the options in a map of strin...Definition GenAlgoOptions.h:32; ROOT::Math::GenAlgoOptions::PrintAllDefaultstatic void PrintAllDefault(std::ostream &os=std::cout)print all the default optionsDefinition GenAlgoOptions.cxx:67; ROOT::Math::GenAlgoOptions::Printvoid Print(std::ostream &os=std::cout) const overrideprint optionsDefinition GenAlgoOptions.h:114; ROOT::Math::GenAlgoOptions::Defaultstatic IOptions & Default(const char *algoname)Definition GenAlgoOptions.cxx:55; ROOT::Math::GenAlgoOptions::FindDefaultstatic IOptions * FindDefault(const char *algoname)Definition GenAlgoOptions.cxx:48; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; MathNamespace for new Math classes and functions.; ROOT::Math::GenAlgoOptUtil::gAlgoOptionsstatic OptionsMap gAlgoOptionsDefinition GenAlgoOptions.cxx:30; ROOT::Math::GenAlgoOptUtil::DoFindDefaultIOptions * DoFindDefault(std::string &algoname, OptionsMap &gOpts)Definition GenAlgoOptions.cxx:33; ROOT::Math::OptionsMapstd::map< std::string, ROOT::Math::GenAlgoOptions > OptionsMapDefinition GenAlgoOptions.cxx:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoresrcGenAlgoOptions.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/GenAlgoOptions_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenAlgoOptions_8cxx_source.html
https://root.cern/doc/master/GenAlgoOptions_8cxx_source.html:3653,Integrability,interface,interface,3653,"return gOpts[algoname];; 64 return *opt;; 65 }; 66 ; 67 void GenAlgoOptions::PrintAllDefault(std::ostream & os) {; 68 const OptionsMap & gOpts = GenAlgoOptUtil::gAlgoOptions;; 69 for ( OptionsMap::const_iterator pos = gOpts.begin();; 70 pos != gOpts.end(); ++pos) {; 71 os << ""Default specific options for algorithm "" << pos->first << "" : "" << std::endl;; 72 (pos->second).Print(os);; 73 }; 74 }; 75 ; 76 } // end namespace Math; 77 ; 78} // end namespace ROOT; 79 ; GenAlgoOptions.h; ROOT::Math::GenAlgoOptionsclass implementing generic options for a numerical algorithm Just store the options in a map of strin...Definition GenAlgoOptions.h:32; ROOT::Math::GenAlgoOptions::PrintAllDefaultstatic void PrintAllDefault(std::ostream &os=std::cout)print all the default optionsDefinition GenAlgoOptions.cxx:67; ROOT::Math::GenAlgoOptions::Printvoid Print(std::ostream &os=std::cout) const overrideprint optionsDefinition GenAlgoOptions.h:114; ROOT::Math::GenAlgoOptions::Defaultstatic IOptions & Default(const char *algoname)Definition GenAlgoOptions.cxx:55; ROOT::Math::GenAlgoOptions::FindDefaultstatic IOptions * FindDefault(const char *algoname)Definition GenAlgoOptions.cxx:48; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; MathNamespace for new Math classes and functions.; ROOT::Math::GenAlgoOptUtil::gAlgoOptionsstatic OptionsMap gAlgoOptionsDefinition GenAlgoOptions.cxx:30; ROOT::Math::GenAlgoOptUtil::DoFindDefaultIOptions * DoFindDefault(std::string &algoname, OptionsMap &gOpts)Definition GenAlgoOptions.cxx:33; ROOT::Math::OptionsMapstd::map< std::string, ROOT::Math::GenAlgoOptions > OptionsMapDefinition GenAlgoOptions.cxx:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoresrcGenAlgoOptions.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/GenAlgoOptions_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenAlgoOptions_8cxx_source.html
https://root.cern/doc/master/GenAlgoOptions_8cxx_source.html:3676,Modifiability,config,configuration,3676,"return gOpts[algoname];; 64 return *opt;; 65 }; 66 ; 67 void GenAlgoOptions::PrintAllDefault(std::ostream & os) {; 68 const OptionsMap & gOpts = GenAlgoOptUtil::gAlgoOptions;; 69 for ( OptionsMap::const_iterator pos = gOpts.begin();; 70 pos != gOpts.end(); ++pos) {; 71 os << ""Default specific options for algorithm "" << pos->first << "" : "" << std::endl;; 72 (pos->second).Print(os);; 73 }; 74 }; 75 ; 76 } // end namespace Math; 77 ; 78} // end namespace ROOT; 79 ; GenAlgoOptions.h; ROOT::Math::GenAlgoOptionsclass implementing generic options for a numerical algorithm Just store the options in a map of strin...Definition GenAlgoOptions.h:32; ROOT::Math::GenAlgoOptions::PrintAllDefaultstatic void PrintAllDefault(std::ostream &os=std::cout)print all the default optionsDefinition GenAlgoOptions.cxx:67; ROOT::Math::GenAlgoOptions::Printvoid Print(std::ostream &os=std::cout) const overrideprint optionsDefinition GenAlgoOptions.h:114; ROOT::Math::GenAlgoOptions::Defaultstatic IOptions & Default(const char *algoname)Definition GenAlgoOptions.cxx:55; ROOT::Math::GenAlgoOptions::FindDefaultstatic IOptions * FindDefault(const char *algoname)Definition GenAlgoOptions.cxx:48; ROOT::Math::IOptionsGeneric interface for defining configuration options of a numerical algorithm.Definition IOptions.h:28; MathNamespace for new Math classes and functions.; ROOT::Math::GenAlgoOptUtil::gAlgoOptionsstatic OptionsMap gAlgoOptionsDefinition GenAlgoOptions.cxx:30; ROOT::Math::GenAlgoOptUtil::DoFindDefaultIOptions * DoFindDefault(std::string &algoname, OptionsMap &gOpts)Definition GenAlgoOptions.cxx:33; ROOT::Math::OptionsMapstd::map< std::string, ROOT::Math::GenAlgoOptions > OptionsMapDefinition GenAlgoOptions.cxx:25; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoresrcGenAlgoOptions.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/GenAlgoOptions_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenAlgoOptions_8cxx_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:4509,Availability,error,error,4509,"size_t InputHeight, size_t InputWidth, size_t Depth,; 91 size_t Height, size_t Width, size_t WeightsNSlices, std::vector<size_t> WeightsNRows,; 92 std::vector<size_t> WeightsNCols, size_t BiasesNSlices, std::vector<size_t> BiasesNRows,; 93 std::vector<size_t> BiasesNCols, size_t OutputNSlices, size_t OutputNRows, size_t OutputNCols,; 94 EInitialization Init);; 95 ; 96 /*! Copy the layer provided as a pointer */; 97 VGeneralLayer(VGeneralLayer<Architecture_t> *layer);; 98 ; 99 /*! Copy Constructor */; 100 VGeneralLayer(const VGeneralLayer &);; 101 ; 102 /*! Virtual Destructor. */; 103 virtual ~VGeneralLayer();; 104 ; 105 /*! Initialize the weights and biases according to the given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<M",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:26179,Availability,error,error,26179,"trixT<Scalar_t> tmatrix(rows, cols);; 555 ; 556 const char * matrixString = gTools().xmlengine().GetNodeContent(matrixXML);; 557 std::stringstream matrixStringStream(matrixString);; 558 ; 559 for (size_t i = 0; i < rows; i++); 560 {; 561 for (size_t j = 0; j < cols; j++); 562 {; 563#ifndef R__HAS_TMVAGPU; 564 matrixStringStream >> tmatrix(i,j);; 565#else; 566 Scalar_t value;; 567 matrixStringStream >> value;; 568 tmatrix(i,j) = value;; 569#endif; 570 ; 571 }; 572 }; 573 ; 574 // copy from tmatrix to matrix; 575 Matrix_t tmp( tmatrix);; 576 Architecture_t::Copy(matrix, tmp);; 577 ; 578}; 579 ; 580 ; 581template <typename Architecture>; 582auto debugTensor(const typename Architecture::Tensor_t & A, const std::string name = ""tensor"") -> void; 583{; 584 Architecture::PrintTensor(A,name);; 585}; 586 ; 587} // namespace DNN; 588} // namespace TMVA; 589 ; 590#endif; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; heightOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t heightDefinition TGWin32VirtualXProxy.cxx:164; namechar name[80]Definition TGX11.cxx:110; Tools.h; TMVA::DNN::VGeneralLayerGeneric General Layer class.Definition GeneralLayer.h:51; TMVA::DNN::VGeneralLayer::fWeightGradientsstd::vector< Matrix_t > fWeightGrad",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:34581,Availability,error,error,34581,"Biases()Definition GeneralLayer.h:179; TMVA::DNN::VGeneralLayer::GetExtraLayerParametersvirtual std::vector< Matrix_t > GetExtraLayerParameters() constDefinition GeneralLayer.h:210; TMVA::DNN::VGeneralLayer::WriteMatrixToXMLvoid WriteMatrixToXML(void *node, const char *name, const Matrix_t &matrix)Definition GeneralLayer.h:521; TMVA::DNN::VGeneralLayer::GetActivationGradientsAtMatrix_t GetActivationGradientsAt(size_t i)Definition GeneralLayer.h:205; TMVA::DNN::VGeneralLayer::GetWeightGradientsstd::vector< Matrix_t > & GetWeightGradients()Definition GeneralLayer.h:185; TMVA::DNN::VGeneralLayer::GetActivationGradientsconst Tensor_t & GetActivationGradients() constDefinition GeneralLayer.h:199; TMVA::DNN::VGeneralLayer::fInputHeightsize_t fInputHeightThe height of the previous layer or input.Definition GeneralLayer.h:62; TMVA::DNN::VGeneralLayer::fDepthsize_t fDepthThe depth of the layer.Definition GeneralLayer.h:65; TMVA::DNN::VGeneralLayer::Backwardvirtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward)=0Backpropagates the error.; TMVA::DNN::VGeneralLayer::CopyBiasesvoid CopyBiases(const std::vector< Matrix_t > &otherBiases)Copies the biases provided as an input.Definition GeneralLayer.h:468; TMVA::DNN::VGeneralLayer::Updatevoid Update(const Scalar_t learningRate)Updates the weights and biases, given the learning rate.Definition GeneralLayer.h:410; TMVA::DNN::VGeneralLayer::GetBiasesAtconst Matrix_t & GetBiasesAt(size_t i) constDefinition GeneralLayer.h:181; TMVA::DNN::VGeneralLayer::ResetTrainingvirtual void ResetTraining()Reset some training flags after a loop on all batches Some layer (e.g.Definition GeneralLayer.h:121; TMVA::DNN::VGeneralLayer::GetInputHeightsize_t GetInputHeight() constDefinition GeneralLayer.h:165; TMVA::DNN::VGeneralLayer::SetInputWidthvoid SetInputWidth(size_t inputWidth)Definition GeneralLayer.h:220; TMVA::DNN::VGeneralLayer::GetBiasGradientsAtconst Matrix_t & GetBiasGradientsAt(size_t i) constDefinition Gen",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:375,Deployability,integrat,integrated,375,". ROOT: tmva/tmva/inc/TMVA/DNN/GeneralLayer.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. GeneralLayer.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Vladimir Ilievski; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : TGeneralLayer *; 8 * *; 9 * *; 10 * Description: *; 11 * General Deep Neural Network Layer *; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_GENERALLAYER; 28#define TMVA_DNN_GENERALLAYER; 29 ; 30#include <sstream>; 31#include <limits>; 32#include <vector>; 33#include <string>; 34 ; 35// for xml; 36#include ""TMVA/Tools.h""; 37#include ""TError.h"" // for R__ASSERT; 38 ; 39#include ""TMVA/DNN/Functions.h""; 40 ; 41namespace TMVA {; 42namespace DNN {; 43 ; 44/** \class VGeneralLayer; 45 Generic General Layer class.; 46 ; 47 This class represents the general class for all layers in the Deep Learning; 48 Module.; 49 */; 50template <typename Architecture_t>; 51class VGeneralLayer {; 52 ; 53 using Tensor_t = typename Architecture_t::Tensor_t;; 54 using Matrix_t = typename Architecture_t::Matrix_t;; 55 using Scalar_t = typename Architecture_t::Scalar_t;; 56 ; 57 ; 58protected:; 59 size_t fBatchSize; ///< Batch size used for training and evaluation; 60 ; 61 size_t fInputDepth; ///< The depth of the previous ",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:375,Integrability,integrat,integrated,375,". ROOT: tmva/tmva/inc/TMVA/DNN/GeneralLayer.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. GeneralLayer.h. Go to the documentation of this file. 1// @(#)root/tmva/tmva/dnn:$Id$; 2// Author: Vladimir Ilievski; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : TGeneralLayer *; 8 * *; 9 * *; 10 * Description: *; 11 * General Deep Neural Network Layer *; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_GENERALLAYER; 28#define TMVA_DNN_GENERALLAYER; 29 ; 30#include <sstream>; 31#include <limits>; 32#include <vector>; 33#include <string>; 34 ; 35// for xml; 36#include ""TMVA/Tools.h""; 37#include ""TError.h"" // for R__ASSERT; 38 ; 39#include ""TMVA/DNN/Functions.h""; 40 ; 41namespace TMVA {; 42namespace DNN {; 43 ; 44/** \class VGeneralLayer; 45 Generic General Layer class.; 46 ; 47 This class represents the general class for all layers in the Deep Learning; 48 Module.; 49 */; 50template <typename Architecture_t>; 51class VGeneralLayer {; 52 ; 53 using Tensor_t = typename Architecture_t::Tensor_t;; 54 using Matrix_t = typename Architecture_t::Matrix_t;; 55 using Scalar_t = typename Architecture_t::Scalar_t;; 56 ; 57 ; 58protected:; 59 size_t fBatchSize; ///< Batch size used for training and evaluation; 60 ; 61 size_t fInputDepth; ///< The depth of the previous ",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:1562,Modifiability,layers,layers,1562,"*; 12 * *; 13 * Authors (alphabetical): *; 14 * Vladimir Ilievski <ilievski.vladimir@live.com> - CERN, Switzerland *; 15 * *; 16 * Copyright (c) 2005-2015: *; 17 * CERN, Switzerland *; 18 * U. of Victoria, Canada *; 19 * MPI-K Heidelberg, Germany *; 20 * U. of Bonn, Germany *; 21 * *; 22 * Redistribution and use in source and binary forms, with or without *; 23 * modification, are permitted according to the terms listed in LICENSE *; 24 * (see tmva/doc/LICENSE) *; 25 **********************************************************************************/; 26 ; 27#ifndef TMVA_DNN_GENERALLAYER; 28#define TMVA_DNN_GENERALLAYER; 29 ; 30#include <sstream>; 31#include <limits>; 32#include <vector>; 33#include <string>; 34 ; 35// for xml; 36#include ""TMVA/Tools.h""; 37#include ""TError.h"" // for R__ASSERT; 38 ; 39#include ""TMVA/DNN/Functions.h""; 40 ; 41namespace TMVA {; 42namespace DNN {; 43 ; 44/** \class VGeneralLayer; 45 Generic General Layer class.; 46 ; 47 This class represents the general class for all layers in the Deep Learning; 48 Module.; 49 */; 50template <typename Architecture_t>; 51class VGeneralLayer {; 52 ; 53 using Tensor_t = typename Architecture_t::Tensor_t;; 54 using Matrix_t = typename Architecture_t::Matrix_t;; 55 using Scalar_t = typename Architecture_t::Scalar_t;; 56 ; 57 ; 58protected:; 59 size_t fBatchSize; ///< Batch size used for training and evaluation; 60 ; 61 size_t fInputDepth; ///< The depth of the previous layer or input.; 62 size_t fInputHeight; ///< The height of the previous layer or input.; 63 size_t fInputWidth; ///< The width of the previous layer or input.; 64 ; 65 size_t fDepth; ///< The depth of the layer.; 66 size_t fHeight; ///< The height of the layer.; 67 size_t fWidth; ///< The width of this layer.; 68 ; 69 bool fIsTraining; ///< Flag indicating the mode; 70 ; 71 std::vector<Matrix_t> fWeights; ///< The weights associated to the layer.; 72 std::vector<Matrix_t> fBiases; ///< The biases associated to the layer.; 73 ; 74 std::vector<Mat",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:6954,Modifiability,layers,layers,6954,,MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:13199,Modifiability,layers,layers,13199,"_________; 263template <typename Architecture_t>; 264VGeneralLayer<Architecture_t>::VGeneralLayer(size_t batchSize, size_t inputDepth, size_t inputHeight, size_t inputWidth,; 265 size_t depth, size_t height, size_t width, size_t weightsNSlices,; 266 std::vector<size_t> weightsNRows, std::vector<size_t> weightsNCols,; 267 size_t biasesNSlices, std::vector<size_t> biasesNRows,; 268 std::vector<size_t> biasesNCols, size_t outputNSlices, size_t outputNRows,; 269 size_t outputNCols, EInitialization init); 270 : fBatchSize(batchSize), fInputDepth(inputDepth), fInputHeight(inputHeight), fInputWidth(inputWidth), fDepth(depth),; 271 fHeight(height), fWidth(width), fIsTraining(true), fWeights(), fBiases(), fWeightGradients(), fBiasGradients(),; 272 fOutput( outputNSlices, outputNRows, outputNCols ),; 273 fActivationGradients( outputNSlices, outputNRows, outputNCols ),; 274 fInit(init); 275{; 276 // add constructor for weights with different shapes (e.g. in recurrent layers); 277 for (size_t i = 0; i < weightsNSlices; i++) {; 278 fWeights.emplace_back(weightsNRows[i], weightsNCols[i]);; 279 fWeightGradients.emplace_back(weightsNRows[i], weightsNCols[i]);; 280 }; 281 ; 282 for (size_t i = 0; i < biasesNSlices; i++) {; 283 fBiases.emplace_back(biasesNRows[i], biasesNCols[i]);; 284 fBiasGradients.emplace_back(biasesNRows[i], biasesNCols[i]);; 285 }; 286 ; 287 // for (size_t i = 0; i < outputNSlices; i++) {; 288 // fOutput.emplace_back(outputNRows, outputNCols);; 289 // fActivationGradients.emplace_back(outputNRows, outputNCols);; 290 // }; 291}; 292 ; 293//_________________________________________________________________________________________________; 294template <typename Architecture_t>; 295VGeneralLayer<Architecture_t>::VGeneralLayer(VGeneralLayer<Architecture_t> *layer); 296 : fBatchSize(layer->GetBatchSize()), fInputDepth(layer->GetInputDepth()), fInputHeight(layer->GetInputHeight()),; 297 fInputWidth(layer->GetInputWidth()), fDepth(layer->GetDepth()), fHeight(layer->GetHei",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:38865,Modifiability,variab,variable,38865,")Definition GeneralLayer.h:197; TMVA::DNN::VGeneralLayer::~VGeneralLayervirtual ~VGeneralLayer()Virtual Destructor.Definition GeneralLayer.h:388; TMVA::DNN::VGeneralLayer::GetOutputAtconst Matrix_t & GetOutputAt(size_t i) constDefinition GeneralLayer.h:203; TMVA::DNN::VGeneralLayer::VGeneralLayerVGeneralLayer(size_t BatchSize, size_t InputDepth, size_t InputHeight, size_t InputWidth, size_t Depth, size_t Height, size_t Width, size_t WeightsNSlices, size_t WeightsNRows, size_t WeightsNCols, size_t BiasesNSlices, size_t BiasesNRows, size_t BiasesNCols, size_t OutputNSlices, size_t OutputNRows, size_t OutputNCols, EInitialization Init)Constructor.Definition GeneralLayer.h:239; TMVA::DNN::VGeneralLayer::GetInputWidthsize_t GetInputWidth() constDefinition GeneralLayer.h:166; TMVA::Tools::xmlengineTXMLEngine & xmlengine()Definition Tools.h:262; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Tools::GetChildvoid * GetChild(void *parent, const char *childname=nullptr)get child nodeDefinition Tools.cxx:1150; TMatrixTTMatrixT.Definition TMatrixT.h:40; TXMLEngine::NewChildXMLNodePointer_t NewChild(XMLNodePointer_t parent, XMLNsPointer_t ns, const char *name, const char *content=nullptr)create new child element for parent nodeDefinition TXMLEngine.cxx:715; TXMLEngine::GetNodeContentconst char * GetNodeContent(XMLNodePointer_t xmlnode)get contents (if any) of xmlnodeDefinition TXMLEngine.cxx:1083; int; TMVA::DNN::EInitializationEInitializationDefinition Functions.h:72; TMVA::DNN::EInitialization::kZero@ kZero; TMVA::DNN::debugTensorauto debugTensor(const typename Architecture::Tensor_t &A, const std::string name=""tensor"") -> voidDefinition GeneralLayer.h:582; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); Functions.h. tmvatmvaincTMVADNNGeneralLayer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:58 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:21742,Testability,assert,assert,21742,"Gradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(const std::vector<Matrix_t> &otherWeights) -> void; 459{; 460 ; 461 for (size_t i = 0; i < fWeights.size(); i++) {; 462 Architecture_t::Copy(fWeights[i], otherWeights[i]);; 463 }; 464}; 465 ; 466//_________________________________________________________________________________________________; 467template <typename Architecture_t>; 468auto VGeneralLayer<Architecture_t>::CopyBiases(const std::vector<Matrix_t> &otherBiases) -> void; 469{; 470 for (size_t i = 0; i < fBiases.size(); i++) {; 471 Architecture_t::Copy(fBiases[i], otherBiases[i]);; 472 }; 473}; 474 ; 475//_________________________________________________________________________________________________; 476template <typename Architecture_t>; 477template <typename Arch>; 478void VGeneralLayer<Architecture_t>::CopyParameters(const VGeneralLayer<Arch> &layer); 479{; 480 //assert(!std::is_same<Arch, Architecture_t>::value);; 481 // copy weights from a different architecture- default generic implementation; 482 Architecture_t::CopyDiffArch(this->GetWeights(), layer.GetWeights());; 483 Architecture_t::CopyDiffArch(this->GetBiases(), layer.GetBiases());; 484 ; 485 // copy also the additional layer parameters; 486 auto params = layer.GetExtraLayerParameters();; 487 if (params.size() > 0) {; 488 auto paramsToCopy = GetExtraLayerParameters();; 489 Architecture_t::CopyDiffArch(paramsToCopy, params );; 490 SetExtraLayerParameters(paramsToCopy);; 491 }; 492}; 493 ; 494//_________________________________________________________________________________________________; 495template <typename Architecture_t>; 496auto VGeneralLayer<Architecture_t>::WriteTensorToXML(void * node, const char * name, const std::vector<Matrix_t> & tensor) -> void; 497{; 498 auto xmlengine = gTools().xmlengi",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5087,Usability,learn,learning,5087,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5136,Usability,learn,learningRate,5136,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5215,Usability,learn,learning,5215,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5318,Usability,learn,learningRate,5318,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5396,Usability,learn,learning,5396,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5496,Usability,learn,learningRate,5496,"error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5594,Usability,learn,learning,5594,"error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5705,Usability,learn,learningRate,5705,"td::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<Arch> &layer);; 149 ; 150 /*! Prints the info about the layer. */; 151 virtual void Print() const = 0;; 152 ; 153 /*! Writes the information and the weights about the layer in an XML node. */; 154 virtua",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5801,Usability,learn,learning,5801,"td::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<Arch> &layer);; 149 ; 150 /*! Prints the info about the layer. */; 151 virtual void Print() const = 0;; 152 ; 153 /*! Writes the information and the weights about the layer in an XML node. */; 154 virtua",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:5908,Usability,learn,learningRate,5908,"o implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<Arch> &layer);; 149 ; 150 /*! Prints the info about the layer. */; 151 virtual void Print() const = 0;; 152 ; 153 /*! Writes the information and the weights about the layer in an XML node. */; 154 virtual void AddWeightsXMLTo(void *parent) = 0;; 155 ; 156 /*! Read the information and the weights about the layer from XML node. */; 157 virtual void ReadWeightsFromXML(void *parent) = 0;; ",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:9468,Usability,learn,learned,9468,,MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:18759,Usability,learn,learningRate,18759,"ture_t>; 388VGeneralLayer<Architecture_t>::~VGeneralLayer(); 389{; 390 // Nothing to do here.; 391}; 392 ; 393//_________________________________________________________________________________________________; 394template <typename Architecture_t>; 395auto VGeneralLayer<Architecture_t>::Initialize() -> void; 396{; 397 for (size_t i = 0; i < fWeights.size(); i++) {; 398 initialize<Architecture_t>(fWeights[i], this->GetInitialization());; 399 initialize<Architecture_t>(fWeightGradients[i], EInitialization::kZero);; 400 }; 401 ; 402 for (size_t i = 0; i < fBiases.size(); i++) {; 403 initialize<Architecture_t>(fBiases[i], EInitialization::kZero);; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_______________",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:18830,Usability,learn,learningRate,18830,"ture_t>; 388VGeneralLayer<Architecture_t>::~VGeneralLayer(); 389{; 390 // Nothing to do here.; 391}; 392 ; 393//_________________________________________________________________________________________________; 394template <typename Architecture_t>; 395auto VGeneralLayer<Architecture_t>::Initialize() -> void; 396{; 397 for (size_t i = 0; i < fWeights.size(); i++) {; 398 initialize<Architecture_t>(fWeights[i], this->GetInitialization());; 399 initialize<Architecture_t>(fWeightGradients[i], EInitialization::kZero);; 400 }; 401 ; 402 for (size_t i = 0; i < fBiases.size(); i++) {; 403 initialize<Architecture_t>(fBiases[i], EInitialization::kZero);; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_______________",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:18885,Usability,learn,learningRate,18885,"ture_t>; 388VGeneralLayer<Architecture_t>::~VGeneralLayer(); 389{; 390 // Nothing to do here.; 391}; 392 ; 393//_________________________________________________________________________________________________; 394template <typename Architecture_t>; 395auto VGeneralLayer<Architecture_t>::Initialize() -> void; 396{; 397 for (size_t i = 0; i < fWeights.size(); i++) {; 398 initialize<Architecture_t>(fWeights[i], this->GetInitialization());; 399 initialize<Architecture_t>(fWeightGradients[i], EInitialization::kZero);; 400 }; 401 ; 402 for (size_t i = 0; i < fBiases.size(); i++) {; 403 initialize<Architecture_t>(fBiases[i], EInitialization::kZero);; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_______________",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:19175,Usability,learn,learningRate,19175,"ture_t>; 388VGeneralLayer<Architecture_t>::~VGeneralLayer(); 389{; 390 // Nothing to do here.; 391}; 392 ; 393//_________________________________________________________________________________________________; 394template <typename Architecture_t>; 395auto VGeneralLayer<Architecture_t>::Initialize() -> void; 396{; 397 for (size_t i = 0; i < fWeights.size(); i++) {; 398 initialize<Architecture_t>(fWeights[i], this->GetInitialization());; 399 initialize<Architecture_t>(fWeightGradients[i], EInitialization::kZero);; 400 }; 401 ; 402 for (size_t i = 0; i < fBiases.size(); i++) {; 403 initialize<Architecture_t>(fBiases[i], EInitialization::kZero);; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_______________",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:19319,Usability,learn,learningRate,19319,"; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(cons",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:19613,Usability,learn,learningRate,19613,"; 404 initialize<Architecture_t>(fBiasGradients[i], EInitialization::kZero);; 405 }; 406}; 407 ; 408//_________________________________________________________________________________________________; 409template <typename Architecture_t>; 410auto VGeneralLayer<Architecture_t>::Update(const Scalar_t learningRate) -> void; 411{; 412 this->UpdateWeights(fWeightGradients, learningRate);; 413 this->UpdateBiases(fBiasGradients, learningRate);; 414}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(cons",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:19753,Usability,learn,learningRate,19753,"}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients,; 449 const Scalar_t learningRate) -> void; 450{; 451 for (size_t i = 0; i < fBiasGradients.size(); i++) {; 452 Architecture_t::ScaleAdd(fBiasGradients[i], biasGradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(co",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:20058,Usability,learn,learningRate,20058,"}; 415 ; 416//_________________________________________________________________________________________________; 417template <typename Architecture_t>; 418auto VGeneralLayer<Architecture_t>::UpdateWeights(const std::vector<Matrix_t> &weightGradients,; 419 const Scalar_t learningRate) -> void; 420{; 421 for (size_t i = 0; i < fWeights.size(); i++) {; 422 Architecture_t::ScaleAdd(fWeights[i], weightGradients[i], -learningRate);; 423 }; 424}; 425 ; 426//_________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients,; 449 const Scalar_t learningRate) -> void; 450{; 451 for (size_t i = 0; i < fBiasGradients.size(); i++) {; 452 Architecture_t::ScaleAdd(fBiasGradients[i], biasGradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(co",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:20218,Usability,learn,learningRate,20218,"________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients,; 449 const Scalar_t learningRate) -> void; 450{; 451 for (size_t i = 0; i < fBiasGradients.size(); i++) {; 452 Architecture_t::ScaleAdd(fBiasGradients[i], biasGradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(const std::vector<Matrix_t> &otherWeights) -> void; 459{; 460 ; 461 for (size_t i = 0; i < fWeights.size(); i++) {; 462 Architecture_t::Copy(fWeights[i], otherWeights[i]);; 463 }; 464}; 465 ; 466//_________________________________________________________________________________________________; 467template <typename Architecture_t>; 468auto VGeneralLayer<Architecture_t>::CopyBiases(const std::vector<Matrix_t> &otherBiases) -> void; 469{; 470 for (size_t i",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:20519,Usability,learn,learningRate,20519,"________________________________________________________________________________________________; 427template <typename Architecture_t>; 428auto VGeneralLayer<Architecture_t>::UpdateBiases(const std::vector<Matrix_t> &biasGradients,; 429 const Scalar_t learningRate) -> void; 430{; 431 for (size_t i = 0; i < fBiases.size(); i++) {; 432 Architecture_t::ScaleAdd(fBiases[i], biasGradients[i], -learningRate);; 433 }; 434}; 435 ; 436//_________________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients,; 449 const Scalar_t learningRate) -> void; 450{; 451 for (size_t i = 0; i < fBiasGradients.size(); i++) {; 452 Architecture_t::ScaleAdd(fBiasGradients[i], biasGradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(const std::vector<Matrix_t> &otherWeights) -> void; 459{; 460 ; 461 for (size_t i = 0; i < fWeights.size(); i++) {; 462 Architecture_t::Copy(fWeights[i], otherWeights[i]);; 463 }; 464}; 465 ; 466//_________________________________________________________________________________________________; 467template <typename Architecture_t>; 468auto VGeneralLayer<Architecture_t>::CopyBiases(const std::vector<Matrix_t> &otherBiases) -> void; 469{; 470 for (size_t i",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:20673,Usability,learn,learningRate,20673,"______________________________________________________________________________________________; 437template <typename Architecture_t>; 438auto VGeneralLayer<Architecture_t>::UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients,; 439 const Scalar_t learningRate) -> void; 440{; 441 for (size_t i = 0; i < fWeightGradients.size(); i++) {; 442 Architecture_t::ScaleAdd(fWeightGradients[i], weightGradients[i], -learningRate);; 443 }; 444}; 445 ; 446//_________________________________________________________________________________________________; 447template <typename Architecture_t>; 448auto VGeneralLayer<Architecture_t>::UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients,; 449 const Scalar_t learningRate) -> void; 450{; 451 for (size_t i = 0; i < fBiasGradients.size(); i++) {; 452 Architecture_t::ScaleAdd(fBiasGradients[i], biasGradients[i], -learningRate);; 453 }; 454}; 455 ; 456//_________________________________________________________________________________________________; 457template <typename Architecture_t>; 458auto VGeneralLayer<Architecture_t>::CopyWeights(const std::vector<Matrix_t> &otherWeights) -> void; 459{; 460 ; 461 for (size_t i = 0; i < fWeights.size(); i++) {; 462 Architecture_t::Copy(fWeights[i], otherWeights[i]);; 463 }; 464}; 465 ; 466//_________________________________________________________________________________________________; 467template <typename Architecture_t>; 468auto VGeneralLayer<Architecture_t>::CopyBiases(const std::vector<Matrix_t> &otherBiases) -> void; 469{; 470 for (size_t i = 0; i < fBiases.size(); i++) {; 471 Architecture_t::Copy(fBiases[i], otherBiases[i]);; 472 }; 473}; 474 ; 475//_________________________________________________________________________________________________; 476template <typename Architecture_t>; 477template <typename Arch>; 478void VGeneralLayer<Architecture_t>::CopyParameters(const VGeneralLayer<Arch> &layer); 479{; 480 //assert(!std::is_same<Arch, Architecture_t>::value);; 4",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:28191,Usability,learn,learningRate,28191,"ts w.r.t. the weights of the layer.Definition GeneralLayer.h:74; TMVA::DNN::VGeneralLayer::fOutputTensor_t fOutputActivations of this layer.Definition GeneralLayer.h:77; TMVA::DNN::VGeneralLayer::GetWeightGradientsconst std::vector< Matrix_t > & GetWeightGradients() constDefinition GeneralLayer.h:184; TMVA::DNN::VGeneralLayer::SetDropoutProbabilityvirtual void SetDropoutProbability(Scalar_t)Set Dropout probability.Definition GeneralLayer.h:160; TMVA::DNN::VGeneralLayer::CopyParametersvoid CopyParameters(const VGeneralLayer< Arch > &layer)Copy all trainable weight and biases from another equivalent layer but with different architecture Th...Definition GeneralLayer.h:478; TMVA::DNN::VGeneralLayer::GetWeightsAtconst Matrix_t & GetWeightsAt(size_t i) constDefinition GeneralLayer.h:175; TMVA::DNN::VGeneralLayer::SetHeightvoid SetHeight(size_t height)Definition GeneralLayer.h:222; TMVA::DNN::VGeneralLayer::UpdateWeightGradientsvoid UpdateWeightGradients(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weight gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:438; TMVA::DNN::VGeneralLayer::Initializevirtual void Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DNN::VGeneralLayer::GetBiasesAtMatrix_t & GetBiasesAt(size_t i)Definition GeneralLayer.h:182; TMVA::DNN::VGeneralLayer::SetInputHeightvoid SetInputHeight(size_t inputHeight)Definition GeneralLayer.h:219; TMVA::DNN::VGeneralLayer::fBiasGradientsstd::vector< Matrix_t > fBiasGradientsGradients w.r.t. the bias values of the layer.Definition GeneralLayer.h:75; TMVA::DNN::VGeneralLayer::SetDepthvoid SetDepth(size_t depth)Definition GeneralLayer.h:221; TMVA::DNN::VGeneralLayer::SetExtraLayerParametersvirtual void SetExtraLayerParameters(const std::vector< Matrix_t > &)Definition GeneralLayer.h:212; TMVA::DNN::VGeneralLayer::ReadWeightsFromXMLvirtual void ReadWeightsFromXM",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:28272,Usability,learn,learning,28272,"ts w.r.t. the weights of the layer.Definition GeneralLayer.h:74; TMVA::DNN::VGeneralLayer::fOutputTensor_t fOutputActivations of this layer.Definition GeneralLayer.h:77; TMVA::DNN::VGeneralLayer::GetWeightGradientsconst std::vector< Matrix_t > & GetWeightGradients() constDefinition GeneralLayer.h:184; TMVA::DNN::VGeneralLayer::SetDropoutProbabilityvirtual void SetDropoutProbability(Scalar_t)Set Dropout probability.Definition GeneralLayer.h:160; TMVA::DNN::VGeneralLayer::CopyParametersvoid CopyParameters(const VGeneralLayer< Arch > &layer)Copy all trainable weight and biases from another equivalent layer but with different architecture Th...Definition GeneralLayer.h:478; TMVA::DNN::VGeneralLayer::GetWeightsAtconst Matrix_t & GetWeightsAt(size_t i) constDefinition GeneralLayer.h:175; TMVA::DNN::VGeneralLayer::SetHeightvoid SetHeight(size_t height)Definition GeneralLayer.h:222; TMVA::DNN::VGeneralLayer::UpdateWeightGradientsvoid UpdateWeightGradients(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weight gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:438; TMVA::DNN::VGeneralLayer::Initializevirtual void Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DNN::VGeneralLayer::GetBiasesAtMatrix_t & GetBiasesAt(size_t i)Definition GeneralLayer.h:182; TMVA::DNN::VGeneralLayer::SetInputHeightvoid SetInputHeight(size_t inputHeight)Definition GeneralLayer.h:219; TMVA::DNN::VGeneralLayer::fBiasGradientsstd::vector< Matrix_t > fBiasGradientsGradients w.r.t. the bias values of the layer.Definition GeneralLayer.h:75; TMVA::DNN::VGeneralLayer::SetDepthvoid SetDepth(size_t depth)Definition GeneralLayer.h:221; TMVA::DNN::VGeneralLayer::SetExtraLayerParametersvirtual void SetExtraLayerParameters(const std::vector< Matrix_t > &)Definition GeneralLayer.h:212; TMVA::DNN::VGeneralLayer::ReadWeightsFromXMLvirtual void ReadWeightsFromXM",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:29384,Usability,learn,learningRate,29384,"d Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DNN::VGeneralLayer::GetBiasesAtMatrix_t & GetBiasesAt(size_t i)Definition GeneralLayer.h:182; TMVA::DNN::VGeneralLayer::SetInputHeightvoid SetInputHeight(size_t inputHeight)Definition GeneralLayer.h:219; TMVA::DNN::VGeneralLayer::fBiasGradientsstd::vector< Matrix_t > fBiasGradientsGradients w.r.t. the bias values of the layer.Definition GeneralLayer.h:75; TMVA::DNN::VGeneralLayer::SetDepthvoid SetDepth(size_t depth)Definition GeneralLayer.h:221; TMVA::DNN::VGeneralLayer::SetExtraLayerParametersvirtual void SetExtraLayerParameters(const std::vector< Matrix_t > &)Definition GeneralLayer.h:212; TMVA::DNN::VGeneralLayer::ReadWeightsFromXMLvirtual void ReadWeightsFromXML(void *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Mat",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:29463,Usability,learn,learning,29463,"d Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DNN::VGeneralLayer::GetBiasesAtMatrix_t & GetBiasesAt(size_t i)Definition GeneralLayer.h:182; TMVA::DNN::VGeneralLayer::SetInputHeightvoid SetInputHeight(size_t inputHeight)Definition GeneralLayer.h:219; TMVA::DNN::VGeneralLayer::fBiasGradientsstd::vector< Matrix_t > fBiasGradientsGradients w.r.t. the bias values of the layer.Definition GeneralLayer.h:75; TMVA::DNN::VGeneralLayer::SetDepthvoid SetDepth(size_t depth)Definition GeneralLayer.h:221; TMVA::DNN::VGeneralLayer::SetExtraLayerParametersvirtual void SetExtraLayerParameters(const std::vector< Matrix_t > &)Definition GeneralLayer.h:212; TMVA::DNN::VGeneralLayer::ReadWeightsFromXMLvirtual void ReadWeightsFromXML(void *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Mat",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:30194,Usability,learn,learningRate,30194,"id *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition GeneralLayer.h:54; TMVA::DNN::VGeneralLayer::GetBiasGradientsconst std::vector< Matrix_t > & GetBiasGradients() constDefinition GeneralLayer.h:190; TMVA::DNN::VGeneralLayer::SetInputDepthvoid SetInputDepth(size_t inputDepth)Definition GeneralLayer.h:218; TMVA::DNN::VGeneralLayer::GetWeightsconst std::vector< Matrix_t > & GetWeights() constDefinition GeneralLayer.h:172; TMVA::DNN::VGeneralLayer::GetDepthsize_t GetDepth() constDefinition GeneralLayer.h:167; TMVA::DNN::VGeneralLayer::GetWeightsstd::vector< Matrix_t > & GetWeights()Definition GeneralLayer.h:173; TMVA::DNN::VGeneralLayer::fWidthsize_t fWidthThe width of this layer.Definition GeneralLayer.h:67; TMVA::DNN::VGeneralLayer::fInitEInitialization fInitThe initialization method.Definition GeneralLayer.h:80; TMVA::DNN:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:30256,Usability,learn,learning,30256,"id *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition GeneralLayer.h:54; TMVA::DNN::VGeneralLayer::GetBiasGradientsconst std::vector< Matrix_t > & GetBiasGradients() constDefinition GeneralLayer.h:190; TMVA::DNN::VGeneralLayer::SetInputDepthvoid SetInputDepth(size_t inputDepth)Definition GeneralLayer.h:218; TMVA::DNN::VGeneralLayer::GetWeightsconst std::vector< Matrix_t > & GetWeights() constDefinition GeneralLayer.h:172; TMVA::DNN::VGeneralLayer::GetDepthsize_t GetDepth() constDefinition GeneralLayer.h:167; TMVA::DNN::VGeneralLayer::GetWeightsstd::vector< Matrix_t > & GetWeights()Definition GeneralLayer.h:173; TMVA::DNN::VGeneralLayer::fWidthsize_t fWidthThe width of this layer.Definition GeneralLayer.h:67; TMVA::DNN::VGeneralLayer::fInitEInitialization fInitThe initialization method.Definition GeneralLayer.h:80; TMVA::DNN:",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:34813,Usability,learn,learningRate,34813,"tion GeneralLayer.h:521; TMVA::DNN::VGeneralLayer::GetActivationGradientsAtMatrix_t GetActivationGradientsAt(size_t i)Definition GeneralLayer.h:205; TMVA::DNN::VGeneralLayer::GetWeightGradientsstd::vector< Matrix_t > & GetWeightGradients()Definition GeneralLayer.h:185; TMVA::DNN::VGeneralLayer::GetActivationGradientsconst Tensor_t & GetActivationGradients() constDefinition GeneralLayer.h:199; TMVA::DNN::VGeneralLayer::fInputHeightsize_t fInputHeightThe height of the previous layer or input.Definition GeneralLayer.h:62; TMVA::DNN::VGeneralLayer::fDepthsize_t fDepthThe depth of the layer.Definition GeneralLayer.h:65; TMVA::DNN::VGeneralLayer::Backwardvirtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward)=0Backpropagates the error.; TMVA::DNN::VGeneralLayer::CopyBiasesvoid CopyBiases(const std::vector< Matrix_t > &otherBiases)Copies the biases provided as an input.Definition GeneralLayer.h:468; TMVA::DNN::VGeneralLayer::Updatevoid Update(const Scalar_t learningRate)Updates the weights and biases, given the learning rate.Definition GeneralLayer.h:410; TMVA::DNN::VGeneralLayer::GetBiasesAtconst Matrix_t & GetBiasesAt(size_t i) constDefinition GeneralLayer.h:181; TMVA::DNN::VGeneralLayer::ResetTrainingvirtual void ResetTraining()Reset some training flags after a loop on all batches Some layer (e.g.Definition GeneralLayer.h:121; TMVA::DNN::VGeneralLayer::GetInputHeightsize_t GetInputHeight() constDefinition GeneralLayer.h:165; TMVA::DNN::VGeneralLayer::SetInputWidthvoid SetInputWidth(size_t inputWidth)Definition GeneralLayer.h:220; TMVA::DNN::VGeneralLayer::GetBiasGradientsAtconst Matrix_t & GetBiasGradientsAt(size_t i) constDefinition GeneralLayer.h:193; TMVA::DNN::VGeneralLayer::WriteTensorToXMLvoid WriteTensorToXML(void *node, const char *name, const std::vector< Matrix_t > &tensor)helper functions for XMLDefinition GeneralLayer.h:496; TMVA::DNN::VGeneralLayer::GetBatchSizesize_t GetBatchSize() constGetters.Definition GeneralLayer.h:163",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:34868,Usability,learn,learning,34868,"tion GeneralLayer.h:521; TMVA::DNN::VGeneralLayer::GetActivationGradientsAtMatrix_t GetActivationGradientsAt(size_t i)Definition GeneralLayer.h:205; TMVA::DNN::VGeneralLayer::GetWeightGradientsstd::vector< Matrix_t > & GetWeightGradients()Definition GeneralLayer.h:185; TMVA::DNN::VGeneralLayer::GetActivationGradientsconst Tensor_t & GetActivationGradients() constDefinition GeneralLayer.h:199; TMVA::DNN::VGeneralLayer::fInputHeightsize_t fInputHeightThe height of the previous layer or input.Definition GeneralLayer.h:62; TMVA::DNN::VGeneralLayer::fDepthsize_t fDepthThe depth of the layer.Definition GeneralLayer.h:65; TMVA::DNN::VGeneralLayer::Backwardvirtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward)=0Backpropagates the error.; TMVA::DNN::VGeneralLayer::CopyBiasesvoid CopyBiases(const std::vector< Matrix_t > &otherBiases)Copies the biases provided as an input.Definition GeneralLayer.h:468; TMVA::DNN::VGeneralLayer::Updatevoid Update(const Scalar_t learningRate)Updates the weights and biases, given the learning rate.Definition GeneralLayer.h:410; TMVA::DNN::VGeneralLayer::GetBiasesAtconst Matrix_t & GetBiasesAt(size_t i) constDefinition GeneralLayer.h:181; TMVA::DNN::VGeneralLayer::ResetTrainingvirtual void ResetTraining()Reset some training flags after a loop on all batches Some layer (e.g.Definition GeneralLayer.h:121; TMVA::DNN::VGeneralLayer::GetInputHeightsize_t GetInputHeight() constDefinition GeneralLayer.h:165; TMVA::DNN::VGeneralLayer::SetInputWidthvoid SetInputWidth(size_t inputWidth)Definition GeneralLayer.h:220; TMVA::DNN::VGeneralLayer::GetBiasGradientsAtconst Matrix_t & GetBiasGradientsAt(size_t i) constDefinition GeneralLayer.h:193; TMVA::DNN::VGeneralLayer::WriteTensorToXMLvoid WriteTensorToXML(void *node, const char *name, const std::vector< Matrix_t > &tensor)helper functions for XMLDefinition GeneralLayer.h:496; TMVA::DNN::VGeneralLayer::GetBatchSizesize_t GetBatchSize() constGetters.Definition GeneralLayer.h:163",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:36746,Usability,learn,learningRate,36746,"N::VGeneralLayer::GetBatchSizesize_t GetBatchSize() constGetters.Definition GeneralLayer.h:163; TMVA::DNN::VGeneralLayer::GetWeightGradientsAtMatrix_t & GetWeightGradientsAt(size_t i)Definition GeneralLayer.h:188; TMVA::DNN::VGeneralLayer::ReadMatrixXMLvoid ReadMatrixXML(void *node, const char *name, Matrix_t &matrix)Definition GeneralLayer.h:544; TMVA::DNN::VGeneralLayer::Forwardvirtual void Forward(Tensor_t &input, bool applyDropout=false)=0Computes activation of the layer for the given input.; TMVA::DNN::VGeneralLayer::GetOutputAtMatrix_t GetOutputAt(size_t i)Definition GeneralLayer.h:202; TMVA::DNN::VGeneralLayer::GetWidthsize_t GetWidth() constDefinition GeneralLayer.h:169; TMVA::DNN::VGeneralLayer::GetHeightsize_t GetHeight() constDefinition GeneralLayer.h:168; TMVA::DNN::VGeneralLayer::GetWeightGradientsAtconst Matrix_t & GetWeightGradientsAt(size_t i) constDefinition GeneralLayer.h:187; TMVA::DNN::VGeneralLayer::UpdateBiasesvoid UpdateBiases(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the biases, given the gradients and the learning rate.Definition GeneralLayer.h:428; TMVA::DNN::VGeneralLayer::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition GeneralLayer.h:53; TMVA::DNN::VGeneralLayer::IsTrainingbool IsTraining() constDefinition GeneralLayer.h:170; TMVA::DNN::VGeneralLayer::GetOutputTensor_t & GetOutput()Definition GeneralLayer.h:197; TMVA::DNN::VGeneralLayer::~VGeneralLayervirtual ~VGeneralLayer()Virtual Destructor.Definition GeneralLayer.h:388; TMVA::DNN::VGeneralLayer::GetOutputAtconst Matrix_t & GetOutputAt(size_t i) constDefinition GeneralLayer.h:203; TMVA::DNN::VGeneralLayer::VGeneralLayerVGeneralLayer(size_t BatchSize, size_t InputDepth, size_t InputHeight, size_t InputWidth, size_t Depth, size_t Height, size_t Width, size_t WeightsNSlices, size_t WeightsNRows, size_t WeightsNCols, size_t BiasesNSlices, size_t BiasesNRows, size_t BiasesNCols, size_t OutputNSlices, size_t OutputNRows, size_t OutputNCols,",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneralLayer_8h_source.html:36807,Usability,learn,learning,36807,"N::VGeneralLayer::GetBatchSizesize_t GetBatchSize() constGetters.Definition GeneralLayer.h:163; TMVA::DNN::VGeneralLayer::GetWeightGradientsAtMatrix_t & GetWeightGradientsAt(size_t i)Definition GeneralLayer.h:188; TMVA::DNN::VGeneralLayer::ReadMatrixXMLvoid ReadMatrixXML(void *node, const char *name, Matrix_t &matrix)Definition GeneralLayer.h:544; TMVA::DNN::VGeneralLayer::Forwardvirtual void Forward(Tensor_t &input, bool applyDropout=false)=0Computes activation of the layer for the given input.; TMVA::DNN::VGeneralLayer::GetOutputAtMatrix_t GetOutputAt(size_t i)Definition GeneralLayer.h:202; TMVA::DNN::VGeneralLayer::GetWidthsize_t GetWidth() constDefinition GeneralLayer.h:169; TMVA::DNN::VGeneralLayer::GetHeightsize_t GetHeight() constDefinition GeneralLayer.h:168; TMVA::DNN::VGeneralLayer::GetWeightGradientsAtconst Matrix_t & GetWeightGradientsAt(size_t i) constDefinition GeneralLayer.h:187; TMVA::DNN::VGeneralLayer::UpdateBiasesvoid UpdateBiases(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the biases, given the gradients and the learning rate.Definition GeneralLayer.h:428; TMVA::DNN::VGeneralLayer::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition GeneralLayer.h:53; TMVA::DNN::VGeneralLayer::IsTrainingbool IsTraining() constDefinition GeneralLayer.h:170; TMVA::DNN::VGeneralLayer::GetOutputTensor_t & GetOutput()Definition GeneralLayer.h:197; TMVA::DNN::VGeneralLayer::~VGeneralLayervirtual ~VGeneralLayer()Virtual Destructor.Definition GeneralLayer.h:388; TMVA::DNN::VGeneralLayer::GetOutputAtconst Matrix_t & GetOutputAt(size_t i) constDefinition GeneralLayer.h:203; TMVA::DNN::VGeneralLayer::VGeneralLayerVGeneralLayer(size_t BatchSize, size_t InputDepth, size_t InputHeight, size_t InputWidth, size_t Depth, size_t Height, size_t Width, size_t WeightsNSlices, size_t WeightsNRows, size_t WeightsNCols, size_t BiasesNSlices, size_t BiasesNRows, size_t BiasesNCols, size_t OutputNSlices, size_t OutputNRows, size_t OutputNCols,",MatchSource.WIKI,doc/master/GeneralLayer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:5391,Availability,error,errors,5391,"d the return value ...Definition GeneticMinimizer.cxx:368; ROOT::Math::GeneticMinimizer::SetRandomSeedvoid SetRandomSeed(int seed)Definition GeneticMinimizer.h:94; ROOT::Math::GeneticMinimizer::NFreeunsigned int NFree() const overridenumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticMinimizer.cxx:191; ROOT::Math::GeneticMinimizer::ProvidesErrorbool ProvidesError() const overrideminimizer provides error and error matrixDefinition GeneticMinimizer.cxx:365; ROOT::Math::GeneticMinimizer::SetVariablebool SetVariable(unsigned int ivar, const std::string &name, double val, double step) overrideset a new free variableDefinition GeneticMinimizer.cxx:153; ROOT::Math::GeneticMinimizer::fResultstd::vector< double > fResultDefinition GeneticMinimizer.h:109; ROOT::Math::GeneticMinimizer::fFitne",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:5980,Availability,error,error,5980,"r supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticMinimizer.cxx:191; ROOT::Math::GeneticMinimizer::ProvidesErrorbool ProvidesError() const overrideminimizer provides error and error matrixDefinition GeneticMinimizer.cxx:365; ROOT::Math::GeneticMinimizer::SetVariablebool SetVariable(unsigned int ivar, const std::string &name, double val, double step) overrideset a new free variableDefinition GeneticMinimizer.cxx:153; ROOT::Math::GeneticMinimizer::fResultstd::vector< double > fResultDefinition GeneticMinimizer.h:109; ROOT::Math::GeneticMinimizer::fFitnessTMVA::IFitterTarget * fFitnessDefinition GeneticMinimizer.h:107; ROOT::Math::GeneticMinimizer::fRangesstd::vector< TMVA::Interval * > fRangesDefinition GeneticMinimizer.h:106; ROOT::Math::GeneticMinimizer::SetParametersvoid SetParameters(const GeneticMinimizerParameters &params)Definition GeneticMinimizer.cxx:177; ROOT::Math::GeneticMinimizer::MinGradientconst double * MinGradient() const overridereturn pointer to gradient values at the minimumDefinition GeneticMinimizer.cxx:364; ROOT::Math::GeneticMinimizer::Edmdouble Edm() const overridereturn expected distance reached f",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:5990,Availability,error,error,5990,"r supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticMinimizer.cxx:191; ROOT::Math::GeneticMinimizer::ProvidesErrorbool ProvidesError() const overrideminimizer provides error and error matrixDefinition GeneticMinimizer.cxx:365; ROOT::Math::GeneticMinimizer::SetVariablebool SetVariable(unsigned int ivar, const std::string &name, double val, double step) overrideset a new free variableDefinition GeneticMinimizer.cxx:153; ROOT::Math::GeneticMinimizer::fResultstd::vector< double > fResultDefinition GeneticMinimizer.h:109; ROOT::Math::GeneticMinimizer::fFitnessTMVA::IFitterTarget * fFitnessDefinition GeneticMinimizer.h:107; ROOT::Math::GeneticMinimizer::fRangesstd::vector< TMVA::Interval * > fRangesDefinition GeneticMinimizer.h:106; ROOT::Math::GeneticMinimizer::SetParametersvoid SetParameters(const GeneticMinimizerParameters &params)Definition GeneticMinimizer.cxx:177; ROOT::Math::GeneticMinimizer::MinGradientconst double * MinGradient() const overridereturn pointer to gradient values at the minimumDefinition GeneticMinimizer.cxx:364; ROOT::Math::GeneticMinimizer::Edmdouble Edm() const overridereturn expected distance reached f",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:8281,Integrability,interface,interface,8281,"tion GeneticMinimizer.cxx:126; ROOT::Math::GeneticMinimizer::OptionsROOT::Math::MinimizerOptions Options() const overrideretrieve the minimizer options (implement derived class if needed)Definition GeneticMinimizer.cxx:185; ROOT::Math::GeneticMinimizer::fParametersGeneticMinimizerParameters fParametersDefinition GeneticMinimizer.h:111; ROOT::Math::GeneticMinimizer::SetFunctionvoid SetFunction(const ROOT::Math::IMultiGenFunction &func) overrideset the function to minimizeDefinition GeneticMinimizer.cxx:137; ROOT::Math::GeneticMinimizer::SetFixedVariablebool SetFixedVariable(unsigned int ivar, const std::string &name, double val) overrideset a new fixed variable (override if minimizer supports them )Definition GeneticMinimizer.cxx:165; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; TMVA::IFitterTargetInterface for a fitter 'target'.Definition IFitterTarget.h:44; TMVA::IntervalThe TMVA::Interval Class.Definition Interval.h:61; double; int; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; ROOT::Math::GeneticMinimizerParametersDefinition GeneticMinimizer.h:35; ROOT::Math::GeneticMinimizerParameters::fCyclesInt_t fCyclesDefinition GeneticMinimizer.h:39; ROOT::Math::GeneticMinimizerParameters::fSC_rateInt_t fSC_rateDefinition GeneticMinimizer.h:41; ROOT::Math::GeneticMinimizerParameters::fSC_stepsInt_t fSC_stepsDefinition GeneticMinimizer.h:",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:4115,Modifiability,variab,variables,4115,") const;; 105 ; 106 std::vector<TMVA::Interval*> fRanges;; 107 TMVA::IFitterTarget* fFitness;; 108 double fMinValue;; 109 std::vector<double> fResult;; 110 ; 111 GeneticMinimizerParameters fParameters;; 112 ; 113};; 114 ; 115 ; 116 } // end namespace Math; 117} // end namespace ROOT; 118 ; 119#endif /* ROOT_Math_GeneticMinimizer */; Minimizer.h; RtypesCore.h; namechar name[80]Definition TGX11.cxx:110; ROOT::Math::GeneticMinimizerGeneticMinimizer.Definition GeneticMinimizer.h:61; ROOT::Math::GeneticMinimizer::Xconst double * X() const overridereturn pointer to X values at the minimumDefinition GeneticMinimizer.cxx:336; ROOT::Math::GeneticMinimizer::fMinValuedouble fMinValueDefinition GeneticMinimizer.h:108; ROOT::Math::GeneticMinimizer::MinimizerParametersconst GeneticMinimizerParameters & MinimizerParameters() constDefinition GeneticMinimizer.h:96; ROOT::Math::GeneticMinimizer::NDimunsigned int NDim() const overridethis is <= Function().NDim() which is the total number of variables (free+ constrained ones)Definition GeneticMinimizer.cxx:348; ROOT::Math::GeneticMinimizer::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) const overridereturn covariance matrices element for variables ivar,jvar if the variable is fixed the return value ...Definition GeneticMinimizer.cxx:368; ROOT::Math::GeneticMinimizer::SetRandomSeedvoid SetRandomSeed(int seed)Definition GeneticMinimizer.h:94; ROOT::Math::GeneticMinimizer::NFreeunsigned int NFree() const overridenumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOpti",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:4327,Modifiability,variab,variables,4327," ; 111 GeneticMinimizerParameters fParameters;; 112 ; 113};; 114 ; 115 ; 116 } // end namespace Math; 117} // end namespace ROOT; 118 ; 119#endif /* ROOT_Math_GeneticMinimizer */; Minimizer.h; RtypesCore.h; namechar name[80]Definition TGX11.cxx:110; ROOT::Math::GeneticMinimizerGeneticMinimizer.Definition GeneticMinimizer.h:61; ROOT::Math::GeneticMinimizer::Xconst double * X() const overridereturn pointer to X values at the minimumDefinition GeneticMinimizer.cxx:336; ROOT::Math::GeneticMinimizer::fMinValuedouble fMinValueDefinition GeneticMinimizer.h:108; ROOT::Math::GeneticMinimizer::MinimizerParametersconst GeneticMinimizerParameters & MinimizerParameters() constDefinition GeneticMinimizer.h:96; ROOT::Math::GeneticMinimizer::NDimunsigned int NDim() const overridethis is <= Function().NDim() which is the total number of variables (free+ constrained ones)Definition GeneticMinimizer.cxx:348; ROOT::Math::GeneticMinimizer::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) const overridereturn covariance matrices element for variables ivar,jvar if the variable is fixed the return value ...Definition GeneticMinimizer.cxx:368; ROOT::Math::GeneticMinimizer::SetRandomSeedvoid SetRandomSeed(int seed)Definition GeneticMinimizer.h:94; ROOT::Math::GeneticMinimizer::NFreeunsigned int NFree() const overridenumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition ",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:4354,Modifiability,variab,variable,4354," ; 111 GeneticMinimizerParameters fParameters;; 112 ; 113};; 114 ; 115 ; 116 } // end namespace Math; 117} // end namespace ROOT; 118 ; 119#endif /* ROOT_Math_GeneticMinimizer */; Minimizer.h; RtypesCore.h; namechar name[80]Definition TGX11.cxx:110; ROOT::Math::GeneticMinimizerGeneticMinimizer.Definition GeneticMinimizer.h:61; ROOT::Math::GeneticMinimizer::Xconst double * X() const overridereturn pointer to X values at the minimumDefinition GeneticMinimizer.cxx:336; ROOT::Math::GeneticMinimizer::fMinValuedouble fMinValueDefinition GeneticMinimizer.h:108; ROOT::Math::GeneticMinimizer::MinimizerParametersconst GeneticMinimizerParameters & MinimizerParameters() constDefinition GeneticMinimizer.h:96; ROOT::Math::GeneticMinimizer::NDimunsigned int NDim() const overridethis is <= Function().NDim() which is the total number of variables (free+ constrained ones)Definition GeneticMinimizer.cxx:348; ROOT::Math::GeneticMinimizer::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) const overridereturn covariance matrices element for variables ivar,jvar if the variable is fixed the return value ...Definition GeneticMinimizer.cxx:368; ROOT::Math::GeneticMinimizer::SetRandomSeedvoid SetRandomSeed(int seed)Definition GeneticMinimizer.h:94; ROOT::Math::GeneticMinimizer::NFreeunsigned int NFree() const overridenumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition ",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:4619,Modifiability,variab,variables,4619,".h:61; ROOT::Math::GeneticMinimizer::Xconst double * X() const overridereturn pointer to X values at the minimumDefinition GeneticMinimizer.cxx:336; ROOT::Math::GeneticMinimizer::fMinValuedouble fMinValueDefinition GeneticMinimizer.h:108; ROOT::Math::GeneticMinimizer::MinimizerParametersconst GeneticMinimizerParameters & MinimizerParameters() constDefinition GeneticMinimizer.h:96; ROOT::Math::GeneticMinimizer::NDimunsigned int NDim() const overridethis is <= Function().NDim() which is the total number of variables (free+ constrained ones)Definition GeneticMinimizer.cxx:348; ROOT::Math::GeneticMinimizer::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) const overridereturn covariance matrices element for variables ivar,jvar if the variable is fixed the return value ...Definition GeneticMinimizer.cxx:368; ROOT::Math::GeneticMinimizer::SetRandomSeedvoid SetRandomSeed(int seed)Definition GeneticMinimizer.h:94; ROOT::Math::GeneticMinimizer::NFreeunsigned int NFree() const overridenumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROO",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:4922,Modifiability,variab,variable,4922,"nimizer::MinimizerParametersconst GeneticMinimizerParameters & MinimizerParameters() constDefinition GeneticMinimizer.h:96; ROOT::Math::GeneticMinimizer::NDimunsigned int NDim() const overridethis is <= Function().NDim() which is the total number of variables (free+ constrained ones)Definition GeneticMinimizer.cxx:348; ROOT::Math::GeneticMinimizer::CovMatrixdouble CovMatrix(unsigned int i, unsigned int j) const overridereturn covariance matrices element for variables ivar,jvar if the variable is fixed the return value ...Definition GeneticMinimizer.cxx:368; ROOT::Math::GeneticMinimizer::SetRandomSeedvoid SetRandomSeed(int seed)Definition GeneticMinimizer.h:94; ROOT::Math::GeneticMinimizer::NFreeunsigned int NFree() const overridenumber of free variables (real dimension of the problem) this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticM",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:6189,Modifiability,variab,variableDefinition,6189,"ions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticMinimizer.cxx:191; ROOT::Math::GeneticMinimizer::ProvidesErrorbool ProvidesError() const overrideminimizer provides error and error matrixDefinition GeneticMinimizer.cxx:365; ROOT::Math::GeneticMinimizer::SetVariablebool SetVariable(unsigned int ivar, const std::string &name, double val, double step) overrideset a new free variableDefinition GeneticMinimizer.cxx:153; ROOT::Math::GeneticMinimizer::fResultstd::vector< double > fResultDefinition GeneticMinimizer.h:109; ROOT::Math::GeneticMinimizer::fFitnessTMVA::IFitterTarget * fFitnessDefinition GeneticMinimizer.h:107; ROOT::Math::GeneticMinimizer::fRangesstd::vector< TMVA::Interval * > fRangesDefinition GeneticMinimizer.h:106; ROOT::Math::GeneticMinimizer::SetParametersvoid SetParameters(const GeneticMinimizerParameters &params)Definition GeneticMinimizer.cxx:177; ROOT::Math::GeneticMinimizer::MinGradientconst double * MinGradient() const overridereturn pointer to gradient values at the minimumDefinition GeneticMinimizer.cxx:364; ROOT::Math::GeneticMinimizer::Edmdouble Edm() const overridereturn expected distance reached from the minimum (re-implement if minimizer provides itDefinition GeneticMinimizer.cxx:367; ROOT::Math::GeneticMinimizer::~GeneticMinimizer~GeneticMinimizer() overrideDefinition",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:7933,Modifiability,variab,variable,7933,"ouble Edm() const overridereturn expected distance reached from the minimum (re-implement if minimizer provides itDefinition GeneticMinimizer.cxx:367; ROOT::Math::GeneticMinimizer::~GeneticMinimizer~GeneticMinimizer() overrideDefinition GeneticMinimizer.cxx:117; ROOT::Math::GeneticMinimizer::Clearvoid Clear() overridereset for consecutive minimization - implement if neededDefinition GeneticMinimizer.cxx:126; ROOT::Math::GeneticMinimizer::OptionsROOT::Math::MinimizerOptions Options() const overrideretrieve the minimizer options (implement derived class if needed)Definition GeneticMinimizer.cxx:185; ROOT::Math::GeneticMinimizer::fParametersGeneticMinimizerParameters fParametersDefinition GeneticMinimizer.h:111; ROOT::Math::GeneticMinimizer::SetFunctionvoid SetFunction(const ROOT::Math::IMultiGenFunction &func) overrideset the function to minimizeDefinition GeneticMinimizer.cxx:137; ROOT::Math::GeneticMinimizer::SetFixedVariablebool SetFixedVariable(unsigned int ivar, const std::string &name, double val) overrideset a new fixed variable (override if minimizer supports them )Definition GeneticMinimizer.cxx:165; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; TMVA::IFitterTargetInterface for a fitter 'target'.Definition IFitterTarget.h:44; TMVA::IntervalThe TMVA::Interval Class.Definition Interval.h:61; double; int; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMVAcreate variable transformationsDefiniti",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:8860,Modifiability,variab,variable,8860," std::string &name, double val) overrideset a new fixed variable (override if minimizer supports them )Definition GeneticMinimizer.cxx:165; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; TMVA::IFitterTargetInterface for a fitter 'target'.Definition IFitterTarget.h:44; TMVA::IntervalThe TMVA::Interval Class.Definition Interval.h:61; double; int; MathNamespace for new Math classes and functions.; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; ROOT::Math::GeneticMinimizerParametersDefinition GeneticMinimizer.h:35; ROOT::Math::GeneticMinimizerParameters::fCyclesInt_t fCyclesDefinition GeneticMinimizer.h:39; ROOT::Math::GeneticMinimizerParameters::fSC_rateInt_t fSC_rateDefinition GeneticMinimizer.h:41; ROOT::Math::GeneticMinimizerParameters::fSC_stepsInt_t fSC_stepsDefinition GeneticMinimizer.h:40; ROOT::Math::GeneticMinimizerParameters::GeneticMinimizerParametersGeneticMinimizerParameters()Definition GeneticMinimizer.cxx:82; ROOT::Math::GeneticMinimizerParameters::fNstepsInt_t fNstepsDefinition GeneticMinimizer.h:38; ROOT::Math::GeneticMinimizerParameters::fConvCritDouble_t fConvCritDefinition GeneticMinimizer.h:43; ROOT::Math::GeneticMinimizerParameters::fSeedInt_t fSeedDefinition GeneticMinimizer.h:44; ROOT::Math::GeneticMinimizerParameters::fPopSizeInt_t fPopSizeDefinition GeneticMinimizer.h:37; ROOT::Math::GeneticMinimizerParameters::fSC_factorDouble_t fSC_factorDefinition GeneticM",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GeneticMinimizer_8h_source.html:5675,Performance,perform,perform,5675," this is <= Function().NDim() which is the to...Definition GeneticMinimizer.cxx:355; ROOT::Math::GeneticMinimizer::SetLimitedVariablebool SetLimitedVariable(unsigned int, const std::string &, double, double, double, double) overrideset a new upper/lower limited variable (override if minimizer supports them ) otherwise as default se...Definition GeneticMinimizer.cxx:146; ROOT::Math::GeneticMinimizer::SetOptionsvirtual void SetOptions(const ROOT::Math::MinimizerOptions &opt)Definition GeneticMinimizer.cxx:217; ROOT::Math::GeneticMinimizer::MinValuedouble MinValue() const overridereturn minimum function valueDefinition GeneticMinimizer.cxx:331; ROOT::Math::GeneticMinimizer::Errorsconst double * Errors() const overridereturn errors at the minimumDefinition GeneticMinimizer.cxx:366; ROOT::Math::GeneticMinimizer::NCallsunsigned int NCalls() const overridenumber of function calls to reach the minimumDefinition GeneticMinimizer.cxx:340; ROOT::Math::GeneticMinimizer::Minimizebool Minimize() overridemethod to perform the minimizationDefinition GeneticMinimizer.cxx:252; ROOT::Math::GeneticMinimizer::GetGeneticOptionsvoid GetGeneticOptions(ROOT::Math::MinimizerOptions &opt) constDefinition GeneticMinimizer.cxx:191; ROOT::Math::GeneticMinimizer::ProvidesErrorbool ProvidesError() const overrideminimizer provides error and error matrixDefinition GeneticMinimizer.cxx:365; ROOT::Math::GeneticMinimizer::SetVariablebool SetVariable(unsigned int ivar, const std::string &name, double val, double step) overrideset a new free variableDefinition GeneticMinimizer.cxx:153; ROOT::Math::GeneticMinimizer::fResultstd::vector< double > fResultDefinition GeneticMinimizer.h:109; ROOT::Math::GeneticMinimizer::fFitnessTMVA::IFitterTarget * fFitnessDefinition GeneticMinimizer.h:107; ROOT::Math::GeneticMinimizer::fRangesstd::vector< TMVA::Interval * > fRangesDefinition GeneticMinimizer.h:106; ROOT::Math::GeneticMinimizer::SetParametersvoid SetParameters(const GeneticMinimizerParameters &params)Definitio",MatchSource.WIKI,doc/master/GeneticMinimizer_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GeneticMinimizer_8h_source.html
https://root.cern/doc/master/GenVectorIO_8h_source.html:774,Deployability,update,update,774,"o to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team (FNAL component) *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Support templates (class and function) for stream i/o of vectors; 12// This is a utuility to allow for control, via manipulators, of the; 13// form of; 14//; 15// Created by: W. E. Brown and M. Fischler at Tue Jun 21 2005; 16//; 17// Last update: Tue Jun 21 2005; 18//; 19#ifndef ROOT_Math_GenVector_GenVectorIO; 20#define ROOT_Math_GenVector_GenVectorIO 1; 21 ; 22#include <cctype>; 23#include <iostream>; 24 ; 25 ; 26namespace ROOT {; 27namespace Math {; 28 ; 29namespace detail {; 30 ; 31 ; 32// -------- Manipulator support ----------; 33 ; 34 ; 35enum manip_t { open, sep, close, bitforbit };; 36 ; 37 ; 38inline int; 39 ios_data( int k ); 40{; 41 static int const ios_data[4] = { std::ios::xalloc() // open; 42 , std::ios::xalloc() // sep; 43 , std::ios::xalloc() // close; 44 , std::ios::xalloc() // bitforbit; 45 };; 46 ; 47 return ios_data[k];; 48 ; 49} // ios_data(); 50 ; 51 ; 52template< class char_t, class traits_t >; 53 inline char_t; 54 get_manip( std::basic_ios<char_t,traits_t> & ios; 55 , manip_t m; 56 ); 57{; 58 char_t ch = static_cast<char_t>( ios.iword( ios_data(m) ) );; 59 if( ch ) return ch;; 60 ; 61 switch( m ); 62 { default : return ios.widen( '?' );; 63 case open : return ios.widen( '(' );; 64 case close : return ios.widen( ')' );; 65 case sep : return ios.widen( ',' );; 66 case bitforbit : return ch;; 67 }; 68 ; 69} // get_manip<>(); 70 ; 71 ; 72template< class char_t, class traits_t >; 73 inline void; 74 set_manip( std::basic_ios<char_t,traits_t> & ios; 75 , manip_t m; 76 , char_t ch; 77 ); 78{; 79 ios.iword( ios_data(m) ) = static_cast<long>(ch);; 80 ; 81} // set_manip<>(); 82 ; 83 ; 84temp",MatchSource.WIKI,doc/master/GenVectorIO_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVectorIO_8h_source.html
https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html:629,Deployability,update,update,629,". ROOT: math/genvector/inc/Math/GenVector/AxisAngle.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. AxisAngle.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class AxisAngle; 12//; 13// Created by: Lorenzo Moneta at Wed May 11 10:37:10 2005; 14//; 15// Last update: Wed May 11 10:37:10 2005; 16//; 17#ifndef ROOT_Math_GenVector_AxisAngle; 18#define ROOT_Math_GenVector_AxisAngle 1; 19 ; 20#include ""Math/GenVector/Rotation3D.h""; 21#include ""Math/GenVector/DisplacementVector3D.h""; 22#include ""Math/GenVector/PositionVector3D.h""; 23#include ""Math/GenVector/LorentzVector.h""; 24#include ""Math/GenVector/3DConversions.h""; 25#include <algorithm>; 26#include <cassert>; 27 ; 28 ; 29namespace ROOT {; 30namespace Math {; 31 ; 32 ; 33//__________________________________________________________________________________________; 34 /**; 35 AxisAngle class describing rotation represented with direction axis (3D Vector) and an; 36 angle of rotation around that axis.; 37 ; 38 @ingroup GenVector; 39 ; 40 @sa Overview of the @ref GenVector ""physics vector library""; 41 */; 42class AxisAngle {; 43 ; 44public:; 45 ; 46 typedef double Scalar;; 47 ; 48 /**; 49 definition of vector axis; 50 */; 51 typedef DisplacementVector3D<Cartesian3D<Scalar> > AxisVector;; 52 ; 53 ; 54 /**; 55 Default constructor (axis is z and angle is zero); 56 */; 57 AxisAngle() : fAxis(0,0,1), fAngle(0) { }; 58 ; 59 /**; 60 Construct from a non-zero vector (x,y,z) and an angle.; 61 Precondition: the Vector needs to implement x(), y(), z(), and unit(); 62 */; 63 template<class AnyVector>; 64 AxisAngle(const AnyVector & v, Scalar angle) :; 65 fAxis(v.unit()), f",MatchSource.WIKI,doc/master/GenVector_2AxisAngle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html
https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html:5602,Security,access,access,5602,"151 *begin = fAngle;; 152 }; 153 ; 154 /**; 155 Set components from a non-zero vector (x,y,z) and an angle.; 156 Precondition: the Vector needs to implement x(), y(), z(), and unit(); 157 */; 158 template<class AnyVector>; 159 void SetComponents(const AnyVector & v, Scalar angle) {; 160 fAxis=v.unit();; 161 fAngle=angle;; 162 }; 163 ; 164 /**; 165 Set components into a non-zero vector (x,y,z) and an angle.; 166 The vector is intended to be a cartesian displacement vector; 167 but any vector class assignable from one will work.; 168 */; 169 template<class AnyVector>; 170 void GetComponents(AnyVector & axis, Scalar & angle) const {; 171 axis = fAxis;; 172 angle = fAngle;; 173 }; 174 ; 175 /**; 176 access to rotation axis; 177 */; 178 AxisVector Axis() const { return fAxis; }; 179 ; 180 /**; 181 access to rotation angle; 182 */; 183 Scalar Angle() const { return fAngle; }; 184 ; 185 // =========== operations ==============; 186 ; 187 /**; 188 Rotation operation on a cartesian vector; 189 */; 190 typedef DisplacementVector3D<Cartesian3D<double>, DefaultCoordinateSystemTag > XYZVector;; 191 XYZVector operator() (const XYZVector & v) const;; 192 ; 193 /**; 194 Rotation operation on a displacement vector in any coordinate system; 195 */; 196 template <class CoordSystem, class Tag>; 197 DisplacementVector3D<CoordSystem, Tag>; 198 operator() (const DisplacementVector3D<CoordSystem, Tag> & v) const {; 199 DisplacementVector3D< Cartesian3D<double> > xyz(v.X(), v.Y(), v.Z());; 200 DisplacementVector3D< Cartesian3D<double> > rxyz = operator()(xyz);; 201 DisplacementVector3D< CoordSystem, Tag > vNew;; 202 vNew.SetXYZ( rxyz.X(), rxyz.Y(), rxyz.Z() );; 203 return vNew;; 204 }; 205 ; 206 /**; 207 Rotation operation on a position vector in any coordinate system; 208 */; 209 template <class CoordSystem, class Tag>; 210 PositionVector3D<CoordSystem, Tag>; 211 operator() (const PositionVector3D<CoordSystem,Tag> & p) const {; 212 DisplacementVector3D< Cartesian3D<double>,Tag > xyz(p);; 21",MatchSource.WIKI,doc/master/GenVector_2AxisAngle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html
https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html:5701,Security,access,access,5701,"151 *begin = fAngle;; 152 }; 153 ; 154 /**; 155 Set components from a non-zero vector (x,y,z) and an angle.; 156 Precondition: the Vector needs to implement x(), y(), z(), and unit(); 157 */; 158 template<class AnyVector>; 159 void SetComponents(const AnyVector & v, Scalar angle) {; 160 fAxis=v.unit();; 161 fAngle=angle;; 162 }; 163 ; 164 /**; 165 Set components into a non-zero vector (x,y,z) and an angle.; 166 The vector is intended to be a cartesian displacement vector; 167 but any vector class assignable from one will work.; 168 */; 169 template<class AnyVector>; 170 void GetComponents(AnyVector & axis, Scalar & angle) const {; 171 axis = fAxis;; 172 angle = fAngle;; 173 }; 174 ; 175 /**; 176 access to rotation axis; 177 */; 178 AxisVector Axis() const { return fAxis; }; 179 ; 180 /**; 181 access to rotation angle; 182 */; 183 Scalar Angle() const { return fAngle; }; 184 ; 185 // =========== operations ==============; 186 ; 187 /**; 188 Rotation operation on a cartesian vector; 189 */; 190 typedef DisplacementVector3D<Cartesian3D<double>, DefaultCoordinateSystemTag > XYZVector;; 191 XYZVector operator() (const XYZVector & v) const;; 192 ; 193 /**; 194 Rotation operation on a displacement vector in any coordinate system; 195 */; 196 template <class CoordSystem, class Tag>; 197 DisplacementVector3D<CoordSystem, Tag>; 198 operator() (const DisplacementVector3D<CoordSystem, Tag> & v) const {; 199 DisplacementVector3D< Cartesian3D<double> > xyz(v.X(), v.Y(), v.Z());; 200 DisplacementVector3D< Cartesian3D<double> > rxyz = operator()(xyz);; 201 DisplacementVector3D< CoordSystem, Tag > vNew;; 202 vNew.SetXYZ( rxyz.X(), rxyz.Y(), rxyz.Z() );; 203 return vNew;; 204 }; 205 ; 206 /**; 207 Rotation operation on a position vector in any coordinate system; 208 */; 209 template <class CoordSystem, class Tag>; 210 PositionVector3D<CoordSystem, Tag>; 211 operator() (const PositionVector3D<CoordSystem,Tag> & p) const {; 212 DisplacementVector3D< Cartesian3D<double>,Tag > xyz(p);; 21",MatchSource.WIKI,doc/master/GenVector_2AxisAngle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html
https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html:4079,Testability,assert,assert,4079,"stexpr AxisAngle(const OtherRotation & r) {gv_detail::convert(r,*this);}; 95 ; 96 ; 97 /**; 98 Assign from another supported rotation type (see gv_detail::convert ); 99 */; 100 template <class OtherRotation>; 101 AxisAngle & operator=( OtherRotation const & r ) {; 102 gv_detail::convert(r,*this);; 103 return *this;; 104 }; 105 ; 106 // ======== Components ==============; 107 ; 108 /**; 109 Set the axis and then the angle given a pair of pointers or iterators; 110 defining the beginning and end of an array of four Scalars.; 111 Precondition: The first three components are assumed to represent; 112 the rotation axis vector and the 4-th the rotation angle.; 113 The angle is assumed to be in the range (-pi,pi].; 114 The axis vector is automatically normalized to be a unit vector; 115 */; 116 template<class IT>; 117 void SetComponents(IT begin, IT end) {; 118 IT a = begin; IT b = ++begin; IT c = ++begin;; 119 fAxis.SetCoordinates(*a,*b,*c);; 120 fAngle = *(++begin);; 121 (void)end;; 122 assert (++begin==end);; 123 // re-normalize the vector; 124 double tot = fAxis.R();; 125 if (tot > 0) fAxis /= tot;; 126 }; 127 ; 128 /**; 129 Get the axis and then the angle into data specified by an iterator begin; 130 and another to the end of the desired data (4 past start).; 131 */; 132 template<class IT>; 133 void GetComponents(IT begin, IT end) const {; 134 IT a = begin; IT b = ++begin; IT c = ++begin;; 135 fAxis.GetCoordinates(*a,*b,*c);; 136 *(++begin) = fAngle;; 137 (void)end;; 138 assert (++begin==end);; 139 }; 140 ; 141 /**; 142 Get the axis and then the angle into data specified by an iterator begin; 143 */; 144 template<class IT>; 145 void GetComponents(IT begin) const {; 146 double ax,ay,az = 0;; 147 fAxis.GetCoordinates(ax,ay,az);; 148 *begin++ = ax;; 149 *begin++ = ay;; 150 *begin++ = az;; 151 *begin = fAngle;; 152 }; 153 ; 154 /**; 155 Set components from a non-zero vector (x,y,z) and an angle.; 156 Precondition: the Vector needs to implement x(), y(), z(), and unit(); 1",MatchSource.WIKI,doc/master/GenVector_2AxisAngle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html
https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html:4576,Testability,assert,assert,4576,"are assumed to represent; 112 the rotation axis vector and the 4-th the rotation angle.; 113 The angle is assumed to be in the range (-pi,pi].; 114 The axis vector is automatically normalized to be a unit vector; 115 */; 116 template<class IT>; 117 void SetComponents(IT begin, IT end) {; 118 IT a = begin; IT b = ++begin; IT c = ++begin;; 119 fAxis.SetCoordinates(*a,*b,*c);; 120 fAngle = *(++begin);; 121 (void)end;; 122 assert (++begin==end);; 123 // re-normalize the vector; 124 double tot = fAxis.R();; 125 if (tot > 0) fAxis /= tot;; 126 }; 127 ; 128 /**; 129 Get the axis and then the angle into data specified by an iterator begin; 130 and another to the end of the desired data (4 past start).; 131 */; 132 template<class IT>; 133 void GetComponents(IT begin, IT end) const {; 134 IT a = begin; IT b = ++begin; IT c = ++begin;; 135 fAxis.GetCoordinates(*a,*b,*c);; 136 *(++begin) = fAngle;; 137 (void)end;; 138 assert (++begin==end);; 139 }; 140 ; 141 /**; 142 Get the axis and then the angle into data specified by an iterator begin; 143 */; 144 template<class IT>; 145 void GetComponents(IT begin) const {; 146 double ax,ay,az = 0;; 147 fAxis.GetCoordinates(ax,ay,az);; 148 *begin++ = ax;; 149 *begin++ = ay;; 150 *begin++ = az;; 151 *begin = fAngle;; 152 }; 153 ; 154 /**; 155 Set components from a non-zero vector (x,y,z) and an angle.; 156 Precondition: the Vector needs to implement x(), y(), z(), and unit(); 157 */; 158 template<class AnyVector>; 159 void SetComponents(const AnyVector & v, Scalar angle) {; 160 fAxis=v.unit();; 161 fAngle=angle;; 162 }; 163 ; 164 /**; 165 Set components into a non-zero vector (x,y,z) and an angle.; 166 The vector is intended to be a cartesian displacement vector; 167 but any vector class assignable from one will work.; 168 */; 169 template<class AnyVector>; 170 void GetComponents(AnyVector & axis, Scalar & angle) const {; 171 axis = fAxis;; 172 angle = fAngle;; 173 }; 174 ; 175 /**; 176 access to rotation axis; 177 */; 178 AxisVector Axis() ",MatchSource.WIKI,doc/master/GenVector_2AxisAngle_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2AxisAngle_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:4085,Energy Efficiency,efficient,efficient,4085,"e <class OtherCoords>; 96 explicit constexpr DisplacementVector2D( const PositionVector2D<OtherCoords,Tag> & p) :; 97 fCoordinates ( p.Coordinates() ) { }; 98 ; 99 ; 100 /**; 101 Construct from a foreign 2D vector type, for example, Hep2Vector; 102 Precondition: v must implement methods x() and y(); 103 */; 104 template <class ForeignVector>; 105 explicit constexpr DisplacementVector2D( const ForeignVector & v) :; 106 fCoordinates ( Cartesian2D<Scalar>( v.x(), v.y() ) ) { }; 107 ; 108 ; 109 ; 110 // compiler-generated copy ctor and dtor are fine.; 111 ; 112 // ------ assignment ------; 113 ; 114 /**; 115 Assignment operator from a displacement vector of arbitrary type; 116 */; 117 template <class OtherCoords>; 118 DisplacementVector2D & operator=; 119 ( const DisplacementVector2D<OtherCoords, Tag> & v) {; 120 fCoordinates = v.Coordinates();; 121 return *this;; 122 }; 123 ; 124 /**; 125 Assignment operator from a position vector; 126 (not necessarily efficient unless one or the other is Cartesian); 127 */; 128 template <class OtherCoords>; 129 DisplacementVector2D & operator=; 130 ( const PositionVector2D<OtherCoords,Tag> & rhs) {; 131 SetXY(rhs.x(), rhs.y() );; 132 return *this;; 133 }; 134 ; 135 ; 136 /**; 137 Assignment from a foreign 2D vector type, for example, Hep2Vector; 138 Precondition: v must implement methods x() and y(); 139 */; 140 template <class ForeignVector>; 141 DisplacementVector2D & operator= ( const ForeignVector & v) {; 142 SetXY( v.x(), v.y() );; 143 return *this;; 144 }; 145 ; 146 ; 147 // ------ Set, Get, and access coordinate data ------; 148 ; 149 /**; 150 Retrieve a copy of the coordinates object; 151 */; 152 CoordSystem Coordinates() const {; 153 return fCoordinates;; 154 }; 155 ; 156 /**; 157 Set internal data based on 2 Scalar numbers.; 158 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 159 */; 160 DisplacementVector2D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b) {; 161 fCoordinates.SetCoordin",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:8327,Performance,perform,perform,8327,"System, Tag>& SetX (Scalar a) {; 248 fCoordinates.SetX(a);; 249 return *this;; 250 }; 251 ; 252 /**; 253 Change Y - Cartesian2D coordinates only; 254 */; 255 DisplacementVector2D<CoordSystem, Tag>& SetY (Scalar a) {; 256 fCoordinates.SetY(a);; 257 return *this;; 258 }; 259 ; 260 ; 261 /**; 262 Change R - Polar2D coordinates only; 263 */; 264 DisplacementVector2D<CoordSystem, Tag>& SetR (Scalar a) {; 265 fCoordinates.SetR(a);; 266 return *this;; 267 }; 268 ; 269 ; 270 /**; 271 Change Phi - Polar2D coordinates; 272 */; 273 DisplacementVector2D<CoordSystem, Tag>& SetPhi (Scalar ang) {; 274 fCoordinates.SetPhi(ang);; 275 return *this;; 276 }; 277 ; 278 ; 279 ; 280 // ------ Operations combining two vectors ------; 281 // -- need to have the specialized version in order to avoid; 282 ; 283 /**; 284 Return the scalar (dot) product of two displacement vectors.; 285 It is possible to perform the product for any type of vector coordinates,; 286 but they must have the same coordinate system tag; 287 */; 288 template< class OtherCoords >; 289 Scalar Dot( const DisplacementVector2D<OtherCoords,Tag> & v) const {; 290 return X()*v.X() + Y()*v.Y();; 291 }; 292 /**; 293 Return the scalar (dot) product of two vectors.; 294 It is possible to perform the product for any classes; 295 implementing x() and y() member functions; 296 */; 297 template< class OtherVector >; 298 Scalar Dot( const OtherVector & v) const {; 299 return X()*v.x() + Y()*v.y();; 300 }; 301 ; 302 ; 303 ; 304 /**; 305 Self Addition with a displacement vector.; 306 */; 307 template <class OtherCoords>; 308 DisplacementVector2D & operator+=; 309 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 310 SetXY( X() + v.X(), Y() + v.Y() );; 311 return *this;; 312 }; 313 ; 314 /**; 315 Self Difference with a displacement vector.; 316 */; 317 template <class OtherCoords>; 318 DisplacementVector2D & operator-=; 319 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 320 SetXY( x() - v.x(), y() - v.y() );; 321 return *this;; ",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:8682,Performance,perform,perform,8682,"ly; 263 */; 264 DisplacementVector2D<CoordSystem, Tag>& SetR (Scalar a) {; 265 fCoordinates.SetR(a);; 266 return *this;; 267 }; 268 ; 269 ; 270 /**; 271 Change Phi - Polar2D coordinates; 272 */; 273 DisplacementVector2D<CoordSystem, Tag>& SetPhi (Scalar ang) {; 274 fCoordinates.SetPhi(ang);; 275 return *this;; 276 }; 277 ; 278 ; 279 ; 280 // ------ Operations combining two vectors ------; 281 // -- need to have the specialized version in order to avoid; 282 ; 283 /**; 284 Return the scalar (dot) product of two displacement vectors.; 285 It is possible to perform the product for any type of vector coordinates,; 286 but they must have the same coordinate system tag; 287 */; 288 template< class OtherCoords >; 289 Scalar Dot( const DisplacementVector2D<OtherCoords,Tag> & v) const {; 290 return X()*v.X() + Y()*v.Y();; 291 }; 292 /**; 293 Return the scalar (dot) product of two vectors.; 294 It is possible to perform the product for any classes; 295 implementing x() and y() member functions; 296 */; 297 template< class OtherVector >; 298 Scalar Dot( const OtherVector & v) const {; 299 return X()*v.x() + Y()*v.y();; 300 }; 301 ; 302 ; 303 ; 304 /**; 305 Self Addition with a displacement vector.; 306 */; 307 template <class OtherCoords>; 308 DisplacementVector2D & operator+=; 309 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 310 SetXY( X() + v.X(), Y() + v.Y() );; 311 return *this;; 312 }; 313 ; 314 /**; 315 Self Difference with a displacement vector.; 316 */; 317 template <class OtherCoords>; 318 DisplacementVector2D & operator-=; 319 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 320 SetXY( x() - v.x(), y() - v.y() );; 321 return *this;; 322 }; 323 ; 324 ; 325 /**; 326 multiply this vector by a scalar quantity; 327 */; 328 DisplacementVector2D & operator*= (Scalar a) {; 329 fCoordinates.Scale(a);; 330 return *this;; 331 }; 332 ; 333 /**; 334 divide this vector by a scalar quantity; 335 */; 336 DisplacementVector2D & operator/= (Scalar a) {; 337 fCoordinates.Sc",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:8217,Safety,avoid,avoid,8217,"= R();; 239 return tot == 0 ? *this : DisplacementVector2D(*this) / tot;; 240 }; 241 ; 242 // ------ Setting individual elements present in coordinate system ------; 243 ; 244 /**; 245 Change X - Cartesian2D coordinates only; 246 */; 247 DisplacementVector2D<CoordSystem, Tag>& SetX (Scalar a) {; 248 fCoordinates.SetX(a);; 249 return *this;; 250 }; 251 ; 252 /**; 253 Change Y - Cartesian2D coordinates only; 254 */; 255 DisplacementVector2D<CoordSystem, Tag>& SetY (Scalar a) {; 256 fCoordinates.SetY(a);; 257 return *this;; 258 }; 259 ; 260 ; 261 /**; 262 Change R - Polar2D coordinates only; 263 */; 264 DisplacementVector2D<CoordSystem, Tag>& SetR (Scalar a) {; 265 fCoordinates.SetR(a);; 266 return *this;; 267 }; 268 ; 269 ; 270 /**; 271 Change Phi - Polar2D coordinates; 272 */; 273 DisplacementVector2D<CoordSystem, Tag>& SetPhi (Scalar ang) {; 274 fCoordinates.SetPhi(ang);; 275 return *this;; 276 }; 277 ; 278 ; 279 ; 280 // ------ Operations combining two vectors ------; 281 // -- need to have the specialized version in order to avoid; 282 ; 283 /**; 284 Return the scalar (dot) product of two displacement vectors.; 285 It is possible to perform the product for any type of vector coordinates,; 286 but they must have the same coordinate system tag; 287 */; 288 template< class OtherCoords >; 289 Scalar Dot( const DisplacementVector2D<OtherCoords,Tag> & v) const {; 290 return X()*v.X() + Y()*v.Y();; 291 }; 292 /**; 293 Return the scalar (dot) product of two vectors.; 294 It is possible to perform the product for any classes; 295 implementing x() and y() member functions; 296 */; 297 template< class OtherVector >; 298 Scalar Dot( const OtherVector & v) const {; 299 return X()*v.x() + Y()*v.y();; 300 }; 301 ; 302 ; 303 ; 304 /**; 305 Self Addition with a displacement vector.; 306 */; 307 template <class OtherCoords>; 308 DisplacementVector2D & operator+=; 309 (const DisplacementVector2D<OtherCoords,Tag> & v) {; 310 SetXY( X() + v.X(), Y() + v.Y() );; 311 return *this;; 312 ",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:4680,Security,access,access,4680,"isplacement vector of arbitrary type; 116 */; 117 template <class OtherCoords>; 118 DisplacementVector2D & operator=; 119 ( const DisplacementVector2D<OtherCoords, Tag> & v) {; 120 fCoordinates = v.Coordinates();; 121 return *this;; 122 }; 123 ; 124 /**; 125 Assignment operator from a position vector; 126 (not necessarily efficient unless one or the other is Cartesian); 127 */; 128 template <class OtherCoords>; 129 DisplacementVector2D & operator=; 130 ( const PositionVector2D<OtherCoords,Tag> & rhs) {; 131 SetXY(rhs.x(), rhs.y() );; 132 return *this;; 133 }; 134 ; 135 ; 136 /**; 137 Assignment from a foreign 2D vector type, for example, Hep2Vector; 138 Precondition: v must implement methods x() and y(); 139 */; 140 template <class ForeignVector>; 141 DisplacementVector2D & operator= ( const ForeignVector & v) {; 142 SetXY( v.x(), v.y() );; 143 return *this;; 144 }; 145 ; 146 ; 147 // ------ Set, Get, and access coordinate data ------; 148 ; 149 /**; 150 Retrieve a copy of the coordinates object; 151 */; 152 CoordSystem Coordinates() const {; 153 return fCoordinates;; 154 }; 155 ; 156 /**; 157 Set internal data based on 2 Scalar numbers.; 158 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 159 */; 160 DisplacementVector2D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b) {; 161 fCoordinates.SetCoordinates(a, b);; 162 return *this;; 163 }; 164 ; 165 ; 166 /**; 167 get internal data into 2 Scalar numbers.; 168 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 169 */; 170 void GetCoordinates( Scalar& a, Scalar& b) const; 171 { fCoordinates.GetCoordinates(a, b); }; 172 ; 173 ; 174 /**; 175 set the values of the vector from the cartesian components (x,y); 176 (if the vector is held in polar coordinates,; 177 then (x, y) are converted to that form); 178 */; 179 DisplacementVector2D<CoordSystem, Tag>& SetXY (Scalar a, Scalar b) {; 180 fCoordinates.SetXY(a,b);; 181 return *this;; 182 }; 183 ; 184 // ----",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html:6104,Security,access,access,6104," return *this;; 163 }; 164 ; 165 ; 166 /**; 167 get internal data into 2 Scalar numbers.; 168 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 169 */; 170 void GetCoordinates( Scalar& a, Scalar& b) const; 171 { fCoordinates.GetCoordinates(a, b); }; 172 ; 173 ; 174 /**; 175 set the values of the vector from the cartesian components (x,y); 176 (if the vector is held in polar coordinates,; 177 then (x, y) are converted to that form); 178 */; 179 DisplacementVector2D<CoordSystem, Tag>& SetXY (Scalar a, Scalar b) {; 180 fCoordinates.SetXY(a,b);; 181 return *this;; 182 }; 183 ; 184 // ------------------- Equality -----------------; 185 ; 186 /**; 187 Exact equality; 188 */; 189 bool operator==(const DisplacementVector2D & rhs) const {; 190 return fCoordinates==rhs.fCoordinates;; 191 }; 192 bool operator!= (const DisplacementVector2D & rhs) const {; 193 return !(operator==(rhs));; 194 }; 195 ; 196 // ------ Individual element access, in various coordinate systems ------; 197 ; 198 /**; 199 Dimension; 200 */; 201 unsigned int Dimension() const { return fDimension; };; 202 ; 203 /**; 204 Cartesian X, converting if necessary from internal coordinate system.; 205 */; 206 Scalar X() const { return fCoordinates.X(); }; 207 ; 208 /**; 209 Cartesian Y, converting if necessary from internal coordinate system.; 210 */; 211 Scalar Y() const { return fCoordinates.Y(); }; 212 ; 213 ; 214 /**; 215 Polar R, converting if necessary from internal coordinate system.; 216 */; 217 Scalar R() const { return fCoordinates.R(); }; 218 ; 219 ; 220 /**; 221 Polar phi, converting if necessary from internal coordinate system.; 222 */; 223 Scalar Phi() const { return fCoordinates.Phi(); }; 224 ; 225 ; 226 // ----- Other fundamental properties -----; 227 ; 228 /**; 229 Magnitute squared ( r^2 in spherical coordinate); 230 */; 231 Scalar Mag2() const { return fCoordinates.Mag2();}; 232 ; 233 ; 234 /**; 235 return unit vector parallel to this; 236 */; 237 DisplacementVect",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:760,Deployability,update,update,760,". ROOT: math/genvector/inc/Math/GenVector/DisplacementVector3D.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. DisplacementVector3D.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team and *; 7 * FNAL LCG ROOT MathLib Team *; 8 * *; 9 * *; 10 **********************************************************************/; 11 ; 12// Header source file for class DisplacementVector3D; 13//; 14// Created by: Lorenzo Moneta at Mon May 30 12:21:43 2005; 15// Major rewrite: M. FIschler at Wed Jun 8 2005; 16//; 17// Last update: $Id$; 18//; 19 ; 20#ifndef ROOT_Math_GenVector_DisplacementVector3D; 21#define ROOT_Math_GenVector_DisplacementVector3D 1; 22 ; 23#include ""Math/GenVector/Cartesian3D.h""; 24 ; 25#include ""Math/GenVector/PositionVector3Dfwd.h""; 26 ; 27#include ""Math/GenVector/GenVectorIO.h""; 28 ; 29#include ""Math/GenVector/BitReproducible.h""; 30 ; 31#include ""Math/GenVector/CoordinateSystemTags.h""; 32 ; 33#include <cassert>; 34 ; 35 ; 36namespace ROOT {; 37 ; 38 namespace Math {; 39 ; 40 ; 41//__________________________________________________________________________________________; 42 /**; 43 Class describing a generic displacement vector in 3 dimensions.; 44 This class is templated on the type of Coordinate system.; 45 One example is the XYZVector which is a vector based on; 46 double precision x,y,z data members by using the; 47 ROOT::Math::Cartesian3D<double> Coordinate system.; 48 The class is having also an extra template parameter, the coordinate system tag,; 49 to be able to identify (tag) vector described in different reference coordinate system,; 50 like global or local coordinate systems.; 51 ; 52 @ingroup GenVector; 53 ; 54 @sa Overview of the @ref GenVector ""physics vector library""; 55 */; 56 ; 57 template <class Coor",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:4694,Energy Efficiency,efficient,efficient,4694,"construct from a generic linear algebra vector of at least size 3; 112 implementing operator [].; 113 \par v LAVector; 114 \par index0 index where coordinates starts (typically zero); 115 It works for all Coordinates types,; 116 ( x= v[index0] for Cartesian and r=v[index0] for Polar ); 117 */; 118 template <class LAVector>; 119 constexpr DisplacementVector3D(const LAVector & v, size_t index0 ) {; 120 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 121 }; 122#endif; 123 ; 124 // compiler-generated copy ctor and dtor are fine.; 125 ; 126 // ------ assignment ------; 127 ; 128 /**; 129 Assignment operator from a displacement vector of arbitrary type; 130 */; 131 template <class OtherCoords>; 132 DisplacementVector3D & operator=; 133 ( const DisplacementVector3D<OtherCoords, Tag> & v) {; 134 fCoordinates = v.Coordinates();; 135 return *this;; 136 }; 137 ; 138 /**; 139 Assignment operator from a position vector; 140 (not necessarily efficient unless one or the other is Cartesian); 141 */; 142 template <class OtherCoords>; 143 DisplacementVector3D & operator=; 144 ( const PositionVector3D<OtherCoords,Tag> & rhs) {; 145 SetXYZ(rhs.x(), rhs.y(), rhs.z());; 146 return *this;; 147 }; 148 ; 149 ; 150 /**; 151 Assignment from a foreign 3D vector type, for example, Hep3Vector; 152 Precondition: v must implement methods x(), y() and z(); 153 */; 154 template <class ForeignVector>; 155 DisplacementVector3D & operator= ( const ForeignVector & v) {; 156 SetXYZ( v.x(), v.y(), v.z() );; 157 return *this;; 158 }; 159 ; 160 ; 161#ifdef LATER; 162 /**; 163 assign from a generic linear algebra vector of at least size 3; 164 implementing operator []. This could be also a C array; 165 \par v LAVector; 166 \par index0 index where coordinates starts (typically zero); 167 It works for all Coordinates types,; 168 ( x= v[index0] for Cartesian and r=v[index0] for Polar ); 169 */; 170 template <class LAVector>; 171 DisplacementVector3D & assignFrom(const LAVector & v, size_t i",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:704,Modifiability,rewrite,rewrite,704,". ROOT: math/genvector/inc/Math/GenVector/DisplacementVector3D.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. DisplacementVector3D.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team and *; 7 * FNAL LCG ROOT MathLib Team *; 8 * *; 9 * *; 10 **********************************************************************/; 11 ; 12// Header source file for class DisplacementVector3D; 13//; 14// Created by: Lorenzo Moneta at Mon May 30 12:21:43 2005; 15// Major rewrite: M. FIschler at Wed Jun 8 2005; 16//; 17// Last update: $Id$; 18//; 19 ; 20#ifndef ROOT_Math_GenVector_DisplacementVector3D; 21#define ROOT_Math_GenVector_DisplacementVector3D 1; 22 ; 23#include ""Math/GenVector/Cartesian3D.h""; 24 ; 25#include ""Math/GenVector/PositionVector3Dfwd.h""; 26 ; 27#include ""Math/GenVector/GenVectorIO.h""; 28 ; 29#include ""Math/GenVector/BitReproducible.h""; 30 ; 31#include ""Math/GenVector/CoordinateSystemTags.h""; 32 ; 33#include <cassert>; 34 ; 35 ; 36namespace ROOT {; 37 ; 38 namespace Math {; 39 ; 40 ; 41//__________________________________________________________________________________________; 42 /**; 43 Class describing a generic displacement vector in 3 dimensions.; 44 This class is templated on the type of Coordinate system.; 45 One example is the XYZVector which is a vector based on; 46 double precision x,y,z data members by using the; 47 ROOT::Math::Cartesian3D<double> Coordinate system.; 48 The class is having also an extra template parameter, the coordinate system tag,; 49 to be able to identify (tag) vector described in different reference coordinate system,; 50 like global or local coordinate systems.; 51 ; 52 @ingroup GenVector; 53 ; 54 @sa Overview of the @ref GenVector ""physics vector library""; 55 */; 56 ; 57 template <class Coor",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:12661,Performance,perform,perform,12661,"ctor3D<CoordSystem, Tag>& SetTheta (Scalar ang) { fCoordinates.SetTheta(ang); return *this;}; 377 ; 378 /**; 379 Change Phi - Polar3D or CylindricalEta3D coordinates; 380 */; 381 DisplacementVector3D<CoordSystem, Tag>& SetPhi (Scalar ang) { fCoordinates.SetPhi(ang); return *this;}; 382 ; 383 /**; 384 Change Rho - CylindricalEta3D coordinates only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 42",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13028,Performance,perform,perform,13028,"s only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVe",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13420,Performance,perform,perform,13420,"void; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVector3D Cross( const OtherVector & v) const {; 438 DisplacementVector3D result;; 439 result.SetXYZ ( Y()*v.z() - v.y()*Z(),; 440 Z()*v.x() - v.z()*X(),; 441 X()*v.y() - v.x()*Y() );; 442 return result;; 443 }; 444 ; 445 ; 446 ; 447 /**; 448 Self Addition with a displacement vector.; 449 */; 450 template <class OtherCoords>; 451 DisplacementVector3D & operator+=; 452 (const DisplacementVector3D<OtherCoords,Tag> & v) {; 453 SetXYZ( X() +",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13966,Performance,perform,perform,13966,"menting x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVector3D Cross( const OtherVector & v) const {; 438 DisplacementVector3D result;; 439 result.SetXYZ ( Y()*v.z() - v.y()*Z(),; 440 Z()*v.x() - v.z()*X(),; 441 X()*v.y() - v.x()*Y() );; 442 return result;; 443 }; 444 ; 445 ; 446 ; 447 /**; 448 Self Addition with a displacement vector.; 449 */; 450 template <class OtherCoords>; 451 DisplacementVector3D & operator+=; 452 (const DisplacementVector3D<OtherCoords,Tag> & v) {; 453 SetXYZ( X() + v.X(), Y() + v.Y(), Z() + v.Z() );; 454 return *this;; 455 }; 456 ; 457 /**; 458 Self Difference with a displacement vector.; 459 */; 460 template <class OtherCoords>; 461 DisplacementVector3D & operator-=; 462 (const DisplacementVector3D<OtherCoords,Tag> & v) {; 463 SetXYZ( x() - v.x(), y() - v.y(), z() - v.z() );; 464 return *this;; 465 }; 466 ; 467 ; 468 /**; 469 multiply this vector by a scalar quantity; 470 */; 471 DisplacementVector3D & operator*= (Scalar a) {; 472 fCoordinates.Scale(a);; 473 return *this;; 4",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:12551,Safety,avoid,avoid,12551,"s;}; 367 ; 368 /**; 369 Change R - Polar3D coordinates only; 370 */; 371 DisplacementVector3D<CoordSystem, Tag>& SetR (Scalar rr) { fCoordinates.SetR(rr); return *this;}; 372 ; 373 /**; 374 Change Theta - Polar3D coordinates only; 375 */; 376 DisplacementVector3D<CoordSystem, Tag>& SetTheta (Scalar ang) { fCoordinates.SetTheta(ang); return *this;}; 377 ; 378 /**; 379 Change Phi - Polar3D or CylindricalEta3D coordinates; 380 */; 381 DisplacementVector3D<CoordSystem, Tag>& SetPhi (Scalar ang) { fCoordinates.SetPhi(ang); return *this;}; 382 ; 383 /**; 384 Change Rho - CylindricalEta3D coordinates only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordi",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:5889,Security,access,access,5889,"onst PositionVector3D<OtherCoords,Tag> & rhs) {; 145 SetXYZ(rhs.x(), rhs.y(), rhs.z());; 146 return *this;; 147 }; 148 ; 149 ; 150 /**; 151 Assignment from a foreign 3D vector type, for example, Hep3Vector; 152 Precondition: v must implement methods x(), y() and z(); 153 */; 154 template <class ForeignVector>; 155 DisplacementVector3D & operator= ( const ForeignVector & v) {; 156 SetXYZ( v.x(), v.y(), v.z() );; 157 return *this;; 158 }; 159 ; 160 ; 161#ifdef LATER; 162 /**; 163 assign from a generic linear algebra vector of at least size 3; 164 implementing operator []. This could be also a C array; 165 \par v LAVector; 166 \par index0 index where coordinates starts (typically zero); 167 It works for all Coordinates types,; 168 ( x= v[index0] for Cartesian and r=v[index0] for Polar ); 169 */; 170 template <class LAVector>; 171 DisplacementVector3D & assignFrom(const LAVector & v, size_t index0 = 0) {; 172 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 173 return *this;; 174 }; 175#endif; 176 ; 177 // ------ Set, Get, and access coordinate data ------; 178 ; 179 /**; 180 Retrieve a copy of the coordinates object; 181 */; 182 CoordSystem Coordinates() const {; 183 return fCoordinates;; 184 }; 185 ; 186 /**; 187 Set internal data based on a C-style array of 3 Scalar numbers; 188 */; 189 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( const Scalar src[] ); 190 { fCoordinates.SetCoordinates(src); return *this; }; 191 ; 192 /**; 193 Set internal data based on 3 Scalar numbers; 194 */; 195 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b, Scalar c ); 196 { fCoordinates.SetCoordinates(a, b, c); return *this; }; 197 ; 198 /**; 199 Set internal data based on 3 Scalars at *begin to *end; 200 */; 201 template <class IT>; 202 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( IT begin, IT end ); 203 { IT a = begin; IT b = ++begin; IT c = ++begin;; 204 (void)end;; 205 assert (++begin==end);; 206 SetCoordinates (*a,*b,*c",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:8560,Security,access,access,8560,"35 template <class IT>; 236 void GetCoordinates( IT begin) const {; 237 Scalar a = Scalar(0);; 238 Scalar b = Scalar(0);; 239 Scalar c = Scalar(0);; 240 GetCoordinates(a, b, c);; 241 *begin++ = a;; 242 *begin++ = b;; 243 *begin = c;; 244 }; 245 ; 246 /**; 247 set the values of the vector from the cartesian components (x,y,z); 248 (if the vector is held in polar or cylindrical eta coordinates,; 249 then (x, y, z) are converted to that form); 250 */; 251 DisplacementVector3D<CoordSystem, Tag>& SetXYZ (Scalar a, Scalar b, Scalar c) {; 252 fCoordinates.SetXYZ(a, b, c);; 253 return *this;; 254 }; 255 ; 256 // ------------------- Equality -----------------; 257 ; 258 /**; 259 Exact equality; 260 */; 261 bool operator==(const DisplacementVector3D & rhs) const {; 262 return fCoordinates==rhs.fCoordinates;; 263 }; 264 bool operator!= (const DisplacementVector3D & rhs) const {; 265 return !(operator==(rhs));; 266 }; 267 ; 268 // ------ Individual element access, in various coordinate systems ------; 269 ; 270 /**; 271 Dimension; 272 */; 273 unsigned int Dimension() const; 274 {; 275 return fDimension;; 276 };; 277 ; 278 /**; 279 Cartesian X, converting if necessary from internal coordinate system.; 280 */; 281 Scalar X() const { return fCoordinates.X(); }; 282 ; 283 /**; 284 Cartesian Y, converting if necessary from internal coordinate system.; 285 */; 286 Scalar Y() const { return fCoordinates.Y(); }; 287 ; 288 /**; 289 Cartesian Z, converting if necessary from internal coordinate system.; 290 */; 291 Scalar Z() const { return fCoordinates.Z(); }; 292 ; 293 /**; 294 Polar R, converting if necessary from internal coordinate system.; 295 */; 296 Scalar R() const { return fCoordinates.R(); }; 297 ; 298 /**; 299 Polar theta, converting if necessary from internal coordinate system.; 300 */; 301 Scalar Theta() const { return fCoordinates.Theta(); }; 302 ; 303 /**; 304 Polar phi, converting if necessary from internal coordinate system.; 305 */; 306 Scalar Phi() const { return fCoord",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:6778,Testability,assert,assert,6778," 172 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 173 return *this;; 174 }; 175#endif; 176 ; 177 // ------ Set, Get, and access coordinate data ------; 178 ; 179 /**; 180 Retrieve a copy of the coordinates object; 181 */; 182 CoordSystem Coordinates() const {; 183 return fCoordinates;; 184 }; 185 ; 186 /**; 187 Set internal data based on a C-style array of 3 Scalar numbers; 188 */; 189 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( const Scalar src[] ); 190 { fCoordinates.SetCoordinates(src); return *this; }; 191 ; 192 /**; 193 Set internal data based on 3 Scalar numbers; 194 */; 195 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b, Scalar c ); 196 { fCoordinates.SetCoordinates(a, b, c); return *this; }; 197 ; 198 /**; 199 Set internal data based on 3 Scalars at *begin to *end; 200 */; 201 template <class IT>; 202 DisplacementVector3D<CoordSystem, Tag>& SetCoordinates( IT begin, IT end ); 203 { IT a = begin; IT b = ++begin; IT c = ++begin;; 204 (void)end;; 205 assert (++begin==end);; 206 SetCoordinates (*a,*b,*c);; 207 return *this;; 208 }; 209 ; 210 /**; 211 get internal data into 3 Scalar numbers; 212 */; 213 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c ) const; 214 { fCoordinates.GetCoordinates(a, b, c); }; 215 ; 216 /**; 217 get internal data into a C-style array of 3 Scalar numbers; 218 */; 219 void GetCoordinates( Scalar dest[] ) const; 220 { fCoordinates.GetCoordinates(dest); }; 221 ; 222 /**; 223 get internal data into 3 Scalars at *begin to *end (3 past begin); 224 */; 225 template <class IT>; 226 void GetCoordinates( IT begin, IT end ) const; 227 { IT a = begin; IT b = ++begin; IT c = ++begin;; 228 (void)end;; 229 assert (++begin==end);; 230 GetCoordinates (*a,*b,*c);; 231 }; 232 /**; 233 get internal data into 3 Scalars starting at *begin; 234 */; 235 template <class IT>; 236 void GetCoordinates( IT begin) const {; 237 Scalar a = Scalar(0);; 238 Scalar b = Scalar(0);; 239 Scalar c = Scalar",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:7463,Testability,assert,assert,7463,"rdinates( IT begin, IT end ); 203 { IT a = begin; IT b = ++begin; IT c = ++begin;; 204 (void)end;; 205 assert (++begin==end);; 206 SetCoordinates (*a,*b,*c);; 207 return *this;; 208 }; 209 ; 210 /**; 211 get internal data into 3 Scalar numbers; 212 */; 213 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c ) const; 214 { fCoordinates.GetCoordinates(a, b, c); }; 215 ; 216 /**; 217 get internal data into a C-style array of 3 Scalar numbers; 218 */; 219 void GetCoordinates( Scalar dest[] ) const; 220 { fCoordinates.GetCoordinates(dest); }; 221 ; 222 /**; 223 get internal data into 3 Scalars at *begin to *end (3 past begin); 224 */; 225 template <class IT>; 226 void GetCoordinates( IT begin, IT end ) const; 227 { IT a = begin; IT b = ++begin; IT c = ++begin;; 228 (void)end;; 229 assert (++begin==end);; 230 GetCoordinates (*a,*b,*c);; 231 }; 232 /**; 233 get internal data into 3 Scalars starting at *begin; 234 */; 235 template <class IT>; 236 void GetCoordinates( IT begin) const {; 237 Scalar a = Scalar(0);; 238 Scalar b = Scalar(0);; 239 Scalar c = Scalar(0);; 240 GetCoordinates(a, b, c);; 241 *begin++ = a;; 242 *begin++ = b;; 243 *begin = c;; 244 }; 245 ; 246 /**; 247 set the values of the vector from the cartesian components (x,y,z); 248 (if the vector is held in polar or cylindrical eta coordinates,; 249 then (x, y, z) are converted to that form); 250 */; 251 DisplacementVector3D<CoordSystem, Tag>& SetXYZ (Scalar a, Scalar b, Scalar c) {; 252 fCoordinates.SetXYZ(a, b, c);; 253 return *this;; 254 }; 255 ; 256 // ------------------- Equality -----------------; 257 ; 258 /**; 259 Exact equality; 260 */; 261 bool operator==(const DisplacementVector3D & rhs) const {; 262 return fCoordinates==rhs.fCoordinates;; 263 }; 264 bool operator!= (const DisplacementVector3D & rhs) const {; 265 return !(operator==(rhs));; 266 }; 267 ; 268 // ------ Individual element access, in various coordinate systems ------; 269 ; 270 /**; 271 Dimension; 272 */; 273 unsigned int Dimension() con",MatchSource.WIKI,doc/master/GenVector_2DisplacementVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2EulerAngles_8h_source.html:636,Deployability,update,update,636,". ROOT: math/genvector/inc/Math/GenVector/EulerAngles.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. EulerAngles.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class EulerAngles; 12//; 13// Created by: Lorenzo Moneta at Tue May 10 17:55:10 2005; 14//; 15// Last update: Tue May 10 17:55:10 2005; 16//; 17#ifndef ROOT_Math_GenVector_EulerAngles; 18#define ROOT_Math_GenVector_EulerAngles 1; 19 ; 20#include ""Math/GenVector/Rotation3D.h""; 21#include ""Math/GenVector/DisplacementVector3D.h""; 22#include ""Math/GenVector/PositionVector3D.h""; 23#include ""Math/GenVector/LorentzVector.h""; 24#include ""Math/GenVector/3DConversions.h""; 25#include <algorithm>; 26#include <cassert>; 27 ; 28namespace ROOT {; 29namespace Math {; 30 ; 31 ; 32//__________________________________________________________________________________________; 33 /**; 34 EulerAngles class describing rotation as three angles (Euler Angles).; 35 The Euler angles definition matches that of Classical Mechanics (Goldstein).; 36 It is also the same convention defined in; 37 <A HREF=""http://mathworld.wolfram.com/EulerAngles.html"">mathworld</A>; 38 and used in Mathematica and CLHEP. Note that the ROOT class TRotation defines; 39 a slightly different convention.; 40 ; 41 @ingroup GenVector; 42 ; 43 @sa Overview of the @ref GenVector ""physics vector library""; 44 */; 45class EulerAngles {; 46 ; 47public:; 48 ; 49 typedef double Scalar;; 50 ; 51 /**; 52 Default constructor; 53 */; 54 constexpr EulerAngles() : fPhi(0.0), fTheta(0.0), fPsi(0.0) { }; 55 ; 56 /**; 57 Constructor from phi, theta and psi; 58 */; 59 EulerAngles( Scalar phi, Scalar theta, Scalar psi )",MatchSource.WIKI,doc/master/GenVector_2EulerAngles_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2EulerAngles_8h_source.html
https://root.cern/doc/master/GenVector_2EulerAngles_8h_source.html:4964,Testability,assert,assert,4964,"detail::convert(r, *this); }; 120 ; 121 ; 122 /**; 123 Assign from an AxisAngle; 124 */; 125 EulerAngles &; 126 operator=( AxisAngle const & a ) { return operator=(EulerAngles(a)); }; 127 ; 128 /**; 129 Assign from a Quaternion; 130 */; 131 EulerAngles &; 132 operator=( Quaternion const & q ) {return operator=(EulerAngles(q)); }; 133 ; 134 /**; 135 Assign from an axial rotation; 136 */; 137 EulerAngles &; 138 operator=( RotationZ const & r ) { return operator=(EulerAngles(r)); }; 139 EulerAngles &; 140 operator=( RotationY const & r ) { return operator=(EulerAngles(r)); }; 141 EulerAngles &; 142 operator=( RotationX const & r ) { return operator=(EulerAngles(r)); }; 143 ; 144#endif; 145 ; 146 // ======== Components ==============; 147 ; 148 /**; 149 Set the three Euler angles given a pair of pointers or iterators; 150 defining the beginning and end of an array of three Scalars.; 151 */; 152 template<class IT>; 153 void SetComponents(IT begin, IT end) {; 154 fPhi = *begin++;; 155 fTheta = *begin++;; 156 fPsi = *begin++;; 157 (void)end;; 158 assert(begin == end);; 159 Rectify(); // Added 27 Jan. 06 JMM; 160 }; 161 ; 162 /**; 163 Get the axis and then the angle into data specified by an iterator begin; 164 and another to the end of the desired data (4 past start).; 165 */; 166 template<class IT>; 167 void GetComponents(IT begin, IT end) const {; 168 *begin++ = fPhi;; 169 *begin++ = fTheta;; 170 *begin++ = fPsi;; 171 (void)end;; 172 assert(begin == end);; 173 }; 174 ; 175 /**; 176 Get the axis and then the angle into data specified by an iterator begin; 177 */; 178 template<class IT>; 179 void GetComponents(IT begin) const {; 180 *begin++ = fPhi;; 181 *begin++ = fTheta;; 182 *begin = fPsi;; 183 }; 184 ; 185 /**; 186 Set the components phi, theta, psi based on three Scalars.; 187 */; 188 void SetComponents(Scalar phi, Scalar theta, Scalar psi) {; 189 fPhi=phi; fTheta=theta; fPsi=psi;; 190 Rectify(); // Added 27 Jan. 06 JMM; 191 }; 192 ; 193 /**; 194 Get the components ph",MatchSource.WIKI,doc/master/GenVector_2EulerAngles_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2EulerAngles_8h_source.html
https://root.cern/doc/master/GenVector_2EulerAngles_8h_source.html:5361,Testability,assert,assert,5361," { return operator=(EulerAngles(r)); }; 141 EulerAngles &; 142 operator=( RotationX const & r ) { return operator=(EulerAngles(r)); }; 143 ; 144#endif; 145 ; 146 // ======== Components ==============; 147 ; 148 /**; 149 Set the three Euler angles given a pair of pointers or iterators; 150 defining the beginning and end of an array of three Scalars.; 151 */; 152 template<class IT>; 153 void SetComponents(IT begin, IT end) {; 154 fPhi = *begin++;; 155 fTheta = *begin++;; 156 fPsi = *begin++;; 157 (void)end;; 158 assert(begin == end);; 159 Rectify(); // Added 27 Jan. 06 JMM; 160 }; 161 ; 162 /**; 163 Get the axis and then the angle into data specified by an iterator begin; 164 and another to the end of the desired data (4 past start).; 165 */; 166 template<class IT>; 167 void GetComponents(IT begin, IT end) const {; 168 *begin++ = fPhi;; 169 *begin++ = fTheta;; 170 *begin++ = fPsi;; 171 (void)end;; 172 assert(begin == end);; 173 }; 174 ; 175 /**; 176 Get the axis and then the angle into data specified by an iterator begin; 177 */; 178 template<class IT>; 179 void GetComponents(IT begin) const {; 180 *begin++ = fPhi;; 181 *begin++ = fTheta;; 182 *begin = fPsi;; 183 }; 184 ; 185 /**; 186 Set the components phi, theta, psi based on three Scalars.; 187 */; 188 void SetComponents(Scalar phi, Scalar theta, Scalar psi) {; 189 fPhi=phi; fTheta=theta; fPsi=psi;; 190 Rectify(); // Added 27 Jan. 06 JMM; 191 }; 192 ; 193 /**; 194 Get the components phi, theta, psi into three Scalars.; 195 */; 196 void GetComponents(Scalar & phi, Scalar & theta, Scalar & psi) const {; 197 phi=fPhi; theta=fTheta; psi=fPsi;; 198 }; 199 ; 200 /**; 201 Set Phi Euler angle // JMM 30 Jan. 2006; 202 */; 203 void SetPhi(Scalar phi) { fPhi=phi; Rectify(); }; 204 ; 205 /**; 206 Return Phi Euler angle; 207 */; 208 Scalar Phi() const { return fPhi; }; 209 ; 210 /**; 211 Set Theta Euler angle // JMM 30 Jan. 2006; 212 */; 213 void SetTheta(Scalar theta) { fTheta=theta; Rectify(); }; 214 ; 215 /**; 216 Return Thet",MatchSource.WIKI,doc/master/GenVector_2EulerAngles_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2EulerAngles_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:17228,Availability,toler,tolerance,17228," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:17417,Availability,toler,tolerance,17417," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:31233,Availability,toler,tolerance,31233,"dinates, or using a different Scalar typeDefinition LorentzVector.h:93; ROOT::Math::LorentzVector::massScalar mass() constDefinition LorentzVector.h:665; ROOT::Math::LorentzVector::RhoScalar Rho() constDefinition LorentzVector.h:325; ROOT::Math::LorentzVector::PScalar P() constDefinition LorentzVector.h:311; ROOT::Math::LorentzVector::yScalar y() constDefinition LorentzVector.h:643; ROOT::Math::LorentzVector::PyScalar Py() constspatial Y componentDefinition LorentzVector.h:284; ROOT::Math::LorentzVector::LorentzVectorconstexpr LorentzVector(const ForeignLorentzVector &v)Construct from a foreign 4D vector type, for example, HepLorentzVector Precondition: v must implement...Definition LorentzVector.h:105; ROOT::Math::LorentzVector::LorentzVectorLorentzVector(const Scalar &a, const Scalar &b, const Scalar &c, const Scalar &d)generic constructors from four scalar values.Definition LorentzVector.h:82; ROOT::Math::LorentzVector::isLightlikebool isLightlike(Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) constDetermine if momentum-energy can represent a massless particle.Definition LorentzVector.h:535; ROOT::Math::LorentzVector::Vect::ROOT::Math::DisplacementVector3D< Cartesian3D< Scalar > > Vect() constget the spatial components of the Vector in a DisplacementVector based on Cartesian CoordinatesDefinition LorentzVector.h:371; ROOT::Math::LorentzVector::ColinearRapidityScalar ColinearRapidity() constRapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)].Definition LorentzVector.h:516; ROOT::Math::LorentzVector::eScalar e() constDefinition LorentzVector.h:649; ROOT::Math::LorentzVector::PzScalar Pz() constspatial Z componentDefinition LorentzVector.h:289; ROOT::Math::LorentzVector::operator-LorentzVector operator-() constNegative of a LorentzVector (q = - v )Definition LorentzVector.h:489; ROOT::Math::LorentzVector::fDimensionstatic constexpr unsigned int fDimensionDefinition LorentzVector.h:686; ROOT::Math::LorentzVector::SetPtLorentzVector<",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:682,Deployability,update,update,682,". ROOT: math/genvector/inc/Math/GenVector/LorentzVector.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. LorentzVector.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class LorentzVector; 12//; 13// Created by: moneta at Tue May 31 17:06:09 2005; 14// Major mods by: fischler at Wed Jul 20 2005; 15//; 16// Last update: $Id$; 17//; 18#ifndef ROOT_Math_GenVector_LorentzVector; 19#define ROOT_Math_GenVector_LorentzVector 1; 20 ; 21#include ""Math/GenVector/PxPyPzE4D.h""; 22 ; 23#include ""Math/GenVector/DisplacementVector3D.h""; 24 ; 25#include ""Math/GenVector/GenVectorIO.h""; 26 ; 27#include <cmath>; 28#include <string>; 29 ; 30namespace ROOT {; 31 ; 32 namespace Math {; 33 ; 34//__________________________________________________________________________________________; 35/** @ingroup GenVector; 36 ; 37Class describing a generic LorentzVector in the 4D space-time,; 38using the specified coordinate system for the spatial vector part.; 39The metric used for the LorentzVector is (-,-,-,+).; 40In the case of LorentzVector we don't distinguish the concepts; 41of points and displacement vectors as in the 3D case,; 42since the main use case for 4D Vectors is to describe the kinematics of; 43relativistic particles. A LorentzVector behaves like a; 44DisplacementVector in 4D. The Minkowski components could be viewed as; 45v and t, or for kinematic 4-vectors, as p and E.; 46 ; 47ROOT provides specialisations and aliases to them of the ROOT::Math::LorentzVector template:; 48- ROOT::Math::PtEtaPhiMVector based on pt (rho),eta,phi and M (t) coordinates in double precision; 49- ROOT::Math::PtEtaPhiEVector based on pt (rho),eta",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:2198,Energy Efficiency,energy,energy,2198,"tor is (-,-,-,+).; 40In the case of LorentzVector we don't distinguish the concepts; 41of points and displacement vectors as in the 3D case,; 42since the main use case for 4D Vectors is to describe the kinematics of; 43relativistic particles. A LorentzVector behaves like a; 44DisplacementVector in 4D. The Minkowski components could be viewed as; 45v and t, or for kinematic 4-vectors, as p and E.; 46 ; 47ROOT provides specialisations and aliases to them of the ROOT::Math::LorentzVector template:; 48- ROOT::Math::PtEtaPhiMVector based on pt (rho),eta,phi and M (t) coordinates in double precision; 49- ROOT::Math::PtEtaPhiEVector based on pt (rho),eta,phi and E (t) coordinates in double precision; 50- ROOT::Math::PxPyPzMVector based on px,py,pz and M (mass) coordinates in double precision; 51- ROOT::Math::PxPyPzEVector based on px,py,pz and E (energy) coordinates in double precision; 52- ROOT::Math::XYZTVector based on x,y,z,t coordinates (cartesian) in double precision (same as PxPyPzEVector); 53- ROOT::Math::XYZTVectorF based on x,y,z,t coordinates (cartesian) in float precision (same as PxPyPzEVector but float); 54 ; 55@sa Overview of the @ref GenVector ""physics vector library""; 56*/; 57 ; 58 template< class CoordSystem >; 59 class LorentzVector {; 60 ; 61 public:; 62 ; 63 // ------ ctors ------; 64 ; 65 typedef typename CoordSystem::Scalar Scalar;; 66 typedef CoordSystem CoordinateType;; 67 ; 68 /**; 69 default constructor of an empty vector (Px = Py = Pz = E = 0 ); 70 */; 71 LorentzVector ( ) : fCoordinates() { }; 72 ; 73 /**; 74 generic constructors from four scalar values.; 75 The association between values and coordinate depends on the; 76 coordinate system. For PxPyPzE4D,; 77 \param a scalar value (Px); 78 \param b scalar value (Py); 79 \param c scalar value (Pz); 80 \param d scalar value (E); 81 */; 82 LorentzVector(const Scalar & a,; 83 const Scalar & b,; 84 const Scalar & c,; 85 const Scalar & d) :; 86 fCoordinates(a , b, c, d) { }; 87 ; 88 /**; 89 construct",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:9644,Energy Efficiency,energy,energy,9644,"uality; 256 */; 257 bool operator==(const LorentzVector & rhs) const {; 258 return fCoordinates==rhs.fCoordinates;; 259 }; 260 bool operator!= (const LorentzVector & rhs) const {; 261 return !(operator==(rhs));; 262 }; 263 ; 264 // ------ Individual element access, in various coordinate systems ------; 265 ; 266 /**; 267 dimension; 268 */; 269 unsigned int Dimension() const; 270 {; 271 return fDimension;; 272 };; 273 ; 274 // individual coordinate accessors in various coordinate systems; 275 ; 276 /**; 277 spatial X component; 278 */; 279 Scalar Px() const { return fCoordinates.Px(); }; 280 Scalar X() const { return fCoordinates.Px(); }; 281 /**; 282 spatial Y component; 283 */; 284 Scalar Py() const { return fCoordinates.Py(); }; 285 Scalar Y() const { return fCoordinates.Py(); }; 286 /**; 287 spatial Z component; 288 */; 289 Scalar Pz() const { return fCoordinates.Pz(); }; 290 Scalar Z() const { return fCoordinates.Pz(); }; 291 /**; 292 return 4-th component (time, or energy for a 4-momentum vector); 293 */; 294 Scalar E() const { return fCoordinates.E(); }; 295 Scalar T() const { return fCoordinates.E(); }; 296 /**; 297 return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; 298 (we use -,-,-,+ metric); 299 */; 300 Scalar M2() const { return fCoordinates.M2(); }; 301 /**; 302 return magnitude (mass) using the (-,-,-,+) metric.; 303 If M2 is negative (space-like vector) a GenVector_exception; 304 is suggested and if continuing, - sqrt( -M2) is returned; 305 */; 306 Scalar M() const { return fCoordinates.M();}; 307 /**; 308 return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ); 309 */; 310 Scalar R() const { return fCoordinates.R(); }; 311 Scalar P() const { return fCoordinates.R(); }; 312 /**; 313 return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ); 314 */; 315 Scalar P2() const { return P() * P(); }; 316 /**; 317 return the square of the transverse spatial component ( X**2 + Y**2 ); 318 */; 319 Scalar Perp2( ) const { return fC",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:11243,Energy Efficiency,energy,energy,11243," ); 309 */; 310 Scalar R() const { return fCoordinates.R(); }; 311 Scalar P() const { return fCoordinates.R(); }; 312 /**; 313 return the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 ); 314 */; 315 Scalar P2() const { return P() * P(); }; 316 /**; 317 return the square of the transverse spatial component ( X**2 + Y**2 ); 318 */; 319 Scalar Perp2( ) const { return fCoordinates.Perp2();}; 320 ; 321 /**; 322 return the transverse spatial component sqrt ( X**2 + Y**2 ); 323 */; 324 Scalar Pt() const { return fCoordinates.Pt(); }; 325 Scalar Rho() const { return fCoordinates.Pt(); }; 326 ; 327 /**; 328 return the transverse mass squared; 329 \f[ m_t^2 = E^2 - p{_z}^2 \f]; 330 */; 331 Scalar Mt2() const { return fCoordinates.Mt2(); }; 332 ; 333 /**; 334 return the transverse mass; 335 \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]; 336 */; 337 Scalar Mt() const { return fCoordinates.Mt(); }; 338 ; 339 /**; 340 return the transverse energy squared; 341 \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]; 342 */; 343 Scalar Et2() const { return fCoordinates.Et2(); }; 344 ; 345 /**; 346 return the transverse energy; 347 \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]; 348 */; 349 Scalar Et() const { return fCoordinates.Et(); }; 350 ; 351 /**; 352 azimuthal Angle; 353 */; 354 Scalar Phi() const { return fCoordinates.Phi();}; 355 ; 356 /**; 357 polar Angle; 358 */; 359 Scalar Theta() const { return fCoordinates.Theta(); }; 360 ; 361 /**; 362 pseudorapidity; 363 \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]; 364 */; 365 Scalar Eta() const { return fCoordinates.Eta(); }; 366 ; 367 /**; 368 get the spatial components of the Vector in a; 369 DisplacementVector based on Cartesian Coordinates; 370 */; 371 ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> > Vect() const {; 372 return ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> >( X(), Y(), Z() );; 373 }; 374 ; 375 // ------ Operations combining two Lorentz vectors ------; 3",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:11415,Energy Efficiency,energy,energy,11415,"X**2 + Y**2 + Z**2 ); 314 */; 315 Scalar P2() const { return P() * P(); }; 316 /**; 317 return the square of the transverse spatial component ( X**2 + Y**2 ); 318 */; 319 Scalar Perp2( ) const { return fCoordinates.Perp2();}; 320 ; 321 /**; 322 return the transverse spatial component sqrt ( X**2 + Y**2 ); 323 */; 324 Scalar Pt() const { return fCoordinates.Pt(); }; 325 Scalar Rho() const { return fCoordinates.Pt(); }; 326 ; 327 /**; 328 return the transverse mass squared; 329 \f[ m_t^2 = E^2 - p{_z}^2 \f]; 330 */; 331 Scalar Mt2() const { return fCoordinates.Mt2(); }; 332 ; 333 /**; 334 return the transverse mass; 335 \f[ \sqrt{ m_t^2 = E^2 - p{_z}^2} X sign(E^ - p{_z}^2) \f]; 336 */; 337 Scalar Mt() const { return fCoordinates.Mt(); }; 338 ; 339 /**; 340 return the transverse energy squared; 341 \f[ e_t = \frac{E^2 p_{\perp}^2 }{ |p|^2 } \f]; 342 */; 343 Scalar Et2() const { return fCoordinates.Et2(); }; 344 ; 345 /**; 346 return the transverse energy; 347 \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]; 348 */; 349 Scalar Et() const { return fCoordinates.Et(); }; 350 ; 351 /**; 352 azimuthal Angle; 353 */; 354 Scalar Phi() const { return fCoordinates.Phi();}; 355 ; 356 /**; 357 polar Angle; 358 */; 359 Scalar Theta() const { return fCoordinates.Theta(); }; 360 ; 361 /**; 362 pseudorapidity; 363 \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]; 364 */; 365 Scalar Eta() const { return fCoordinates.Eta(); }; 366 ; 367 /**; 368 get the spatial components of the Vector in a; 369 DisplacementVector based on Cartesian Coordinates; 370 */; 371 ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> > Vect() const {; 372 return ::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> >( X(), Y(), Z() );; 373 }; 374 ; 375 // ------ Operations combining two Lorentz vectors ------; 376 ; 377 /**; 378 scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); 379 Enable the product using any other LorentzVector implementing; 380 the x(), y() , y",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16950,Energy Efficiency,energy,energy,16950," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:17149,Energy Efficiency,energy,energy,17149," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:17485,Energy Efficiency,energy,energy,17485," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:21543,Energy Efficiency,energy,energy,21543,y() const { return fCoordinates.Py(); }; 644 Scalar z() const { return fCoordinates.Pz(); }; 645 Scalar t() const { return fCoordinates.E(); }; 646 Scalar px() const { return fCoordinates.Px(); }; 647 Scalar py() const { return fCoordinates.Py(); }; 648 Scalar pz() const { return fCoordinates.Pz(); }; 649 Scalar e() const { return fCoordinates.E(); }; 650 Scalar r() const { return fCoordinates.R(); }; 651 Scalar theta() const { return fCoordinates.Theta(); }; 652 Scalar phi() const { return fCoordinates.Phi(); }; 653 Scalar rho() const { return fCoordinates.Rho(); }; 654 Scalar eta() const { return fCoordinates.Eta(); }; 655 Scalar pt() const { return fCoordinates.Pt(); }; 656 Scalar perp2() const { return fCoordinates.Perp2(); }; 657 Scalar mag2() const { return fCoordinates.M2(); }; 658 Scalar mag() const { return fCoordinates.M(); }; 659 Scalar mt() const { return fCoordinates.Mt(); }; 660 Scalar mt2() const { return fCoordinates.Mt2(); }; 661 ; 662 ; 663 // Methods requested by CMS ---; 664 Scalar energy() const { return fCoordinates.E(); }; 665 Scalar mass() const { return fCoordinates.M(); }; 666 Scalar mass2() const { return fCoordinates.M2(); }; 667 ; 668 ; 669 /**; 670 Methods setting a Single-component; 671 Work only if the component is one of which the vector is represented.; 672 For example SetE will work for a PxPyPzE Vector but not for a PxPyPzM Vector.; 673 */; 674 LorentzVector<CoordSystem>& SetE ( Scalar a ) { fCoordinates.SetE (a); return *this; }; 675 LorentzVector<CoordSystem>& SetEta( Scalar a ) { fCoordinates.SetEta(a); return *this; }; 676 LorentzVector<CoordSystem>& SetM ( Scalar a ) { fCoordinates.SetM (a); return *this; }; 677 LorentzVector<CoordSystem>& SetPhi( Scalar a ) { fCoordinates.SetPhi(a); return *this; }; 678 LorentzVector<CoordSystem>& SetPt ( Scalar a ) { fCoordinates.SetPt (a); return *this; }; 679 LorentzVector<CoordSystem>& SetPx ( Scalar a ) { fCoordinates.SetPx (a); return *this; }; 680 LorentzVector<CoordSystem>& SetPy ( Sc,MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:27063,Energy Efficiency,energy,energy,27063,"ze void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; srcOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::DisplacementVector3DClass describing a generic displacement vector in 3 dimensions.Definition DisplacementVector3D.h:58; ROOT::Math::DisplacementVector3D::Mag2Scalar Mag2() constMagnitute squared ( r^2 in spherical coordinate)Definition DisplacementVector3D.h:323; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::Math::LorentzVector::pzScalar pz() constDefinition LorentzVector.h:648; ROOT::Math::LorentzVector::ZScalar Z() constDefinition LorentzVector.h:290; ROOT::Math::LorentzVector::EScalar E() constreturn 4-th component (time, or energy for a 4-momentum vector)Definition LorentzVector.h:294; ROOT::Math::LorentzVector::thetaScalar theta() constDefinition LorentzVector.h:651; ROOT::Math::LorentzVector::EtScalar Et() constreturn the transverse energyDefinition LorentzVector.h:349; ROOT::Math::LorentzVector::YScalar Y() constDefinition LorentzVector.h:285; ROOT::Math::LorentzVector::SetPzLorentzVector< CoordSystem > & SetPz(Scalar a)Definition LorentzVector.h:681; ROOT::Math::LorentzVector::TScalar T() constDefinition LorentzVector.h:295; ROOT::Math::LorentzVector::GetCoordinatesvoid GetCoordinates(Scalar dest[]) constget internal data into an array of 4 Scalar numbersDefinition LorentzVector.h:211; ROOT::Math::LorentzVector::BoostToCMBetaVector BoostToCM() constThe beta vector for the boost that would bring this vector into its center of mass frame (zero moment...Definition LorentzVector.h:555; ROOT::Math::LorentzVector::operator==bool operator==(const LorentzVector &rhs) constExact equality.Definitio",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:27278,Energy Efficiency,energy,energyDefinition,27278," GetTextColor GetTextSize void char Point_t Rectangle_t srcDefinition TGWin32VirtualXProxy.cxx:164; qfloat * qDefinition THbookFile.cxx:89; ROOT::Math::DisplacementVector3DClass describing a generic displacement vector in 3 dimensions.Definition DisplacementVector3D.h:58; ROOT::Math::DisplacementVector3D::Mag2Scalar Mag2() constMagnitute squared ( r^2 in spherical coordinate)Definition DisplacementVector3D.h:323; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; ROOT::Math::LorentzVector::pzScalar pz() constDefinition LorentzVector.h:648; ROOT::Math::LorentzVector::ZScalar Z() constDefinition LorentzVector.h:290; ROOT::Math::LorentzVector::EScalar E() constreturn 4-th component (time, or energy for a 4-momentum vector)Definition LorentzVector.h:294; ROOT::Math::LorentzVector::thetaScalar theta() constDefinition LorentzVector.h:651; ROOT::Math::LorentzVector::EtScalar Et() constreturn the transverse energyDefinition LorentzVector.h:349; ROOT::Math::LorentzVector::YScalar Y() constDefinition LorentzVector.h:285; ROOT::Math::LorentzVector::SetPzLorentzVector< CoordSystem > & SetPz(Scalar a)Definition LorentzVector.h:681; ROOT::Math::LorentzVector::TScalar T() constDefinition LorentzVector.h:295; ROOT::Math::LorentzVector::GetCoordinatesvoid GetCoordinates(Scalar dest[]) constget internal data into an array of 4 Scalar numbersDefinition LorentzVector.h:211; ROOT::Math::LorentzVector::BoostToCMBetaVector BoostToCM() constThe beta vector for the boost that would bring this vector into its center of mass frame (zero moment...Definition LorentzVector.h:555; ROOT::Math::LorentzVector::operator==bool operator==(const LorentzVector &rhs) constExact equality.Definition LorentzVector.h:257; ROOT::Math::LorentzVector::MScalar M() constreturn magnitude (mass) using the (-,-,-,+) metric.Definition LorentzVector.h:306; ROOT::Math::LorentzVector::rhoScalar rho() constDefiniti",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:31317,Energy Efficiency,energy,energy,31317,"dinates, or using a different Scalar typeDefinition LorentzVector.h:93; ROOT::Math::LorentzVector::massScalar mass() constDefinition LorentzVector.h:665; ROOT::Math::LorentzVector::RhoScalar Rho() constDefinition LorentzVector.h:325; ROOT::Math::LorentzVector::PScalar P() constDefinition LorentzVector.h:311; ROOT::Math::LorentzVector::yScalar y() constDefinition LorentzVector.h:643; ROOT::Math::LorentzVector::PyScalar Py() constspatial Y componentDefinition LorentzVector.h:284; ROOT::Math::LorentzVector::LorentzVectorconstexpr LorentzVector(const ForeignLorentzVector &v)Construct from a foreign 4D vector type, for example, HepLorentzVector Precondition: v must implement...Definition LorentzVector.h:105; ROOT::Math::LorentzVector::LorentzVectorLorentzVector(const Scalar &a, const Scalar &b, const Scalar &c, const Scalar &d)generic constructors from four scalar values.Definition LorentzVector.h:82; ROOT::Math::LorentzVector::isLightlikebool isLightlike(Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) constDetermine if momentum-energy can represent a massless particle.Definition LorentzVector.h:535; ROOT::Math::LorentzVector::Vect::ROOT::Math::DisplacementVector3D< Cartesian3D< Scalar > > Vect() constget the spatial components of the Vector in a DisplacementVector based on Cartesian CoordinatesDefinition LorentzVector.h:371; ROOT::Math::LorentzVector::ColinearRapidityScalar ColinearRapidity() constRapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)].Definition LorentzVector.h:516; ROOT::Math::LorentzVector::eScalar e() constDefinition LorentzVector.h:649; ROOT::Math::LorentzVector::PzScalar Pz() constspatial Z componentDefinition LorentzVector.h:289; ROOT::Math::LorentzVector::operator-LorentzVector operator-() constNegative of a LorentzVector (q = - v )Definition LorentzVector.h:489; ROOT::Math::LorentzVector::fDimensionstatic constexpr unsigned int fDimensionDefinition LorentzVector.h:686; ROOT::Math::LorentzVector::SetPtLorentzVector<",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:34837,Energy Efficiency,energy,energy,34837,"itude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2 (we use -,-,-,+ metric)Definition LorentzVector.h:300; ROOT::Math::LorentzVector::rScalar r() constDefinition LorentzVector.h:650; ROOT::Math::LorentzVector::CoordinateTypeCoordSystem CoordinateTypeDefinition LorentzVector.h:66; ROOT::Math::LorentzVector::DotScalar Dot(const OtherLorentzVector &q) constscalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+) Enable the product using any ot...Definition LorentzVector.h:387; ROOT::Math::LorentzVector::GetCoordinatesvoid GetCoordinates(Scalar &a, Scalar &b, Scalar &c, Scalar &d) constget internal data into 4 Scalar numbersDefinition LorentzVector.h:205; ROOT::Math::LorentzVector::GammaScalar Gamma() constReturn Gamma scalar value.Definition LorentzVector.h:617; ROOT::Math::LorentzVector::XScalar X() constDefinition LorentzVector.h:280; ROOT::Math::LorentzVector::mt2Scalar mt2() constDefinition LorentzVector.h:660; ROOT::Math::LorentzVector::isSpacelikebool isSpacelike() constDetermine if momentum-energy is spacelike, and represents a tachyon.Definition LorentzVector.h:545; ROOT::Math::LorentzVector::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::Lore",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35437,Energy Efficiency,energy,energy,35437,"t internal data into 4 Scalar numbersDefinition LorentzVector.h:205; ROOT::Math::LorentzVector::GammaScalar Gamma() constReturn Gamma scalar value.Definition LorentzVector.h:617; ROOT::Math::LorentzVector::XScalar X() constDefinition LorentzVector.h:280; ROOT::Math::LorentzVector::mt2Scalar mt2() constDefinition LorentzVector.h:660; ROOT::Math::LorentzVector::isSpacelikebool isSpacelike() constDetermine if momentum-energy is spacelike, and represents a tachyon.Definition LorentzVector.h:545; ROOT::Math::LorentzVector::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefin",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35740,Energy Efficiency,energy,energyScalar,35740,"60; ROOT::Math::LorentzVector::isSpacelikebool isSpacelike() constDetermine if momentum-energy is spacelike, and represents a tachyon.Definition LorentzVector.h:545; ROOT::Math::LorentzVector::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefinition LorentzVector.h:654; ROOT::Math::LorentzVector::MtScalar Mt() constreturn the transverse massDefinition LorentzVector.h:337; ROOT::Math::LorentzVector::xScalar x() constDefinition LorentzVector.h:642; ROOT::Math::LorentzVector::mass2Scalar mass2() constDefinition LorentzVector.h:666; ROOT::Math::LorentzVector::Dimensionunsig",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35753,Energy Efficiency,energy,energy,35753,"60; ROOT::Math::LorentzVector::isSpacelikebool isSpacelike() constDetermine if momentum-energy is spacelike, and represents a tachyon.Definition LorentzVector.h:545; ROOT::Math::LorentzVector::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefinition LorentzVector.h:654; ROOT::Math::LorentzVector::MtScalar Mt() constreturn the transverse massDefinition LorentzVector.h:337; ROOT::Math::LorentzVector::xScalar x() constDefinition LorentzVector.h:642; ROOT::Math::LorentzVector::mass2Scalar mass2() constDefinition LorentzVector.h:666; ROOT::Math::LorentzVector::Dimensionunsig",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:35959,Energy Efficiency,energy,energy,35959,r::zScalar z() constDefinition LorentzVector.h:644; ROOT::Math::LorentzVector::RScalar R() constreturn the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) )Definition LorentzVector.h:310; ROOT::Math::LorentzVector::ScalarCoordSystem::Scalar ScalarDefinition LorentzVector.h:65; ROOT::Math::LorentzVector::P2Scalar P2() constreturn the square of the spatial (3D) magnitude ( X**2 + Y**2 + Z**2 )Definition LorentzVector.h:315; ROOT::Math::LorentzVector::Et2Scalar Et2() constreturn the transverse energy squaredDefinition LorentzVector.h:343; ROOT::Math::LorentzVector::mag2Scalar mag2() constDefinition LorentzVector.h:657; ROOT::Math::LorentzVector::LorentzVectorLorentzVector()default constructor of an empty vector (Px = Py = Pz = E = 0 )Definition LorentzVector.h:71; ROOT::Math::LorentzVector::energyScalar energy() constDefinition LorentzVector.h:664; ROOT::Math::LorentzVector::mtScalar mt() constDefinition LorentzVector.h:659; ROOT::Math::LorentzVector::isTimelikebool isTimelike() constDetermine if momentum-energy can represent a physical massive particle.Definition LorentzVector.h:528; ROOT::Math::LorentzVector::operator-=LorentzVector & operator-=(const OtherLorentzVector &q)Self subtraction of another Vector from this ( v-= q ) Enable the addition with any other LorentzVect...Definition LorentzVector.h:411; ROOT::Math::LorentzVector::PxScalar Px() constspatial X componentDefinition LorentzVector.h:279; ROOT::Math::LorentzVector::etaScalar eta() constDefinition LorentzVector.h:654; ROOT::Math::LorentzVector::MtScalar Mt() constreturn the transverse massDefinition LorentzVector.h:337; ROOT::Math::LorentzVector::xScalar x() constDefinition LorentzVector.h:642; ROOT::Math::LorentzVector::mass2Scalar mass2() constDefinition LorentzVector.h:666; ROOT::Math::LorentzVector::Dimensionunsigned int Dimension() constdimensionDefinition LorentzVector.h:269; ROOT::Math::LorentzVector::SetMLorentzVector< CoordSystem > & SetM(Scalar a)Definition LorentzVector.h:676; ROOT::Math::Lor,MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:39087,Energy Efficiency,energy,energy,39087,"ion LorentzVector.h:645; ROOT::Math::LorentzVector::ThetaScalar Theta() constpolar AngleDefinition LorentzVector.h:359; ROOT::Math::LorentzVector::BoostToCMBetaVector BoostToCM(const Other4Vector &v) constThe beta vector for the boost that would bring this vector into its center of mass frame (zero moment...Definition LorentzVector.h:577; ROOT::Math::LorentzVector::operator=LorentzVector & operator=(const LorentzVector< OtherCoords > &v)Assignment operator from a lorentz vector of arbitrary type.Definition LorentzVector.h:130; ROOT::Math::LorentzVector::fCoordinatesCoordSystem fCoordinatesDefinition LorentzVector.h:685; ROOT::Math::LorentzVector::SetCoordinatesLorentzVector< CoordSystem > & SetCoordinates(Scalar a, Scalar b, Scalar c, Scalar d)Set internal data based on 4 Scalar numbers.Definition LorentzVector.h:185; ROOT::Math::LorentzVector::SetPhiLorentzVector< CoordSystem > & SetPhi(Scalar a)Definition LorentzVector.h:677; ROOT::Math::PxPyPzE4DClass describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors...Definition PxPyPzE4D.h:44; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::GenVector::Throwvoid Throw(const char *)function throwing exception, by creating internally a GenVector_exception only when neededDefinition GenVector_exception.h:80; ROOT::Math::detail::get_manipchar_t get_manip(std::basic_ios< char_t, traits_t > &ios, manip_t m)Definition GenVectorIO.h:54; ROOT::Math::detail::require_delimstd::basic_istream< char_t, traits_t > & require_delim(std::basic_istream< char_t, traits_t > &is, manip_t m)Definition GenVectorIO.h:113; ROOT::Math::detail::set_manipvoid set_manip(std::basic_ios< char_t, traits_t > &ios, manip_t m, char_t ch)Definition GenVectorIO.h:74; ROOT::Math::detail::open@ openDefinition GenVectorIO.h:35; ROOT::Math::detail::sep@ sepDefinition GenVectorIO.h:35; ROOT::Math::detail::close@ closeDefinition GenVec",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:2999,Integrability,depend,depends,2999,"(rho),eta,phi and E (t) coordinates in double precision; 50- ROOT::Math::PxPyPzMVector based on px,py,pz and M (mass) coordinates in double precision; 51- ROOT::Math::PxPyPzEVector based on px,py,pz and E (energy) coordinates in double precision; 52- ROOT::Math::XYZTVector based on x,y,z,t coordinates (cartesian) in double precision (same as PxPyPzEVector); 53- ROOT::Math::XYZTVectorF based on x,y,z,t coordinates (cartesian) in float precision (same as PxPyPzEVector but float); 54 ; 55@sa Overview of the @ref GenVector ""physics vector library""; 56*/; 57 ; 58 template< class CoordSystem >; 59 class LorentzVector {; 60 ; 61 public:; 62 ; 63 // ------ ctors ------; 64 ; 65 typedef typename CoordSystem::Scalar Scalar;; 66 typedef CoordSystem CoordinateType;; 67 ; 68 /**; 69 default constructor of an empty vector (Px = Py = Pz = E = 0 ); 70 */; 71 LorentzVector ( ) : fCoordinates() { }; 72 ; 73 /**; 74 generic constructors from four scalar values.; 75 The association between values and coordinate depends on the; 76 coordinate system. For PxPyPzE4D,; 77 \param a scalar value (Px); 78 \param b scalar value (Py); 79 \param c scalar value (Pz); 80 \param d scalar value (E); 81 */; 82 LorentzVector(const Scalar & a,; 83 const Scalar & b,; 84 const Scalar & c,; 85 const Scalar & d) :; 86 fCoordinates(a , b, c, d) { }; 87 ; 88 /**; 89 constructor from a LorentzVector expressed in different; 90 coordinates, or using a different Scalar type; 91 */; 92 template< class Coords >; 93 explicit constexpr LorentzVector(const LorentzVector<Coords> & v ) :; 94 fCoordinates( v.Coordinates() ) { }; 95 ; 96 /**; 97 Construct from a foreign 4D vector type, for example, HepLorentzVector; 98 Precondition: v must implement methods x(), y(), z(), and t(); 99 */; 100 template<class ForeignLorentzVector,; 101 typename = decltype(std::declval<ForeignLorentzVector>().x(); 102 + std::declval<ForeignLorentzVector>().y(); 103 + std::declval<ForeignLorentzVector>().z(); 104 + std::declval<ForeignLorentzV",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16297,Performance,load,load,16297, LorentzVector operator * ( const Scalar & a) const {; 469 LorentzVector tmp(*this);; 470 tmp *= a;; 471 return tmp;; 472 }; 473 ; 474 /**; 475 Divide a LorentzVector by a scalar quantity; 476 \param a scalar quantity of type a; 477 \return a new mathcoreLorentzVector q = v / a same type as v; 478 */; 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Sca,MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16751,Performance,load,load,16751,"3 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:19232,Safety,avoid,avoid,19232,"oostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVector();; 583 } else {; 584 // TODO - should attempt to Throw with msg about; 585 // boostToCM computed for two 4-vectors with combined t=0; 586 return BetaVector(vecSum/eSum);; 587 }; 588 // TODO - should attempt to Throw with msg about; 589 // boostToCM computed for two 4-vectors with combined e=0; 590 }; 591 return BetaVector (vecSum * (-1./eSum));; 592 }; 593 ; 594 //beta and gamma; 595 ; 596 /**; 597 Return beta scalar value; 598 */; 599 Scalar Beta() const {; 600 if ( E() == 0 ) {; 601 if ( P2() == 0); 602 // to avoid Nan; 603 return 0;; 604 else {; 605 GenVector::Throw (""LorentzVector::Beta() - beta computed for LorentzVector with t = 0. Return an Infinite result"");; 606 return 1./E();; 607 }; 608 }; 609 if ( M2() <= 0 ) {; 610 GenVector::Throw (""LorentzVector::Beta() - beta computed for non-timelike LorentzVector . Result is physically meaningless"" );; 611 }; 612 return P() / E();; 613 }; 614 /**; 615 Return Gamma scalar value; 616 */; 617 Scalar Gamma() const {; 618 const Scalar v2 = P2();; 619 const Scalar t2 = E() * E();; 620 if (E() == 0) {; 621 if ( P2() == 0) {; 622 return 1;; 623 } else {; 624 GenVector::Throw (""LorentzVector::Gamma() - gamma computed for LorentzVector with t = 0. Return a zero result"");; 625 ; 626 }; 627 }; 628 if ( t2 < v2 ) {; 629 GenVector::Throw (""LorentzVector::Gamma() - gamma computed for a spacelike LorentzVector. Imaginary result"");; 630 return 0;; 631 }; 632 else if ( t2 == v2 ) {; 633 GenVector::Throw (""LorentzVector::Gamma() - gamm",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:6078,Security,access,access,6078,"eclval<ForeignLorentzVector>().x(); 141 + std::declval<ForeignLorentzVector>().y(); 142 + std::declval<ForeignLorentzVector>().z(); 143 + std::declval<ForeignLorentzVector>().t())>; 144 LorentzVector & operator = ( const ForeignLorentzVector & v) {; 145 SetXYZT( v.x(), v.y(), v.z(), v.t() );; 146 return *this;; 147 }; 148 ; 149#ifdef LATER; 150 /**; 151 assign from a generic linear algebra vector implementing operator []; 152 and with a size of at least 4; 153 In this case v[0] is the first data member; 154 ( Px for a PxPyPzE4D base); 155 \param v LA vector; 156 \param index0 index of first vector element (Px); 157 */; 158 template< class LAVector >; 159 LorentzVector & AssignFrom(const LAVector & v, size_t index0=0 ) {; 160 fCoordinates.SetCoordinates( v[index0], v[index0+1], v[index0+2], v[index0+3] );; 161 return *this;; 162 }; 163#endif; 164 ; 165 // ------ Set, Get, and access coordinate data ------; 166 ; 167 /**; 168 Retrieve a const reference to the coordinates object; 169 */; 170 const CoordSystem & Coordinates() const {; 171 return fCoordinates;; 172 }; 173 ; 174 /**; 175 Set internal data based on an array of 4 Scalar numbers; 176 */; 177 LorentzVector<CoordSystem>& SetCoordinates( const Scalar src[] ) {; 178 fCoordinates.SetCoordinates(src);; 179 return *this;; 180 }; 181 ; 182 /**; 183 Set internal data based on 4 Scalar numbers; 184 */; 185 LorentzVector<CoordSystem>& SetCoordinates( Scalar a, Scalar b, Scalar c, Scalar d ) {; 186 fCoordinates.SetCoordinates(a, b, c, d);; 187 return *this;; 188 }; 189 ; 190 /**; 191 Set internal data based on 4 Scalars at *begin to *end; 192 */; 193 template< class IT >; 194 LorentzVector<CoordSystem>& SetCoordinates( IT begin, IT end ) {; 195 IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 196 (void)end;; 197 assert (++begin==end);; 198 SetCoordinates (*a,*b,*c,*d);; 199 return *this;; 200 }; 201 ; 202 /**; 203 get internal data into 4 Scalar numbers; 204 */; 205 void GetCoordinates( Scalar& a, Scalar& b",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:8917,Security,access,access,8917,"+ = c;; 235 *begin = d;; 236 }; 237 ; 238 /**; 239 set the values of the vector from the cartesian components (x,y,z,t); 240 (if the vector is held in another coordinates, like (Pt,eta,phi,m); 241 then (x, y, z, t) are converted to that form); 242 */; 243 LorentzVector<CoordSystem>& SetXYZT (Scalar xx, Scalar yy, Scalar zz, Scalar tt) {; 244 fCoordinates.SetPxPyPzE(xx,yy,zz,tt);; 245 return *this;; 246 }; 247 LorentzVector<CoordSystem>& SetPxPyPzE (Scalar xx, Scalar yy, Scalar zz, Scalar ee) {; 248 fCoordinates.SetPxPyPzE(xx,yy,zz,ee);; 249 return *this;; 250 }; 251 ; 252 // ------------------- Equality -----------------; 253 ; 254 /**; 255 Exact equality; 256 */; 257 bool operator==(const LorentzVector & rhs) const {; 258 return fCoordinates==rhs.fCoordinates;; 259 }; 260 bool operator!= (const LorentzVector & rhs) const {; 261 return !(operator==(rhs));; 262 }; 263 ; 264 // ------ Individual element access, in various coordinate systems ------; 265 ; 266 /**; 267 dimension; 268 */; 269 unsigned int Dimension() const; 270 {; 271 return fDimension;; 272 };; 273 ; 274 // individual coordinate accessors in various coordinate systems; 275 ; 276 /**; 277 spatial X component; 278 */; 279 Scalar Px() const { return fCoordinates.Px(); }; 280 Scalar X() const { return fCoordinates.Px(); }; 281 /**; 282 spatial Y component; 283 */; 284 Scalar Py() const { return fCoordinates.Py(); }; 285 Scalar Y() const { return fCoordinates.Py(); }; 286 /**; 287 spatial Z component; 288 */; 289 Scalar Pz() const { return fCoordinates.Pz(); }; 290 Scalar Z() const { return fCoordinates.Pz(); }; 291 /**; 292 return 4-th component (time, or energy for a 4-momentum vector); 293 */; 294 Scalar E() const { return fCoordinates.E(); }; 295 Scalar T() const { return fCoordinates.E(); }; 296 /**; 297 return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; 298 (we use -,-,-,+ metric); 299 */; 300 Scalar M2() const { return fCoordinates.M2(); }; 301 /**; 302 return magnitude (mass) using the (",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:9111,Security,access,accessors,9111,"+ = c;; 235 *begin = d;; 236 }; 237 ; 238 /**; 239 set the values of the vector from the cartesian components (x,y,z,t); 240 (if the vector is held in another coordinates, like (Pt,eta,phi,m); 241 then (x, y, z, t) are converted to that form); 242 */; 243 LorentzVector<CoordSystem>& SetXYZT (Scalar xx, Scalar yy, Scalar zz, Scalar tt) {; 244 fCoordinates.SetPxPyPzE(xx,yy,zz,tt);; 245 return *this;; 246 }; 247 LorentzVector<CoordSystem>& SetPxPyPzE (Scalar xx, Scalar yy, Scalar zz, Scalar ee) {; 248 fCoordinates.SetPxPyPzE(xx,yy,zz,ee);; 249 return *this;; 250 }; 251 ; 252 // ------------------- Equality -----------------; 253 ; 254 /**; 255 Exact equality; 256 */; 257 bool operator==(const LorentzVector & rhs) const {; 258 return fCoordinates==rhs.fCoordinates;; 259 }; 260 bool operator!= (const LorentzVector & rhs) const {; 261 return !(operator==(rhs));; 262 }; 263 ; 264 // ------ Individual element access, in various coordinate systems ------; 265 ; 266 /**; 267 dimension; 268 */; 269 unsigned int Dimension() const; 270 {; 271 return fDimension;; 272 };; 273 ; 274 // individual coordinate accessors in various coordinate systems; 275 ; 276 /**; 277 spatial X component; 278 */; 279 Scalar Px() const { return fCoordinates.Px(); }; 280 Scalar X() const { return fCoordinates.Px(); }; 281 /**; 282 spatial Y component; 283 */; 284 Scalar Py() const { return fCoordinates.Py(); }; 285 Scalar Y() const { return fCoordinates.Py(); }; 286 /**; 287 spatial Z component; 288 */; 289 Scalar Pz() const { return fCoordinates.Pz(); }; 290 Scalar Z() const { return fCoordinates.Pz(); }; 291 /**; 292 return 4-th component (time, or energy for a 4-momentum vector); 293 */; 294 Scalar E() const { return fCoordinates.E(); }; 295 Scalar T() const { return fCoordinates.E(); }; 296 /**; 297 return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; 298 (we use -,-,-,+ metric); 299 */; 300 Scalar M2() const { return fCoordinates.M2(); }; 301 /**; 302 return magnitude (mass) using the (",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:6993,Testability,assert,assert,6993,"ndex0], v[index0+1], v[index0+2], v[index0+3] );; 161 return *this;; 162 }; 163#endif; 164 ; 165 // ------ Set, Get, and access coordinate data ------; 166 ; 167 /**; 168 Retrieve a const reference to the coordinates object; 169 */; 170 const CoordSystem & Coordinates() const {; 171 return fCoordinates;; 172 }; 173 ; 174 /**; 175 Set internal data based on an array of 4 Scalar numbers; 176 */; 177 LorentzVector<CoordSystem>& SetCoordinates( const Scalar src[] ) {; 178 fCoordinates.SetCoordinates(src);; 179 return *this;; 180 }; 181 ; 182 /**; 183 Set internal data based on 4 Scalar numbers; 184 */; 185 LorentzVector<CoordSystem>& SetCoordinates( Scalar a, Scalar b, Scalar c, Scalar d ) {; 186 fCoordinates.SetCoordinates(a, b, c, d);; 187 return *this;; 188 }; 189 ; 190 /**; 191 Set internal data based on 4 Scalars at *begin to *end; 192 */; 193 template< class IT >; 194 LorentzVector<CoordSystem>& SetCoordinates( IT begin, IT end ) {; 195 IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 196 (void)end;; 197 assert (++begin==end);; 198 SetCoordinates (*a,*b,*c,*d);; 199 return *this;; 200 }; 201 ; 202 /**; 203 get internal data into 4 Scalar numbers; 204 */; 205 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c, Scalar & d ) const; 206 { fCoordinates.GetCoordinates(a, b, c, d); }; 207 ; 208 /**; 209 get internal data into an array of 4 Scalar numbers; 210 */; 211 void GetCoordinates( Scalar dest[] ) const; 212 { fCoordinates.GetCoordinates(dest); }; 213 ; 214 /**; 215 get internal data into 4 Scalars at *begin to *end; 216 */; 217 template <class IT>; 218 void GetCoordinates( IT begin, IT end ) const; 219 { IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 220 (void)end;; 221 assert (++begin==end);; 222 GetCoordinates (*a,*b,*c,*d);; 223 }; 224 ; 225 /**; 226 get internal data into 4 Scalars at *begin; 227 */; 228 template <class IT>; 229 void GetCoordinates( IT begin ) const {; 230 Scalar a,b,c,d = 0;; 231 GetCoordinates (a,b,c,d);; 232 *",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:7690,Testability,assert,assert,7690,"in, IT end ) {; 195 IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 196 (void)end;; 197 assert (++begin==end);; 198 SetCoordinates (*a,*b,*c,*d);; 199 return *this;; 200 }; 201 ; 202 /**; 203 get internal data into 4 Scalar numbers; 204 */; 205 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c, Scalar & d ) const; 206 { fCoordinates.GetCoordinates(a, b, c, d); }; 207 ; 208 /**; 209 get internal data into an array of 4 Scalar numbers; 210 */; 211 void GetCoordinates( Scalar dest[] ) const; 212 { fCoordinates.GetCoordinates(dest); }; 213 ; 214 /**; 215 get internal data into 4 Scalars at *begin to *end; 216 */; 217 template <class IT>; 218 void GetCoordinates( IT begin, IT end ) const; 219 { IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 220 (void)end;; 221 assert (++begin==end);; 222 GetCoordinates (*a,*b,*c,*d);; 223 }; 224 ; 225 /**; 226 get internal data into 4 Scalars at *begin; 227 */; 228 template <class IT>; 229 void GetCoordinates( IT begin ) const {; 230 Scalar a,b,c,d = 0;; 231 GetCoordinates (a,b,c,d);; 232 *begin++ = a;; 233 *begin++ = b;; 234 *begin++ = c;; 235 *begin = d;; 236 }; 237 ; 238 /**; 239 set the values of the vector from the cartesian components (x,y,z,t); 240 (if the vector is held in another coordinates, like (Pt,eta,phi,m); 241 then (x, y, z, t) are converted to that form); 242 */; 243 LorentzVector<CoordSystem>& SetXYZT (Scalar xx, Scalar yy, Scalar zz, Scalar tt) {; 244 fCoordinates.SetPxPyPzE(xx,yy,zz,tt);; 245 return *this;; 246 }; 247 LorentzVector<CoordSystem>& SetPxPyPzE (Scalar xx, Scalar yy, Scalar zz, Scalar ee) {; 248 fCoordinates.SetPxPyPzE(xx,yy,zz,ee);; 249 return *this;; 250 }; 251 ; 252 // ------------------- Equality -----------------; 253 ; 254 /**; 255 Exact equality; 256 */; 257 bool operator==(const LorentzVector & rhs) const {; 258 return fCoordinates==rhs.fCoordinates;; 259 }; 260 bool operator!= (const LorentzVector & rhs) const {; 261 return !(operator==(rhs));; 262 }; 263 ; 264 //",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16135,Testability,log,log,16135, LorentzVector operator * ( const Scalar & a) const {; 469 LorentzVector tmp(*this);; 470 tmp *= a;; 471 return tmp;; 472 }; 473 ; 474 /**; 475 Divide a LorentzVector by a scalar quantity; 476 \param a scalar quantity of type a; 477 \return a new mathcoreLorentzVector q = v / a same type as v; 478 */; 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Sca,MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16443,Testability,log,log,16443,param a scalar quantity of type a; 477 \return a new mathcoreLorentzVector q = v / a same type as v; 478 */; 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < to,MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16474,Testability,log,log,16474," 479 LorentzVector<CoordSystem> operator / ( const Scalar & a) const {; 480 LorentzVector<CoordSystem> tmp(*this);; 481 tmp /= a;; 482 return tmp;; 483 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tac",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16585,Testability,log,log,16585,"3 }; 484 ; 485 /**; 486 Negative of a LorentzVector (q = - v ); 487 \return a new LorentzVector with opposite direction and time; 488 */; 489 LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16842,Testability,log,log,16842,"LorentzVector operator - () const {; 490 //LorentzVector<CoordinateType> v(*this);; 491 //v.Negate();; 492 return operator*( Scalar(-1) );; 493 }; 494 LorentzVector operator + () const {; 495 return *this;; 496 }; 497 ; 498 // ---- Relativistic Properties ----; 499 ; 500 /**; 501 Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]; 502 */; 503 Scalar Rapidity() const {; 504 // TODO - It would be good to check that E > Pz and use the Throw(); 505 // mechanism or at least load a NAN if not.; 506 // We should then move the code to a .cpp file.; 507 const Scalar ee = E();; 508 const Scalar ppz = Pz();; 509 using std::log;; 510 return Scalar(0.5) * log((ee + ppz) / (ee - ppz));; 511 }; 512 ; 513 /**; 514 Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]; 515 */; 516 Scalar ColinearRapidity() const {; 517 // TODO - It would be good to check that E > P and use the Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of m",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:16873,Testability,log,log,16873," Throw(); 518 // mechanism or at least load a NAN if not.; 519 const Scalar ee = E();; 520 const Scalar pp = P();; 521 using std::log;; 522 return Scalar(0.5) * log((ee + pp) / (ee - pp));; 523 }; 524 ; 525 /**; 526 Determine if momentum-energy can represent a physical massive particle; 527 */; 528 bool isTimelike( ) const {; 529 Scalar ee = E(); Scalar pp = P(); return ee*ee > pp*pp;; 530 }; 531 ; 532 /**; 533 Determine if momentum-energy can represent a massless particle; 534 */; 535 bool isLightlike( Scalar tolerance; 536 = 100*std::numeric_limits<Scalar>::epsilon() ) const {; 537 Scalar ee = E(); Scalar pp = P(); Scalar delta = ee-pp;; 538 if ( ee==0 ) return pp==0;; 539 return delta*delta < tolerance * ee*ee;; 540 }; 541 ; 542 /**; 543 Determine if momentum-energy is spacelike, and represents a tachyon; 544 */; 545 bool isSpacelike( ) const {; 546 Scalar ee = E(); Scalar pp = P(); return ee*ee < pp*pp;; 547 }; 548 ; 549 typedef DisplacementVector3D< Cartesian3D<Scalar> > BetaVector;; 550 ; 551 /**; 552 The beta vector for the boost that would bring this vector into; 553 its center of mass frame (zero momentum); 554 */; 555 BetaVector BoostToCM( ) const {; 556 if (E() == 0) {; 557 if (P() == 0) {; 558 return BetaVector();; 559 } else {; 560 // TODO - should attempt to Throw with msg about; 561 // boostVector computed for LorentzVector with t=0; 562 return -Vect()/E();; 563 }; 564 }; 565 if (M2() <= 0) {; 566 // TODO - should attempt to Throw with msg about; 567 // boostVector computed for a non-timelike LorentzVector; 568 }; 569 return -Vect()/E();; 570 }; 571 ; 572 /**; 573 The beta vector for the boost that would bring this vector into; 574 its center of mass frame (zero momentum); 575 */; 576 template <class Other4Vector>; 577 BetaVector BoostToCM(const Other4Vector& v ) const {; 578 Scalar eSum = E() + v.E();; 579 DisplacementVector3D< Cartesian3D<Scalar> > vecSum = Vect() + v.Vect();; 580 if (eSum == 0) {; 581 if (vecSum.Mag2() == 0) {; 582 return BetaVecto",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:28736,Testability,log,log,28736,"T::Math::LorentzVector::BoostToCMBetaVector BoostToCM() constThe beta vector for the boost that would bring this vector into its center of mass frame (zero moment...Definition LorentzVector.h:555; ROOT::Math::LorentzVector::operator==bool operator==(const LorentzVector &rhs) constExact equality.Definition LorentzVector.h:257; ROOT::Math::LorentzVector::MScalar M() constreturn magnitude (mass) using the (-,-,-,+) metric.Definition LorentzVector.h:306; ROOT::Math::LorentzVector::rhoScalar rho() constDefinition LorentzVector.h:653; ROOT::Math::LorentzVector::SetPyLorentzVector< CoordSystem > & SetPy(Scalar a)Definition LorentzVector.h:680; ROOT::Math::LorentzVector::PtScalar Pt() constreturn the transverse spatial component sqrt ( X**2 + Y**2 )Definition LorentzVector.h:324; ROOT::Math::LorentzVector::Mt2Scalar Mt2() constreturn the transverse mass squaredDefinition LorentzVector.h:331; ROOT::Math::LorentzVector::RapidityScalar Rapidity() constRapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)].Definition LorentzVector.h:503; ROOT::Math::LorentzVector::BetaScalar Beta() constReturn beta scalar value.Definition LorentzVector.h:599; ROOT::Math::LorentzVector::SetPxLorentzVector< CoordSystem > & SetPx(Scalar a)Definition LorentzVector.h:679; ROOT::Math::LorentzVector::Perp2Scalar Perp2() constreturn the square of the transverse spatial component ( X**2 + Y**2 )Definition LorentzVector.h:319; ROOT::Math::LorentzVector::GetCoordinatesvoid GetCoordinates(IT begin) constget internal data into 4 Scalars at *beginDefinition LorentzVector.h:229; ROOT::Math::LorentzVector::operator/LorentzVector< CoordSystem > operator/(const Scalar &a) constDivide a LorentzVector by a scalar quantity.Definition LorentzVector.h:479; ROOT::Math::LorentzVector::SetPxPyPzELorentzVector< CoordSystem > & SetPxPyPzE(Scalar xx, Scalar yy, Scalar zz, Scalar ee)Definition LorentzVector.h:247; ROOT::Math::LorentzVector::operator+=LorentzVector & operator+=(const OtherLorentzVector &q)Self addition with",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:31748,Testability,log,log,31748,":LorentzVector::LorentzVectorconstexpr LorentzVector(const ForeignLorentzVector &v)Construct from a foreign 4D vector type, for example, HepLorentzVector Precondition: v must implement...Definition LorentzVector.h:105; ROOT::Math::LorentzVector::LorentzVectorLorentzVector(const Scalar &a, const Scalar &b, const Scalar &c, const Scalar &d)generic constructors from four scalar values.Definition LorentzVector.h:82; ROOT::Math::LorentzVector::isLightlikebool isLightlike(Scalar tolerance=100 *std::numeric_limits< Scalar >::epsilon()) constDetermine if momentum-energy can represent a massless particle.Definition LorentzVector.h:535; ROOT::Math::LorentzVector::Vect::ROOT::Math::DisplacementVector3D< Cartesian3D< Scalar > > Vect() constget the spatial components of the Vector in a DisplacementVector based on Cartesian CoordinatesDefinition LorentzVector.h:371; ROOT::Math::LorentzVector::ColinearRapidityScalar ColinearRapidity() constRapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)].Definition LorentzVector.h:516; ROOT::Math::LorentzVector::eScalar e() constDefinition LorentzVector.h:649; ROOT::Math::LorentzVector::PzScalar Pz() constspatial Z componentDefinition LorentzVector.h:289; ROOT::Math::LorentzVector::operator-LorentzVector operator-() constNegative of a LorentzVector (q = - v )Definition LorentzVector.h:489; ROOT::Math::LorentzVector::fDimensionstatic constexpr unsigned int fDimensionDefinition LorentzVector.h:686; ROOT::Math::LorentzVector::SetPtLorentzVector< CoordSystem > & SetPt(Scalar a)Definition LorentzVector.h:678; ROOT::Math::LorentzVector::operator+LorentzVector operator+() constDefinition LorentzVector.h:494; ROOT::Math::LorentzVector::Coordinatesconst CoordSystem & Coordinates() constRetrieve a const reference to the coordinates object.Definition LorentzVector.h:170; ROOT::Math::LorentzVector::pyScalar py() constDefinition LorentzVector.h:647; ROOT::Math::LorentzVector::perp2Scalar perp2() constDefinition LorentzVector.h:656; ROOT::M",MatchSource.WIKI,doc/master/GenVector_2LorentzVector_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html
https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html:1464,Availability,avail,available,1464,"**************************/; 10 ; 11// Header file for class LorentzVector; 12//; 13// Created by: moneta at Fri Dec 02 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_Plane3D; 18#define ROOT_Math_GenVector_Plane3D 1; 19 ; 20#include <type_traits>; 21 ; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/PositionVector3D.h""; 24 ; 25 ; 26 ; 27namespace ROOT {; 28 ; 29namespace Math {; 30 ; 31namespace Impl {; 32 ; 33//_______________________________________________________________________________; 34/**; 35 Class describing a geometrical plane in 3 dimensions.; 36 A Plane3D is a 2 dimensional surface spanned by two linearly independent vectors.; 37 The plane is described by the equation; 38 \f$ a*x + b*y + c*z + d = 0 \f$ where (a,b,c) are the components of the; 39 normal vector to the plane \f$ n = (a,b,c) \f$ and \f$ d = - n \dot x \f$, where x is any point; 40 belonging to plane.; 41 More information on the mathematics describing a plane in 3D is available on; 42 <A HREF=http://mathworld.wolfram.com/Plane.html>MathWord</A>.; 43 The Plane3D class contains the 4 scalar values in T which represent the; 44 four coefficients, fA, fB, fC, fD. fA, fB, fC are the normal components normalized to 1,; 45 i.e. fA**2 + fB**2 + fC**2 = 1; 46 ; 47 @ingroup GenVector; 48 ; 49 @sa Overview of the @ref GenVector ""physics vector library""; 50*/; 51 ; 52template <typename T = double>; 53class Plane3D {; 54 ; 55public:; 56 // ------ ctors ------; 57 ; 58 typedef T Scalar;; 59 ; 60 typedef DisplacementVector3D<Cartesian3D<T>, DefaultCoordinateSystemTag> Vector;; 61 typedef PositionVector3D<Cartesian3D<T>, DefaultCoordinateSystemTag> Point;; 62 ; 63 /**; 64 default constructor create plane z = 0; 65 */; 66 Plane3D() : fA(0), fB(0), fC(1), fD(0) {}; 67 ; 68 /**; 69 generic constructors from the four scalar values describing the plane; 70 according to the equation ax + by + cz + d = 0; 71 \param a scalar value; 72 \param b scalar value; 73 ",MatchSource.WIKI,doc/master/GenVector_2Plane3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html
https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html:592,Deployability,update,update,592,". ROOT: math/genvector/inc/Math/GenVector/Plane3D.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Plane3D.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: L. Moneta 12/2005; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class LorentzVector; 12//; 13// Created by: moneta at Fri Dec 02 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_Plane3D; 18#define ROOT_Math_GenVector_Plane3D 1; 19 ; 20#include <type_traits>; 21 ; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/PositionVector3D.h""; 24 ; 25 ; 26 ; 27namespace ROOT {; 28 ; 29namespace Math {; 30 ; 31namespace Impl {; 32 ; 33//_______________________________________________________________________________; 34/**; 35 Class describing a geometrical plane in 3 dimensions.; 36 A Plane3D is a 2 dimensional surface spanned by two linearly independent vectors.; 37 The plane is described by the equation; 38 \f$ a*x + b*y + c*z + d = 0 \f$ where (a,b,c) are the components of the; 39 normal vector to the plane \f$ n = (a,b,c) \f$ and \f$ d = - n \dot x \f$, where x is any point; 40 belonging to plane.; 41 More information on the mathematics describing a plane in 3D is available on; 42 <A HREF=http://mathworld.wolfram.com/Plane.html>MathWord</A>.; 43 The Plane3D class contains the 4 scalar values in T which represent the; 44 four coefficients, fA, fB, fC, fD. fA, fB, fC are the normal components normalized to 1,; 45 i.e. fA**2 + fB**2 + fC**2 = 1; 46 ; 47 @ingroup GenVector; 48 ; 49 @sa Overview of the @ref GenVector ""physics vector library""; 50*/; 51 ; 52template <typename T = double>; 53class Plane3D {; 54 ; 55public:; 56 // ------ ctors ------; 57 ; 58 typedef T Scalar;; 59 ; 60 typedef Displa",MatchSource.WIKI,doc/master/GenVector_2Plane3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html
https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html:8685,Safety,avoid,avoid,8685,"PositionVector3D<T, U>(pxyz.X(), pxyz.Y(), pxyz.Z());; 203 }; 204 ; 205 // ------------------- Equality -----------------; 206 ; 207 /**; 208 Exact equality; 209 */; 210 bool operator==(const Plane3D &rhs) const { return (fA == rhs.fA && fB == rhs.fB && fC == rhs.fC && fD == rhs.fD); }; 211 bool operator!=(const Plane3D &rhs) const { return !(operator==(rhs)); }; 212 ; 213protected:; 214 /**; 215 Normalize the normal (a,b,c) plane components; 216 */; 217 template <typename SCALAR = T, typename std::enable_if<std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 218 void Normalize(); 219 {; 220 // normalize the plane; 221 using std::sqrt;; 222 const SCALAR s = sqrt(fA * fA + fB * fB + fC * fC);; 223 // what to do if s = 0 ?; 224 if (s == SCALAR(0)) {; 225 fD = SCALAR(0);; 226 } else {; 227 const SCALAR w = Scalar(1) / s;; 228 fA *= w;; 229 fB *= w;; 230 fC *= w;; 231 fD *= w;; 232 }; 233 }; 234 ; 235 /**; 236 Normalize the normal (a,b,c) plane components; 237 */; 238 template <typename SCALAR = T, typename std::enable_if<!std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 239 void Normalize(); 240 {; 241 // normalize the plane; 242 using std::sqrt;; 243 SCALAR s = sqrt(fA * fA + fB * fB + fC * fC);; 244 // what to do if s = 0 ?; 245 const auto m = (s == SCALAR(0));; 246 // set zero entries to 1 in the vector to avoid /0 later on; 247 s(m) = SCALAR(1);; 248 fD(m) = SCALAR(0);; 249 const SCALAR w = SCALAR(1) / s;; 250 fA *= w;; 251 fB *= w;; 252 fC *= w;; 253 fD *= w;; 254 }; 255 ; 256private:; 257 // internal method to construct class from a vector and a point; 258 void BuildFromVecAndPoint(const Vector &n, const Point &p); 259 {; 260 // build from a normal vector and a point; 261 fA = n.X();; 262 fB = n.Y();; 263 fC = n.Z();; 264 fD = -n.Dot(p);; 265 Normalize();; 266 }; 267 ; 268 // internal method to construct class from 3 points; 269 void BuildFrom3Points(const Point &p1, const Point &p2, const Point &p3); 270 {; 271 // plane from three points; 272 // normal ",MatchSource.WIKI,doc/master/GenVector_2Plane3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Plane3D_8h_source.html
https://root.cern/doc/master/GenVector_2PositionVector2D_8h_source.html:5592,Security,access,access,5592," b);; 144 return *this;; 145 }; 146 ; 147 ; 148 /**; 149 get internal data into 2 Scalar numbers.; 150 These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector; 151 */; 152 void GetCoordinates( Scalar& a, Scalar& b) const; 153 { fCoordinates.GetCoordinates(a, b); }; 154 ; 155 ; 156 /**; 157 set the values of the vector from the cartesian components (x,y); 158 (if the vector is held in polar coordinates,; 159 then (x, y) are converted to that form); 160 */; 161 PositionVector2D<CoordSystem, Tag>& SetXY (Scalar a, Scalar b) {; 162 fCoordinates.SetXY (a,b);; 163 return *this;; 164 }; 165 ; 166 // ------------------- Equality -----------------; 167 ; 168 /**; 169 Exact equality; 170 */; 171 bool operator==(const PositionVector2D & rhs) const {; 172 return fCoordinates==rhs.fCoordinates;; 173 }; 174 bool operator!= (const PositionVector2D & rhs) const {; 175 return !(operator==(rhs));; 176 }; 177 ; 178 // ------ Individual element access, in various coordinate systems ------; 179 ; 180 /**; 181 Dimension; 182 */; 183 unsigned int Dimension() const { return fDimension; };; 184 ; 185 /**; 186 Cartesian X, converting if necessary from internal coordinate system.; 187 */; 188 Scalar X() const { return fCoordinates.X(); }; 189 ; 190 /**; 191 Cartesian Y, converting if necessary from internal coordinate system.; 192 */; 193 Scalar Y() const { return fCoordinates.Y(); }; 194 ; 195 /**; 196 Polar R, converting if necessary from internal coordinate system.; 197 */; 198 Scalar R() const { return fCoordinates.R(); }; 199 ; 200 /**; 201 Polar phi, converting if necessary from internal coordinate system.; 202 */; 203 Scalar Phi() const { return fCoordinates.Phi(); }; 204 ; 205 /**; 206 Magnitute squared ( r^2 in spherical coordinate); 207 */; 208 Scalar Mag2() const { return fCoordinates.Mag2();}; 209 ; 210 ; 211 // It is physically meaningless to speak of the unit vector corresponding; 212 // to a point.; 213 ; 214 // ------ Setting individual elements presen",MatchSource.WIKI,doc/master/GenVector_2PositionVector2D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2PositionVector2D_8h_source.html
https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html:651,Deployability,update,update,651,". ROOT: math/genvector/inc/Math/GenVector/PositionVector3D.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. PositionVector3D.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class PositionVector3D; 12//; 13// Created by: Lorenzo Moneta at Mon May 30 15:25:04 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_PositionVector3D; 18#define ROOT_Math_GenVector_PositionVector3D 1; 19 ; 20#include ""Math/GenVector/DisplacementVector3Dfwd.h""; 21 ; 22#include ""Math/GenVector/Cartesian3D.h""; 23 ; 24#include ""Math/GenVector/GenVectorIO.h""; 25 ; 26#include ""Math/GenVector/BitReproducible.h""; 27 ; 28#include ""Math/GenVector/CoordinateSystemTags.h""; 29 ; 30 ; 31#include <cassert>; 32 ; 33namespace ROOT {; 34 ; 35 namespace Math {; 36 ; 37 ; 38//__________________________________________________________________________________________; 39 /**; 40 Class describing a generic position vector (point) in 3 dimensions.; 41 This class is templated on the type of Coordinate system.; 42 One example is the XYZPoint which is a vector based on; 43 double precision x,y,z data members by using the; 44 ROOT::Math::Cartesian3D<double> Coordinate system.; 45 The class is having also an extra template parameter, the coordinate system tag,; 46 to be able to identify (tag) vector described in different reference coordinate system,; 47 like global or local coordinate systems.; 48 ; 49 @ingroup GenVector; 50 ; 51 @sa Overview of the @ref GenVector ""physics vector library""; 52 */; 53 ; 54 template <class CoordSystem, class Tag = DefaultCoordinateSystemTag >; 55 class PositionVector3D {; 56 ; 57 public:; 58 ; 59 typedef ty",MatchSource.WIKI,doc/master/GenVector_2PositionVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html:8087,Security,access,access,8087,"; 223 */; 224 template <class IT>; 225 void GetCoordinates( IT begin ) const {; 226 Scalar a = Scalar(0);; 227 Scalar b = Scalar(0);; 228 Scalar c = Scalar(0);; 229 GetCoordinates(a, b, c);; 230 *begin++ = a;; 231 *begin++ = b;; 232 *begin = c;; 233 }; 234 ; 235 /**; 236 set the values of the vector from the cartesian components (x,y,z); 237 (if the vector is held in polar or cylindrical eta coordinates,; 238 then (x, y, z) are converted to that form); 239 */; 240 PositionVector3D<CoordSystem, Tag>& SetXYZ (Scalar a, Scalar b, Scalar c) {; 241 fCoordinates.SetXYZ(a,b,c);; 242 return *this;; 243 }; 244 ; 245 // ------------------- Equality -----------------; 246 ; 247 /**; 248 Exact equality; 249 */; 250 bool operator==(const PositionVector3D & rhs) const {; 251 return fCoordinates==rhs.fCoordinates;; 252 }; 253 bool operator!= (const PositionVector3D & rhs) const {; 254 return !(operator==(rhs));; 255 }; 256 ; 257 // ------ Individual element access, in various coordinate systems ------; 258 ; 259 /**; 260 Dimension; 261 */; 262 unsigned int Dimension() const; 263 {; 264 return fDimension;; 265 };; 266 ; 267 /**; 268 Cartesian X, converting if necessary from internal coordinate system.; 269 */; 270 Scalar X() const { return fCoordinates.X(); }; 271 ; 272 /**; 273 Cartesian Y, converting if necessary from internal coordinate system.; 274 */; 275 Scalar Y() const { return fCoordinates.Y(); }; 276 ; 277 /**; 278 Cartesian Z, converting if necessary from internal coordinate system.; 279 */; 280 Scalar Z() const { return fCoordinates.Z(); }; 281 ; 282 /**; 283 Polar R, converting if necessary from internal coordinate system.; 284 */; 285 Scalar R() const { return fCoordinates.R(); }; 286 ; 287 /**; 288 Polar theta, converting if necessary from internal coordinate system.; 289 */; 290 Scalar Theta() const { return fCoordinates.Theta(); }; 291 ; 292 /**; 293 Polar phi, converting if necessary from internal coordinate system.; 294 */; 295 Scalar Phi() const { return fCoordin",MatchSource.WIKI,doc/master/GenVector_2PositionVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html:6321,Testability,assert,assert,6321,"tionVector3D & assignFrom(const LAVector & v, size_t index0 = 0) {; 162 fCoordinates = CoordSystem ( v[index0], v[index0+1], v[index0+2] );; 163 return *this;; 164 }; 165#endif; 166 ; 167 /**; 168 Retrieve a copy of the coordinates object; 169 */; 170 const CoordSystem & Coordinates() const {; 171 return fCoordinates;; 172 }; 173 ; 174 /**; 175 Set internal data based on a C-style array of 3 Scalar numbers; 176 */; 177 PositionVector3D<CoordSystem, Tag>& SetCoordinates( const Scalar src[] ); 178 { fCoordinates.SetCoordinates(src); return *this; }; 179 ; 180 /**; 181 Set internal data based on 3 Scalar numbers; 182 */; 183 PositionVector3D<CoordSystem, Tag>& SetCoordinates( Scalar a, Scalar b, Scalar c ); 184 { fCoordinates.SetCoordinates(a, b, c); return *this; }; 185 ; 186 /**; 187 Set internal data based on 3 Scalars at *begin to *end; 188 */; 189 template <class IT>; 190 PositionVector3D<CoordSystem, Tag>& SetCoordinates( IT begin, IT end ); 191 { IT a = begin; IT b = ++begin; IT c = ++begin;; 192 (void)end;; 193 assert (++begin==end);; 194 SetCoordinates (*a,*b,*c);; 195 return *this;; 196 }; 197 ; 198 /**; 199 get internal data into 3 Scalar numbers; 200 */; 201 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c ) const; 202 { fCoordinates.GetCoordinates(a, b, c); }; 203 ; 204 /**; 205 get internal data into a C-style array of 3 Scalar numbers; 206 */; 207 void GetCoordinates( Scalar dest[] ) const; 208 { fCoordinates.GetCoordinates(dest); }; 209 ; 210 /**; 211 get internal data into 3 Scalars at *begin to *end (3 past begin); 212 */; 213 template <class IT>; 214 void GetCoordinates( IT begin, IT end ) const; 215 { IT a = begin; IT b = ++begin; IT c = ++begin;; 216 (void)end;; 217 assert (++begin==end);; 218 GetCoordinates (*a,*b,*c);; 219 }; 220 ; 221 /**; 222 get internal data into 3 Scalars at *begin; 223 */; 224 template <class IT>; 225 void GetCoordinates( IT begin ) const {; 226 Scalar a = Scalar(0);; 227 Scalar b = Scalar(0);; 228 Scalar c = Scalar(0);",MatchSource.WIKI,doc/master/GenVector_2PositionVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html:7006,Testability,assert,assert,7006,"Coordinates( IT begin, IT end ); 191 { IT a = begin; IT b = ++begin; IT c = ++begin;; 192 (void)end;; 193 assert (++begin==end);; 194 SetCoordinates (*a,*b,*c);; 195 return *this;; 196 }; 197 ; 198 /**; 199 get internal data into 3 Scalar numbers; 200 */; 201 void GetCoordinates( Scalar& a, Scalar& b, Scalar& c ) const; 202 { fCoordinates.GetCoordinates(a, b, c); }; 203 ; 204 /**; 205 get internal data into a C-style array of 3 Scalar numbers; 206 */; 207 void GetCoordinates( Scalar dest[] ) const; 208 { fCoordinates.GetCoordinates(dest); }; 209 ; 210 /**; 211 get internal data into 3 Scalars at *begin to *end (3 past begin); 212 */; 213 template <class IT>; 214 void GetCoordinates( IT begin, IT end ) const; 215 { IT a = begin; IT b = ++begin; IT c = ++begin;; 216 (void)end;; 217 assert (++begin==end);; 218 GetCoordinates (*a,*b,*c);; 219 }; 220 ; 221 /**; 222 get internal data into 3 Scalars at *begin; 223 */; 224 template <class IT>; 225 void GetCoordinates( IT begin ) const {; 226 Scalar a = Scalar(0);; 227 Scalar b = Scalar(0);; 228 Scalar c = Scalar(0);; 229 GetCoordinates(a, b, c);; 230 *begin++ = a;; 231 *begin++ = b;; 232 *begin = c;; 233 }; 234 ; 235 /**; 236 set the values of the vector from the cartesian components (x,y,z); 237 (if the vector is held in polar or cylindrical eta coordinates,; 238 then (x, y, z) are converted to that form); 239 */; 240 PositionVector3D<CoordSystem, Tag>& SetXYZ (Scalar a, Scalar b, Scalar c) {; 241 fCoordinates.SetXYZ(a,b,c);; 242 return *this;; 243 }; 244 ; 245 // ------------------- Equality -----------------; 246 ; 247 /**; 248 Exact equality; 249 */; 250 bool operator==(const PositionVector3D & rhs) const {; 251 return fCoordinates==rhs.fCoordinates;; 252 }; 253 bool operator!= (const PositionVector3D & rhs) const {; 254 return !(operator==(rhs));; 255 }; 256 ; 257 // ------ Individual element access, in various coordinate systems ------; 258 ; 259 /**; 260 Dimension; 261 */; 262 unsigned int Dimension() const; 263 {; 26",MatchSource.WIKI,doc/master/GenVector_2PositionVector3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2PositionVector3D_8h_source.html
https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html:658,Deployability,update,update,658,". ROOT: math/genvector/inc/Math/GenVector/Quaternion.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Quaternion.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for rotation in 3 dimensions, represented by a quaternion; 12// Created by: Mark Fischler Thurs June 9 2005; 13//; 14// Last update: $Id$; 15//; 16#ifndef ROOT_Math_GenVector_Quaternion; 17#define ROOT_Math_GenVector_Quaternion 1; 18 ; 19 ; 20#include ""Math/GenVector/Cartesian3D.h""; 21#include ""Math/GenVector/DisplacementVector3D.h""; 22#include ""Math/GenVector/PositionVector3D.h""; 23#include ""Math/GenVector/LorentzVector.h""; 24#include ""Math/GenVector/3DConversions.h""; 25#include ""Math/GenVector/3DDistances.h""; 26 ; 27#include <algorithm>; 28#include <cassert>; 29 ; 30 ; 31namespace ROOT {; 32namespace Math {; 33 ; 34 ; 35//__________________________________________________________________________________________; 36 /**; 37 Rotation class with the (3D) rotation represented by; 38 a unit quaternion (u, i, j, k).; 39 This is the optimal representation for multiplication of multiple; 40 rotations, and for computation of group-manifold-invariant distance; 41 between two rotations.; 42 See also ROOT::Math::AxisAngle, ROOT::Math::EulerAngles, and ROOT::Math::Rotation3D.; 43 ; 44 @ingroup GenVector; 45 ; 46 @sa Overview of the @ref GenVector ""physics vector library""; 47 */; 48 ; 49class Quaternion {; 50 ; 51public:; 52 ; 53 typedef double Scalar;; 54 ; 55 // ========== Constructors and Assignment =====================; 56 ; 57 /**; 58 Default constructor (identity rotation); 59 */; 60 Quaternion(); 61 : fU(1.0); 62 , fI(0.0); 63 , fJ(0.0); 64 , fK(0.",MatchSource.WIKI,doc/master/GenVector_2Quaternion_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html
https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html:3548,Testability,assert,assert,3548," 83 /**; 84 Construct from four Scalars representing the coefficients of u, i, j, k; 85 */; 86 Quaternion(Scalar u, Scalar i, Scalar j, Scalar k) :; 87 fU(u), fI(i), fJ(j), fK(k) { }; 88 ; 89 // The compiler-generated copy ctor, copy assignment, and dtor are OK.; 90 ; 91 /**; 92 Re-adjust components to eliminate small deviations from |Q| = 1; 93 orthonormality.; 94 */; 95 void Rectify();; 96 ; 97 /**; 98 Assign from another supported rotation type (see gv_detail::convert ); 99 */; 100 template <class OtherRotation>; 101 Quaternion & operator=( OtherRotation const & r ) {; 102 gv_detail::convert(r,*this);; 103 return *this;; 104 }; 105 ; 106 // ======== Components ==============; 107 ; 108 /**; 109 Set the four components given an iterator to the start of; 110 the desired data, and another to the end (4 past start).; 111 */; 112 template<class IT>; 113 void SetComponents(IT begin, IT end) {; 114 fU = *begin++;; 115 fI = *begin++;; 116 fJ = *begin++;; 117 fK = *begin++;; 118 (void)end;; 119 assert (end==begin);; 120 }; 121 ; 122 /**; 123 Get the components into data specified by an iterator begin; 124 and another to the end of the desired data (4 past start).; 125 */; 126 template<class IT>; 127 void GetComponents(IT begin, IT end) const {; 128 *begin++ = fU;; 129 *begin++ = fI;; 130 *begin++ = fJ;; 131 *begin++ = fK;; 132 (void)end;; 133 assert (end==begin);; 134 }; 135 ; 136 /**; 137 Get the components into data specified by an iterator begin; 138 */; 139 template<class IT>; 140 void GetComponents(IT begin ) const {; 141 *begin++ = fU;; 142 *begin++ = fI;; 143 *begin++ = fJ;; 144 *begin = fK;; 145 }; 146 ; 147 /**; 148 Set the components based on four Scalars. The sum of the squares of; 149 these Scalars should be 1; no checking is done.; 150 */; 151 void SetComponents(Scalar u, Scalar i, Scalar j, Scalar k) {; 152 fU=u; fI=i; fJ=j; fK=k;; 153 }; 154 ; 155 /**; 156 Get the components into four Scalars.; 157 */; 158 void GetComponents(Scalar & u, Scalar & i, Scalar & ",MatchSource.WIKI,doc/master/GenVector_2Quaternion_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html
https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html:3903,Testability,assert,assert,3903,"ported rotation type (see gv_detail::convert ); 99 */; 100 template <class OtherRotation>; 101 Quaternion & operator=( OtherRotation const & r ) {; 102 gv_detail::convert(r,*this);; 103 return *this;; 104 }; 105 ; 106 // ======== Components ==============; 107 ; 108 /**; 109 Set the four components given an iterator to the start of; 110 the desired data, and another to the end (4 past start).; 111 */; 112 template<class IT>; 113 void SetComponents(IT begin, IT end) {; 114 fU = *begin++;; 115 fI = *begin++;; 116 fJ = *begin++;; 117 fK = *begin++;; 118 (void)end;; 119 assert (end==begin);; 120 }; 121 ; 122 /**; 123 Get the components into data specified by an iterator begin; 124 and another to the end of the desired data (4 past start).; 125 */; 126 template<class IT>; 127 void GetComponents(IT begin, IT end) const {; 128 *begin++ = fU;; 129 *begin++ = fI;; 130 *begin++ = fJ;; 131 *begin++ = fK;; 132 (void)end;; 133 assert (end==begin);; 134 }; 135 ; 136 /**; 137 Get the components into data specified by an iterator begin; 138 */; 139 template<class IT>; 140 void GetComponents(IT begin ) const {; 141 *begin++ = fU;; 142 *begin++ = fI;; 143 *begin++ = fJ;; 144 *begin = fK;; 145 }; 146 ; 147 /**; 148 Set the components based on four Scalars. The sum of the squares of; 149 these Scalars should be 1; no checking is done.; 150 */; 151 void SetComponents(Scalar u, Scalar i, Scalar j, Scalar k) {; 152 fU=u; fI=i; fJ=j; fK=k;; 153 }; 154 ; 155 /**; 156 Get the components into four Scalars.; 157 */; 158 void GetComponents(Scalar & u, Scalar & i, Scalar & j, Scalar & k) const {; 159 u=fU; i=fI; j=fJ; k=fK;; 160 }; 161 ; 162 /**; 163 Access to the four quaternion components:; 164 U() is the coefficient of the identity Pauli matrix,; 165 I(), J() and K() are the coefficients of sigma_x, sigma_y, sigma_z; 166 */; 167 Scalar U() const { return fU; }; 168 Scalar I() const { return fI; }; 169 Scalar J() const { return fJ; }; 170 Scalar K() const { return fK; }; 171 ; 172 // ==========",MatchSource.WIKI,doc/master/GenVector_2Quaternion_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Quaternion_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:668,Deployability,update,update,668,". ROOT: math/genvector/inc/Math/GenVector/Rotation3D.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Rotation3D.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class Rotation in 3 dimensions, represented by 3x3 matrix; 12//; 13// Created by: Mark Fischler Thurs June 9 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_Rotation3D; 18#define ROOT_Math_GenVector_Rotation3D 1; 19 ; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/PositionVector3D.h""; 24#include ""Math/GenVector/PxPyPzE4D.h""; 25#include ""Math/GenVector/LorentzVector.h""; 26#include ""Math/GenVector/3DConversions.h""; 27#include ""Math/GenVector/3DDistances.h""; 28 ; 29#include ""Math/GenVector/Rotation3Dfwd.h""; 30#include ""Math/GenVector/AxisAnglefwd.h""; 31#include ""Math/GenVector/EulerAnglesfwd.h""; 32#include ""Math/GenVector/Quaternionfwd.h""; 33#include ""Math/GenVector/RotationXfwd.h""; 34#include ""Math/GenVector/RotationYfwd.h""; 35#include ""Math/GenVector/RotationZfwd.h""; 36 ; 37 ; 38#include <algorithm>; 39#include <cassert>; 40#include <iostream>; 41 ; 42 ; 43namespace ROOT {; 44namespace Math {; 45 ; 46 ; 47//__________________________________________________________________________________________; 48 /**; 49 Rotation class with the (3D) rotation represented by; 50 a 3x3 orthogonal matrix.; 51 This is the optimal representation for application to vectors.; 52 See also ROOT::Math::AxisAngle, ROOT::Math::EulerAngles, and ROOT::Math::Quaternion for; 53 classes which have conversion operators to Rotation3D.; 54 ; 55 All Rotations types (not onl",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:4385,Performance,perform,performed,4385,") { gv_detail::convert(a, *this); }; 104 ; 105 /**; 106 Construct from EulerAngles; 107 */; 108 explicit Rotation3D( EulerAngles const & e ) { gv_detail::convert(e, *this); }; 109 ; 110 /**; 111 Construct from RotationZYX; 112 */; 113 explicit Rotation3D( RotationZYX const & e ) { gv_detail::convert(e, *this); }; 114 ; 115 /**; 116 Construct from a Quaternion; 117 */; 118 explicit Rotation3D( Quaternion const & q ) { gv_detail::convert(q, *this); }; 119 ; 120 /**; 121 Construct from an axial rotation; 122 */; 123 explicit Rotation3D( RotationZ const & r ) { gv_detail::convert(r, *this); }; 124 explicit Rotation3D( RotationY const & r ) { gv_detail::convert(r, *this); }; 125 explicit Rotation3D( RotationX const & r ) { gv_detail::convert(r, *this); }; 126 ; 127 /**; 128 Construct from a linear algebra matrix of size at least 3x3,; 129 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 130 Precondition: The matrix is assumed to be orthonormal. No checking; 131 or re-adjusting is performed.; 132 */; 133 template<class ForeignMatrix>; 134 explicit constexpr Rotation3D(const ForeignMatrix & m) { SetComponents(m); }; 135 ; 136 /**; 137 Construct from three orthonormal vectors (which must have methods; 138 x(), y() and z()) which will be used as the columns of the rotation; 139 matrix. The orthonormality will be checked, and values adjusted; 140 so that the result will always be a good rotation matrix.; 141 */; 142 template<class ForeignVector>; 143 Rotation3D(const ForeignVector& v1,; 144 const ForeignVector& v2,; 145 const ForeignVector& v3 ) { SetComponents(v1, v2, v3); }; 146 ; 147 // compiler generated destruuctor is ok; 148 ; 149 /**; 150 Raw constructor from nine Scalar components (without any checking); 151 */; 152 Rotation3D(Scalar xx, Scalar xy, Scalar xz,; 153 Scalar yx, Scalar yy, Scalar yz,; 154 Scalar zx, Scalar zy, Scalar zz); 155 {; 156 SetComponents (xx, xy, xz, yx, yy, yz, zx, zy, zz);; 157 }; 158 ; 159 // need to implement assignment",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:9497,Performance,perform,performed,9497," template<class IT>; 264 void SetComponents(IT begin, IT end) {; 265 for (int i = 0; i <9; ++i) {; 266 fM[i] = *begin;; 267 ++begin;; 268 }; 269 (void)end;; 270 assert (end==begin);; 271 }; 272 ; 273 /**; 274 Get the 9 matrix components into data specified by an iterator begin; 275 and another to the end of the desired data (9 past start).; 276 */; 277 template<class IT>; 278 void GetComponents(IT begin, IT end) const {; 279 for (int i = 0; i <9; ++i) {; 280 *begin = fM[i];; 281 ++begin;; 282 }; 283 (void)end;; 284 assert (end==begin);; 285 }; 286 ; 287 /**; 288 Get the 9 matrix components into data specified by an iterator begin; 289 */; 290 template<class IT>; 291 void GetComponents(IT begin) const {; 292 std::copy ( fM, fM+9, begin );; 293 }; 294 ; 295 /**; 296 Set components from a linear algebra matrix of size at least 3x3,; 297 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 298 Precondition: The matrix is assumed to be orthonormal. NO checking; 299 or re-adjusting is performed.; 300 */; 301 template<class ForeignMatrix>; 302 void; 303 SetRotationMatrix (const ForeignMatrix & m) {; 304 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2);; 305 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2);; 306 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2);; 307 }; 308 ; 309 /**; 310 Get components into a linear algebra matrix of size at least 3x3,; 311 which must support operator()(i,j) for write access to elements; 312 (0,0) thru (2,2).; 313 */; 314 template<class ForeignMatrix>; 315 void; 316 GetRotationMatrix (ForeignMatrix & m) const {; 317 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ];; 318 m(1,0)=fM[kYX]; m(1,1)=fM[kYY]; m(1,2)=fM[kYZ];; 319 m(2,0)=fM[kZX]; m(2,1)=fM[kZY]; m(2,2)=fM[kZZ];; 320 }; 321 ; 322 /**; 323 Set the components from nine scalars -- UNCHECKED for orthonormaility; 324 */; 325 void; 326 SetComponents (Scalar xx, Scalar xy, Scalar xz,; 327 Scalar yx, Scalar yy, Scalar yz,; 328 Scalar zx, Scalar zy, Scalar zz) {; 329 fM[kXX]=xx; fM",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:5385,Safety,avoid,avoid,5385,"bra matrix of size at least 3x3,; 129 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 130 Precondition: The matrix is assumed to be orthonormal. No checking; 131 or re-adjusting is performed.; 132 */; 133 template<class ForeignMatrix>; 134 explicit constexpr Rotation3D(const ForeignMatrix & m) { SetComponents(m); }; 135 ; 136 /**; 137 Construct from three orthonormal vectors (which must have methods; 138 x(), y() and z()) which will be used as the columns of the rotation; 139 matrix. The orthonormality will be checked, and values adjusted; 140 so that the result will always be a good rotation matrix.; 141 */; 142 template<class ForeignVector>; 143 Rotation3D(const ForeignVector& v1,; 144 const ForeignVector& v2,; 145 const ForeignVector& v3 ) { SetComponents(v1, v2, v3); }; 146 ; 147 // compiler generated destruuctor is ok; 148 ; 149 /**; 150 Raw constructor from nine Scalar components (without any checking); 151 */; 152 Rotation3D(Scalar xx, Scalar xy, Scalar xz,; 153 Scalar yx, Scalar yy, Scalar yz,; 154 Scalar zx, Scalar zy, Scalar zz); 155 {; 156 SetComponents (xx, xy, xz, yx, yy, yz, zx, zy, zz);; 157 }; 158 ; 159 // need to implement assignment operator to avoid using the templated one; 160 ; 161 /**; 162 Assignment operator; 163 */; 164 Rotation3D &; 165 operator=( Rotation3D const & rhs ) {; 166 SetComponents( rhs.fM[0], rhs.fM[1], rhs.fM[2],; 167 rhs.fM[3], rhs.fM[4], rhs.fM[5],; 168 rhs.fM[6], rhs.fM[7], rhs.fM[8] );; 169 return *this;; 170 }; 171 ; 172 /**; 173 Assign from an AxisAngle; 174 */; 175 Rotation3D &; 176 operator=( AxisAngle const & a ) { return operator=(Rotation3D(a)); }; 177 ; 178 /**; 179 Assign from EulerAngles; 180 */; 181 Rotation3D &; 182 operator=( EulerAngles const & e ) { return operator=(Rotation3D(e)); }; 183 ; 184 /**; 185 Assign from RotationZYX; 186 */; 187 Rotation3D &; 188 operator=( RotationZYX const & r ) { return operator=(Rotation3D(r)); }; 189 ; 190 /**; 191 Assign from a Quaternion; 192 */; 193 R",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:9914,Security,access,access,9914,"pecified by an iterator begin; 275 and another to the end of the desired data (9 past start).; 276 */; 277 template<class IT>; 278 void GetComponents(IT begin, IT end) const {; 279 for (int i = 0; i <9; ++i) {; 280 *begin = fM[i];; 281 ++begin;; 282 }; 283 (void)end;; 284 assert (end==begin);; 285 }; 286 ; 287 /**; 288 Get the 9 matrix components into data specified by an iterator begin; 289 */; 290 template<class IT>; 291 void GetComponents(IT begin) const {; 292 std::copy ( fM, fM+9, begin );; 293 }; 294 ; 295 /**; 296 Set components from a linear algebra matrix of size at least 3x3,; 297 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 298 Precondition: The matrix is assumed to be orthonormal. NO checking; 299 or re-adjusting is performed.; 300 */; 301 template<class ForeignMatrix>; 302 void; 303 SetRotationMatrix (const ForeignMatrix & m) {; 304 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2);; 305 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2);; 306 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2);; 307 }; 308 ; 309 /**; 310 Get components into a linear algebra matrix of size at least 3x3,; 311 which must support operator()(i,j) for write access to elements; 312 (0,0) thru (2,2).; 313 */; 314 template<class ForeignMatrix>; 315 void; 316 GetRotationMatrix (ForeignMatrix & m) const {; 317 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ];; 318 m(1,0)=fM[kYX]; m(1,1)=fM[kYY]; m(1,2)=fM[kYZ];; 319 m(2,0)=fM[kZX]; m(2,1)=fM[kZY]; m(2,2)=fM[kZZ];; 320 }; 321 ; 322 /**; 323 Set the components from nine scalars -- UNCHECKED for orthonormaility; 324 */; 325 void; 326 SetComponents (Scalar xx, Scalar xy, Scalar xz,; 327 Scalar yx, Scalar yy, Scalar yz,; 328 Scalar zx, Scalar zy, Scalar zz) {; 329 fM[kXX]=xx; fM[kXY]=xy; fM[kXZ]=xz;; 330 fM[kYX]=yx; fM[kYY]=yy; fM[kYZ]=yz;; 331 fM[kZX]=zx; fM[kZY]=zy; fM[kZZ]=zz;; 332 }; 333 ; 334 /**; 335 Get the nine components into nine scalars; 336 */; 337 void; 338 GetComponents (Scalar &xx, Scalar &xy, Scalar &xz,;",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:8644,Testability,assert,assert,8644,"]=v1.x(); fM[kXY]=v2.x(); fM[kXZ]=v3.x();; 239 fM[kYX]=v1.y(); fM[kYY]=v2.y(); fM[kYZ]=v3.y();; 240 fM[kZX]=v1.z(); fM[kZY]=v2.z(); fM[kZZ]=v3.z();; 241 Rectify();; 242 }; 243 ; 244 /**; 245 Get components into three vectors which will be the (orthonormal); 246 columns of the rotation matrix. (The vector class must have a; 247 constructor from 3 Scalars.); 248 */; 249 template<class ForeignVector>; 250 void; 251 GetComponents ( ForeignVector& v1,; 252 ForeignVector& v2,; 253 ForeignVector& v3 ) const {; 254 v1 = ForeignVector ( fM[kXX], fM[kYX], fM[kZX] );; 255 v2 = ForeignVector ( fM[kXY], fM[kYY], fM[kZY] );; 256 v3 = ForeignVector ( fM[kXZ], fM[kYZ], fM[kZZ] );; 257 }; 258 ; 259 /**; 260 Set the 9 matrix components given an iterator to the start of; 261 the desired data, and another to the end (9 past start).; 262 */; 263 template<class IT>; 264 void SetComponents(IT begin, IT end) {; 265 for (int i = 0; i <9; ++i) {; 266 fM[i] = *begin;; 267 ++begin;; 268 }; 269 (void)end;; 270 assert (end==begin);; 271 }; 272 ; 273 /**; 274 Get the 9 matrix components into data specified by an iterator begin; 275 and another to the end of the desired data (9 past start).; 276 */; 277 template<class IT>; 278 void GetComponents(IT begin, IT end) const {; 279 for (int i = 0; i <9; ++i) {; 280 *begin = fM[i];; 281 ++begin;; 282 }; 283 (void)end;; 284 assert (end==begin);; 285 }; 286 ; 287 /**; 288 Get the 9 matrix components into data specified by an iterator begin; 289 */; 290 template<class IT>; 291 void GetComponents(IT begin) const {; 292 std::copy ( fM, fM+9, begin );; 293 }; 294 ; 295 /**; 296 Set components from a linear algebra matrix of size at least 3x3,; 297 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 298 Precondition: The matrix is assumed to be orthonormal. NO checking; 299 or re-adjusting is performed.; 300 */; 301 template<class ForeignMatrix>; 302 void; 303 SetRotationMatrix (const ForeignMatrix & m) {; 304 fM[kXX]=m(0,0); fM[kXY]=m(0,1)",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html:9004,Testability,assert,assert,9004,"ctor& v2,; 253 ForeignVector& v3 ) const {; 254 v1 = ForeignVector ( fM[kXX], fM[kYX], fM[kZX] );; 255 v2 = ForeignVector ( fM[kXY], fM[kYY], fM[kZY] );; 256 v3 = ForeignVector ( fM[kXZ], fM[kYZ], fM[kZZ] );; 257 }; 258 ; 259 /**; 260 Set the 9 matrix components given an iterator to the start of; 261 the desired data, and another to the end (9 past start).; 262 */; 263 template<class IT>; 264 void SetComponents(IT begin, IT end) {; 265 for (int i = 0; i <9; ++i) {; 266 fM[i] = *begin;; 267 ++begin;; 268 }; 269 (void)end;; 270 assert (end==begin);; 271 }; 272 ; 273 /**; 274 Get the 9 matrix components into data specified by an iterator begin; 275 and another to the end of the desired data (9 past start).; 276 */; 277 template<class IT>; 278 void GetComponents(IT begin, IT end) const {; 279 for (int i = 0; i <9; ++i) {; 280 *begin = fM[i];; 281 ++begin;; 282 }; 283 (void)end;; 284 assert (end==begin);; 285 }; 286 ; 287 /**; 288 Get the 9 matrix components into data specified by an iterator begin; 289 */; 290 template<class IT>; 291 void GetComponents(IT begin) const {; 292 std::copy ( fM, fM+9, begin );; 293 }; 294 ; 295 /**; 296 Set components from a linear algebra matrix of size at least 3x3,; 297 which must support operator()(i,j) to obtain elements (0,0) thru (2,2).; 298 Precondition: The matrix is assumed to be orthonormal. NO checking; 299 or re-adjusting is performed.; 300 */; 301 template<class ForeignMatrix>; 302 void; 303 SetRotationMatrix (const ForeignMatrix & m) {; 304 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2);; 305 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2);; 306 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2);; 307 }; 308 ; 309 /**; 310 Get components into a linear algebra matrix of size at least 3x3,; 311 which must support operator()(i,j) for write access to elements; 312 (0,0) thru (2,2).; 313 */; 314 template<class ForeignMatrix>; 315 void; 316 GetRotationMatrix (ForeignMatrix & m) const {; 317 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ];",MatchSource.WIKI,doc/master/GenVector_2Rotation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Rotation3D_8h_source.html
https://root.cern/doc/master/GenVector_2RotationX_8h_source.html:664,Deployability,update,update,664,". ROOT: math/genvector/inc/Math/GenVector/RotationX.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RotationX.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class RotationZ representing a rotation about the Z axis; 12//; 13// Created by: Mark Fischler Mon July 18 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_RotationX; 18#define ROOT_Math_GenVector_RotationX 1; 19 ; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/PositionVector3D.h""; 24#include ""Math/GenVector/LorentzVector.h""; 25#include ""Math/GenVector/3DDistances.h""; 26 ; 27#include ""Math/GenVector/RotationXfwd.h""; 28 ; 29#include <cmath>; 30 ; 31namespace ROOT {; 32namespace Math {; 33 ; 34 ; 35//__________________________________________________________________________________________; 36 /**; 37 Rotation class representing a 3D rotation about the X axis by the angle of rotation.; 38 For efficiency reason, in addition to the angle, the sine and cosine of the angle are held; 39 ; 40 @ingroup GenVector; 41 ; 42 @sa Overview of the @ref GenVector ""physics vector library""; 43 */; 44 ; 45class RotationX {; 46 ; 47public:; 48 ; 49 typedef double Scalar;; 50 ; 51 ; 52 // ========== Constructors and Assignment =====================; 53 ; 54 /**; 55 Default constructor (identity rotation); 56 */; 57 RotationX() : fAngle(0), fSin(0), fCos(1) { }; 58 ; 59 /**; 60 Construct from an angle; 61 */; 62 explicit RotationX( Scalar angle ) : fAngle(angle),; 63 fSin(std::sin(angle)),; 64 fCos(std::cos(angle)); 65 {; 66 Rectify();; 67 }; 68 ; 69 // The compil",MatchSource.WIKI,doc/master/GenVector_2RotationX_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2RotationX_8h_source.html
https://root.cern/doc/master/GenVector_2RotationY_8h_source.html:664,Deployability,update,update,664,". ROOT: math/genvector/inc/Math/GenVector/RotationY.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RotationY.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class RotationY representing a rotation about the Y axis; 12//; 13// Created by: Mark Fischler Mon July 18 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_RotationY; 18#define ROOT_Math_GenVector_RotationY 1; 19 ; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/PositionVector3D.h""; 24#include ""Math/GenVector/LorentzVector.h""; 25#include ""Math/GenVector/3DDistances.h""; 26 ; 27#include ""Math/GenVector/RotationYfwd.h""; 28 ; 29#include <cmath>; 30 ; 31namespace ROOT {; 32namespace Math {; 33 ; 34 ; 35//__________________________________________________________________________________________; 36 /**; 37 Rotation class representing a 3D rotation about the Y axis by the angle of rotation.; 38 For efficiency reason, in addition to the angle, the sine and cosine of the angle are held; 39 ; 40 @ingroup GenVector; 41 ; 42 @sa Overview of the @ref GenVector ""physics vector library""; 43 */; 44 ; 45class RotationY {; 46 ; 47public:; 48 ; 49 typedef double Scalar;; 50 ; 51 ; 52 // ========== Constructors and Assignment =====================; 53 ; 54 /**; 55 Default constructor (identity rotation); 56 */; 57 RotationY() : fAngle(0), fSin(0), fCos(1) { }; 58 ; 59 /**; 60 Construct from an angle; 61 */; 62 explicit RotationY( Scalar angle ) : fAngle(angle),; 63 fSin(std::sin(angle)),; 64 fCos(std::cos(angle)); 65 {; 66 Rectify();; 67 }; 68 ; 69 // The compil",MatchSource.WIKI,doc/master/GenVector_2RotationY_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2RotationY_8h_source.html
https://root.cern/doc/master/GenVector_2RotationZYX_8h_source.html:712,Deployability,update,update,712,". ROOT: math/genvector/inc/Math/GenVector/RotationZYX.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RotationZYX.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: J. Palacios, L. Moneta 2007; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2007 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class Rotation in 3 dimensions, described by 3 Z-Y-X Euler angles; 12// representing a rotation along Z, Y and X; 13//; 14// Created by: Lorenzo Moneta, Wed. May 22, 2007; 15//; 16// Last update: $Id$; 17//; 18#ifndef ROOT_Math_GenVector_RotationZYX; 19#define ROOT_Math_GenVector_RotationZYX 1; 20 ; 21#include ""Math/Math.h""; 22 ; 23#include ""Math/GenVector/Rotation3D.h""; 24 ; 25 ; 26#include ""Math/GenVector/DisplacementVector3D.h""; 27 ; 28#include ""Math/GenVector/PositionVector3D.h""; 29 ; 30#include ""Math/GenVector/LorentzVector.h""; 31 ; 32#include ""Math/GenVector/3DConversions.h""; 33 ; 34 ; 35#include <algorithm>; 36#include <cassert>; 37#include <iostream>; 38 ; 39 ; 40namespace ROOT {; 41namespace Math {; 42 ; 43 ; 44//__________________________________________________________________________________________; 45 /**; 46 Rotation class with the (3D) rotation represented by; 47 angles describing first a rotation of; 48 an angle phi (yaw) about the Z axis,; 49 followed by a rotation of an angle theta (pitch) about the Y axis,; 50 followed by a third rotation of an angle psi (roll) about the X axis.; 51 Note that the rotations are extrinsic rotations happening around a fixed coordinate system. ; 52 This is different than the convention of the ROOT::Math::EulerAngles class, where the rotation are intrinsic. ; 53 Also it has not to be confused with the typical Goldstein definition of the Euler Angles; 54 (Z-X-Z or 313 sequence) which is used by the ROOT::M",MatchSource.WIKI,doc/master/GenVector_2RotationZYX_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2RotationZYX_8h_source.html
https://root.cern/doc/master/GenVector_2RotationZYX_8h_source.html:4196,Testability,assert,assert,4196,"6 */; 97 void Rectify();; 98 ; 99 ; 100 // ======== Construction and Assignment From other Rotation Forms ==================; 101 ; 102 /**; 103 Construct from another supported rotation type (see gv_detail::convert ); 104 */; 105 template <class OtherRotation>; 106 explicit constexpr RotationZYX(const OtherRotation & r) {gv_detail::convert(r,*this);}; 107 ; 108 ; 109 /**; 110 Assign from another supported rotation type (see gv_detail::convert ); 111 */; 112 template <class OtherRotation>; 113 RotationZYX & operator=( OtherRotation const & r ) {; 114 gv_detail::convert(r,*this);; 115 return *this;; 116 }; 117 ; 118 ; 119 // ======== Components ==============; 120 ; 121 /**; 122 Set the three Euler angles given a pair of pointers or iterators; 123 defining the beginning and end of an array of three Scalars.; 124 */; 125 template<class IT>; 126 void SetComponents(IT begin, IT end) {; 127 fPhi = *begin++;; 128 fTheta = *begin++;; 129 fPsi = *begin++;; 130 (void)end;; 131 assert(begin == end);; 132 Rectify();; 133 }; 134 ; 135 /**; 136 Get the axis and then the angle into data specified by an iterator begin; 137 and another to the end of the desired data (4 past start).; 138 */; 139 template<class IT>; 140 void GetComponents(IT begin, IT end) const {; 141 *begin++ = fPhi;; 142 *begin++ = fTheta;; 143 *begin++ = fPsi;; 144 (void)end;; 145 assert(begin == end);; 146 }; 147 ; 148 /**; 149 Get the axis and then the angle into data specified by an iterator begin; 150 */; 151 template<class IT>; 152 void GetComponents(IT begin) const {; 153 *begin++ = fPhi;; 154 *begin++ = fTheta;; 155 *begin = fPsi;; 156 }; 157 ; 158 /**; 159 Set the components phi, theta, psi based on three Scalars.; 160 */; 161 void SetComponents(Scalar phi, Scalar theta, Scalar psi) {; 162 fPhi=phi; fTheta=theta; fPsi=psi;; 163 Rectify();; 164 }; 165 ; 166 /**; 167 Get the components phi, theta, psi into three Scalars.; 168 */; 169 void GetComponents(Scalar & phi, Scalar & theta, Scalar & psi) const {; 170",MatchSource.WIKI,doc/master/GenVector_2RotationZYX_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2RotationZYX_8h_source.html
https://root.cern/doc/master/GenVector_2RotationZYX_8h_source.html:4569,Testability,assert,assert,4569,"vert ); 111 */; 112 template <class OtherRotation>; 113 RotationZYX & operator=( OtherRotation const & r ) {; 114 gv_detail::convert(r,*this);; 115 return *this;; 116 }; 117 ; 118 ; 119 // ======== Components ==============; 120 ; 121 /**; 122 Set the three Euler angles given a pair of pointers or iterators; 123 defining the beginning and end of an array of three Scalars.; 124 */; 125 template<class IT>; 126 void SetComponents(IT begin, IT end) {; 127 fPhi = *begin++;; 128 fTheta = *begin++;; 129 fPsi = *begin++;; 130 (void)end;; 131 assert(begin == end);; 132 Rectify();; 133 }; 134 ; 135 /**; 136 Get the axis and then the angle into data specified by an iterator begin; 137 and another to the end of the desired data (4 past start).; 138 */; 139 template<class IT>; 140 void GetComponents(IT begin, IT end) const {; 141 *begin++ = fPhi;; 142 *begin++ = fTheta;; 143 *begin++ = fPsi;; 144 (void)end;; 145 assert(begin == end);; 146 }; 147 ; 148 /**; 149 Get the axis and then the angle into data specified by an iterator begin; 150 */; 151 template<class IT>; 152 void GetComponents(IT begin) const {; 153 *begin++ = fPhi;; 154 *begin++ = fTheta;; 155 *begin = fPsi;; 156 }; 157 ; 158 /**; 159 Set the components phi, theta, psi based on three Scalars.; 160 */; 161 void SetComponents(Scalar phi, Scalar theta, Scalar psi) {; 162 fPhi=phi; fTheta=theta; fPsi=psi;; 163 Rectify();; 164 }; 165 ; 166 /**; 167 Get the components phi, theta, psi into three Scalars.; 168 */; 169 void GetComponents(Scalar & phi, Scalar & theta, Scalar & psi) const {; 170 phi=fPhi; theta=fTheta; psi=fPsi;; 171 }; 172 ; 173 /**; 174 Set Phi angle (Z rotation angle); 175 */; 176 void SetPhi(Scalar phi) { fPhi=phi; Rectify(); }; 177 ; 178 /**; 179 Return Phi angle (Z rotation angle); 180 */; 181 Scalar Phi() const { return fPhi; }; 182 ; 183 /**; 184 Set Theta angle (Y' rotation angle); 185 */; 186 void SetTheta(Scalar theta) { fTheta=theta; Rectify(); }; 187 ; 188 /**; 189 Return Theta angle (Y' rotation ang",MatchSource.WIKI,doc/master/GenVector_2RotationZYX_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2RotationZYX_8h_source.html
https://root.cern/doc/master/GenVector_2RotationZ_8h_source.html:664,Deployability,update,update,664,". ROOT: math/genvector/inc/Math/GenVector/RotationZ.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. RotationZ.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT FNAL MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class RotationZ representing a rotation about the Z axis; 12//; 13// Created by: Mark Fischler Mon July 18 2005; 14//; 15// Last update: $Id$; 16//; 17#ifndef ROOT_Math_GenVector_RotationZ; 18#define ROOT_Math_GenVector_RotationZ 1; 19 ; 20 ; 21#include ""Math/GenVector/Cartesian3D.h""; 22#include ""Math/GenVector/DisplacementVector3D.h""; 23#include ""Math/GenVector/PositionVector3D.h""; 24#include ""Math/GenVector/LorentzVector.h""; 25#include ""Math/GenVector/3DDistances.h""; 26 ; 27#include ""Math/GenVector/RotationZfwd.h""; 28 ; 29#include <cmath>; 30 ; 31namespace ROOT {; 32namespace Math {; 33 ; 34 ; 35//__________________________________________________________________________________________; 36 /**; 37 Rotation class representing a 3D rotation about the Z axis by the angle of rotation.; 38 For efficiency reason, in addition to the angle, the sine and cosine of the angle are held; 39 ; 40 @ingroup GenVector; 41 ; 42 @sa Overview of the @ref GenVector ""physics vector library""; 43 */; 44 ; 45class RotationZ {; 46 ; 47public:; 48 ; 49 typedef double Scalar;; 50 ; 51 ; 52 // ========== Constructors and Assignment =====================; 53 ; 54 /**; 55 Default constructor (identity rotation); 56 */; 57 RotationZ() : fAngle(0), fSin(0), fCos(1) { }; 58 ; 59 /**; 60 Construct from an angle; 61 */; 62 explicit RotationZ( Scalar angle ) : fAngle(angle),; 63 fSin(std::sin(angle)),; 64 fCos(std::cos(angle)); 65 {; 66 Rectify();; 67 }; 68 ; 69 // The compil",MatchSource.WIKI,doc/master/GenVector_2RotationZ_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2RotationZ_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:27950,Availability,error,error,27950,"scalar); 792 */; 793 template <typename SCALAR = T, typename std::enable_if<std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 794 void Invert(); 795 {; 796 //; 797 // Name: Transform3D::inverse Date: 24.09.96; 798 // Author: E.Chernyaev (IHEP/Protvino) Revised:; 799 //; 800 // Function: Find inverse affine transformation.; 801 ; 802 T detxx = fM[kYY] * fM[kZZ] - fM[kYZ] * fM[kZY];; 803 T detxy = fM[kYX] * fM[kZZ] - fM[kYZ] * fM[kZX];; 804 T detxz = fM[kYX] * fM[kZY] - fM[kYY] * fM[kZX];; 805 T det = fM[kXX] * detxx - fM[kXY] * detxy + fM[kXZ] * detxz;; 806 if (det == T(0)) {; 807 std::cerr << ""Transform3D::inverse error: zero determinant"" << std::endl;; 808 return;; 809 }; 810 det = T(1) / det;; 811 detxx *= det;; 812 detxy *= det;; 813 detxz *= det;; 814 T detyx = (fM[kXY] * fM[kZZ] - fM[kXZ] * fM[kZY]) * det;; 815 T detyy = (fM[kXX] * fM[kZZ] - fM[kXZ] * fM[kZX]) * det;; 816 T detyz = (fM[kXX] * fM[kZY] - fM[kXY] * fM[kZX]) * det;; 817 T detzx = (fM[kXY] * fM[kYZ] - fM[kXZ] * fM[kYY]) * det;; 818 T detzy = (fM[kXX] * fM[kYZ] - fM[kXZ] * fM[kYX]) * det;; 819 T detzz = (fM[kXX] * fM[kYY] - fM[kXY] * fM[kYX]) * det;; 820 SetComponents(detxx, -detyx, detzx, -detxx * fM[kDX] + detyx * fM[kDY] - detzx * fM[kDZ], -detxy, detyy, -detzy,; 821 detxy * fM[kDX] - detyy * fM[kDY] + detzy * fM[kDZ], detxz, -detyz, detzz,; 822 -detxz * fM[kDX] + detyz * fM[kDY] - detzz * fM[kDZ]);; 823 }; 824 ; 825 /**; 826 Invert the transformation in place (vectorised); 827 */; 828 template <typename SCALAR = T, typename std::enable_if<!std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 829 void Invert(); 830 {; 831 //; 832 // Name: Transform3D::inverse Date: 24.09.96; 833 // Author: E.Chernyaev (IHEP/Protvino) Revised:; 834 //; 835 // Function: Find inverse affine transformation.; 836 ; 837 T detxx = fM[kYY] * fM[kZZ] - fM[kYZ] * fM[kZY];; 838 T detxy = fM[kYX] * fM[kZZ] - fM[kYZ] * fM[kZX];; 839 T detxz = fM[kYX] * fM[kZY] - fM[kYY] * fM[kZX];; 840 T det = fM[kXX] * detxx - fM[kXY] ",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:29461,Availability,error,error,29461,"value>::type * = nullptr>; 829 void Invert(); 830 {; 831 //; 832 // Name: Transform3D::inverse Date: 24.09.96; 833 // Author: E.Chernyaev (IHEP/Protvino) Revised:; 834 //; 835 // Function: Find inverse affine transformation.; 836 ; 837 T detxx = fM[kYY] * fM[kZZ] - fM[kYZ] * fM[kZY];; 838 T detxy = fM[kYX] * fM[kZZ] - fM[kYZ] * fM[kZX];; 839 T detxz = fM[kYX] * fM[kZY] - fM[kYY] * fM[kZX];; 840 T det = fM[kXX] * detxx - fM[kXY] * detxy + fM[kXZ] * detxz;; 841 const auto detZmask = (det == T(0));; 842 if (any_of(detZmask)) {; 843 std::cerr << ""Transform3D::inverse error: zero determinant"" << std::endl;; 844 det(detZmask) = T(1);; 845 }; 846 det = T(1) / det;; 847 detxx *= det;; 848 detxy *= det;; 849 detxz *= det;; 850 T detyx = (fM[kXY] * fM[kZZ] - fM[kXZ] * fM[kZY]) * det;; 851 T detyy = (fM[kXX] * fM[kZZ] - fM[kXZ] * fM[kZX]) * det;; 852 T detyz = (fM[kXX] * fM[kZY] - fM[kXY] * fM[kZX]) * det;; 853 T detzx = (fM[kXY] * fM[kYZ] - fM[kXZ] * fM[kYY]) * det;; 854 T detzy = (fM[kXX] * fM[kYZ] - fM[kXZ] * fM[kYX]) * det;; 855 T detzz = (fM[kXX] * fM[kYY] - fM[kXY] * fM[kYX]) * det;; 856 // Set det=0 cases to 0; 857 if (any_of(detZmask)) {; 858 detxx(detZmask) = T(0);; 859 detxy(detZmask) = T(0);; 860 detxz(detZmask) = T(0);; 861 detyx(detZmask) = T(0);; 862 detyy(detZmask) = T(0);; 863 detyz(detZmask) = T(0);; 864 detzx(detZmask) = T(0);; 865 detzy(detZmask) = T(0);; 866 detzz(detZmask) = T(0);; 867 }; 868 // set final components; 869 SetComponents(detxx, -detyx, detzx, -detxx * fM[kDX] + detyx * fM[kDY] - detzx * fM[kDZ], -detxy, detyy, -detzy,; 870 detxy * fM[kDX] - detyy * fM[kDY] + detzy * fM[kDZ], detxz, -detyz, detzz,; 871 -detxz * fM[kDX] + detyz * fM[kDY] - detzz * fM[kDZ]);; 872 }; 873 ; 874 /**; 875 Return the inverse of the transformation.; 876 */; 877 Transform3D<T> Inverse() const; 878 {; 879 Transform3D<T> t(*this);; 880 t.Invert();; 881 return t;; 882 }; 883 ; 884 /**; 885 Equality operator. Check equality for each element; 886 To do: use T tolerance; 887",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:30877,Availability,toler,tolerance,30877,"] * fM[kYX]) * det;; 855 T detzz = (fM[kXX] * fM[kYY] - fM[kXY] * fM[kYX]) * det;; 856 // Set det=0 cases to 0; 857 if (any_of(detZmask)) {; 858 detxx(detZmask) = T(0);; 859 detxy(detZmask) = T(0);; 860 detxz(detZmask) = T(0);; 861 detyx(detZmask) = T(0);; 862 detyy(detZmask) = T(0);; 863 detyz(detZmask) = T(0);; 864 detzx(detZmask) = T(0);; 865 detzy(detZmask) = T(0);; 866 detzz(detZmask) = T(0);; 867 }; 868 // set final components; 869 SetComponents(detxx, -detyx, detzx, -detxx * fM[kDX] + detyx * fM[kDY] - detzx * fM[kDZ], -detxy, detyy, -detzy,; 870 detxy * fM[kDX] - detyy * fM[kDY] + detzy * fM[kDZ], detxz, -detyz, detzz,; 871 -detxz * fM[kDX] + detyz * fM[kDY] - detzz * fM[kDZ]);; 872 }; 873 ; 874 /**; 875 Return the inverse of the transformation.; 876 */; 877 Transform3D<T> Inverse() const; 878 {; 879 Transform3D<T> t(*this);; 880 t.Invert();; 881 return t;; 882 }; 883 ; 884 /**; 885 Equality operator. Check equality for each element; 886 To do: use T tolerance; 887 */; 888 bool operator==(const Transform3D<T> &rhs) const; 889 {; 890 return (fM[0] == rhs.fM[0] && fM[1] == rhs.fM[1] && fM[2] == rhs.fM[2] && fM[3] == rhs.fM[3] &&; 891 fM[4] == rhs.fM[4] && fM[5] == rhs.fM[5] && fM[6] == rhs.fM[6] && fM[7] == rhs.fM[7] &&; 892 fM[8] == rhs.fM[8] && fM[9] == rhs.fM[9] && fM[10] == rhs.fM[10] && fM[11] == rhs.fM[11]);; 893 }; 894 ; 895 /**; 896 Inequality operator. Check equality for each element; 897 To do: use T tolerance; 898 */; 899 bool operator!=(const Transform3D<T> &rhs) const { return !operator==(rhs); }; 900 ; 901protected:; 902 ; 903 /**; 904 make transformation from first a rotation then a translation; 905 */; 906 void AssignFrom(const Rotation3D &r, const Vector &v); 907 {; 908 // assignment from rotation + translation; 909 ; 910 T rotData[9];; 911 r.GetComponents(rotData, rotData + 9);; 912 // first raw; 913 for (int i = 0; i < 3; ++i) fM[i] = rotData[i];; 914 // second raw; 915 for (int i = 0; i < 3; ++i) fM[kYX + i] = rotData[3 + i];; 916 // third ",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:31344,Availability,toler,tolerance,31344,"] + detzy * fM[kDZ], detxz, -detyz, detzz,; 871 -detxz * fM[kDX] + detyz * fM[kDY] - detzz * fM[kDZ]);; 872 }; 873 ; 874 /**; 875 Return the inverse of the transformation.; 876 */; 877 Transform3D<T> Inverse() const; 878 {; 879 Transform3D<T> t(*this);; 880 t.Invert();; 881 return t;; 882 }; 883 ; 884 /**; 885 Equality operator. Check equality for each element; 886 To do: use T tolerance; 887 */; 888 bool operator==(const Transform3D<T> &rhs) const; 889 {; 890 return (fM[0] == rhs.fM[0] && fM[1] == rhs.fM[1] && fM[2] == rhs.fM[2] && fM[3] == rhs.fM[3] &&; 891 fM[4] == rhs.fM[4] && fM[5] == rhs.fM[5] && fM[6] == rhs.fM[6] && fM[7] == rhs.fM[7] &&; 892 fM[8] == rhs.fM[8] && fM[9] == rhs.fM[9] && fM[10] == rhs.fM[10] && fM[11] == rhs.fM[11]);; 893 }; 894 ; 895 /**; 896 Inequality operator. Check equality for each element; 897 To do: use T tolerance; 898 */; 899 bool operator!=(const Transform3D<T> &rhs) const { return !operator==(rhs); }; 900 ; 901protected:; 902 ; 903 /**; 904 make transformation from first a rotation then a translation; 905 */; 906 void AssignFrom(const Rotation3D &r, const Vector &v); 907 {; 908 // assignment from rotation + translation; 909 ; 910 T rotData[9];; 911 r.GetComponents(rotData, rotData + 9);; 912 // first raw; 913 for (int i = 0; i < 3; ++i) fM[i] = rotData[i];; 914 // second raw; 915 for (int i = 0; i < 3; ++i) fM[kYX + i] = rotData[3 + i];; 916 // third raw; 917 for (int i = 0; i < 3; ++i) fM[kZX + i] = rotData[6 + i];; 918 ; 919 // translation data; 920 T vecData[3];; 921 v.GetCoordinates(vecData, vecData + 3);; 922 fM[kDX] = vecData[0];; 923 fM[kDY] = vecData[1];; 924 fM[kDZ] = vecData[2];; 925 }; 926 ; 927 /**; 928 make transformation from only rotations (zero translation); 929 */; 930 void AssignFrom(const Rotation3D &r); 931 {; 932 // assign from only a rotation (null translation); 933 T rotData[9];; 934 r.GetComponents(rotData, rotData + 9);; 935 for (int i = 0; i < 3; ++i) {; 936 for (int j = 0; j < 3; ++j) fM[4 * i + j] = rotDa",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:33614,Availability,mask,mask,33614," fM[kXX] = T(1);; 949 fM[kXY] = T(0);; 950 fM[kXZ] = T(0);; 951 fM[kDX] = v.X();; 952 fM[kYX] = T(0);; 953 fM[kYY] = T(1);; 954 fM[kYZ] = T(0);; 955 fM[kDY] = v.Y();; 956 fM[kZX] = T(0);; 957 fM[kZY] = T(0);; 958 fM[kZZ] = T(1);; 959 fM[kDZ] = v.Z();; 960 }; 961 ; 962 /**; 963 Set identity transformation (identity rotation , zero translation); 964 */; 965 void SetIdentity(); 966 {; 967 // set identity ( identity rotation and zero translation); 968 fM[kXX] = T(1);; 969 fM[kXY] = T(0);; 970 fM[kXZ] = T(0);; 971 fM[kDX] = T(0);; 972 fM[kYX] = T(0);; 973 fM[kYY] = T(1);; 974 fM[kYZ] = T(0);; 975 fM[kDY] = T(0);; 976 fM[kZX] = T(0);; 977 fM[kZY] = T(0);; 978 fM[kZZ] = T(1);; 979 fM[kDZ] = T(0);; 980 }; 981 ; 982 /**; 983 Set identity transformation (identity rotation , zero translation); 984 vectorised version that sets using a mask; 985 */; 986 template <typename SCALAR = T, typename std::enable_if<!std::is_arithmetic<SCALAR>::value>::type * = nullptr>; 987 void SetIdentity(const typename SCALAR::mask_type m); 988 {; 989 // set identity ( identity rotation and zero translation); 990 fM[kXX](m) = T(1);; 991 fM[kXY](m) = T(0);; 992 fM[kXZ](m) = T(0);; 993 fM[kDX](m) = T(0);; 994 fM[kYX](m) = T(0);; 995 fM[kYY](m) = T(1);; 996 fM[kYZ](m) = T(0);; 997 fM[kDY](m) = T(0);; 998 fM[kZX](m) = T(0);; 999 fM[kZY](m) = T(0);; 1000 fM[kZZ](m) = T(1);; 1001 fM[kDZ](m) = T(0);; 1002 }; 1003 ; 1004private:; 1005 T fM[12]; // transformation elements (3x4 matrix); 1006};; 1007 ; 1008 ; 1009 ; 1010 ; 1011// inline functions (combination of transformations); 1012 ; 1013template <class T>; 1014inline Transform3D<T> &Transform3D<T>::operator*=(const Transform3D<T> &t); 1015{; 1016 // combination of transformations; 1017 ; 1018 SetComponents(fM[kXX]*t.fM[kXX]+fM[kXY]*t.fM[kYX]+fM[kXZ]*t.fM[kZX],; 1019 fM[kXX]*t.fM[kXY]+fM[kXY]*t.fM[kYY]+fM[kXZ]*t.fM[kZY],; 1020 fM[kXX]*t.fM[kXZ]+fM[kXY]*t.fM[kYZ]+fM[kXZ]*t.fM[kZZ],; 1021 fM[kXX]*t.fM[kDX]+fM[kXY]*t.fM[kDY]+fM[kXZ]*t.fM[kDZ]+fM[kDX],; 1022 ; 10",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:17977,Security,access,access,17977,"onents into data specified by an iterator begin; 484 and another to the end of the desired data (12 past start).; 485 */; 486 template<class IT>; 487 void GetComponents(IT begin, IT end) const {; 488 for (int i = 0; i <12; ++i) {; 489 *begin = fM[i];; 490 ++begin;; 491 }; 492 (void)end;; 493 assert (end==begin);; 494 }; 495 ; 496 /**; 497 Get the 12 matrix components into data specified by an iterator begin; 498 */; 499 template<class IT>; 500 void GetComponents(IT begin) const {; 501 std::copy(fM, fM + 12, begin);; 502 }; 503 ; 504 /**; 505 Set components from a linear algebra matrix of size at least 3x4,; 506 which must support operator()(i,j) to obtain elements (0,0) thru (2,3).; 507 The 3x3 sub-block is assumed to be the rotation part and the translations vector; 508 are described by the 4-th column; 509 */; 510 template<class ForeignMatrix>; 511 void; 512 SetTransformMatrix (const ForeignMatrix & m) {; 513 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2); fM[kDX]=m(0,3);; 514 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2); fM[kDY]=m(1,3);; 515 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2); fM[kDZ]=m(2,3);; 516 }; 517 ; 518 /**; 519 Get components into a linear algebra matrix of size at least 3x4,; 520 which must support operator()(i,j) for write access to elements; 521 (0,0) thru (2,3).; 522 */; 523 template<class ForeignMatrix>; 524 void; 525 GetTransformMatrix (ForeignMatrix & m) const {; 526 m(0,0)=fM[kXX]; m(0,1)=fM[kXY]; m(0,2)=fM[kXZ]; m(0,3)=fM[kDX];; 527 m(1,0)=fM[kYX]; m(1,1)=fM[kYY]; m(1,2)=fM[kYZ]; m(1,3)=fM[kDY];; 528 m(2,0)=fM[kZX]; m(2,1)=fM[kZY]; m(2,2)=fM[kZZ]; m(2,3)=fM[kDZ];; 529 }; 530 ; 531 ; 532 /**; 533 Set the components from 12 scalars; 534 */; 535 void SetComponents(T xx, T xy, T xz, T dx, T yx, T yy, T yz, T dy, T zx, T zy, T zz, T dz); 536 {; 537 fM[kXX]=xx; fM[kXY]=xy; fM[kXZ]=xz; fM[kDX]=dx;; 538 fM[kYX]=yx; fM[kYY]=yy; fM[kYZ]=yz; fM[kDY]=dy;; 539 fM[kZX]=zx; fM[kZY]=zy; fM[kZZ]=zz; fM[kDZ]=dz;; 540 }; 541 ; 542 /**; 543 Get the comp",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:16637,Testability,assert,assert,16637,"; 445 Transform3D(T xx, T xy, T xz, T dx, T yx, T yy, T yz, T dy, T zx, T zy, T zz, T dz); 446 {; 447 SetComponents (xx, xy, xz, dx, yx, yy, yz, dy, zx, zy, zz, dz);; 448 }; 449 ; 450 ; 451 /**; 452 Construct from a linear algebra matrix of size at least 3x4,; 453 which must support operator()(i,j) to obtain elements (0,0) thru (2,3).; 454 The 3x3 sub-block is assumed to be the rotation part and the translations vector; 455 are described by the 4-th column; 456 */; 457 template <class ForeignMatrix>; 458 Transform3D<T> &operator=(const ForeignMatrix &m); 459 {; 460 SetComponents(m);; 461 return *this;; 462 }; 463 ; 464 ; 465 // ======== Components ==============; 466 ; 467 ; 468 /**; 469 Set the 12 matrix components given an iterator to the start of; 470 the desired data, and another to the end (12 past start).; 471 */; 472 template<class IT>; 473 void SetComponents(IT begin, IT end) {; 474 for (int i = 0; i <12; ++i) {; 475 fM[i] = *begin;; 476 ++begin;; 477 }; 478 (void)end;; 479 assert (end==begin);; 480 }; 481 ; 482 /**; 483 Get the 12 matrix components into data specified by an iterator begin; 484 and another to the end of the desired data (12 past start).; 485 */; 486 template<class IT>; 487 void GetComponents(IT begin, IT end) const {; 488 for (int i = 0; i <12; ++i) {; 489 *begin = fM[i];; 490 ++begin;; 491 }; 492 (void)end;; 493 assert (end==begin);; 494 }; 495 ; 496 /**; 497 Get the 12 matrix components into data specified by an iterator begin; 498 */; 499 template<class IT>; 500 void GetComponents(IT begin) const {; 501 std::copy(fM, fM + 12, begin);; 502 }; 503 ; 504 /**; 505 Set components from a linear algebra matrix of size at least 3x4,; 506 which must support operator()(i,j) to obtain elements (0,0) thru (2,3).; 507 The 3x3 sub-block is assumed to be the rotation part and the translations vector; 508 are described by the 4-th column; 509 */; 510 template<class ForeignMatrix>; 511 void; 512 SetTransformMatrix (const ForeignMatrix & m) {; 513 fM[kXX]=m",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:17000,Testability,assert,assert,17000,"; 457 template <class ForeignMatrix>; 458 Transform3D<T> &operator=(const ForeignMatrix &m); 459 {; 460 SetComponents(m);; 461 return *this;; 462 }; 463 ; 464 ; 465 // ======== Components ==============; 466 ; 467 ; 468 /**; 469 Set the 12 matrix components given an iterator to the start of; 470 the desired data, and another to the end (12 past start).; 471 */; 472 template<class IT>; 473 void SetComponents(IT begin, IT end) {; 474 for (int i = 0; i <12; ++i) {; 475 fM[i] = *begin;; 476 ++begin;; 477 }; 478 (void)end;; 479 assert (end==begin);; 480 }; 481 ; 482 /**; 483 Get the 12 matrix components into data specified by an iterator begin; 484 and another to the end of the desired data (12 past start).; 485 */; 486 template<class IT>; 487 void GetComponents(IT begin, IT end) const {; 488 for (int i = 0; i <12; ++i) {; 489 *begin = fM[i];; 490 ++begin;; 491 }; 492 (void)end;; 493 assert (end==begin);; 494 }; 495 ; 496 /**; 497 Get the 12 matrix components into data specified by an iterator begin; 498 */; 499 template<class IT>; 500 void GetComponents(IT begin) const {; 501 std::copy(fM, fM + 12, begin);; 502 }; 503 ; 504 /**; 505 Set components from a linear algebra matrix of size at least 3x4,; 506 which must support operator()(i,j) to obtain elements (0,0) thru (2,3).; 507 The 3x3 sub-block is assumed to be the rotation part and the translations vector; 508 are described by the 4-th column; 509 */; 510 template<class ForeignMatrix>; 511 void; 512 SetTransformMatrix (const ForeignMatrix & m) {; 513 fM[kXX]=m(0,0); fM[kXY]=m(0,1); fM[kXZ]=m(0,2); fM[kDX]=m(0,3);; 514 fM[kYX]=m(1,0); fM[kYY]=m(1,1); fM[kYZ]=m(1,2); fM[kDY]=m(1,3);; 515 fM[kZX]=m(2,0); fM[kZY]=m(2,1); fM[kZZ]=m(2,2); fM[kDZ]=m(2,3);; 516 }; 517 ; 518 /**; 519 Get components into a linear algebra matrix of size at least 3x4,; 520 which must support operator()(i,j) for write access to elements; 521 (0,0) thru (2,3).; 522 */; 523 template<class ForeignMatrix>; 524 void; 525 GetTransformMatrix (ForeignMatr",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:1797,Usability,simpl,simple,1797," ; 23#include ""Math/GenVector/PositionVector3D.h""; 24 ; 25#include ""Math/GenVector/Rotation3D.h""; 26 ; 27#include ""Math/GenVector/Translation3D.h""; 28 ; 29 ; 30#include ""Math/GenVector/AxisAnglefwd.h""; 31#include ""Math/GenVector/EulerAnglesfwd.h""; 32#include ""Math/GenVector/Quaternionfwd.h""; 33#include ""Math/GenVector/RotationZYXfwd.h""; 34#include ""Math/GenVector/RotationXfwd.h""; 35#include ""Math/GenVector/RotationYfwd.h""; 36#include ""Math/GenVector/RotationZfwd.h""; 37 ; 38#include <iostream>; 39#include <type_traits>; 40#include <cmath>; 41 ; 42//#include ""Math/Vector3Dfwd.h""; 43 ; 44 ; 45 ; 46namespace ROOT {; 47 ; 48namespace Math {; 49 ; 50namespace Impl {; 51 ; 52//_________________________________________________________________________________________; 53/**; 54 Basic 3D Transformation class describing a rotation and then a translation; 55 The internal data are a 3D rotation data (represented as a 3x3 matrix) and a 3D vector data.; 56 They are represented and held in this class like a 3x4 matrix (a simple array of 12 numbers).; 57 ; 58 The class can be constructed from any 3D rotation object; 59 (ROOT::Math::Rotation3D, ROOT::Math::AxisAngle, ROOT::Math::Quaternion, etc...) and/or; 60 a 3D Vector (ROOT::Math::DislacementVector3D or via ROOT::Math::Translation ) representing a Translation.; 61 The Transformation is defined by applying first the rotation and then the translation.; 62 A transformation defined by applying first a translation and then a rotation is equivalent to the; 63 transformation obtained applying first the rotation and then a translation equivalent to the rotated vector.; 64 The operator * can be used to obtain directly such transformations, in addition to combine various; 65 transformations.; 66 Keep in mind that the operator * (like in the case of rotations ) is not commutative.; 67 The operator * is used (in addition to operator() ) to apply a transformations on the vector; 68 (DisplacementVector3D and LorentzVector classes) and point (Po",MatchSource.WIKI,doc/master/GenVector_2Transform3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html
https://root.cern/doc/master/GenVector_2Translation3D_8h_source.html:1533,Performance,perform,performs,1533,"**********************/; 10 ; 11// Header file for class Translation3D; 12//; 13// Created by: Lorenzo Moneta October 21 2005; 14//; 15//; 16#ifndef ROOT_Math_GenVector_Translation3D; 17#define ROOT_Math_GenVector_Translation3D 1; 18 ; 19 ; 20#include ""Math/GenVector/DisplacementVector3D.h""; 21 ; 22#include ""Math/GenVector/Plane3D.h""; 23 ; 24#include ""Math/GenVector/PositionVector3Dfwd.h""; 25 ; 26#include ""Math/GenVector/LorentzVectorfwd.h""; 27 ; 28#include <iostream>; 29#include <type_traits>; 30 ; 31namespace ROOT {; 32 ; 33namespace Math {; 34 ; 35namespace Impl {; 36 ; 37//____________________________________________________________________________________________________; 38/**; 39 Class describing a 3 dimensional translation. It can be combined (using the operator *); 40 with the ROOT::Math::Rotation3D classes and ROOT::Math::Transform3D to obtained combined; 41 transformations and to operate on points and vectors.; 42 Note that a the translation applied to a Vector object (DisplacementVector3D and LorentzVector classes); 43 performs a noop, i.e. it returns the same vector. A translation can be applied only to the Point objects; 44 (PositionVector3D classes).; 45 ; 46 @ingroup GenVector; 47 ; 48 @sa Overview of the @ref GenVector ""physics vector library""; 49 ; 50*/; 51 ; 52template <typename T = double>; 53class Translation3D {; 54 ; 55public:; 56 typedef T Scalar;; 57 ; 58 typedef DisplacementVector3D<Cartesian3D<T>, DefaultCoordinateSystemTag> Vector;; 59 ; 60 /**; 61 Default constructor ( zero translation ); 62 */; 63 Translation3D() {}; 64 ; 65 /**; 66 Construct given a pair of pointers or iterators defining the; 67 beginning and end of an array of 3 Scalars representing the z,y,z of the translation vector; 68 */; 69 template<class IT>; 70 Translation3D(IT begin, IT end); 71 {; 72 fVect.SetCoordinates(begin,end);; 73 }; 74 ; 75 /**; 76 Construct from x,y,z values representing the translation; 77 */; 78 Translation3D(T dx, T dy, T dz) : fVect(Vector(dx, dy,",MatchSource.WIKI,doc/master/GenVector_2Translation3D_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GenVector_2Translation3D_8h_source.html
https://root.cern/doc/master/geodemo_8C.html:6362,Deployability,toggle,toggle,6362,"dObject(""geom_help"");; if (c) {; c->Clear();; c->Update();; c->cd();; } else {; c = new TCanvas(""geom_help"",""Help to run demos"",200,10,700,600);; }; ; TPaveText *welcome = new TPaveText(.1,.8,.9,.97);; welcome->AddText(""Welcome to the new geometry package"");; welcome->SetTextFont(32);; welcome->SetTextColor(4);; welcome->SetFillColor(24);; welcome->Draw();; ; TPaveText *hdemo = new TPaveText(.05,.05,.95,.7);; hdemo->SetTextAlign(12);; hdemo->SetTextFont(52);; hdemo->AddText(""- Demo for building TGeo basic shapes and simple geometry. Shape parameters are"");; hdemo->AddText("" displayed in the right pad"");; hdemo->AddText(""- Click left mouse button to execute one demo"");; hdemo->AddText(""- While pointing the mouse to the pad containing the geometry, do:"");; hdemo->AddText(""- .... click-and-move to rotate"");; hdemo->AddText(""- .... press j/k to zoom/unzoom"");; hdemo->AddText(""- .... press l/h/u/i to move the view center around"");; hdemo->AddText(""- Click Ray-trace ON/OFF to toggle ray-tracing"");; hdemo->AddText(""- Use <View with x3d> from the <View> menu to get an x3d view"");; hdemo->AddText(""- .... same methods to rotate/zoom/move the view"");; hdemo->AddText(""- Execute box(1,8) to divide a box in 8 equal slices along X"");; hdemo->AddText(""- Most shapes can be divided on X,Y,Z,Rxy or Phi :"");; hdemo->AddText(""- .... root[0] <shape>(IAXIS, NDIV, START, STEP);"");; hdemo->AddText("" .... IAXIS = 1,2,3 meaning (X,Y,Z) or (Rxy, Phi, Z)"");; hdemo->AddText("" .... NDIV = number of slices"");; hdemo->AddText("" .... START = start slicing position"");; hdemo->AddText("" .... STEP = division step"");; hdemo->AddText(""- Click Comments ON/OFF to toggle comments"");; hdemo->AddText(""- Click Ideal/Align geometry to see how alignment works"");; hdemo->AddText("" "");; hdemo->SetAllWith(""...."",""color"",2);; hdemo->SetAllWith(""...."",""font"",72);; hdemo->SetAllWith(""...."",""size"",0.03);; ; hdemo->Draw();; ; c->Update();; }; ; //__________________________________________________________________________",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:7028,Deployability,toggle,toggle,7028,"AddText(""- While pointing the mouse to the pad containing the geometry, do:"");; hdemo->AddText(""- .... click-and-move to rotate"");; hdemo->AddText(""- .... press j/k to zoom/unzoom"");; hdemo->AddText(""- .... press l/h/u/i to move the view center around"");; hdemo->AddText(""- Click Ray-trace ON/OFF to toggle ray-tracing"");; hdemo->AddText(""- Use <View with x3d> from the <View> menu to get an x3d view"");; hdemo->AddText(""- .... same methods to rotate/zoom/move the view"");; hdemo->AddText(""- Execute box(1,8) to divide a box in 8 equal slices along X"");; hdemo->AddText(""- Most shapes can be divided on X,Y,Z,Rxy or Phi :"");; hdemo->AddText(""- .... root[0] <shape>(IAXIS, NDIV, START, STEP);"");; hdemo->AddText("" .... IAXIS = 1,2,3 meaning (X,Y,Z) or (Rxy, Phi, Z)"");; hdemo->AddText("" .... NDIV = number of slices"");; hdemo->AddText("" .... START = start slicing position"");; hdemo->AddText("" .... STEP = division step"");; hdemo->AddText(""- Click Comments ON/OFF to toggle comments"");; hdemo->AddText(""- Click Ideal/Align geometry to see how alignment works"");; hdemo->AddText("" "");; hdemo->SetAllWith(""...."",""color"",2);; hdemo->SetAllWith(""...."",""font"",72);; hdemo->SetAllWith(""...."",""size"",0.03);; ; hdemo->Draw();; ; c->Update();; }; ; //______________________________________________________________________________; void autorotate(); {; grotate = !grotate;; if (!grotate) {; gROOT->SetInterrupt(kTRUE);; return;; }; if (!gPad) return;; TView *view = gPad->GetView();; if (!view) return;; if (!gGeoManager) return;; TVirtualGeoPainter *painter = gGeoManager->GetGeomPainter();; if (!painter) return;; Double_t longit = view->GetLongitude();; // Double_t lat = view->GetLatitude();; // Double_t psi = view->GetPsi();; Double_t dphi = 1.;; Int_t irep;; TProcessEventTimer *timer = new TProcessEventTimer(5);; gROOT->SetInterrupt(kFALSE);; while (grotate) {; if (timer->ProcessEvents()) break;; if (gROOT->IsInterrupted()) break;; longit += dphi;; if (longit>360) longit -= 360.;; if (!gPad) {; grot",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:30679,Integrability,rout,rout,30679,"gGeoManager->MakeHype(""HYPE"",med,10, 45 ,20,45,40);; TGeoHype *hype = (TGeoHype*)vol->GetShape();; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol,1);; gGeoManager->CloseGeometry();; gGeoManager->SetNsegments(80);; ; top->Draw();; ; MakePicture();; if (!comments) return;; c->cd(2);; TPaveText *pt = new TPaveText(0.01,0.01,0.99,0.99);; pt->SetLineColor(1);; TText *text = pt->AddText(""TGeoHype - Hyperboloid class"");; text->SetTextColor(2);; AddMemberInfo(pt, ""fRmin"", hype->GetRmin(), ""minimum inner radius"");; AddMemberInfo(pt, ""fStIn"", hype->GetStIn(), ""inner surface stereo angle [deg]"");; AddMemberInfo(pt, ""fRmax"", hype->GetRmax(), ""minimum outer radius"");; AddMemberInfo(pt, ""fStOut"",hype->GetStOut(),""outer surface stereo angle [deg]"");; AddMemberInfo(pt, ""fDz"", hype->GetDz(), ""half-length on Z axis"");; pt->AddText(""----- A hyperboloid is described by the equation:"");; pt->AddText(""----- r^2 - (tan(stereo)*z)^2 = rmin^2; where: r = x*x + y*y"");; pt->AddText(""----- Create with: TGeoHype *hype = new TGeoHype(rin, stin, rout, stout, dz);"");; pt->AddText(""----- rin < rout; rout > 0"");; pt->AddText(""----- rin = 0; stin > 0 => inner surface conical"");; pt->AddText(""----- stin/stout = 0 => corresponding surface cylindrical"");; AddExecInfo(pt, ""hype"");; pt->Draw();; c->cd(1);; }; ; //______________________________________________________________________________; void pcon(Int_t iaxis=0, Int_t ndiv=8, Double_t start=0, Double_t step=0); {; auto c = create_canvas(""A polycone"");; ; if (gGeoManager) delete gGeoManager;; new TGeoManager(""pcon"", ""poza10"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);; gGeoManager->SetTopVolume(top);; TGeoVolume *vol = gGeoManager->MakePcon(""PCON"",med, -30.0,300,4);; TGeoPcon *pcon = (TGeoPcon*)(vol->GetShape());; pcon->DefineSection(0,0,15,20);; pcon->DefineSection(1,20,15,20);; pcon->DefineSectio",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:30726,Integrability,rout,rout,30726,"gGeoManager->MakeHype(""HYPE"",med,10, 45 ,20,45,40);; TGeoHype *hype = (TGeoHype*)vol->GetShape();; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol,1);; gGeoManager->CloseGeometry();; gGeoManager->SetNsegments(80);; ; top->Draw();; ; MakePicture();; if (!comments) return;; c->cd(2);; TPaveText *pt = new TPaveText(0.01,0.01,0.99,0.99);; pt->SetLineColor(1);; TText *text = pt->AddText(""TGeoHype - Hyperboloid class"");; text->SetTextColor(2);; AddMemberInfo(pt, ""fRmin"", hype->GetRmin(), ""minimum inner radius"");; AddMemberInfo(pt, ""fStIn"", hype->GetStIn(), ""inner surface stereo angle [deg]"");; AddMemberInfo(pt, ""fRmax"", hype->GetRmax(), ""minimum outer radius"");; AddMemberInfo(pt, ""fStOut"",hype->GetStOut(),""outer surface stereo angle [deg]"");; AddMemberInfo(pt, ""fDz"", hype->GetDz(), ""half-length on Z axis"");; pt->AddText(""----- A hyperboloid is described by the equation:"");; pt->AddText(""----- r^2 - (tan(stereo)*z)^2 = rmin^2; where: r = x*x + y*y"");; pt->AddText(""----- Create with: TGeoHype *hype = new TGeoHype(rin, stin, rout, stout, dz);"");; pt->AddText(""----- rin < rout; rout > 0"");; pt->AddText(""----- rin = 0; stin > 0 => inner surface conical"");; pt->AddText(""----- stin/stout = 0 => corresponding surface cylindrical"");; AddExecInfo(pt, ""hype"");; pt->Draw();; c->cd(1);; }; ; //______________________________________________________________________________; void pcon(Int_t iaxis=0, Int_t ndiv=8, Double_t start=0, Double_t step=0); {; auto c = create_canvas(""A polycone"");; ; if (gGeoManager) delete gGeoManager;; new TGeoManager(""pcon"", ""poza10"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);; gGeoManager->SetTopVolume(top);; TGeoVolume *vol = gGeoManager->MakePcon(""PCON"",med, -30.0,300,4);; TGeoPcon *pcon = (TGeoPcon*)(vol->GetShape());; pcon->DefineSection(0,0,15,20);; pcon->DefineSection(1,20,15,20);; pcon->DefineSectio",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:30732,Integrability,rout,rout,30732,"gGeoManager->MakeHype(""HYPE"",med,10, 45 ,20,45,40);; TGeoHype *hype = (TGeoHype*)vol->GetShape();; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol,1);; gGeoManager->CloseGeometry();; gGeoManager->SetNsegments(80);; ; top->Draw();; ; MakePicture();; if (!comments) return;; c->cd(2);; TPaveText *pt = new TPaveText(0.01,0.01,0.99,0.99);; pt->SetLineColor(1);; TText *text = pt->AddText(""TGeoHype - Hyperboloid class"");; text->SetTextColor(2);; AddMemberInfo(pt, ""fRmin"", hype->GetRmin(), ""minimum inner radius"");; AddMemberInfo(pt, ""fStIn"", hype->GetStIn(), ""inner surface stereo angle [deg]"");; AddMemberInfo(pt, ""fRmax"", hype->GetRmax(), ""minimum outer radius"");; AddMemberInfo(pt, ""fStOut"",hype->GetStOut(),""outer surface stereo angle [deg]"");; AddMemberInfo(pt, ""fDz"", hype->GetDz(), ""half-length on Z axis"");; pt->AddText(""----- A hyperboloid is described by the equation:"");; pt->AddText(""----- r^2 - (tan(stereo)*z)^2 = rmin^2; where: r = x*x + y*y"");; pt->AddText(""----- Create with: TGeoHype *hype = new TGeoHype(rin, stin, rout, stout, dz);"");; pt->AddText(""----- rin < rout; rout > 0"");; pt->AddText(""----- rin = 0; stin > 0 => inner surface conical"");; pt->AddText(""----- stin/stout = 0 => corresponding surface cylindrical"");; AddExecInfo(pt, ""hype"");; pt->Draw();; c->cd(1);; }; ; //______________________________________________________________________________; void pcon(Int_t iaxis=0, Int_t ndiv=8, Double_t start=0, Double_t step=0); {; auto c = create_canvas(""A polycone"");; ; if (gGeoManager) delete gGeoManager;; new TGeoManager(""pcon"", ""poza10"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);; gGeoManager->SetTopVolume(top);; TGeoVolume *vol = gGeoManager->MakePcon(""PCON"",med, -30.0,300,4);; TGeoPcon *pcon = (TGeoPcon*)(vol->GetShape());; pcon->DefineSection(0,0,15,20);; pcon->DefineSection(1,20,15,20);; pcon->DefineSectio",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:61257,Integrability,depend,depending,61257,") {; for (Int_t j=1; j<=10; j++) {; TGeoPhysicalNode *node = nullptr;; auto name = TString::Format(""TOP_1/SX_%d/SY_%d/CELL_1"",i,j);; if (list) node = (TGeoPhysicalNode*)list->At(10*(i-1)+j-1);; if (!node) node = gGeoManager->MakePhysicalNode(name.Data());; TGeoTranslation *tr;; if (node->IsAligned()) {; tr = (TGeoTranslation*)node->GetNode()->GetMatrix();; tr->SetTranslation(2.*gRandom->Rndm(), 2.*gRandom->Rndm(),0.);; } else {; tr = new TGeoTranslation(2.*gRandom->Rndm(), 2.*gRandom->Rndm(),0.);; }; node->Align(tr);; }; }; if (gPad) {; gPad->Modified();; gPad->Update();; }; }; ; //______________________________________________________________________________; void geodemo (); {; // root[0] .x geodemo.C; // root[1] box(); //draw a TGeoBBox with description; //; // The box can be divided on one axis.; //; // root[2] box(iaxis, ndiv, start, step);; //; // where: iaxis = 1,2 or 3, meaning (X,Y,Z) or (Rxy, phi, Z) depending on shape type; // ndiv = number of slices; // start = starting position (must be in shape range); // step = division step; // If step=0, all range of a given axis will be divided; //; // The same can procedure can be performed for visualizing other shapes.; // When drawing one shape after another, the old geometry/canvas will be deleted.; TControlBar *bar = new TControlBar(""vertical"", ""TGeo shapes"",10,10);; bar->AddButton(""How to run "",""help()"",""Instructions for running this macro"");; bar->AddButton(""Arb8 "",""arb8()"",""An arbitrary polyhedron defined by vertices (max 8) sitting on 2 parallel planes"");; bar->AddButton(""Box "",""box()"",""A box shape."");; bar->AddButton(""Composite "",""composite()"",""A composite shape"");; bar->AddButton(""Cone "",""cone()"",""A conical tube"");; bar->AddButton(""Cone segment"",""coneseg()"",""A conical segment"");; bar->AddButton(""Cut tube "",""ctub()"",""A cut tube segment"");; bar->AddButton(""Elliptical tube"",""eltu()"",""An elliptical tube"");; bar->AddButton(""Extruded poly"",""xtru()"",""A general polygone extrusion"");; bar->AddButton(""Hyperboloid ",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:72822,Integrability,rout,rout,72822,"ume * MakePgon(const char *name, TGeoMedium *medium, Double_t phi, Double_t dphi, Int_t nedges, Int_t nz)Make in one step a volume pointing to a polygone shape with given medium.Definition TGeoManager.cxx:3284; TGeoManager::MakeTrapTGeoVolume * MakeTrap(const char *name, TGeoMedium *medium, Double_t dz, Double_t theta, Double_t phi, Double_t h1, Double_t bl1, Double_t tl1, Double_t alpha1, Double_t h2, Double_t bl2, Double_t tl2, Double_t alpha2)Make in one step a volume pointing to a trapezoid shape with given medium.Definition TGeoManager.cxx:3310; TGeoManager::SetNsegmentsvoid SetNsegments(Int_t nseg)Set number of segments for approximating circles in drawing.Definition TGeoManager.cxx:3594; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoManager::GetListOfPhysicalNodesTObjArray * GetListOfPhysicalNodes()Definition TGeoManager.h:468; TGeoManager::MakeHypeTGeoVolume * MakeHype(const char *name, TGeoMedium *medium, Double_t rin, Double_t stin, Double_t rout, Double_t stout, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3230; TGeoManager::MakeParaboloidTGeoVolume * MakeParaboloid(const char *name, TGeoMedium *medium, Double_t rlo, Double_t rhi, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3239; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; TGeoManager::MakeEltuTGeoVolume * MakeEltu(const char *name, TGeoMedium *medium, Double_t a, Double_t b, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3222; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMatrix::RegisterYourselfvirtual void RegisterYourself()Reg",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:65737,Modifiability,config,configurable,65737,"h; TPaveText.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom3.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TView.h; TVirtualGeoPainter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::GetDzDouble_t GetDz() constDefinition TGeoArb8.h:66; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoAtt::SetVisRaytracevoid SetVisRaytrace(Bool_t flag=kTRUE)Definition TGeoAtt.h:66; TGeoBBoxDefinition TGeoBBox.h:17; TGeoBBox::GetDZvirtual Double_t GetDZ() constDefinition TGeoBBox.h:81; TGeoCompositeShapeComposite shapes are Boolean combinations of two or more shape components.Definition TGeoCompositeShape.h:27; TGeoConeSegDefinition TGeoCone.h:99; TGeoConeSeg::GetPhi1Double_t GetPhi1() constDefinition TGeoCone.h:166; TGeoConeSeg::GetPhi2Double_t GetPhi2() constDefinitio",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:61484,Performance,perform,performed,61484,") {; for (Int_t j=1; j<=10; j++) {; TGeoPhysicalNode *node = nullptr;; auto name = TString::Format(""TOP_1/SX_%d/SY_%d/CELL_1"",i,j);; if (list) node = (TGeoPhysicalNode*)list->At(10*(i-1)+j-1);; if (!node) node = gGeoManager->MakePhysicalNode(name.Data());; TGeoTranslation *tr;; if (node->IsAligned()) {; tr = (TGeoTranslation*)node->GetNode()->GetMatrix();; tr->SetTranslation(2.*gRandom->Rndm(), 2.*gRandom->Rndm(),0.);; } else {; tr = new TGeoTranslation(2.*gRandom->Rndm(), 2.*gRandom->Rndm(),0.);; }; node->Align(tr);; }; }; if (gPad) {; gPad->Modified();; gPad->Update();; }; }; ; //______________________________________________________________________________; void geodemo (); {; // root[0] .x geodemo.C; // root[1] box(); //draw a TGeoBBox with description; //; // The box can be divided on one axis.; //; // root[2] box(iaxis, ndiv, start, step);; //; // where: iaxis = 1,2 or 3, meaning (X,Y,Z) or (Rxy, phi, Z) depending on shape type; // ndiv = number of slices; // start = starting position (must be in shape range); // step = division step; // If step=0, all range of a given axis will be divided; //; // The same can procedure can be performed for visualizing other shapes.; // When drawing one shape after another, the old geometry/canvas will be deleted.; TControlBar *bar = new TControlBar(""vertical"", ""TGeo shapes"",10,10);; bar->AddButton(""How to run "",""help()"",""Instructions for running this macro"");; bar->AddButton(""Arb8 "",""arb8()"",""An arbitrary polyhedron defined by vertices (max 8) sitting on 2 parallel planes"");; bar->AddButton(""Box "",""box()"",""A box shape."");; bar->AddButton(""Composite "",""composite()"",""A composite shape"");; bar->AddButton(""Cone "",""cone()"",""A conical tube"");; bar->AddButton(""Cone segment"",""coneseg()"",""A conical segment"");; bar->AddButton(""Cut tube "",""ctub()"",""A cut tube segment"");; bar->AddButton(""Elliptical tube"",""eltu()"",""An elliptical tube"");; bar->AddButton(""Extruded poly"",""xtru()"",""A general polygone extrusion"");; bar->AddButton(""Hyperboloid ",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:65775,Security,access,access,65775,"h; TPaveText.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom3.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TSystem.h; TView.h; TVirtualGeoPainter.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TGeoArb8Definition TGeoArb8.h:17; TGeoArb8::GetDzDouble_t GetDz() constDefinition TGeoArb8.h:66; TGeoArb8::SetVertexvirtual void SetVertex(Int_t vnum, Double_t x, Double_t y); TGeoArb8::GetVerticesDouble_t * GetVertices()Definition TGeoArb8.h:71; TGeoAtt::SetVisRaytracevoid SetVisRaytrace(Bool_t flag=kTRUE)Definition TGeoAtt.h:66; TGeoBBoxDefinition TGeoBBox.h:17; TGeoBBox::GetDZvirtual Double_t GetDZ() constDefinition TGeoBBox.h:81; TGeoCompositeShapeComposite shapes are Boolean combinations of two or more shape components.Definition TGeoCompositeShape.h:27; TGeoConeSegDefinition TGeoCone.h:99; TGeoConeSeg::GetPhi1Double_t GetPhi1() constDefinition TGeoCone.h:166; TGeoConeSeg::GetPhi2Double_t GetPhi2() constDefinitio",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:56923,Testability,log,logical,56923,"hapeName:transfName> components related by Boolean operators"");; pt->AddText(""----- Boolean operators can be: (+) union, (-) subtraction and (*) intersection"");; pt->AddText(""----- Use parenthesis in the expression to force precedence"");; AddExecInfo(pt, ""composite"");; pt->Draw();; c->cd(1);; }; ; //______________________________________________________________________________; void ideal(); {; // This is an ideal geometry. In real life, some geometry pieces are moved/rotated; // with respect to their ideal positions. This is called alignment. Alignment; // operations can be handled by TGeo starting from a CLOSED geometry (applied a posteriori); // Alignment is handled by PHYSICAL NODES, representing an unique object in geometry.; //; // Creating physical nodes:; // 1. TGeoPhysicalNode *node = gGeoManager->MakePhysicalNode(const char *path); // - creates a physical node represented by path; // - path can be : TOP_1/A_2/B_3; // - B_3 is the 'final node' e.g. the logical node represented by this physical node; // 2. TGeoPhysicalNode *node = gGeoManager->MakePhysicalNode(); // - creates a physical node representing the current modeller state; ; // Setting visualisation options for TGeoPhysicalNode *node:; // 1. node->SetVisibility(Bool_t flag); // set node visible(*) or invisible; // 2. node->SetIsVolAtt(Bool_t flag); // set line attributes to match the ones of the volumes in the branch; // - default - TRUE; // - when called with FALSE - the attributes defined for the physical node will be taken; // node->SetLineColor(color);; // node->SetLineWidth(width);; // node->SetLineStyle(style);; // 3. node->SetVisibleFull(Bool_t flag); // not only last node in the branch is visible (default); //; // Activating/deactivating physical nodes drawing - not needed in case of alignment; ; // Aligning physical nodes; //==========================; // node->Align(TGeoMatrix *newmat, TGeoShape *newshape, Bool_t check=kFALSE);; // newmat = new matrix to replace final node LOCAL matrix; //",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:5899,Usability,simpl,simple,5899,"return (1+Int_t(color));; }; ; //______________________________________________________________________________; void raytrace() {; raytracing = !raytracing;; if (gGeoManager && gPad) {; auto top = gGeoManager->GetTopVolume();; bool drawn = gPad->GetListOfPrimitives()->FindObject(top);; if (drawn) top->SetVisRaytrace(raytracing);; gPad->Modified();; gPad->Update();; }; }; ; //______________________________________________________________________________; void help() {; ; auto c =(TCanvas *) gROOT->GetListOfCanvases()->FindObject(""geom_help"");; if (c) {; c->Clear();; c->Update();; c->cd();; } else {; c = new TCanvas(""geom_help"",""Help to run demos"",200,10,700,600);; }; ; TPaveText *welcome = new TPaveText(.1,.8,.9,.97);; welcome->AddText(""Welcome to the new geometry package"");; welcome->SetTextFont(32);; welcome->SetTextColor(4);; welcome->SetFillColor(24);; welcome->Draw();; ; TPaveText *hdemo = new TPaveText(.05,.05,.95,.7);; hdemo->SetTextAlign(12);; hdemo->SetTextFont(52);; hdemo->AddText(""- Demo for building TGeo basic shapes and simple geometry. Shape parameters are"");; hdemo->AddText("" displayed in the right pad"");; hdemo->AddText(""- Click left mouse button to execute one demo"");; hdemo->AddText(""- While pointing the mouse to the pad containing the geometry, do:"");; hdemo->AddText(""- .... click-and-move to rotate"");; hdemo->AddText(""- .... press j/k to zoom/unzoom"");; hdemo->AddText(""- .... press l/h/u/i to move the view center around"");; hdemo->AddText(""- Click Ray-trace ON/OFF to toggle ray-tracing"");; hdemo->AddText(""- Use <View with x3d> from the <View> menu to get an x3d view"");; hdemo->AddText(""- .... same methods to rotate/zoom/move the view"");; hdemo->AddText(""- Execute box(1,8) to divide a box in 8 equal slices along X"");; hdemo->AddText(""- Most shapes can be divided on X,Y,Z,Rxy or Phi :"");; hdemo->AddText(""- .... root[0] <shape>(IAXIS, NDIV, START, STEP);"");; hdemo->AddText("" .... IAXIS = 1,2,3 meaning (X,Y,Z) or (Rxy, Phi, Z)"");; hdemo->AddText("" ..",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:9124,Usability,simpl,simple,9124,"rn;; }; view = gPad->GetView();; if (!view) {; grotate = kFALSE;; return;; }; view->SetView(longit,view->GetLatitude(),view->GetPsi(),irep);; gPad->Modified();; gPad->Update();; }; delete timer;; }; ; //______________________________________________________________________________; void axes(); {; axis = !axis;; TView *view = gPad ? gPad->GetView() : nullptr;; if(view); view->ShowAxis();; }; ; //______________________________________________________________________________; TCanvas *create_canvas(const char *title); {; auto c = (TCanvas *) gROOT->GetListOfCanvases()->FindObject(""geom_draw"");; if (c) {; c->Clear();; c->Update();; c->SetTitle(title);; } else {; c = new TCanvas(""geom_draw"", title, 700,1000);; }; if (comments) {; c->Divide(1,2,0,0);; c->GetPad(2)->SetPad(0,0,1,0.4);; c->GetPad(1)->SetPad(0,0.4,1,1);; c->cd(1);; }; ; return c;; }; ; //______________________________________________________________________________; void box(Int_t iaxis=0, Int_t ndiv=8, Double_t start=0, Double_t step=0); {; auto c = create_canvas(""A simple box"");; ; if (gGeoManager) delete gGeoManager;; new TGeoManager(""box"", ""A simple box"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);; gGeoManager->SetTopVolume(top);; TGeoVolume *vol = gGeoManager->MakeBox(""BOX"",med, 20,30,40);; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol,1);; if ((iaxis > 0) && (iaxis < 4)) {; TGeoVolume *slice = vol->Divide(""SLICE"",iaxis,ndiv,start,step);; if (!slice) return;; slice->SetLineColor(randomColor());; }; gGeoManager->CloseGeometry();; gGeoManager->SetNsegments(80);; ; top->Draw();; ; MakePicture();; if (!comments) return;; c->cd(2);; TPaveText *pt = new TPaveText(0.01,0.01,0.99,0.99);; pt->SetLineColor(1);; TGeoBBox *box = (TGeoBBox *) vol->GetShape();; TText *text = pt->AddText(""TGeoBBox - box class"");; text->SetTextColor(2);; AddMemberInfo(pt, ""fDX"", ",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geodemo_8C.html:9205,Usability,simpl,simple,9205,"rn;; }; view = gPad->GetView();; if (!view) {; grotate = kFALSE;; return;; }; view->SetView(longit,view->GetLatitude(),view->GetPsi(),irep);; gPad->Modified();; gPad->Update();; }; delete timer;; }; ; //______________________________________________________________________________; void axes(); {; axis = !axis;; TView *view = gPad ? gPad->GetView() : nullptr;; if(view); view->ShowAxis();; }; ; //______________________________________________________________________________; TCanvas *create_canvas(const char *title); {; auto c = (TCanvas *) gROOT->GetListOfCanvases()->FindObject(""geom_draw"");; if (c) {; c->Clear();; c->Update();; c->SetTitle(title);; } else {; c = new TCanvas(""geom_draw"", title, 700,1000);; }; if (comments) {; c->Divide(1,2,0,0);; c->GetPad(2)->SetPad(0,0,1,0.4);; c->GetPad(1)->SetPad(0,0.4,1,1);; c->cd(1);; }; ; return c;; }; ; //______________________________________________________________________________; void box(Int_t iaxis=0, Int_t ndiv=8, Double_t start=0, Double_t step=0); {; auto c = create_canvas(""A simple box"");; ; if (gGeoManager) delete gGeoManager;; new TGeoManager(""box"", ""A simple box"");; TGeoMaterial *mat = new TGeoMaterial(""Al"", 26.98,13,2.7);; TGeoMedium *med = new TGeoMedium(""MED"",1,mat);; TGeoVolume *top = gGeoManager->MakeBox(""TOP"",med,100,100,100);; gGeoManager->SetTopVolume(top);; TGeoVolume *vol = gGeoManager->MakeBox(""BOX"",med, 20,30,40);; vol->SetLineColor(randomColor());; vol->SetLineWidth(2);; top->AddNode(vol,1);; if ((iaxis > 0) && (iaxis < 4)) {; TGeoVolume *slice = vol->Divide(""SLICE"",iaxis,ndiv,start,step);; if (!slice) return;; slice->SetLineColor(randomColor());; }; gGeoManager->CloseGeometry();; gGeoManager->SetNsegments(80);; ; top->Draw();; ; MakePicture();; if (!comments) return;; c->cd(2);; TPaveText *pt = new TPaveText(0.01,0.01,0.99,0.99);; pt->SetLineColor(1);; TGeoBBox *box = (TGeoBBox *) vol->GetShape();; TText *text = pt->AddText(""TGeoBBox - box class"");; text->SetTextColor(2);; AddMemberInfo(pt, ""fDX"", ",MatchSource.WIKI,doc/master/geodemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geodemo_8C.html
https://root.cern/doc/master/geomAlice_8C.html:229,Safety,detect,detector,229,". ROOT: tutorials/geom/geomAlice.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAlice.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ALICE). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAlice(); {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; // gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""HALL"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCC"")->InvisibleAll();; gGeoManager->GetVolume(""ZDCA"")->InvisibleAll();; gGeoManager->GetVolume(""L3MO"")->InvisibleAll();; gGeoManager->GetVolume(""YOUT1"")->InvisibleAll();; gGeoManager->GetVolume(""YOUT2"")->InvisibleAll();; gGeoManager->GetVolume(""YSAA"")->InvisibleAll();; gGeoManager->GetVolume(""RB24"")->InvisibleAll();; gGeoManager->GetVolume(""RB26Pipe"")->InvisibleAll();; gGeoManager->GetVolume(""DDIP"")->InvisibleAll();; gGeoManager->GetVolume(""DCM0"")->InvisibleAll();; // gGeoManager->GetVolume(""PPRD"")->InvisibleAll();; gGeoManager->GetVolume(""BRS1"")->InvisibleAll();; gGeoManager->GetVolume(""BRS4"")->InvisibleAll();; // gGeoManager->GetVolume(""Dipole"")->InvisibleAll();; gGeoManager->GetVolume(""ZN1"")->InvisibleAll();; gGeoManager->GetVolume(""Q13T"")->InvisibleAll();; gGeoManager->GetVolume(""ZP1"")->InvisibleAll();; gGeoManager->GetVolume(""QTD1"")->InvisibleAll();; gGeoManager->GetVolume(""QTD2"")->InvisibleAll();; gGeoManager->GetVolume(""QBS7"")->InvisibleAll();; gGeoManager->GetVolume(""QA07"")->InvisibleAll();; gGeoManager->GetVolume(""MD1V"")->InvisibleAll();; gGeoManager->GetVolume(""QTD3"")->InvisibleAll();; gGeoManager->GetVolume(""QTD4"")->InvisibleAll();; gGeoManager->GetVolume(""QTD5"")->InvisibleAll();; gGeoManager->GetVolume(""QBS3"")->InvisibleAll();; gGeoManager->GetVolume(""QBS4""",MatchSource.WIKI,doc/master/geomAlice_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomAlice_8C.html
https://root.cern/doc/master/geomAlice__itsv_8C.html:239,Safety,detect,detector,239,". ROOT: tutorials/geom/geomAlice_itsv.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAlice_itsv.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ITSV from Alice). ; By default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAlice_itsv() {; TGeoManager::Import(""http://root.cern/files/alice2.root"");; gGeoManager->DefaultColors();; gGeoManager->GetVolume(""ITSV"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoManager::DefaultColorsvoid DefaultColors()Set default volume colors according to A of material.Definition TGeoManager.cxx:2259; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomAlice_itsv.C. tutorialsgeomgeomAlice_itsv.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/geomAlice__itsv_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomAlice__itsv_8C.html
https://root.cern/doc/master/geomAtlas_8C.html:229,Safety,detect,detector,229,". ROOT: tutorials/geom/geomAtlas.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomAtlas.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here ATLAS). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomAtlas() {; TGeoManager::Import(""http://root.cern/files/atlas.root"");; //gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(5000);; //gGeoManager->SetVisLevel(4);; gGeoManager->GetVolume(""ATLS"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoManager::SetMaxVisNodesvoid SetMaxVisNodes(Int_t maxnodes=10000)set the maximum number of visible nodes.Definition TGeoManager.cxx:2380; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomAtlas.C. tutorialsgeomgeomAtlas.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/geomAtlas_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomAtlas_8C.html
https://root.cern/doc/master/geomBrahms_8C.html:231,Safety,detect,detector,231,". ROOT: tutorials/geom/geomBrahms.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomBrahms.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here BRAHMS). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site. ; void geomBrahms() {; TGeoManager::Import(""http://root.cern/files/brahms.root"");; gGeoManager->GetVolume(""CAVE"")->Draw(""ogl"");; new TBrowser;; }; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume * GetVolume(const char *name) constSearch for a named volume. All trailing blanks stripped.Definition TGeoManager.cxx:2942; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; AuthorRene Brun ; Definition in file geomBrahms.C. tutorialsgeomgeomBrahms.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/geomBrahms_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomBrahms_8C.html
https://root.cern/doc/master/geomD0_8C.html:223,Safety,detect,detector,223,". ROOT: tutorials/geom/geomD0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomD0.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here D0). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site.; run with .x geomD0.C top level detectors are transparent; or .x geomD0.C(1) top level detectors are visible. ; void RecursiveInvisible(TGeoVolume *vol);; void RecursiveTransparency(TGeoVolume *vol, Int_t transp);; ; void geomD0(Int_t allVisible=0) {; TGeoManager::Import(""http://root.cern/files/d0.root"");; gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(40000);; //gGeoManager->SetVisLevel(4);; if (!allVisible) {; RecursiveInvisible(gGeoManager->GetVolume(""D0-""));; RecursiveInvisible(gGeoManager->GetVolume(""D0+""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WZ""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WL""));; RecursiveTransparency(gGeoManager->GetVolume(""MUON""), 90);; }; ; gGeoManager->GetVolume(""D0"")->Draw(""ogl"");; }; ; void RecursiveInvisible(TGeoVolume *vol); {; vol->InvisibleAll();; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveInvisible(vol->GetNode(i)->GetVolume());; }; }; ; void RecursiveTransparency(TGeoVolume *vol, Int_t transp); {; vol->SetTransparency(transp);; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveTransparency(vol->GetNode(i)->GetVolume(), transp);; }; }; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume *",MatchSource.WIKI,doc/master/geomD0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomD0_8C.html
https://root.cern/doc/master/geomD0_8C.html:513,Safety,detect,detectors,513,". ROOT: tutorials/geom/geomD0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomD0.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here D0). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site.; run with .x geomD0.C top level detectors are transparent; or .x geomD0.C(1) top level detectors are visible. ; void RecursiveInvisible(TGeoVolume *vol);; void RecursiveTransparency(TGeoVolume *vol, Int_t transp);; ; void geomD0(Int_t allVisible=0) {; TGeoManager::Import(""http://root.cern/files/d0.root"");; gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(40000);; //gGeoManager->SetVisLevel(4);; if (!allVisible) {; RecursiveInvisible(gGeoManager->GetVolume(""D0-""));; RecursiveInvisible(gGeoManager->GetVolume(""D0+""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WZ""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WL""));; RecursiveTransparency(gGeoManager->GetVolume(""MUON""), 90);; }; ; gGeoManager->GetVolume(""D0"")->Draw(""ogl"");; }; ; void RecursiveInvisible(TGeoVolume *vol); {; vol->InvisibleAll();; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveInvisible(vol->GetNode(i)->GetVolume());; }; }; ; void RecursiveTransparency(TGeoVolume *vol, Int_t transp); {; vol->SetTransparency(transp);; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveTransparency(vol->GetNode(i)->GetVolume(), transp);; }; }; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume *",MatchSource.WIKI,doc/master/geomD0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomD0_8C.html
https://root.cern/doc/master/geomD0_8C.html:568,Safety,detect,detectors,568,". ROOT: tutorials/geom/geomD0.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. geomD0.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Script drawing a detector geometry (here D0). ; by default the geometry is drawn using the GL viewer Using the TBrowser, you can select other components if the file containing the geometry is not found in the local directory, it is automatically read from the ROOT web site.; run with .x geomD0.C top level detectors are transparent; or .x geomD0.C(1) top level detectors are visible. ; void RecursiveInvisible(TGeoVolume *vol);; void RecursiveTransparency(TGeoVolume *vol, Int_t transp);; ; void geomD0(Int_t allVisible=0) {; TGeoManager::Import(""http://root.cern/files/d0.root"");; gGeoManager->DefaultColors();; gGeoManager->SetMaxVisNodes(40000);; //gGeoManager->SetVisLevel(4);; if (!allVisible) {; RecursiveInvisible(gGeoManager->GetVolume(""D0-""));; RecursiveInvisible(gGeoManager->GetVolume(""D0+""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WZ""));; RecursiveInvisible(gGeoManager->GetVolume(""D0WL""));; RecursiveTransparency(gGeoManager->GetVolume(""MUON""), 90);; }; ; gGeoManager->GetVolume(""D0"")->Draw(""ogl"");; }; ; void RecursiveInvisible(TGeoVolume *vol); {; vol->InvisibleAll();; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveInvisible(vol->GetNode(i)->GetVolume());; }; }; ; void RecursiveTransparency(TGeoVolume *vol, Int_t transp); {; vol->SetTransparency(transp);; Int_t nd = vol->GetNdaughters();; for (Int_t i=0; i<nd; i++) {; RecursiveTransparency(vol->GetNode(i)->GetVolume(), transp);; }; }; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; TGeoManager::GetVolumeTGeoVolume *",MatchSource.WIKI,doc/master/geomD0_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geomD0_8C.html
https://root.cern/doc/master/geom_2assembly_8C.html:3570,Availability,down,down,3570,"lls-i,new TGeoTranslation(0,-ycell,0));; }; ; Double_t dxrow = 3.*(dshift+10.)*TMath::Tan(30.*TMath::DegToRad());; Double_t dyrow = dshift+10.;; Int_t nrows = 5;; for (i=0; i<nrows; i++) {; Double_t xrow = 0.5*(2*i+1)*dxrow;; Double_t yrow = 0.5*dyrow;; if ((i%2)==0) yrow = -yrow;; top->AddNode(row, nrows+i+1, new TGeoTranslation(xrow,yrow,0));; top->AddNode(row, nrows-i, new TGeoTranslation(-xrow,-yrow,0));; }; ; //--- close the geometry; geom->CloseGeometry();; ; geom->SetVisLevel(4);; geom->SetVisOption(0);; top->Draw();; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kBlue@ kBlueDefinition Rtypes.h:66; TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::SetVisOptionvoid SetVisOption(Int_t option=0)set drawing mode :Definition TGeoManager.cxx:2426; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoRotationClass describing rotations.Definition TGeoMatrix.h:168; TGeoRotation::RotateXvoid RotateX(Double_t a",MatchSource.WIKI,doc/master/geom_2assembly_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html
https://root.cern/doc/master/geom_2assembly_8C.html:3601,Performance,perform,performedDefinition,3601,"lls-i,new TGeoTranslation(0,-ycell,0));; }; ; Double_t dxrow = 3.*(dshift+10.)*TMath::Tan(30.*TMath::DegToRad());; Double_t dyrow = dshift+10.;; Int_t nrows = 5;; for (i=0; i<nrows; i++) {; Double_t xrow = 0.5*(2*i+1)*dxrow;; Double_t yrow = 0.5*dyrow;; if ((i%2)==0) yrow = -yrow;; top->AddNode(row, nrows+i+1, new TGeoTranslation(xrow,yrow,0));; top->AddNode(row, nrows-i, new TGeoTranslation(-xrow,-yrow,0));; }; ; //--- close the geometry; geom->CloseGeometry();; ; geom->SetVisLevel(4);; geom->SetVisOption(0);; top->Draw();; }; ; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kBlue@ kBlueDefinition Rtypes.h:66; TGeoCombiTransClass describing rotation + translation.Definition TGeoMatrix.h:317; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::SetVisOptionvoid SetVisOption(Int_t option=0)set drawing mode :Definition TGeoManager.cxx:2426; TGeoManager::SetVisLevelvoid SetVisLevel(Int_t level=3)set default level down to which visualization is performedDefinition TGeoManager.cxx:2459; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; TGeoRotationClass describing rotations.Definition TGeoMatrix.h:168; TGeoRotation::RotateXvoid RotateX(Double_t a",MatchSource.WIKI,doc/master/geom_2assembly_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html
https://root.cern/doc/master/geom_2assembly_8C.html:219,Safety,detect,detector,219,". ROOT: tutorials/geom/assembly.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. assembly.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Geometry detector assembly example. ; ��A2␏V ; void assembly(); {; //--- Definition of a simple geometry; TGeoManager *geom = new TGeoManager(""Assemblies"",; ""Geometry using assemblies"");; Int_t i;; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Aluminium"",2, matAl);; ; //--- make the top container volume; TGeoVolume *top = geom->MakeBox(""TOP"", Vacuum, 1000., 1000., 100.);; geom->SetTopVolume(top);; ; // Make the elementary assembly of the whole structure; TGeoVolume *tplate = new TGeoVolumeAssembly(""TOOTHPLATE"");; ; Int_t ntooth = 5;; Double_t xplate = 25;; Double_t yplate = 50;; Double_t xtooth = 10;; Double_t ytooth = 0.5*yplate/ntooth;; Double_t dshift = 2.*xplate + xtooth;; Double_t xt,yt;; ; TGeoVolume *plate = geom->MakeBox(""PLATE"", Al, xplate,yplate,1);; plate->SetLineColor(kBlue);; TGeoVolume *tooth = geom->MakeBox(""TOOTH"", Al, xtooth,ytooth,1);; tooth->SetLineColor(kBlue);; tplate->AddNode(plate,1);; for (i=0; i<ntooth; i++) {; xt = xplate+xtooth;; yt = -yplate + (4*i+1)*ytooth;; tplate->AddNode(tooth, i+1, new TGeoTranslation(xt,yt,0));; xt = -xplate-xtooth;; yt = -yplate + (4*i+3)*ytooth;; tplate->AddNode(tooth, ntooth+i+1, new TGeoTranslation(xt,yt,0));; }; ; TGeoRotation *rot1 = new TGeoRotation();; rot1->RotateX(90);; TGeoRotation *rot;; // Make a hexagone cell out of 6 tooth plates. These can zip together; // without generating overlaps (they are self-contained); TGeoVolume *cell = new TGeoVolumeAssembly(""CELL"");; for (i=0; i<6; i++) {; Double_t phi = 60.*i;; Double_t phirad = phi*TMath::DegToRad();; Double_t xp = dshift*TM",MatchSource.WIKI,doc/master/geom_2assembly_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html
https://root.cern/doc/master/geom_2assembly_8C.html:299,Usability,simpl,simple,299,". ROOT: tutorials/geom/assembly.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. assembly.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Geometry detector assembly example. ; ��A2␏V ; void assembly(); {; //--- Definition of a simple geometry; TGeoManager *geom = new TGeoManager(""Assemblies"",; ""Geometry using assemblies"");; Int_t i;; //--- define some materials; TGeoMaterial *matVacuum = new TGeoMaterial(""Vacuum"", 0,0,0);; TGeoMaterial *matAl = new TGeoMaterial(""Al"", 26.98,13,2.7);; // //--- define some media; TGeoMedium *Vacuum = new TGeoMedium(""Vacuum"",1, matVacuum);; TGeoMedium *Al = new TGeoMedium(""Aluminium"",2, matAl);; ; //--- make the top container volume; TGeoVolume *top = geom->MakeBox(""TOP"", Vacuum, 1000., 1000., 100.);; geom->SetTopVolume(top);; ; // Make the elementary assembly of the whole structure; TGeoVolume *tplate = new TGeoVolumeAssembly(""TOOTHPLATE"");; ; Int_t ntooth = 5;; Double_t xplate = 25;; Double_t yplate = 50;; Double_t xtooth = 10;; Double_t ytooth = 0.5*yplate/ntooth;; Double_t dshift = 2.*xplate + xtooth;; Double_t xt,yt;; ; TGeoVolume *plate = geom->MakeBox(""PLATE"", Al, xplate,yplate,1);; plate->SetLineColor(kBlue);; TGeoVolume *tooth = geom->MakeBox(""TOOTH"", Al, xtooth,ytooth,1);; tooth->SetLineColor(kBlue);; tplate->AddNode(plate,1);; for (i=0; i<ntooth; i++) {; xt = xplate+xtooth;; yt = -yplate + (4*i+1)*ytooth;; tplate->AddNode(tooth, i+1, new TGeoTranslation(xt,yt,0));; xt = -xplate-xtooth;; yt = -yplate + (4*i+3)*ytooth;; tplate->AddNode(tooth, ntooth+i+1, new TGeoTranslation(xt,yt,0));; }; ; TGeoRotation *rot1 = new TGeoRotation();; rot1->RotateX(90);; TGeoRotation *rot;; // Make a hexagone cell out of 6 tooth plates. These can zip together; // without generating overlaps (they are self-contained); TGeoVolume *cell = new TGeoVolumeAssembly(""CELL"");; for (i=0; i<6; i++) {; Double_t phi = 60.*i;; Double_t phirad = phi*TMath::DegToRad();; Double_t xp = dshift*TM",MatchSource.WIKI,doc/master/geom_2assembly_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geom_2assembly_8C.html
https://root.cern/doc/master/geom_2csgdemo_8C.html:11034,Modifiability,config,configurable,11034,"; TGeoManager.h; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TGeoAtt::SetVisRaytracevoid SetVisRaytrace(Bool_t flag=kTRUE)Definition TGeoAtt.h:66; TGeoBBoxDefinition TGeoBBox.h:17; TGeoCompositeShapeComposite shapes are Boolean combinations of two or more shape components.Definition TGeoCompositeShape.h:27; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition ",MatchSource.WIKI,doc/master/geom_2csgdemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geom_2csgdemo_8C.html
https://root.cern/doc/master/geom_2csgdemo_8C.html:11072,Security,access,access,11072,"; TGeoManager.h; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; gROOT#define gROOTDefinition TROOT.h:406; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; gPad#define gPadDefinition TVirtualPad.h:308; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TGeoAtt::SetVisRaytracevoid SetVisRaytrace(Bool_t flag=kTRUE)Definition TGeoAtt.h:66; TGeoBBoxDefinition TGeoBBox.h:17; TGeoCompositeShapeComposite shapes are Boolean combinations of two or more shape components.Definition TGeoCompositeShape.h:27; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition ",MatchSource.WIKI,doc/master/geom_2csgdemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/geom_2csgdemo_8C.html
https://root.cern/doc/master/gerrors2_8C.html:231,Availability,error,error,231,". ROOT: tutorials/graphs/gerrors2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gerrors2.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw two graphs with error bars . ; void gerrors2() {; TCanvas *c1 = new TCanvas(""c1"",""gerrors2"",200,10,700,500);; c1->SetGrid();; ; // draw a frame to define the range; TH1F *hr = c1->DrawFrame(-0.4,0,1.2,12);; hr->SetXTitle(""X title"");; hr->SetYTitle(""Y title"");; c1->GetFrame()->SetBorderSize(12);; ; // create first graph; const Int_t n1 = 10;; Double_t xval1[] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t yval1[] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex1[] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey1[] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr1 = new TGraphErrors(n1,xval1,yval1,ex1,ey1);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(21);; gr1->Draw(""LP"");; ; // create second graph; const Int_t n2 = 10;; Float_t xval2[] = {-0.28, 0.005, 0.19, 0.29, 0.45, 0.56,0.65,0.80,0.90,1.01};; Float_t yval2[] = {0.82,3.86,7,9,10,10.55,9.64,7.26,5.42,2};; Float_t ex2[] = {.04,.12,.08,.06,.05,.04,.07,.06,.08,.04};; Float_t ey2[] = {.6,.8,.7,.4,.3,.3,.4,.5,.6,.7};; TGraphErrors *gr2 = new TGraphErrors(n2,xval2,yval2,ex2,ey2);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(20);; gr2->Draw(""LP"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt=""",MatchSource.WIKI,doc/master/gerrors2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors2_8C.html
https://root.cern/doc/master/gerrors2_8C.html:1921,Availability,error,error,1921,"t Int_t n1 = 10;; Double_t xval1[] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t yval1[] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex1[] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey1[] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr1 = new TGraphErrors(n1,xval1,yval1,ex1,ey1);; gr1->SetMarkerColor(kBlue);; gr1->SetMarkerStyle(21);; gr1->Draw(""LP"");; ; // create second graph; const Int_t n2 = 10;; Float_t xval2[] = {-0.28, 0.005, 0.19, 0.29, 0.45, 0.56,0.65,0.80,0.90,1.01};; Float_t yval2[] = {0.82,3.86,7,9,10,10.55,9.64,7.26,5.42,2};; Float_t ex2[] = {.04,.12,.08,.06,.05,.04,.07,.06,.08,.04};; Float_t ey2[] = {.6,.8,.7,.4,.3,.3,.4,.5,.6,.7};; TGraphErrors *gr2 = new TGraphErrors(n2,xval2,yval2,ex2,ey2);; gr2->SetMarkerColor(kRed);; gr2->SetMarkerStyle(20);; gr2->Draw(""LP"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetXTitlevirtual void SetXTitle(const char *title)Definition TH1.h:419; TH1::SetYTitlevirtual void SetYTitle(const char *title)Definition TH1.h:420; c1return c1Definition legend1.C:41; AuthorRene Brun ; Definition in file gerrors2.C. tutorialsgraphsgerrors2.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gerrors2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors2_8C.html
https://root.cern/doc/master/gerrors_8C.html:226,Availability,error,error,226,". ROOT: tutorials/graphs/gerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gerrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with error bars . ; void gerrors() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; ; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t n = 10;; Float_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; gerrorsDefinition gerrors.py:1; AuthorRene Brun ; Definition in file gerrors.C. tutorialsgraphsgerrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ;",MatchSource.WIKI,doc/master/gerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors_8C.html
https://root.cern/doc/master/gerrors_8C.html:311,Availability,error,error,311,". ROOT: tutorials/graphs/gerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gerrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with error bars . ; void gerrors() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; ; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t n = 10;; Float_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; gerrorsDefinition gerrors.py:1; AuthorRene Brun ; Definition in file gerrors.C. tutorialsgraphsgerrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ;",MatchSource.WIKI,doc/master/gerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors_8C.html
https://root.cern/doc/master/gerrors_8C.html:1253,Availability,error,error,1253,"OT: tutorials/graphs/gerrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gerrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with error bars . ; void gerrors() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; ; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t n = 10;; Float_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; eyDouble_t ey[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25; exDouble_t ex[n]Definition legend1.C:17; gerrorsDefinition gerrors.py:1; AuthorRene Brun ; Definition in file gerrors.C. tutorialsgraphsgerrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gerrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors_8C.html
https://root.cern/doc/master/gerrors_8py.html:243,Availability,error,error,243,". ROOT: tutorials/pyroot/gerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; gerrors.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple Graph with error bars . ; from ROOT import TCanvas, TGraphErrors; from ROOT import gROOT; from array import array; ; c1 = TCanvas( 'c1', 'A Simple Graph with error bars', 200, 10, 700, 500 ); ; c1.SetGrid(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); ; n = 10;; x = array( 'f', [ -0.22, 0.05, 0.25, 0.35, 0.5, 0.61, 0.7, 0.85, 0.89, 0.95 ] ); ex = array( 'f', [ 0.05, 0.1, 0.07, 0.07, 0.04, 0.05, 0.06, 0.07, 0.08, 0.05 ] ); y = array( 'f', [ 1, 2.9, 5.6, 7.4, 9.0, 9.6, 8.7, 6.3, 4.5, 1 ] ); ey = array( 'f', [ 0.8, 0.7, 0.6, 0.5, 0.4, 0.4, 0.5, 0.6, 0.7, 0.8 ] ); ; gr = TGraphErrors( n, x, y, ex, ey ); gr.SetTitle( 'TGraphErrors Example' ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.Draw( 'ALP' ); ; c1.Update(); SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file gerrors.py. tutorialspyrootgerrors.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors_8py.html
https://root.cern/doc/master/gerrors_8py.html:390,Availability,error,error,390,". ROOT: tutorials/pyroot/gerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; gerrors.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple Graph with error bars . ; from ROOT import TCanvas, TGraphErrors; from ROOT import gROOT; from array import array; ; c1 = TCanvas( 'c1', 'A Simple Graph with error bars', 200, 10, 700, 500 ); ; c1.SetGrid(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); ; n = 10;; x = array( 'f', [ -0.22, 0.05, 0.25, 0.35, 0.5, 0.61, 0.7, 0.85, 0.89, 0.95 ] ); ex = array( 'f', [ 0.05, 0.1, 0.07, 0.07, 0.04, 0.05, 0.06, 0.07, 0.08, 0.05 ] ); y = array( 'f', [ 1, 2.9, 5.6, 7.4, 9.0, 9.6, 8.7, 6.3, 4.5, 1 ] ); ey = array( 'f', [ 0.8, 0.7, 0.6, 0.5, 0.4, 0.4, 0.5, 0.6, 0.7, 0.8 ] ); ; gr = TGraphErrors( n, x, y, ex, ey ); gr.SetTitle( 'TGraphErrors Example' ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.Draw( 'ALP' ); ; c1.Update(); SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file gerrors.py. tutorialspyrootgerrors.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors_8py.html
https://root.cern/doc/master/gerrors_8py.html:1160,Availability,error,error,1160,". ROOT: tutorials/pyroot/gerrors.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; gerrors.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; A Simple Graph with error bars . ; from ROOT import TCanvas, TGraphErrors; from ROOT import gROOT; from array import array; ; c1 = TCanvas( 'c1', 'A Simple Graph with error bars', 200, 10, 700, 500 ); ; c1.SetGrid(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); ; n = 10;; x = array( 'f', [ -0.22, 0.05, 0.25, 0.35, 0.5, 0.61, 0.7, 0.85, 0.89, 0.95 ] ); ex = array( 'f', [ 0.05, 0.1, 0.07, 0.07, 0.04, 0.05, 0.06, 0.07, 0.08, 0.05 ] ); y = array( 'f', [ 1, 2.9, 5.6, 7.4, 9.0, 9.6, 8.7, 6.3, 4.5, 1 ] ); ey = array( 'f', [ 0.8, 0.7, 0.6, 0.5, 0.4, 0.4, 0.5, 0.6, 0.7, 0.8 ] ); ; gr = TGraphErrors( n, x, y, ex, ey ); gr.SetTitle( 'TGraphErrors Example' ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.Draw( 'ALP' ); ; c1.Update(); SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file gerrors.py. tutorialspyrootgerrors.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gerrors_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gerrors_8py.html
https://root.cern/doc/master/gldemos_8C.html:3230,Modifiability,config,configurable,3230,"xt(""You can select one of back box planes, press middle mouse button and move cursor-"");; hdemo->AddText(""this will create \""slice\"" (TF does not support yet)."");; hdemo->AddText(""After the slice was created, you can project it on a back box"");; hdemo->AddText("" ---press key 'p' (now implemented only for surf options )."");; hdemo->AddText(""Left double click removes all slices/projections."");; ; hdemo->Draw();; ; }; kBlue@ kBlueDefinition Rtypes.h:66; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; AuthorTimur Pocheptsov ; Definition in file gldemos.C. tutorialsglgldemos.C. ROOT master - Reference Guide ",MatchSource.WIKI,doc/master/gldemos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gldemos_8C.html
https://root.cern/doc/master/gldemos_8C.html:3268,Security,access,access,3268,"xt(""You can select one of back box planes, press middle mouse button and move cursor-"");; hdemo->AddText(""this will create \""slice\"" (TF does not support yet)."");; hdemo->AddText(""After the slice was created, you can project it on a back box"");; hdemo->AddText("" ---press key 'p' (now implemented only for surf options )."");; hdemo->AddText(""Left double click removes all slices/projections."");; ; hdemo->Draw();; ; }; kBlue@ kBlueDefinition Rtypes.h:66; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TCanvasThe Canvas class.Definition TCanvas.h:23; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; TControlBar::Showvoid Show()Show control bar.Definition TControlBar.cxx:317; TControlBar::AddButtonvoid AddButton(TControlBarButton *button)Add button.Definition TControlBar.cxx:141; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveLabel::Drawvoid Draw(Option_t *option="""") overrideDraw this pavelabel with its current attributes.Definition TPaveLabel.cxx:88; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveText::AddTextvirtual TText * AddText(Double_t x1, Double_t y1, const char *label)Add a new Text line to this pavetext at given coordinates.Definition TPaveText.cxx:191; TPaveText::Drawvoid Draw(Option_t *option="""") overrideDraw this pavetext with its current attributes.Definition TPaveText.cxx:242; AuthorTimur Pocheptsov ; Definition in file gldemos.C. tutorialsglgldemos.C. ROOT master - Reference Guide ",MatchSource.WIKI,doc/master/gldemos_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gldemos_8C.html
https://root.cern/doc/master/glparametric_8C.html:1895,Testability,log,log,1895,"(u,...Definition TGLParametric.h:35; where FORMULA is the same string (mathematical expression), as in TF2, but you should use 'u' (or 'U') instead of 'x' and 'v' (or 'V') instead of 'y'.; Call equation->Draw(); Parametric surfaces support 21 color ""schemes"", you can change the color:; place mouse cursor above surface (surface is selected in pad); press 's' or 'S'. ; void glparametric(); {; gStyle->SetCanvasPreferGL(kTRUE);; TCanvas *c = new TCanvas(""canvas"",""Parametric surfaces with gl"", 100, 10,; 700, 700);; c->SetFillColor(42);; gStyle->SetFrameFillColor(42);; ; c->Divide(2, 2);; c->cd(1);; TGLParametricEquation *p1 = new TGLParametricEquation(""Conchoid"",; ""1.2 ^ u * (1 + cos(v)) * cos(u)"",; ""1.2 ^ u * (1 + cos(v)) * sin(u)"",; ""1.2 ^ u * sin(v) - 1.5 * 1.2 ^ u"",; 0., 6 * TMath::Pi(), 0., TMath::TwoPi());; p1->Draw();; ; c->cd(2);; TGLParametricEquation *p2 = new TGLParametricEquation(""Apple"",; ""cos(u) * (4 + 3.8 * cos(v)) "",; ""sin(u) * (4 + 3.8 * cos(v))"",; ""(cos(v) + sin(v) - 1) * (1 + sin(v)) * log(1 - pi * v / 10) + 7.5 * sin(v)"",; 0, TMath::TwoPi(), -TMath::Pi(), TMath::Pi());; p2->Draw();; ; c->cd(3);; TGLParametricEquation *p3 = new TGLParametricEquation(""Toupie"",; ""(abs(u) - 1) ^ 2 * cos(v)"",; ""(abs(u) - 1) ^ 2 * sin(v)"",; ""u"",; -1., 1., 0, TMath::TwoPi());; p3->Draw();; ; c->cd(4);; TGLParametricEquation *p4 = new TGLParametricEquation(""Trangluoid trefoil"",; ""2 * sin(3 * u) / (2 + cos(v))"",; ""2 * (sin(u) + 2 * sin(2 * u)) / (2 + cos(v + 2 * pi / 3))"",; ""(cos(u) - 2 * cos(2 * u)) * (2 + cos(v)) * (2 + cos(v + 2 * pi / 3)) / 4"",; -TMath::Pi(), TMath::Pi(), -TMath::Pi(), TMath::Pi());; p4->Draw();; }; c#define c(i)Definition RSha256.hxx:101; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TStyle::SetFrameFillColorvoid SetFrameFillColor",MatchSource.WIKI,doc/master/glparametric_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glparametric_8C.html
https://root.cern/doc/master/glViewerExercise_8C.html:5446,Deployability,configurat,configuration,5446,"tion TGLLightSet.h:28; TGLLightSet::SetLightvoid SetLight(ELight light, Bool_t on)Set a light on/off.Definition TGLLightSet.cxx:55; TGLOrthoCameraOrthographic projection camera.Definition TGLOrthoCamera.h:36; TGLOrthoCamera::SetEnableRotatevoid SetEnableRotate(Bool_t x)Definition TGLOrthoCamera.h:80; TGLRnrCtx::kFill@ kFillDefinition TGLRnrCtx.h:46; TGLRnrCtx::kWireFrame@ kWireFrameDefinition TGLRnrCtx.h:48; TGLRnrCtx::kOutline@ kOutlineDefinition TGLRnrCtx.h:47; TGLSAViewerThe top level standalone GL-viewer - created via plugin manager.Definition TGLSAViewer.h:38; TGLSAViewer::GetFrameTGCompositeFrame * GetFrame() constReturn the main-frame.Definition TGLSAViewer.cxx:325; TGLViewerBase::SetStylevoid SetStyle(Short_t st)Definition TGLViewerBase.h:111; TGLViewerBase GL viewer object - used by both standalone and embedded (in pad) GL.Definition TGLViewer.h:55; TGLViewer::SetPerspectiveCameravoid SetPerspectiveCamera(ECameraType camera, Double_t fov, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate)Set a perspective camera to supplied configuration - note this does not need to be the current camera...Definition TGLViewer.cxx:1957; TGLViewer::ECameraTypeECameraTypeDefinition TGLViewer.h:61; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; v@ vDefinition rootcling_impl.cxx:3699; AuthorRichard Maunder ; Definition in file glViewerExercise.C. tutorialsglglViewerExercise.C. ROOT master - Refe",MatchSource.WIKI,doc/master/glViewerExercise_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glViewerExercise_8C.html
https://root.cern/doc/master/glViewerExercise_8C.html:4904,Modifiability,plugin,plugin,4904,"_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TTimer.h; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TGLLightSetEncapsulates a set of lights for OpenGL.Definition TGLLightSet.h:22; TGLLightSet::kLightLeft@ kLightLeftDefinition TGLLightSet.h:27; TGLLightSet::kLightBottom@ kLightBottomDefinition TGLLightSet.h:26; TGLLightSet::kLightTop@ kLightTopDefinition TGLLightSet.h:25; TGLLightSet::kLightRight@ kLightRightDefinition TGLLightSet.h:28; TGLLightSet::SetLightvoid SetLight(ELight light, Bool_t on)Set a light on/off.Definition TGLLightSet.cxx:55; TGLOrthoCameraOrthographic projection camera.Definition TGLOrthoCamera.h:36; TGLOrthoCamera::SetEnableRotatevoid SetEnableRotate(Bool_t x)Definition TGLOrthoCamera.h:80; TGLRnrCtx::kFill@ kFillDefinition TGLRnrCtx.h:46; TGLRnrCtx::kWireFrame@ kWireFrameDefinition TGLRnrCtx.h:48; TGLRnrCtx::kOutline@ kOutlineDefinition TGLRnrCtx.h:47; TGLSAViewerThe top level standalone GL-viewer - created via plugin manager.Definition TGLSAViewer.h:38; TGLSAViewer::GetFrameTGCompositeFrame * GetFrame() constReturn the main-frame.Definition TGLSAViewer.cxx:325; TGLViewerBase::SetStylevoid SetStyle(Short_t st)Definition TGLViewerBase.h:111; TGLViewerBase GL viewer object - used by both standalone and embedded (in pad) GL.Definition TGLViewer.h:55; TGLViewer::SetPerspectiveCameravoid SetPerspectiveCamera(ECameraType camera, Double_t fov, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate)Set a perspective camera to supplied configuration - note this does not need to be the current camera...Definition TGLViewer.cxx:1957; TGLViewer::ECameraTypeECameraTypeDefinition TGLViewer.h:61; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TRandomThis is the base class for the ROOT R",MatchSource.WIKI,doc/master/glViewerExercise_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glViewerExercise_8C.html
https://root.cern/doc/master/glViewerExercise_8C.html:5446,Modifiability,config,configuration,5446,"tion TGLLightSet.h:28; TGLLightSet::SetLightvoid SetLight(ELight light, Bool_t on)Set a light on/off.Definition TGLLightSet.cxx:55; TGLOrthoCameraOrthographic projection camera.Definition TGLOrthoCamera.h:36; TGLOrthoCamera::SetEnableRotatevoid SetEnableRotate(Bool_t x)Definition TGLOrthoCamera.h:80; TGLRnrCtx::kFill@ kFillDefinition TGLRnrCtx.h:46; TGLRnrCtx::kWireFrame@ kWireFrameDefinition TGLRnrCtx.h:48; TGLRnrCtx::kOutline@ kOutlineDefinition TGLRnrCtx.h:47; TGLSAViewerThe top level standalone GL-viewer - created via plugin manager.Definition TGLSAViewer.h:38; TGLSAViewer::GetFrameTGCompositeFrame * GetFrame() constReturn the main-frame.Definition TGLSAViewer.cxx:325; TGLViewerBase::SetStylevoid SetStyle(Short_t st)Definition TGLViewerBase.h:111; TGLViewerBase GL viewer object - used by both standalone and embedded (in pad) GL.Definition TGLViewer.h:55; TGLViewer::SetPerspectiveCameravoid SetPerspectiveCamera(ECameraType camera, Double_t fov, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate)Set a perspective camera to supplied configuration - note this does not need to be the current camera...Definition TGLViewer.cxx:1957; TGLViewer::ECameraTypeECameraTypeDefinition TGLViewer.h:61; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TMath::PiOver2constexpr Double_t PiOver2()Definition TMath.h:51; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; v@ vDefinition rootcling_impl.cxx:3699; AuthorRichard Maunder ; Definition in file glViewerExercise.C. tutorialsglglViewerExercise.C. ROOT master - Refe",MatchSource.WIKI,doc/master/glViewerExercise_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glViewerExercise_8C.html
https://root.cern/doc/master/glViewerLOD_8C.html:463,Testability,test,test,463,". ROOT: tutorials/gl/glViewerLOD.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glViewerLOD.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; To set the Level Of Details when rendering geometry shapes. ; ; void glViewerLOD(Int_t reqNodes = 1000, Bool_t randomDist = kTRUE,; Bool_t reqSpheres = kTRUE, Bool_t reqTubes = kTRUE); {; TGeoManager * geom = new TGeoManager(""LODTest"", ""GL viewer LOD test"");; geom->SetNsegments(4); // Doesn't matter keep low; TGeoMaterial *matEmptySpace = new TGeoMaterial(""EmptySpace"", 0, 0, 0);; TGeoMaterial *matSolid = new TGeoMaterial(""Solid"" , .938, 1., 10000.);; ; TGeoMedium *medEmptySpace = new TGeoMedium(""Empty"", 1, matEmptySpace);; TGeoMedium *medSolid = new TGeoMedium(""Solid"", 1, matSolid);; ; Double_t sizeBase = 20.0;; Double_t worldRadius;; if (randomDist) {; worldRadius = pow(reqNodes,.5)*sizeBase;; } else {; worldRadius = pow(reqNodes,.3)*sizeBase;; }; ; TGeoVolume *top = geom->MakeBox; (""WORLD"", medEmptySpace, worldRadius, worldRadius, worldRadius);; geom->SetTopVolume(top);; ; gRandom->SetSeed();; ; // Create random number of unique sphere shapes - up to 25% of; // total placed sphere requested; UInt_t volumeCount = gRandom->Integer(reqNodes/4)+1;; TGeoVolume ** volumes = new TGeoVolume *[volumeCount];; TGeoVolume * volume;; UInt_t i;; Double_t dummy;; ; for (i = 0; i < volumeCount; i++) {; char name[128];; sprintf(name, ""Volume_%d"", i);; ; // Random volume shape; Int_t type = -1;; if (reqSpheres && reqTubes) {; type = gRandom->Integer(2);; if (type == 1); type += gRandom->Integer(3);; }; else if(reqSpheres); type = 0;; else if(reqTubes); type = 1 + gRandom->Integer(3);; ; // Random dimensions; Double_t rMin = gRandom->Rndm() * sizeBase;; Double_t rMax = rMin + gRandom->Rndm() * sizeBase * 2.0;; Double_t dz = pow(gRandom->Rndm(),2.0) * sizeBase * 15.0;; Double_t phi1 = gRandom->Rndm() * 90.0;; Double_t phi2 = phi1 + gRandom->Rndm() * 270.0;; ; // Pick random co",MatchSource.WIKI,doc/master/glViewerLOD_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glViewerLOD_8C.html
https://root.cern/doc/master/glViewerLOD_8C.html:3358,Testability,assert,assert,3358," color, rMin, rMax, dz);; break;; }; case 2: {; volumes[i] = geom->MakeTubs(name, medSolid, rMin, rMax, dz,; phi1, phi2);; printf(""Volume %d : Color %d, Tube Seg, Inner Radius %f, ""; ""Outer Radius %f, Length %f, Phi1 %f, Phi2 %f\n"",; i, color, rMin, rMax, dz, phi1, phi2);; break;; }; case 3: {; Double_t n1[3], n2[3];; n1[0] = gRandom->Rndm()*.5;; n1[1] = gRandom->Rndm()*.5; n1[2] = -1.0 + gRandom->Rndm()*.5;; n2[0] = gRandom->Rndm()*.5;; n2[1] = gRandom->Rndm()*.5; n2[2] = 1.0 - gRandom->Rndm()*.5;; ; volumes[i] = geom->MakeCtub(name, medSolid, rMin, rMax, dz,; phi1, phi2, n1[0], n1[1], n1[2],; n2[0], n2[1], n2[2]);; printf(""Volume %d : Color %d, Cut Tube, Inner Radius %f, ""; ""Outer Radius %f, Length %f, Phi1 %f, Phi2 %f, ""; ""n1 (%f,%f,%f), n2 (%f,%f,%f)\n"",; i, color, rMin, rMax, dz, phi1, phi2,; n1[0], n1[1], n1[2], n2[0], n2[1], n2[2]);; break;; }; default: {; assert(kFALSE);; }; }; ; volumes[i]->SetLineColor(color);; }; ; printf(""\nCreated %d volumes\n\n"", volumeCount);; ; // Scatter reqSpheres placed sphere randomly in space; Double_t x, y, z;; for (i = 0; i < reqNodes; i++) {; // Pick random volume; UInt_t useVolume = gRandom->Integer(volumeCount);; ; TGeoTranslation * trans;; TGeoRotation * rot;; if (randomDist) {; // Random translation; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; trans = new TGeoTranslation(x*worldRadius, y*worldRadius, z*worldRadius);; ; // Random rotation; gRandom->Rannor(x, y);; gRandom->Rannor(z,dummy);; rot = new TGeoRotation(""rot"", x*360.0, y*360.0, z*360.0);; } else {; UInt_t perSide = pow(reqNodes,1.0/3.0)+0.5;; Double_t distance = sizeBase*5.0;; UInt_t xi, yi, zi;; zi = i / (perSide*perSide);; yi = (i / perSide) % perSide;; xi = i % perSide;; trans = new TGeoTranslation(xi*distance,yi*distance,zi*distance);; rot = new TGeoRotation(""rot"",0.0, 0.0, 0.0);; }; top->AddNode(volumes[useVolume], i, new TGeoCombiTrans(*trans, *rot));; //printf(""Added node %d (Volume %d)\n"", i, useVolume);; }; geom->CloseGeometry();; top->Draw(""ogl"");;",MatchSource.WIKI,doc/master/glViewerLOD_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glViewerLOD_8C.html
https://root.cern/doc/master/glvox2_8C.html:996,Usability,learn,learn,996,". ROOT: tutorials/gl/glvox2.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. glvox2.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; This macro demonstrates how to use ""glcol"" option for TH3 and how to create user defined TRANSFER FUNCTION: transfer function maps bin value to voxel's opacity. ; codomain is [0, 1] (1. - non-transparent, 0.5 is semitransparent, etc.) To pass transparency function into painting algorithm, you have to:; Create TF1 object (with symbolic expression like ""0.5 * (sin(x) + 1)"": ...; TF1 * tf = new TF1(""TransferFunction"", ""0.5 * (sin(x) + 1)"", -10., 10.);; ...; TF11-Dim function classDefinition TF1.h:233; IMPORTANT, the name of TF1 object MUST be ""TransferFunction"".; Add this function into a hist's list of functions: ...; TList * lof = hist->GetListOfFunctions();; if (lof) lof->Add(tf);; ...; It's also possible to use your own function and pass it into TF1, please read TF1 documentation to learn how. This macro is to be compiled: TF1 is extremely slow with interpreted function as an argument. ; ; #include ""TStyle.h""; #include ""TList.h""; #include ""TH3.h""; #include ""TF1.h""; ; namespace {; ; Double_t my_transfer_function(const Double_t *x, const Double_t * /*param*/); {; // Bin values in our example range from -2 to 1.; // Let's make values from -2. to -1.5 more transparent:; if (*x < -1.5); return 0.008;; ; if (*x < -0.5); return 0.015;; ; if (*x < 0.); return 0.02;; ; if (*x < 0.5); return 0.03;; ; if (*x < 0.8); return 0.04;; ; return 0.05;; }; ; } // namespace; ; void glvox2(); {; //Create and fill TH3.; const UInt_t nX = 30;; const Double_t xMin = -1., xMax = 1., xStep = (xMax - xMin) / (nX - 1);; ; const UInt_t nY = 30;; const Double_t yMin = -1., yMax = 1., yStep = (yMax - yMin) / (nY - 1);; ; const UInt_t nZ = 30;; const Double_t zMin = -1., zMax = 1., zStep = (zMax - zMin) / (nZ - 1);; ; TH3F *hist = new TH3F(""glvoxel"", ""glvoxel"", nX, -1., 1., nY, -1., 1., nZ, -1., 1.);",MatchSource.WIKI,doc/master/glvox2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/glvox2_8C.html
https://root.cern/doc/master/gl_2grad2_8C.html:1157,Energy Efficiency,green,green,1157,"renceTutorials » OpenGL tutorials. Detailed Description; Gradient fill with transparency and the ""SAME"" option. ; To use this macro you need OpenGL enabled in pad: either set OpenGL.CanvasPreferGL to 1 in $ROOTSYS/etc/system.rootrc; or call gStyle->SetCanvasPreferGL(kTRUE); before canvas created. ; //Includes for ACLiC (cling does not need them).; #include ""TColorGradient.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void grad2(bool gl = true); {; //Make sure canvas supports OpenGL.; gStyle->SetCanvasPreferGL(gl);; ; //2. Check that we have a canvas with an OpenGL support.; auto cnv = new TCanvas(""grad2"", ""gradient demo 2"", 100, 100, 800, 600);; if (!cnv->UseGL() && !cnv->IsWeb()); ::Warning(""grad2"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; //3. Custom colors:; // a) Custom semi-transparent red.; auto customRed = TColor::GetColor((Float_t) 1., 0., 0., 0.5);; ; // Custom semi-transparent green.; auto customGreen = TColor::GetColor((Float_t) 0., 1., 0., 0.5);; ; // 4. Linear gradient colors; // b) Gradient (from our semi-transparent red to ROOT's kOrange).; // Linear gradient is defined by: 1) angle in grad; // 2) colors (to interpolate between them),; // If necessary, TLinearGradient object can be retrieved and modified later; ; auto grad1 = TColor::GetLinearGradient(90., {customRed, kOrange});; ; //Vertical gradient fill.; auto grad2 = TColor::GetLinearGradient(90., {customGreen, kBlue});; ; auto hist = new TH1F(""a2"", ""b2"", 10, -2., 3.);; auto hist2 = new TH1F(""c3"", ""d3"", 10, -3., 3.);; hist->FillRandom(""landau"", 100000);; hist2->FillRandom(""gaus"", 100000);; ; hist->SetFillColor(grad1);; hist2->SetFillColor(grad2);; ; hist2->Draw();; hist->Draw(""SAME"");; }; Float_tfloat Float_tDefinition RtypesCore.h:57; kOrange@ kOrangeDefinition Rtypes.h:67; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TColorGradient.h; TColor.h; TError.h; Warningvoid Warning(const c",MatchSource.WIKI,doc/master/gl_2grad2_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2grad2_8C.html
https://root.cern/doc/master/gl_2gradients_8C.html:775,Energy Efficiency,allocate,allocated,775,". ROOT: tutorials/gl/gradients.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gradients.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Features: . Radial and linear gradients; Transparent/semitransparent colours. ; //Includes for ACLiC:; #include ""TColorGradient.h""; #include ""TCanvas.h""; #include ""TError.h""; #include ""TStyle.h""; #include ""TText.h""; #include ""TPie.h""; ; ; void gradients(bool gl = true); {; //Find free colour indices in the ROOT's palette for:; //1. A radial gradient for TPie;; //2. A linear gradient for TCanvas; //3. A fully transparent fill color for a nested pad.; ; gStyle->SetCanvasPreferGL(gl);; ; auto c = new TCanvas(""cpie"",""Gradient colours demo"", 700, 700);; //Before we allocated any new colour or created any object:; if (!c->UseGL() && !c->IsWeb()); ::Warning(""gradients"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; //Linear gradient is defined by: 1) colors (to interpolate between them),; //2) coordinates for these colors along the gradient axis [0., 1.] (must be sorted!).; //3) Start and end points for a gradient, you specify them in some NDC rect ([0,0 - 1,1]),; //and this rect is either: bounding rect of your polygon/object to fill; //(gradient->SetCoordinateMode(TColorGradient::kObjectBoundingMode)); //or bounding rect of a pad (gradient->SetCoordinateMode(TColorGradient::kPadMode)).; //kObjectBoundingMode is the default one.; ; ; //Draw a text in the canvas (the object above the text will be; //semi-transparent):; auto t = new TText(0.05, 0.7, ""Can you see the text?"");; t->Draw();; ; //We create a nested pad on top to render a TPie in,; //this way we still have a text (below) + TPie with; //a fancy colour on top.; auto pad = new TPad(""p"", ""p"", 0., 0., 1., 1.);; ; //TPad itself is fully transparent:; auto transparentFill = TColor::GetColor((Float_t) 1., 1., 1., 0.);; pad->SetFillColor(transparentFill);; //Add our pad into",MatchSource.WIKI,doc/master/gl_2gradients_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2gradients_8C.html
https://root.cern/doc/master/gl_2gradients_8C.html:2563,Energy Efficiency,green,green,2563,"; auto t = new TText(0.05, 0.7, ""Can you see the text?"");; t->Draw();; ; //We create a nested pad on top to render a TPie in,; //this way we still have a text (below) + TPie with; //a fancy colour on top.; auto pad = new TPad(""p"", ""p"", 0., 0., 1., 1.);; ; //TPad itself is fully transparent:; auto transparentFill = TColor::GetColor((Float_t) 1., 1., 1., 0.);; pad->SetFillColor(transparentFill);; //Add our pad into the canvas:; pad->Draw();; pad->cd();; ; ; //Radial gradient fill for a TPie object:; auto col3 = TColor::GetColor((Float_t) 1., 0.8, 0., 1.); /*opaque orange at the start:*/; auto col4 = TColor::GetColor((Float_t) 1., 0.2, 0., 0.65); /*transparent red at the end:*/; ; //'Simple' radial gradient with radius 0.4; auto radialFill = TColor::GetRadialGradient(0.4, {col3, col4});; ; ; //Linear gradient fill (with an axis angle == 45):; auto col1 = TColor::GetColor((Float_t) 0.2, 0.2, 0.2); /*gray*/; auto col2 = TColor::GetColor((Float_t) 0.8, 1., 0.9); /*pale green*/; auto linearFill = TColor::GetLinearGradient(45., {col1, col2}); //45 degrees:; ; //Set as a background color in the canvas:; c->SetFillColor(linearFill);; ; ; const UInt_t nSlices = 5;; //Values for a TPie (non-const, that's how TPie's ctor is declared):; Double_t values[nSlices] = {0.8, 1.2, 1.2, 0.8, 1.};; Int_t colors[nSlices] = {radialFill, radialFill, radialFill,; radialFill, radialFill};; ; TPie * const pie = new TPie(""pie"", ""TPie:"", nSlices, values, colors);; //One slice is slightly shifted:; pie->SetEntryRadiusOffset(2, 0.05);; //Move labels to the center (to fit the pad's space):; pie->SetLabelsOffset(-0.08);; //; pie->SetRadius(0.4);; pie->Draw(""rsc"");; }; c#define c(i)Definition RSha256.hxx:101; Int_tint Int_tDefinition RtypesCore.h:45; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TColorGradient.h; TError.h; Warningvoid Warning(const char *location, const char *msgfmt,...)",MatchSource.WIKI,doc/master/gl_2gradients_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2gradients_8C.html
https://root.cern/doc/master/gl_2parallelcoordtrans_8C.html:5720,Modifiability,variab,variables,5720,"rtualGLProxy.cxx:39; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::SetAlphavirtual void SetAlpha(Float_t a)Definition TColor.h:70; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::SetHistogramHeightvoid SetHistogramHeight(Double_t h=0)Set the height of the bar histogram.Definition TParallelCoordVar.cxx:892; TParallelCoordVar::Drawvoid Draw(Option_t *option="""") overrideDraw the axis.Definition TParallelCoordVar.cxx:150; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::SetLineColorvoid SetLineColor(Color_t col)Definition TParallelCoord.h:127; TParallelCoord::GetVarListTList * GetVarList()Definition TParallelCoord.h:102; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDef",MatchSource.WIKI,doc/master/gl_2parallelcoordtrans_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2parallelcoordtrans_8C.html
https://root.cern/doc/master/gl_2parallelcoordtrans_8C.html:5677,Usability,simpl,simple,5677,"rtualGLProxy.cxx:39; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TNtuple.h; TParallelCoordRange.h; TParallelCoordVar.h; TParallelCoord.h; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; TStyle.h; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TColorThe color creation and management class.Definition TColor.h:21; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TColor::SetAlphavirtual void SetAlpha(Float_t a)Definition TColor.h:70; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TParallelCoordVarTParallelCoord axes.Definition TParallelCoordVar.h:24; TParallelCoordVar::SetHistogramHeightvoid SetHistogramHeight(Double_t h=0)Set the height of the bar histogram.Definition TParallelCoordVar.cxx:892; TParallelCoordVar::Drawvoid Draw(Option_t *option="""") overrideDraw the axis.Definition TParallelCoordVar.cxx:150; TParallelCoordParallel Coordinates class.Definition TParallelCoord.h:28; TParallelCoord::SetLineColorvoid SetLineColor(Color_t col)Definition TParallelCoord.h:127; TParallelCoord::GetVarListTList * GetVarList()Definition TParallelCoord.h:102; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDef",MatchSource.WIKI,doc/master/gl_2parallelcoordtrans_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2parallelcoordtrans_8C.html
https://root.cern/doc/master/gl_2radialgradients_8C.html:2501,Availability,error,error,2501,"r == -1) {; ::Error(""add_ellipse"", ""failed to find a new color index for a gradient fill"");; return false;; }; ; TEllipse * const newEllipse = new TEllipse(xC, yC, r, r);; newEllipse->SetFillColor(newColor);; newEllipse->Draw();; ; return true;; }; ; //______________________________________________________________________; void radialgradients(bool gl = true); {; gRandom->SetSeed(4357);; ; gStyle->SetCanvasPreferGL(gl);; ; auto cnv = new TCanvas(""radialgradients"", ""radial gradients"", 800, 800);; if (!cnv->UseGL() && !cnv->IsWeb()); ::Warning(""radialgradients"", ""This macro requires either OpenGL or Web canvas to correctly handle gradient colors"");; ; for (unsigned i = 0; i < 100; ++i); add_ellipse(gRandom->Rndm(), gRandom->Rndm(), 0.5 * gRandom->Rndm());; }; Color_tshort Color_tDefinition RtypesCore.h:85; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvas.h; TColorGradient.h; TEllipse.h; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gROOT#define gROOTDefinition TROOT.h:406; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; colorsColor * colorsDefinition X3DBuffer.c:21; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::GetRadialGradientstatic Int_t GetRadialGradient(Double_t r, const std::vector< Int_t > &colors, const std::vector< Double_t > &positions={})Static function: Returns the rad",MatchSource.WIKI,doc/master/gl_2radialgradients_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2radialgradients_8C.html
https://root.cern/doc/master/gl_2transparentpad_8C.html:1684,Energy Efficiency,green,green,1684,"""You can see the transparency ONLY in a pdf or png output (\""File\""->\""Save As\"" ->...)\n""; ""To have transparency in a canvas graphics, you need either OpenGL or Web rendering enabled"");; ; // 2. Some arbitrary histograms.; auto h1 = new TH1F(""TH1F 1"", ""TH1F 1"", 100, -1.5, 1.5);; h1->FillRandom(""gaus"");; ; auto h2 = new TH1F(""TH1F 2"", ""TH1F 2"", 100, -1.5, 0.);; h2->FillRandom(""gaus"");; ; auto h3 = new TH1F(""TH1F 3"", ""TH1F 3"", 100, 0.5, 2.);; h3->FillRandom(""landau"");; ; // 3. Now overlapping transparent pads.; auto pad1 = new TPad(""transparent pad 1"", ""transparent pad 1"", 0.1, 0.1, 0.7, 0.7);; pad1->SetFillColor(TColor::GetColor((Float_t) 1., 0.2, 0.2, 0.25)); // transparent pink, here's the magic!; c1->cd();; pad1->Draw();; pad1->cd();; h1->Draw(""lego2"");; ; auto pad2 = new TPad(""transparent pad 2"", ""transparent pad 2"", 0.2, 0.2, 0.8, 0.8);; pad2->SetFillColor(TColor::GetColor((Float_t) 0.2, 1., 0.2, 0.25)); // transparent green, here's the magic!; c1->cd();; pad2->Draw();; pad2->cd();; h2->Draw();; ; auto pad3 = new TPad(""transparent pad 3"", ""transparent pad 3"", 0.3, 0.3, 0.9, 0.9);; pad3->SetFillColor(TColor::GetColor((Float_t) 0.2, 1., 1., 0.15)); // transparent blue, here's the magic!; c1->cd();; pad3->Draw();; pad3->cd();; h3->Draw();; }; ; Float_tfloat Float_tDefinition RtypesCore.h:57; TCanvas.h; TColor.h; TError.h; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TH1F.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TCanvasThe Canvas class.Definition TCanvas.h:23; TColor::GetColorstatic Int_t GetColor(const char *hexcolor)Static method returning color number for color specified by hex color string of form: ""#rrggbb"",...Definition TColor.cxx:1920; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following di",MatchSource.WIKI,doc/master/gl_2transparentpad_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2transparentpad_8C.html
https://root.cern/doc/master/gl_2transp__text_8C.html:1384,Testability,test,test,1384,"nt text. The macro requires OpenGL or Web-based canvas. ; //Includes for ACLiC (cling does not need them).; #include ""TPaveText.h""; #include ""TCanvas.h""; #include ""TRandom.h""; #include ""TError.h""; #include ""TColor.h""; #include ""TStyle.h""; #include ""TH1F.h""; ; void transp_text(bool gl = true); {; // 1. Create special transparent colors for both pavetext fill color and text color.; auto grayColorIndex = TColor::GetColor((Float_t) 0.8, 0.8, 0.8, 0.85);; auto blackColorIndex = TColor::GetColor((Float_t) 0., 0., 0., 0.5);; ; // 2. Create a TCanvas.; gStyle->SetCanvasPreferGL(gl);; ; auto c1 = new TCanvas(""transp_text"",""transparent text demo"", 10, 10, 900, 500);; if (!c1->UseGL() && !c1->IsWeb()); ::Warning(""transp_text"", ""to use this macro you need either OpenGL or Web"");; ; c1->SetGrid();; c1->SetBottomMargin(0.15);; ; const Int_t nx = 20;; const char *people[nx] = {""Jean"",""Pierre"",""Marie"",""Odile"",; ""Sebastien"",""Fons"",""Rene"",""Nicolas"",""Xavier"",""Greg"",; ""Bjarne"",""Anton"",""Otto"",""Eddy"",""Peter"",""Pasha"",; ""Philippe"",""Suzanne"",""Jeff"",""Valery""};; ; auto h = new TH1F(""h4"", ""test"", nx, 0, nx);; ; h->SetFillColor(38);; for (Int_t i = 0; i < 5000; ++i); h->Fill(gRandom->Gaus(0.5 * nx, 0.2 * nx));; ; h->SetStats(false);; for (Int_t i = 1; i <= nx; ++i); h->GetXaxis()->SetBinLabel(i, people[i - 1]);; ; h->Draw();; ; auto pt = new TPaveText(0.3, 0.3, 0.98, 0.98, ""brNDC"");; //Transparent 'rectangle' with transparent text.; pt->SetFillColor(grayColorIndex);; pt->SetTextColor(blackColorIndex);; ; pt->SetTextSize(0.5);; pt->SetTextAlign(12);; ; pt->AddText(""Hello"");; pt->Draw();; }; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; TCanvas.h; TColor.h; TError.h; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TH1F.h; TPaveText.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TStyle.h; gStyleR__EXTERN T",MatchSource.WIKI,doc/master/gl_2transp__text_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gl_2transp__text_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:247,Availability,error,errors,247,". ROOT: tutorials/graphs/gmultierrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gmultierrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with multiple y errors . ; void gmultierrors() {; TCanvas *c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 0.5};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; ; TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; ; // Graph and x erros drawn with ""APS""; // Stat Errors drawn with ""Z""; // Sys Errors drawn with ""5 s=0.5""; gme->Draw(""APS ; Z ; 5 s=0.5"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProx",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:345,Availability,error,errors,345,". ROOT: tutorials/graphs/gmultierrors.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. gmultierrors.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with multiple y errors . ; void gmultierrors() {; TCanvas *c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; ; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 0.5};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; ; TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; ; // Graph and x erros drawn with ""APS""; // Stat Errors drawn with ""Z""; // Sys Errors drawn with ""5 s=0.5""; gme->Draw(""APS ; Z ; 5 s=0.5"");; ; c1->Update();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProx",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:2442,Availability,error,error,2442,"eDefinition Rtypes.h:66; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:2468,Availability,error,error,2468,"eDefinition Rtypes.h:66; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:2621,Availability,error,error,2621,"Style GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; AuthorSimon Spies ; Definition in file gmultierrors.C. tutorialsgraphsgmultierrors.C. ROOT master - Refer",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:2806,Availability,error,error,2806,"utes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; AuthorSimon Spies ; Definition in file gmultierrors.C. tutorialsgraphsgmultierrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:3008,Availability,error,error,3008,"utes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; AuthorSimon Spies ; Definition in file gmultierrors.C. tutorialsgraphsgmultierrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:3162,Availability,error,error,3162,"utes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; AuthorSimon Spies ; Definition in file gmultierrors.C. tutorialsgraphsgmultierrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/gmultierrors_8C.html:3189,Availability,error,errors,3189,"utes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::AddYErrorvirtual void AddYError(Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr)Add a new y error to the graph and fill it with the values from eyL and eyHDefinition TGraphMultiErrors.cxx:917; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; AuthorSimon Spies ; Definition in file gmultierrors.C. tutorialsgraphsgmultierrors.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/gmultierrors_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/gmultierrors_8C.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:11203,Availability,error,error,11203,"e_t x) const {; 300 return ROOT::Math::exponential_cdf(x, fParams[0]);; 301 }; 302 ; 303 void GoFTest::LogSample() {; 304 transform(fSamples[0].begin(), fSamples[0].end(), fSamples[0].begin(),; 305 std::function<Double_t(Double_t)>(TMath::Log));; 306 }; 307 ; 308/* ; 309 Taken from (1); 310*/ ; 311 Double_t GoFTest::GetSigmaN(const std::vector<size_t> & ns, size_t N) {; 312 // compute moments of AD distribution (from Scholz-Stephen paper, paragraph 3); 313 ; 314 Double_t sigmaN = 0.0, h = 0.0, H = 0.0, g = 0.0, a, b, c, d, k = ns.size();; 315 ; 316 for (size_t i = 0; i < ns.size(); ++i) {; 317 H += 1.0 / double( ns[i] );; 318 }; 319 ; 320 // use approximate formulas for large N; 321 // cache Sum( 1 / i); 322 if (N < 2000) { ; 323 std::vector<double> invI(N); ; 324 for (size_t i = 1; i <= N - 1; ++i) {; 325 invI[i] = 1.0 / i; ; 326 h += invI[i]; ; 327 }; 328 for (size_t i = 1; i <= N - 2; ++i) {; 329 double tmp = invI[N-i];; 330 for (size_t j = i + 1; j <= N - 1; ++j) {; 331 g += tmp * invI[j];; 332 }; 333 }; 334 }; 335 else {; 336 // for N larger than 2000 error difference in g is ~ 5 10^-3 while in h is at the level of 10^-5; 337 const double emc = 0.5772156649015328606065120900824024; // Euler-Mascheroni constant; 338 h = std::log(double(N-1) ) + emc;; 339 g = (M_PI)*(M_PI)/6.0;; 340 }; 341 double k2 = std::pow(k,2);; 342 a = (4 * g - 6) * k + (10 - 6 * g) * H - 4 * g + 6;; 343 b = (2 * g - 4) * k2 + 8 * h * k + (2 * g - 14 * h - 4) * H - 8 * h + 4 * g - 6;; 344 c = (6 * h + 2 * g - 2) * k2 + (4 * h - 4 *g + 6) * k + (2 * h - 6) * H + 4 * h;; 345 d = (2 * h + 6) * k2 - 4 * h * k;; 346 sigmaN += a * std::pow(double(N),3) + b * std::pow(double(N),2) + c * N + d;; 347 sigmaN /= ( double(N - 1) * double(N - 2) * double(N - 3) );; 348 sigmaN = TMath::Sqrt(sigmaN);; 349 return sigmaN;; 350 }; 351 ; 352 ; 353 Double_t GoFTest::PValueADKSamples(size_t nsamples, Double_t tx) {; 354 ; 355 /*; 356 Computation of p-values according to ; 357 ""K-Sample Anderson-Darling Tests"" b",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:37588,Availability,error,error,37588,"t char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TStopwatch.h; WrappedFunction.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe clas",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:47176,Availability,down,down,47176,")Definition GoFTest.cxx:520; ROOT::Math::getSumint getSum(const int *x, int n)Definition GoFTest.cxx:534; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ROOT::Math::CDFWrapperDefinition GoFTest.cxx:40; ROOT::Math::CDFWrapper::CDFWrapperCDFWrapper(const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:50; ROOT::Math::CDFWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:65; ROOT::Math::CDFWrapper::CloneIGenFunction * Clone() const overrideClone a function.Definition GoFTest.cxx:71; ROOT::Math::CDFWrapper::fCDFconst IGenFunction * fCDFDefinition GoFTest.cxx:45; ROOT::Math::CDFWrapper::fXmaxDouble_t fXmaxDefinition GoFTest.cxx:43; ROOT::Math::CDFWrapper::fXminDouble_t fXminDefinition GoFTest.cxx:42; ROOT::Math::CDFWrapper::~CDFWrapper~CDFWrapper() overrideDefinition GoFTest.cxx:48; ROOT::Mat",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:43278,Deployability,integrat,integration,43278,") constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest::fSamplesstd::vector< std::vector< Double_t > > fSamplesThe input data.Definition GoFTest.h:243; ROOT::Math::GoFTest::PValueAD1SampleDouble_t PValueAD1Sample(Double_t A2) constComputation of the 1-Sample Anderson-Darling Test's p-value.Definition GoFTest.cxx:483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(Function &f)method to set the a generic integration functionDefinition Integrator.h:492; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cx",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:43644,Deployability,integrat,integration,43644,"483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(Function &f)method to set the a generic integration functionDefinition Integrator.h:492; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:87; ROOT::Math::PDFIntegral::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:110; ROOT::Math::PDFIntegral::fNormDouble_t fNormDefinition GoFTest.cxx:80; ROOT::Math::PDFIntegral::fPDFconst IGenFunction * fPDFDefinition GoFTest.cxx:82; ROOT::Mat",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:21008,Energy Efficiency,allocate,allocate,21008,"n) {; 535 int i;; 536 int sum = 0;; 537 ; 538 for (i = 0; i < n; i++) {; 539 sum += x[i];; 540 }; 541 ; 542 return(sum);; 543}; 544 ; 545 ; 546void adkTestStat(double *adk, const std::vector<std::vector<double> > & samples, const std::vector<double> & zstar) {; 547 ; 548 int i;; 549 int j;; 550 ; 551 int nsum; /* total sample size = n_1 + ... + n_k */; 552 int k = samples.size();; 553 int l = zstar.size();; 554 ; 555 /* fij records the number of observations in the ith sample coinciding; 556 with zstar[j], where i = 1, ..., k, and j = 1, ..., l */; 557 std::vector<int> fij (k*l);; 558 /* lvec is an integer vector with length l,; 559 whose jth entry = \sum_{i=1}^{k} f_{ij}, i.e., the multiplicity; 560 of zstar[j] */; 561 std::vector<int> lvec(l);; 562 ; 563 /* for computation */; 564 double mij;; 565 double maij;; 566 double innerSum;; 567 double aInnerSum;; 568 double bj;; 569 double baj;; 570 double tmp;; 571 ; 572 /* samples is a two-dimensional double array with length k;; 573 it stores an array of k pointers to double arrays which are; 574 the k samples being compared */; 575// double **samples;; 576 ; 577 /* dynamically allocate memory */; 578 //std::vector< std::vector<double> > samples(k);; 579 std::vector<int> ns(k);; 580 nsum = 0;; 581 for (i = 0; i < k; i++) {; 582 ns[i] = samples[i].size();; 583 nsum += ns[i];; 584 }; 585 ; 586 /* fij: k*l integer matrix, where l is the length of zstar and; 587 k is the number of samples being compared; 588 lvec: integer vector of length l, records the multiplicity of; 589 each element of zstar */; 590 for (j = 0; j < l; j++) {; 591 lvec[j] = 0;; 592 for (i = 0; i < k; i++) {; 593 fij[i + j*k] = getCount(zstar[j], &samples[i][0], ns[i]);; 594 lvec[j] += fij[i + j*k];; 595 }; 596 }; 597 ; 598 // loop on samples to compute the adk's; 599 // Formula (6) and (7) of the paper; 600 adk[0] = adk[1] = 0;; 601 for (i = 0; i < k; i++) {; 602 mij = 0;; 603 maij = 0;; 604 innerSum = 0;; 605 aInnerSum = 0;; 606 ; 607 for (j = 0; j < l;",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:37802,Energy Efficiency,efficient,efficient,37802,"oat_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TStopwatch.h; WrappedFunction.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(co",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:46944,Energy Efficiency,power,power,46944,"ce for new Math classes and functions.; ROOT::Math::adkTestStatvoid adkTestStat(double *adk, const std::vector< std::vector< double > > &samples, const std::vector< double > &zstar)Definition GoFTest.cxx:546; ROOT::Math::getCountint getCount(double z, const double *dat, int n)Definition GoFTest.cxx:520; ROOT::Math::getSumint getSum(const int *x, int n)Definition GoFTest.cxx:534; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ROOT::Math::CDFWrapperDefinition GoFTest.cxx:40; ROOT::Math::CDFWrapper::CDFWrapperCDFWrapper(const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:50; ROOT::Math::CDFWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:65; ROOT::Math::CDFWrapper::CloneIGenFunction * Clone() const overrideClone a function.Definition GoFTest.cxx:71; ROOT::Math::CDFWrapper::fCDFconst IGen",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:1201,Integrability,wrap,wrapper,1201,"(c) 2006 , LCG ROOT MathLib Team *; 6 * *; 7 * *; 8 **********************************************************************/; 9// implementation file for GoFTest; 10 ; 11 ; 12#include <algorithm>; 13#include <functional>; 14#include <iostream>; 15#include <map>; 16#include <memory>; 17#include <numeric>; 18#include <cstring>; 19#include <cassert>; 20 ; 21#include ""Math/Error.h""; 22#include ""Math/Math.h""; 23#include ""Math/IFunction.h""; 24#include ""Math/IFunctionfwd.h""; 25#include ""Math/Integrator.h""; 26#include ""Math/ProbFuncMathCore.h""; 27#include ""Math/WrappedFunction.h""; 28 ; 29#include ""Math/GoFTest.h""; 30 ; 31#include ""Fit/BinData.h""; 32 ; 33#include ""TStopwatch.h""; 34 ; 35/* Note: The references mentioned here are stated in GoFTest.h */; 36 ; 37namespace ROOT {; 38namespace Math {; 39 ; 40 struct CDFWrapper : public IGenFunction {; 41 // wrapper around a cdf function to re-scale for the range; 42 Double_t fXmin; // lower range for x; 43 Double_t fXmax; // lower range for x; 44 Double_t fNorm; // normalization; 45 const IGenFunction* fCDF; // cdf pointer (owned by the class); 46 ; 47 ; 48 ~CDFWrapper() override { if (fCDF) delete fCDF; }; 49 ; 50 CDFWrapper(const IGenFunction& cdf, Double_t xmin=0, Double_t xmax=-1) :; 51 fCDF(cdf.Clone()); 52 {; 53 if (xmin >= xmax) {; 54 fNorm = 1;; 55 fXmin = -std::numeric_limits<double>::infinity();; 56 fXmax = std::numeric_limits<double>::infinity();; 57 }; 58 else {; 59 fNorm = cdf(xmax) - cdf(xmin);; 60 fXmin = xmin;; 61 fXmax = xmax;; 62 }; 63 }; 64 ; 65 Double_t DoEval(Double_t x) const override {; 66 if (x <= fXmin) return 0;; 67 if (x >= fXmax) return 1.0;; 68 return (*fCDF)(x)/fNorm;; 69 }; 70 ; 71 IGenFunction* Clone() const override {; 72 return new CDFWrapper(*fCDF,fXmin,fXmax);; 73 }; 74 };; 75 ; 76 ; 77 class PDFIntegral : public IGenFunction {; 78 Double_t fXmin; // lower range for x; 79 Double_t fXmax; // lower range for x; 80 Double_t fNorm; // normalization; 81 mutable IntegratorOneDim fIntegral;; 82 const IG",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:9075,Integrability,wrap,wrapper,9075,"ty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = new ROOT::Math::WrappedMemFunction<GoFTest, Double_t (GoFTest::*)(Double_t) const>(*this, &GoFTest::GaussianCDF);; 253 if (fParams.empty()) fParams = {0,1};; 254 break;; 255 case kExponential:; 256 cdf = new ROOT::Math::WrappedMemFunction<GoFTest, Double_t (GoFTest::*)(Double_t) const>(*this, &GoFTest::ExponentialCDF);; 257 if (fParams.empty()) fParams = {1};; 258 break;; 259 case kUserDefined:; 260 case kUndefined:; 261 default:; 262 break;; 263 }; 264 fCDF.reset(cdf);; 265 }; 266 ; 267 void GoFTest::SetDistributionFunction(const IGenFunction& f, Bool_t isPDF, Double_t xmin, Double_t xmax) {; 268 if (fDist > kUserDefined) {; 269 MATH_WARN_MSG(""SetDistributionFunction"",""Distribution type is changed to user defined"");; 270 }; 271 fDist = kUserDefined;; 272 // function will be cloned inside the wrapper PDFIntegral of CDFWrapper classes; 273 if (isPDF); 274 fCDF = std::make_unique<PDFIntegral>(f, xmin, xmax );; 275 else; 276 fCDF = std::make_unique<CDFWrapper>(f, xmin, xmax );; 277 }; 278 ; 279 void GoFTest::Instantiate(const Double_t* sample, size_t sampleSize) {; 280 // initialization function for the template constructors; 281 Bool_t badSampleArg = sample == nullptr || sampleSize == 0;; 282 if (badSampleArg) {; 283 std::string msg = ""'sample"";; 284 msg += !sampleSize ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 285 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 286 assert(!badSampleArg);; 287 }; 288 fCDF.reset((IGenFunction*)nullptr);; 289 fDist = kUserDefined;; 290 fSamples = std::vector<std::vector<Double_t> >(1);; 291 fTestSampleFromH0 = kTRUE;; 292 SetSamples(std::vector<const Double_t*>(1, sample), std::vector<size_t>(1, sampleSize));; 293 }; 294 ; 295 Double_t GoFTest::GaussianCDF(Double_t x) const {; 296 return ROOT::Math::normal_cdf(x, fParams[1], fParams[0]);; 297 }; 298 ; 299 Double_t GoFTest::ExponentialCDF(Double_t x) const {; 300 return ROOT::Math::exponential_cdf(x, fPa",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:43278,Integrability,integrat,integration,43278,") constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest::fSamplesstd::vector< std::vector< Double_t > > fSamplesThe input data.Definition GoFTest.h:243; ROOT::Math::GoFTest::PValueAD1SampleDouble_t PValueAD1Sample(Double_t A2) constComputation of the 1-Sample Anderson-Darling Test's p-value.Definition GoFTest.cxx:483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(Function &f)method to set the a generic integration functionDefinition Integrator.h:492; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cx",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:43644,Integrability,integrat,integration,43644,"483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(Function &f)method to set the a generic integration functionDefinition Integrator.h:492; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:87; ROOT::Math::PDFIntegral::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:110; ROOT::Math::PDFIntegral::fNormDouble_t fNormDefinition GoFTest.cxx:80; ROOT::Math::PDFIntegral::fPDFconst IGenFunction * fPDFDefinition GoFTest.cxx:82; ROOT::Mat",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:45080,Integrability,wrap,wrap,45080,"ath::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:87; ROOT::Math::PDFIntegral::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition GoFTest.cxx:110; ROOT::Math::PDFIntegral::fNormDouble_t fNormDefinition GoFTest.cxx:80; ROOT::Math::PDFIntegral::fPDFconst IGenFunction * fPDFDefinition GoFTest.cxx:82; ROOT::Math::PDFIntegral::fXminDouble_t fXminDefinition GoFTest.cxx:78; ROOT::Math::PDFIntegral::fXmaxDouble_t fXmaxDefinition GoFTest.cxx:79; ROOT::Math::PDFIntegral::~PDFIntegral~PDFIntegral() overrideDefinition GoFTest.cxx:85; ROOT::Math::PDFIntegral::fIntegralIntegratorOneDim fIntegralDefinition GoFTest.cxx:81; ROOT::Math::PDFIntegral::CloneIGenFunction * Clone() const overrideClone a function.Definition GoFTest.cxx:119; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; bool; double; int; ROOT::Math::normal_cdfdouble normal_cdf(double x, double sigma=1, double x0=0)Cumulative distribution function of the normal (Gaussian) distribution (lower tail).Definition ProbFuncMathCore.cxx:234; ROOT::Math::exponential_cdfdouble exponential_cdf(double x, double lambda, double x0=0)Cumulative distribution function of the exponential distribution (lower tail).Definition ProbFuncMathCore.cxx:161; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; F#define F(x, y, z); H#define H(x, y, z); MathNamespace for new Math classes and functions.; ROOT::Math::adkTestStatvoid adkTestStat(double *adk, const std::vector< std::vector< double > > &samples, const std::vector< double > &zstar)Definition G",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:10825,Performance,cache,cache,10825," 292 SetSamples(std::vector<const Double_t*>(1, sample), std::vector<size_t>(1, sampleSize));; 293 }; 294 ; 295 Double_t GoFTest::GaussianCDF(Double_t x) const {; 296 return ROOT::Math::normal_cdf(x, fParams[1], fParams[0]);; 297 }; 298 ; 299 Double_t GoFTest::ExponentialCDF(Double_t x) const {; 300 return ROOT::Math::exponential_cdf(x, fParams[0]);; 301 }; 302 ; 303 void GoFTest::LogSample() {; 304 transform(fSamples[0].begin(), fSamples[0].end(), fSamples[0].begin(),; 305 std::function<Double_t(Double_t)>(TMath::Log));; 306 }; 307 ; 308/* ; 309 Taken from (1); 310*/ ; 311 Double_t GoFTest::GetSigmaN(const std::vector<size_t> & ns, size_t N) {; 312 // compute moments of AD distribution (from Scholz-Stephen paper, paragraph 3); 313 ; 314 Double_t sigmaN = 0.0, h = 0.0, H = 0.0, g = 0.0, a, b, c, d, k = ns.size();; 315 ; 316 for (size_t i = 0; i < ns.size(); ++i) {; 317 H += 1.0 / double( ns[i] );; 318 }; 319 ; 320 // use approximate formulas for large N; 321 // cache Sum( 1 / i); 322 if (N < 2000) { ; 323 std::vector<double> invI(N); ; 324 for (size_t i = 1; i <= N - 1; ++i) {; 325 invI[i] = 1.0 / i; ; 326 h += invI[i]; ; 327 }; 328 for (size_t i = 1; i <= N - 2; ++i) {; 329 double tmp = invI[N-i];; 330 for (size_t j = i + 1; j <= N - 1; ++j) {; 331 g += tmp * invI[j];; 332 }; 333 }; 334 }; 335 else {; 336 // for N larger than 2000 error difference in g is ~ 5 10^-3 while in h is at the level of 10^-5; 337 const double emc = 0.5772156649015328606065120900824024; // Euler-Mascheroni constant; 338 h = std::log(double(N-1) ) + emc;; 339 g = (M_PI)*(M_PI)/6.0;; 340 }; 341 double k2 = std::pow(k,2);; 342 a = (4 * g - 6) * k + (10 - 6 * g) * H - 4 * g + 6;; 343 b = (2 * g - 4) * k2 + 8 * h * k + (2 * g - 14 * h - 4) * H - 8 * h + 4 * g - 6;; 344 c = (6 * h + 2 * g - 2) * k2 + (4 * h - 4 *g + 6) * k + (2 * h - 6) * H + 4 * h;; 345 d = (2 * h + 6) * k2 - 4 * h * k;; 346 sigmaN += a * std::pow(double(N),3) + b * std::pow(double(N),2) + c * N + d;; 347 sigmaN /= ( double(N - ",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:38559,Performance,perform,performing,38559,"e binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoF",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:43257,Performance,perform,performing,43257,") constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest::fSamplesstd::vector< std::vector< Double_t > > fSamplesThe input data.Definition GoFTest.h:243; ROOT::Math::GoFTest::PValueAD1SampleDouble_t PValueAD1Sample(Double_t A2) constComputation of the 1-Sample Anderson-Darling Test's p-value.Definition GoFTest.cxx:483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(Function &f)method to set the a generic integration functionDefinition Integrator.h:492; ROOT::Math::IntegratorOneDim::Integraldouble Integral(Function &f, double a, double b)evaluate the Integral of a function f over the defined interval (a,b)Definition Integrator.h:499; ROOT::Math::IntegratorOneDim::IntegralLowdouble IntegralLow(const IGenFunction &f, double b)evaluate the Integral of a function f over the over the semi-infinite interval (-inf,...Definition Integrator.h:296; ROOT::Math::PDFIntegralDefinition GoFTest.cxx:77; ROOT::Math::PDFIntegral::PDFIntegralPDFIntegral(const IGenFunction &pdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cx",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:13029,Safety,avoid,avoid,13029,"t tx) {; 354 ; 355 /*; 356 Computation of p-values according to ; 357 ""K-Sample Anderson-Darling Tests"" by F.W. Scholz ; 358 and M.A. Stephens (1987), Journal of the American Statistical Association, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m quantiles as obtained via simulation of; 363 the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; 364 for each sample, and after standardization, in order to emulate the Table 1 ; 365 values given in the above reference. However, here we estimate p-quantiles; 366 for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; 367 .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; 368 .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; 369 First the appropriate p-quantiles are determined from those simulated; 370 for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; 371 Since we use only m=2 we avoid this interpolation. ; 372 ; 373 Next linear inetrpolation to find the observed p value given the observed test statistic value. ; 374 We use interpolation in the test statistic -> log((1-p)/p) domain; 375 and we extrapolatelinearly) beyond p = .00001 and .99999.; 376 */; 377 ; 378 // sample values ; 379 //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; 380 //int ns = ms.size();; 381 const int ns = 8;; 382 double ts[ ] = { -1.1954, -1.5806, -1.8172, ; 383 -2.0032, -2.2526, -2.4204, -2.5283, -4.2649, -1.1786, -1.5394, ; 384 -1.7728, -1.9426, -2.1685, -2.3288, -2.4374, -3.8906, -1.166, ; 385 -1.5193, -1.7462, -1.9067, -2.126, -2.2818, -2.3926, -3.719, ; 386 -1.1407, -1.4659, -1.671, -1.8105, -2.0048, -2.1356, -2.2348, ; 387 -3.2905, -1.1253, -1.4371, -1.6314, -1.7619, -1.9396, -2.0637, ; 388 -2.1521, -3.0902, -1.0777, -1.3503, -1.5102, -1.6177, -1.761, ; 389 -1.8537, -1.9178, -2.5758, -1.0489, -1.2984, -1.4415, -1.5355, ; 390 -1.6625, -1.738, -1.7936, -2.3263, -0.9978",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:4608,Testability,assert,assert,4608,";; 121 }; 122 };; 123 ; 124 void GoFTest::SetDistribution(EDistribution dist, const std::vector<double> & distParams ) {; 125 if (!(kGaussian <= dist && dist <= kExponential)) {; 126 MATH_ERROR_MSG(""SetDistribution"", ""Cannot set distribution type! Distribution type option must be enabled."");; 127 return;; 128 }; 129 fDist = dist;; 130 SetParameters(distParams);; 131 SetCDF();; 132 }; 133 ; 134 GoFTest::GoFTest( size_t sample1Size, const Double_t* sample1, size_t sample2Size, const Double_t* sample2 ); 135 : fDist(kUndefined),; 136 fSamples(std::vector<std::vector<Double_t> >(2)),; 137 fTestSampleFromH0(kFALSE) {; 138 Bool_t badSampleArg = sample1 == nullptr || sample1Size == 0;; 139 if (badSampleArg) {; 140 std::string msg = ""'sample1"";; 141 msg += !sample1Size ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 142 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 143 assert(!badSampleArg);; 144 }; 145 badSampleArg = sample2 == nullptr || sample2Size == 0;; 146 if (badSampleArg) {; 147 std::string msg = ""'sample2"";; 148 msg += !sample2Size ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 149 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 150 assert(!badSampleArg);; 151 }; 152 std::vector<const Double_t*> samples(2);; 153 std::vector<size_t> samplesSizes(2);; 154 samples[0] = sample1;; 155 samples[1] = sample2;; 156 samplesSizes[0] = sample1Size;; 157 samplesSizes[1] = sample2Size;; 158 SetSamples(samples, samplesSizes);; 159 }; 160 ; 161 GoFTest::GoFTest(size_t sampleSize, const Double_t* sample, EDistribution dist, const std::vector<double> & distParams); 162 : fDist(dist),; 163 fSamples(std::vector<std::vector<Double_t> >(1)),; 164 fTestSampleFromH0(kTRUE) {; 165 Bool_t badSampleArg = sample == nullptr || sampleSize == 0;; 166 if (badSampleArg) {; 167 std::string msg = ""'sample"";; 168 msg += !sampleSize ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 169 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 170 assert(!badSampleArg);; 171 }; 172 std::vector<const Double_t*> s",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:4887,Testability,assert,assert,4887,",; 136 fSamples(std::vector<std::vector<Double_t> >(2)),; 137 fTestSampleFromH0(kFALSE) {; 138 Bool_t badSampleArg = sample1 == nullptr || sample1Size == 0;; 139 if (badSampleArg) {; 140 std::string msg = ""'sample1"";; 141 msg += !sample1Size ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 142 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 143 assert(!badSampleArg);; 144 }; 145 badSampleArg = sample2 == nullptr || sample2Size == 0;; 146 if (badSampleArg) {; 147 std::string msg = ""'sample2"";; 148 msg += !sample2Size ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 149 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 150 assert(!badSampleArg);; 151 }; 152 std::vector<const Double_t*> samples(2);; 153 std::vector<size_t> samplesSizes(2);; 154 samples[0] = sample1;; 155 samples[1] = sample2;; 156 samplesSizes[0] = sample1Size;; 157 samplesSizes[1] = sample2Size;; 158 SetSamples(samples, samplesSizes);; 159 }; 160 ; 161 GoFTest::GoFTest(size_t sampleSize, const Double_t* sample, EDistribution dist, const std::vector<double> & distParams); 162 : fDist(dist),; 163 fSamples(std::vector<std::vector<Double_t> >(1)),; 164 fTestSampleFromH0(kTRUE) {; 165 Bool_t badSampleArg = sample == nullptr || sampleSize == 0;; 166 if (badSampleArg) {; 167 std::string msg = ""'sample"";; 168 msg += !sampleSize ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 169 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 170 assert(!badSampleArg);; 171 }; 172 std::vector<const Double_t*> samples(1, sample);; 173 std::vector<size_t> samplesSizes(1, sampleSize);; 174 SetSamples(samples, samplesSizes);; 175 SetParameters(distParams);; 176 SetCDF();; 177 }; 178 ; 179 GoFTest::~GoFTest() {}; 180 ; 181 void GoFTest::SetSamples(std::vector<const Double_t*> samples, const std::vector<size_t> samplesSizes) {; 182 fCombinedSamples.assign(std::accumulate(samplesSizes.begin(), samplesSizes.end(), 0u), 0.0);; 183 size_t combinedSamplesSize = 0;; 184 for (size_t i = 0; i < samples.size(); ++i) {; 185 fSamples[i].assign(sam",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:5668,Testability,assert,assert,5668,"est"", msg.c_str());; 150 assert(!badSampleArg);; 151 }; 152 std::vector<const Double_t*> samples(2);; 153 std::vector<size_t> samplesSizes(2);; 154 samples[0] = sample1;; 155 samples[1] = sample2;; 156 samplesSizes[0] = sample1Size;; 157 samplesSizes[1] = sample2Size;; 158 SetSamples(samples, samplesSizes);; 159 }; 160 ; 161 GoFTest::GoFTest(size_t sampleSize, const Double_t* sample, EDistribution dist, const std::vector<double> & distParams); 162 : fDist(dist),; 163 fSamples(std::vector<std::vector<Double_t> >(1)),; 164 fTestSampleFromH0(kTRUE) {; 165 Bool_t badSampleArg = sample == nullptr || sampleSize == 0;; 166 if (badSampleArg) {; 167 std::string msg = ""'sample"";; 168 msg += !sampleSize ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 169 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 170 assert(!badSampleArg);; 171 }; 172 std::vector<const Double_t*> samples(1, sample);; 173 std::vector<size_t> samplesSizes(1, sampleSize);; 174 SetSamples(samples, samplesSizes);; 175 SetParameters(distParams);; 176 SetCDF();; 177 }; 178 ; 179 GoFTest::~GoFTest() {}; 180 ; 181 void GoFTest::SetSamples(std::vector<const Double_t*> samples, const std::vector<size_t> samplesSizes) {; 182 fCombinedSamples.assign(std::accumulate(samplesSizes.begin(), samplesSizes.end(), 0u), 0.0);; 183 size_t combinedSamplesSize = 0;; 184 for (size_t i = 0; i < samples.size(); ++i) {; 185 fSamples[i].assign(samples[i], samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all ident",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:6924,Testability,assert,assert,6924,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7127,Testability,test,test,7127,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7161,Testability,test,testStat,7161,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7192,Testability,test,test,7192,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7262,Testability,test,testStat,7262,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7343,Testability,test,testStat,7343,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7416,Testability,test,testStat,7416,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7499,Testability,test,testStat,7499,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7574,Testability,test,test,7574,"samples[i] + samplesSizes[i]);; 186 std::sort(fSamples[i].begin(), fSamples[i].end());; 187 for (size_t j = 0; j < samplesSizes[i]; ++j) {; 188 fCombinedSamples[combinedSamplesSize + j] = samples[i][j];; 189 }; 190 combinedSamplesSize += samplesSizes[i];; 191 }; 192 std::sort(fCombinedSamples.begin(), fCombinedSamples.end());; 193 ; 194 Bool_t degenerateSamples = *(fCombinedSamples.begin()) == *(fCombinedSamples.end() - 1);; 195 if (degenerateSamples) {; 196 std::string msg = ""Degenerate sample"";; 197 msg += samplesSizes.size() > 1 ? ""s!"" : ""!"";; 198 msg += "" Sampling values all identical."";; 199 MATH_ERROR_MSG(""SetSamples"", msg.c_str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = n",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:7651,Testability,test,test,7651,"str());; 200 assert(!degenerateSamples);; 201 }; 202 }; 203 ; 204 void GoFTest::SetParameters(const std::vector<double> & distParams) {; 205 fParams = distParams;; 206 }; 207 ; 208 void GoFTest::operator()(ETestType test, Double_t& pvalue, Double_t& testStat) const {; 209 switch (test) {; 210 default:; 211 case kAD:; 212 AndersonDarlingTest(pvalue, testStat);; 213 break;; 214 case kAD2s:; 215 AndersonDarling2SamplesTest(pvalue, testStat);; 216 break;; 217 case kKS:; 218 KolmogorovSmirnovTest(pvalue, testStat);; 219 break;; 220 case kKS2s:; 221 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 222 }; 223 }; 224 ; 225 Double_t GoFTest::operator()(ETestType test, const Char_t* option) const {; 226 Double_t result = 0.0;; 227 switch (test) {; 228 default:; 229 case kAD:; 230 result = AndersonDarlingTest(option);; 231 break;; 232 case kAD2s:; 233 result = AndersonDarling2SamplesTest(option);; 234 break;; 235 case kKS:; 236 result = KolmogorovSmirnovTest(option);; 237 break;; 238 case kKS2s:; 239 result = KolmogorovSmirnov2SamplesTest(option);; 240 }; 241 return result;; 242 }; 243 ; 244 void GoFTest::SetCDF() { // Setting parameter-free distributions; 245 IGenFunction* cdf = nullptr;; 246 switch (fDist) {; 247 case kLogNormal:; 248 LogSample();; 249 if (fParams.empty()) fParams = {0,1};; 250 /* fall through */; 251 case kGaussian :; 252 cdf = new ROOT::Math::WrappedMemFunction<GoFTest, Double_t (GoFTest::*)(Double_t) const>(*this, &GoFTest::GaussianCDF);; 253 if (fParams.empty()) fParams = {0,1};; 254 break;; 255 case kExponential:; 256 cdf = new ROOT::Math::WrappedMemFunction<GoFTest, Double_t (GoFTest::*)(Double_t) const>(*this, &GoFTest::ExponentialCDF);; 257 if (fParams.empty()) fParams = {1};; 258 break;; 259 case kUserDefined:; 260 case kUndefined:; 261 default:; 262 break;; 263 }; 264 fCDF.reset(cdf);; 265 }; 266 ; 267 void GoFTest::SetDistributionFunction(const IGenFunction& f, Bool_t isPDF, Double_t xmin, Double_t xmax) {; 268 if (fDist > kUserDefined) {; 269 MAT",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:9663,Testability,assert,assert,9663,"ase kUndefined:; 261 default:; 262 break;; 263 }; 264 fCDF.reset(cdf);; 265 }; 266 ; 267 void GoFTest::SetDistributionFunction(const IGenFunction& f, Bool_t isPDF, Double_t xmin, Double_t xmax) {; 268 if (fDist > kUserDefined) {; 269 MATH_WARN_MSG(""SetDistributionFunction"",""Distribution type is changed to user defined"");; 270 }; 271 fDist = kUserDefined;; 272 // function will be cloned inside the wrapper PDFIntegral of CDFWrapper classes; 273 if (isPDF); 274 fCDF = std::make_unique<PDFIntegral>(f, xmin, xmax );; 275 else; 276 fCDF = std::make_unique<CDFWrapper>(f, xmin, xmax );; 277 }; 278 ; 279 void GoFTest::Instantiate(const Double_t* sample, size_t sampleSize) {; 280 // initialization function for the template constructors; 281 Bool_t badSampleArg = sample == nullptr || sampleSize == 0;; 282 if (badSampleArg) {; 283 std::string msg = ""'sample"";; 284 msg += !sampleSize ? ""Size' cannot be zero"" : ""' cannot be zero-length"";; 285 MATH_ERROR_MSG(""GoFTest"", msg.c_str());; 286 assert(!badSampleArg);; 287 }; 288 fCDF.reset((IGenFunction*)nullptr);; 289 fDist = kUserDefined;; 290 fSamples = std::vector<std::vector<Double_t> >(1);; 291 fTestSampleFromH0 = kTRUE;; 292 SetSamples(std::vector<const Double_t*>(1, sample), std::vector<size_t>(1, sampleSize));; 293 }; 294 ; 295 Double_t GoFTest::GaussianCDF(Double_t x) const {; 296 return ROOT::Math::normal_cdf(x, fParams[1], fParams[0]);; 297 }; 298 ; 299 Double_t GoFTest::ExponentialCDF(Double_t x) const {; 300 return ROOT::Math::exponential_cdf(x, fParams[0]);; 301 }; 302 ; 303 void GoFTest::LogSample() {; 304 transform(fSamples[0].begin(), fSamples[0].end(), fSamples[0].begin(),; 305 std::function<Double_t(Double_t)>(TMath::Log));; 306 }; 307 ; 308/* ; 309 Taken from (1); 310*/ ; 311 Double_t GoFTest::GetSigmaN(const std::vector<size_t> & ns, size_t N) {; 312 // compute moments of AD distribution (from Scholz-Stephen paper, paragraph 3); 313 ; 314 Double_t sigmaN = 0.0, h = 0.0, H = 0.0, g = 0.0, a, b, c, d, k = ns.size();; 3",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:11379,Testability,log,log,11379,"ath::Log));; 306 }; 307 ; 308/* ; 309 Taken from (1); 310*/ ; 311 Double_t GoFTest::GetSigmaN(const std::vector<size_t> & ns, size_t N) {; 312 // compute moments of AD distribution (from Scholz-Stephen paper, paragraph 3); 313 ; 314 Double_t sigmaN = 0.0, h = 0.0, H = 0.0, g = 0.0, a, b, c, d, k = ns.size();; 315 ; 316 for (size_t i = 0; i < ns.size(); ++i) {; 317 H += 1.0 / double( ns[i] );; 318 }; 319 ; 320 // use approximate formulas for large N; 321 // cache Sum( 1 / i); 322 if (N < 2000) { ; 323 std::vector<double> invI(N); ; 324 for (size_t i = 1; i <= N - 1; ++i) {; 325 invI[i] = 1.0 / i; ; 326 h += invI[i]; ; 327 }; 328 for (size_t i = 1; i <= N - 2; ++i) {; 329 double tmp = invI[N-i];; 330 for (size_t j = i + 1; j <= N - 1; ++j) {; 331 g += tmp * invI[j];; 332 }; 333 }; 334 }; 335 else {; 336 // for N larger than 2000 error difference in g is ~ 5 10^-3 while in h is at the level of 10^-5; 337 const double emc = 0.5772156649015328606065120900824024; // Euler-Mascheroni constant; 338 h = std::log(double(N-1) ) + emc;; 339 g = (M_PI)*(M_PI)/6.0;; 340 }; 341 double k2 = std::pow(k,2);; 342 a = (4 * g - 6) * k + (10 - 6 * g) * H - 4 * g + 6;; 343 b = (2 * g - 4) * k2 + 8 * h * k + (2 * g - 14 * h - 4) * H - 8 * h + 4 * g - 6;; 344 c = (6 * h + 2 * g - 2) * k2 + (4 * h - 4 *g + 6) * k + (2 * h - 6) * H + 4 * h;; 345 d = (2 * h + 6) * k2 - 4 * h * k;; 346 sigmaN += a * std::pow(double(N),3) + b * std::pow(double(N),2) + c * N + d;; 347 sigmaN /= ( double(N - 1) * double(N - 2) * double(N - 3) );; 348 sigmaN = TMath::Sqrt(sigmaN);; 349 return sigmaN;; 350 }; 351 ; 352 ; 353 Double_t GoFTest::PValueADKSamples(size_t nsamples, Double_t tx) {; 354 ; 355 /*; 356 Computation of p-values according to ; 357 ""K-Sample Anderson-Darling Tests"" by F.W. Scholz ; 358 and M.A. Stephens (1987), Journal of the American Statistical Association, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m qu",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:12429,Testability,test,test,12429,"d::pow(k,2);; 342 a = (4 * g - 6) * k + (10 - 6 * g) * H - 4 * g + 6;; 343 b = (2 * g - 4) * k2 + 8 * h * k + (2 * g - 14 * h - 4) * H - 8 * h + 4 * g - 6;; 344 c = (6 * h + 2 * g - 2) * k2 + (4 * h - 4 *g + 6) * k + (2 * h - 6) * H + 4 * h;; 345 d = (2 * h + 6) * k2 - 4 * h * k;; 346 sigmaN += a * std::pow(double(N),3) + b * std::pow(double(N),2) + c * N + d;; 347 sigmaN /= ( double(N - 1) * double(N - 2) * double(N - 3) );; 348 sigmaN = TMath::Sqrt(sigmaN);; 349 return sigmaN;; 350 }; 351 ; 352 ; 353 Double_t GoFTest::PValueADKSamples(size_t nsamples, Double_t tx) {; 354 ; 355 /*; 356 Computation of p-values according to ; 357 ""K-Sample Anderson-Darling Tests"" by F.W. Scholz ; 358 and M.A. Stephens (1987), Journal of the American Statistical Association, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m quantiles as obtained via simulation of; 363 the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; 364 for each sample, and after standardization, in order to emulate the Table 1 ; 365 values given in the above reference. However, here we estimate p-quantiles; 366 for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; 367 .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; 368 .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; 369 First the appropriate p-quantiles are determined from those simulated; 370 for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; 371 Since we use only m=2 we avoid this interpolation. ; 372 ; 373 Next linear inetrpolation to find the observed p value given the observed test statistic value. ; 374 We use interpolation in the test statistic -> log((1-p)/p) domain; 375 and we extrapolatelinearly) beyond p = .00001 and .99999.; 376 */; 377 ; 378 // sample values ; 379 //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; 380 //int ns = ms.size();; 381 const int ns = 8;; 382 dou",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:13141,Testability,test,test,13141,"erson-Darling Tests"" by F.W. Scholz ; 358 and M.A. Stephens (1987), Journal of the American Statistical Association, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m quantiles as obtained via simulation of; 363 the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; 364 for each sample, and after standardization, in order to emulate the Table 1 ; 365 values given in the above reference. However, here we estimate p-quantiles; 366 for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; 367 .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; 368 .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; 369 First the appropriate p-quantiles are determined from those simulated; 370 for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; 371 Since we use only m=2 we avoid this interpolation. ; 372 ; 373 Next linear inetrpolation to find the observed p value given the observed test statistic value. ; 374 We use interpolation in the test statistic -> log((1-p)/p) domain; 375 and we extrapolatelinearly) beyond p = .00001 and .99999.; 376 */; 377 ; 378 // sample values ; 379 //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; 380 //int ns = ms.size();; 381 const int ns = 8;; 382 double ts[ ] = { -1.1954, -1.5806, -1.8172, ; 383 -2.0032, -2.2526, -2.4204, -2.5283, -4.2649, -1.1786, -1.5394, ; 384 -1.7728, -1.9426, -2.1685, -2.3288, -2.4374, -3.8906, -1.166, ; 385 -1.5193, -1.7462, -1.9067, -2.126, -2.2818, -2.3926, -3.719, ; 386 -1.1407, -1.4659, -1.671, -1.8105, -2.0048, -2.1356, -2.2348, ; 387 -3.2905, -1.1253, -1.4371, -1.6314, -1.7619, -1.9396, -2.0637, ; 388 -2.1521, -3.0902, -1.0777, -1.3503, -1.5102, -1.6177, -1.761, ; 389 -1.8537, -1.9178, -2.5758, -1.0489, -1.2984, -1.4415, -1.5355, ; 390 -1.6625, -1.738, -1.7936, -2.3263, -0.9978, -1.2098, -1.3251, ; 391 -1.4007, -1.4977, -1.5555, -1.5941, -1.96, -0.9417, -1.1",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:13197,Testability,test,test,13197,"on, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m quantiles as obtained via simulation of; 363 the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; 364 for each sample, and after standardization, in order to emulate the Table 1 ; 365 values given in the above reference. However, here we estimate p-quantiles; 366 for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; 367 .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; 368 .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; 369 First the appropriate p-quantiles are determined from those simulated; 370 for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; 371 Since we use only m=2 we avoid this interpolation. ; 372 ; 373 Next linear inetrpolation to find the observed p value given the observed test statistic value. ; 374 We use interpolation in the test statistic -> log((1-p)/p) domain; 375 and we extrapolatelinearly) beyond p = .00001 and .99999.; 376 */; 377 ; 378 // sample values ; 379 //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; 380 //int ns = ms.size();; 381 const int ns = 8;; 382 double ts[ ] = { -1.1954, -1.5806, -1.8172, ; 383 -2.0032, -2.2526, -2.4204, -2.5283, -4.2649, -1.1786, -1.5394, ; 384 -1.7728, -1.9426, -2.1685, -2.3288, -2.4374, -3.8906, -1.166, ; 385 -1.5193, -1.7462, -1.9067, -2.126, -2.2818, -2.3926, -3.719, ; 386 -1.1407, -1.4659, -1.671, -1.8105, -2.0048, -2.1356, -2.2348, ; 387 -3.2905, -1.1253, -1.4371, -1.6314, -1.7619, -1.9396, -2.0637, ; 388 -2.1521, -3.0902, -1.0777, -1.3503, -1.5102, -1.6177, -1.761, ; 389 -1.8537, -1.9178, -2.5758, -1.0489, -1.2984, -1.4415, -1.5355, ; 390 -1.6625, -1.738, -1.7936, -2.3263, -0.9978, -1.2098, -1.3251, ; 391 -1.4007, -1.4977, -1.5555, -1.5941, -1.96, -0.9417, -1.1187, ; 392 -1.209, -1.2671, -1.3382, -1.379, -1.405, -1.6449, -0.8981, -1.0491, ; 393 -1.1235, -1.1692, -1.2249, ",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:13215,Testability,log,log,13215,"on, ; 359 Vol 82, No. 399, pp 918-924.; 360 Code from kSamples package from R (author F. Scholtz); 361 ; 362 This function uses the upper T_m quantiles as obtained via simulation of; 363 the Anderson-Darling test statistics (Nsim = 2*10^6) with sample sizes n=500; 364 for each sample, and after standardization, in order to emulate the Table 1 ; 365 values given in the above reference. However, here we estimate p-quantiles; 366 for p = .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,; 367 .1,.2,.3,.4,.5,.6,.7,.8,.9,.925,.95,.975,.99,.9925,.995,.9975,.999,; 368 .99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999; 369 First the appropriate p-quantiles are determined from those simulated; 370 for ms = 1,2,3,4,6,8,10, Inf, interpolating to the given value of m. ; 371 Since we use only m=2 we avoid this interpolation. ; 372 ; 373 Next linear inetrpolation to find the observed p value given the observed test statistic value. ; 374 We use interpolation in the test statistic -> log((1-p)/p) domain; 375 and we extrapolatelinearly) beyond p = .00001 and .99999.; 376 */; 377 ; 378 // sample values ; 379 //double ms[] = { 1, 2, 3, 4, 6, 8, 10, TMath::Infinity() };; 380 //int ns = ms.size();; 381 const int ns = 8;; 382 double ts[ ] = { -1.1954, -1.5806, -1.8172, ; 383 -2.0032, -2.2526, -2.4204, -2.5283, -4.2649, -1.1786, -1.5394, ; 384 -1.7728, -1.9426, -2.1685, -2.3288, -2.4374, -3.8906, -1.166, ; 385 -1.5193, -1.7462, -1.9067, -2.126, -2.2818, -2.3926, -3.719, ; 386 -1.1407, -1.4659, -1.671, -1.8105, -2.0048, -2.1356, -2.2348, ; 387 -3.2905, -1.1253, -1.4371, -1.6314, -1.7619, -1.9396, -2.0637, ; 388 -2.1521, -3.0902, -1.0777, -1.3503, -1.5102, -1.6177, -1.761, ; 389 -1.8537, -1.9178, -2.5758, -1.0489, -1.2984, -1.4415, -1.5355, ; 390 -1.6625, -1.738, -1.7936, -2.3263, -0.9978, -1.2098, -1.3251, ; 391 -1.4007, -1.4977, -1.5555, -1.5941, -1.96, -0.9417, -1.1187, ; 392 -1.209, -1.2671, -1.3382, -1.379, -1.405, -1.6449, -0.8981, -1.0491, ; 393 -1.1235, -1.1692, -1.2249, ",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:16354,Testability,assert,assert,16354,"4022, 4.1791, ; 410 3.9357, 3.7809, 3.6963, 2.807, 6.4954, 5.5823, 5.1456, 4.8657, ; 411 4.5506, 4.3275, 4.2228, 3.0902, 6.8279, 5.8282, 5.3658, 5.0749, ; 412 4.7318, 4.4923, 4.3642, 3.1747, 7.2755, 6.197, 5.6715, 5.3642, ; 413 4.9991, 4.7135, 4.5945, 3.2905, 8.1885, 6.8537, 6.2077, 5.8499, ; 414 5.4246, 5.1137, 4.9555, 3.4808, 9.3061, 7.6592, 6.85, 6.4806, ; 415 5.9919, 5.6122, 5.5136, 3.719, 9.6132, 7.9234, 7.1025, 6.6731, ; 416 6.1549, 5.8217, 5.7345, 3.7911, 10.0989, 8.2395, 7.4326, 6.9567, ; 417 6.3908, 6.011, 5.9566, 3.8906, 10.8825, 8.8994, 7.8934, 7.4501, ; 418 6.9009, 6.4538, 6.2705, 4.0556, 11.8537, 9.5482, 8.5568, 8.0283, ; 419 7.4418, 6.9524, 6.6195, 4.2649 };; 420 ; 421 ; 422 ; 423 ; 424 ; 425 // p values bins ; 426 double p[] = { .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,.1,.2,.3,.4,.5,.6,.7,.8,.9,; 427 .925,.95,.975,.99,.9925,.995,.9975,.999,.99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999 };; 428 ; 429 //int nbins = p.size();; 430 const int nbins = 35;; 431 //assert ( nbins*ns == ts.size() ); ; 432 ; 433 // get ts values for nsamples = 2; 434 // corresponding value is for m=nsamples-1; 435 int offset = 0; // for m = 1 (i.e. for nsamples = 2); 436 if (nsamples != 2) { ; 437 MATH_ERROR_MSG(""InterpolatePValues"", ""Interpolation not implemented for nsamples not equal to 2"");; 438 return 0;; 439 }; 440 std::vector<double> ts2(nbins); // ts values for nsamples = 2; 441 std::vector<double> lp(nbins); // log ( p / (1-p) ); 442 for (int i = 0; i < nbins; ++i) ; 443 { ; 444 ts2[i] = ts[offset+ i * ns]; ; 445 p[i] = 1.-p[i];; 446 lp[i] = std::log( p[i]/(1.-p[i] ) ); ; 447 }; 448 // do linear interpolation to find right lp value for given observed test staistic value; 449 //auto it = std::lower_bound(ts2.begin(), ts2.end(), tx ); ; 450 int i1 = std::distance(ts2.begin(), std::lower_bound(ts2.begin(), ts2.end(), tx ) ) - 1; ; 451 int i2 = i1+1;; 452 // if tx is before min of tabulated data; 453 if (i1 < 0) { ; 454 i1 = 0;; 455 i2 = 1;; 456 }; 45",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:16799,Testability,log,log,16799,"9, 5.6122, 5.5136, 3.719, 9.6132, 7.9234, 7.1025, 6.6731, ; 416 6.1549, 5.8217, 5.7345, 3.7911, 10.0989, 8.2395, 7.4326, 6.9567, ; 417 6.3908, 6.011, 5.9566, 3.8906, 10.8825, 8.8994, 7.8934, 7.4501, ; 418 6.9009, 6.4538, 6.2705, 4.0556, 11.8537, 9.5482, 8.5568, 8.0283, ; 419 7.4418, 6.9524, 6.6195, 4.2649 };; 420 ; 421 ; 422 ; 423 ; 424 ; 425 // p values bins ; 426 double p[] = { .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,.1,.2,.3,.4,.5,.6,.7,.8,.9,; 427 .925,.95,.975,.99,.9925,.995,.9975,.999,.99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999 };; 428 ; 429 //int nbins = p.size();; 430 const int nbins = 35;; 431 //assert ( nbins*ns == ts.size() ); ; 432 ; 433 // get ts values for nsamples = 2; 434 // corresponding value is for m=nsamples-1; 435 int offset = 0; // for m = 1 (i.e. for nsamples = 2); 436 if (nsamples != 2) { ; 437 MATH_ERROR_MSG(""InterpolatePValues"", ""Interpolation not implemented for nsamples not equal to 2"");; 438 return 0;; 439 }; 440 std::vector<double> ts2(nbins); // ts values for nsamples = 2; 441 std::vector<double> lp(nbins); // log ( p / (1-p) ); 442 for (int i = 0; i < nbins; ++i) ; 443 { ; 444 ts2[i] = ts[offset+ i * ns]; ; 445 p[i] = 1.-p[i];; 446 lp[i] = std::log( p[i]/(1.-p[i] ) ); ; 447 }; 448 // do linear interpolation to find right lp value for given observed test staistic value; 449 //auto it = std::lower_bound(ts2.begin(), ts2.end(), tx ); ; 450 int i1 = std::distance(ts2.begin(), std::lower_bound(ts2.begin(), ts2.end(), tx ) ) - 1; ; 451 int i2 = i1+1;; 452 // if tx is before min of tabulated data; 453 if (i1 < 0) { ; 454 i1 = 0;; 455 i2 = 1;; 456 }; 457 // if tx is after max of tabulated data; 458 if (i2 >= int(ts2.size()) ) { ; 459 i1 = ts2.size()-2; ; 460 i2 = ts2.size()-1;; 461 }; 462 ; 463 //std::cout << i1 << "" , "" << i2 << std::endl;; 464 assert(i1 < (int) lp.size() && i2 < (int) lp.size() ); ; 465 double lp1 = lp[i1]; ; 466 double lp2 = lp[i2];; 467 double tx1 = ts2[i1];; 468 double tx2 = ts2[i2];; 469 ; 470 /",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:16937,Testability,log,log,16937,"4538, 6.2705, 4.0556, 11.8537, 9.5482, 8.5568, 8.0283, ; 419 7.4418, 6.9524, 6.6195, 4.2649 };; 420 ; 421 ; 422 ; 423 ; 424 ; 425 // p values bins ; 426 double p[] = { .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,.1,.2,.3,.4,.5,.6,.7,.8,.9,; 427 .925,.95,.975,.99,.9925,.995,.9975,.999,.99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999 };; 428 ; 429 //int nbins = p.size();; 430 const int nbins = 35;; 431 //assert ( nbins*ns == ts.size() ); ; 432 ; 433 // get ts values for nsamples = 2; 434 // corresponding value is for m=nsamples-1; 435 int offset = 0; // for m = 1 (i.e. for nsamples = 2); 436 if (nsamples != 2) { ; 437 MATH_ERROR_MSG(""InterpolatePValues"", ""Interpolation not implemented for nsamples not equal to 2"");; 438 return 0;; 439 }; 440 std::vector<double> ts2(nbins); // ts values for nsamples = 2; 441 std::vector<double> lp(nbins); // log ( p / (1-p) ); 442 for (int i = 0; i < nbins; ++i) ; 443 { ; 444 ts2[i] = ts[offset+ i * ns]; ; 445 p[i] = 1.-p[i];; 446 lp[i] = std::log( p[i]/(1.-p[i] ) ); ; 447 }; 448 // do linear interpolation to find right lp value for given observed test staistic value; 449 //auto it = std::lower_bound(ts2.begin(), ts2.end(), tx ); ; 450 int i1 = std::distance(ts2.begin(), std::lower_bound(ts2.begin(), ts2.end(), tx ) ) - 1; ; 451 int i2 = i1+1;; 452 // if tx is before min of tabulated data; 453 if (i1 < 0) { ; 454 i1 = 0;; 455 i2 = 1;; 456 }; 457 // if tx is after max of tabulated data; 458 if (i2 >= int(ts2.size()) ) { ; 459 i1 = ts2.size()-2; ; 460 i2 = ts2.size()-1;; 461 }; 462 ; 463 //std::cout << i1 << "" , "" << i2 << std::endl;; 464 assert(i1 < (int) lp.size() && i2 < (int) lp.size() ); ; 465 double lp1 = lp[i1]; ; 466 double lp2 = lp[i2];; 467 double tx1 = ts2[i1];; 468 double tx2 = ts2[i2];; 469 ; 470 //std::cout << "" tx1,2 "" << tx1 << "" "" << tx2 << std::endl;; 471 /// find interpolated (or extrapolated value)( ; 472 double lp0 = (lp1-lp2) * (tx - tx2)/ ( tx1-tx2) + lp2; ; 473 ; 474 ; 475 double p0 = exp(lp0)/(1.",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:17043,Testability,test,test,17043,"; 420 ; 421 ; 422 ; 423 ; 424 ; 425 // p values bins ; 426 double p[] = { .00001,.00005,.0001,.0005,.001,.005,.01,.025,.05,.075,.1,.2,.3,.4,.5,.6,.7,.8,.9,; 427 .925,.95,.975,.99,.9925,.995,.9975,.999,.99925,.9995,.99975,.9999,.999925,.99995,.999975,.99999 };; 428 ; 429 //int nbins = p.size();; 430 const int nbins = 35;; 431 //assert ( nbins*ns == ts.size() ); ; 432 ; 433 // get ts values for nsamples = 2; 434 // corresponding value is for m=nsamples-1; 435 int offset = 0; // for m = 1 (i.e. for nsamples = 2); 436 if (nsamples != 2) { ; 437 MATH_ERROR_MSG(""InterpolatePValues"", ""Interpolation not implemented for nsamples not equal to 2"");; 438 return 0;; 439 }; 440 std::vector<double> ts2(nbins); // ts values for nsamples = 2; 441 std::vector<double> lp(nbins); // log ( p / (1-p) ); 442 for (int i = 0; i < nbins; ++i) ; 443 { ; 444 ts2[i] = ts[offset+ i * ns]; ; 445 p[i] = 1.-p[i];; 446 lp[i] = std::log( p[i]/(1.-p[i] ) ); ; 447 }; 448 // do linear interpolation to find right lp value for given observed test staistic value; 449 //auto it = std::lower_bound(ts2.begin(), ts2.end(), tx ); ; 450 int i1 = std::distance(ts2.begin(), std::lower_bound(ts2.begin(), ts2.end(), tx ) ) - 1; ; 451 int i2 = i1+1;; 452 // if tx is before min of tabulated data; 453 if (i1 < 0) { ; 454 i1 = 0;; 455 i2 = 1;; 456 }; 457 // if tx is after max of tabulated data; 458 if (i2 >= int(ts2.size()) ) { ; 459 i1 = ts2.size()-2; ; 460 i2 = ts2.size()-1;; 461 }; 462 ; 463 //std::cout << i1 << "" , "" << i2 << std::endl;; 464 assert(i1 < (int) lp.size() && i2 < (int) lp.size() ); ; 465 double lp1 = lp[i1]; ; 466 double lp2 = lp[i2];; 467 double tx1 = ts2[i1];; 468 double tx2 = ts2[i2];; 469 ; 470 //std::cout << "" tx1,2 "" << tx1 << "" "" << tx2 << std::endl;; 471 /// find interpolated (or extrapolated value)( ; 472 double lp0 = (lp1-lp2) * (tx - tx2)/ ( tx1-tx2) + lp2; ; 473 ; 474 ; 475 double p0 = exp(lp0)/(1. + exp(lp0) );; 476 return p0; ; 477 ; 478 }; 479 ; 480 ; 481/*; 482 Taken from (2); 483*/ Doub",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:17542,Testability,assert,assert,17542,"= 1 (i.e. for nsamples = 2); 436 if (nsamples != 2) { ; 437 MATH_ERROR_MSG(""InterpolatePValues"", ""Interpolation not implemented for nsamples not equal to 2"");; 438 return 0;; 439 }; 440 std::vector<double> ts2(nbins); // ts values for nsamples = 2; 441 std::vector<double> lp(nbins); // log ( p / (1-p) ); 442 for (int i = 0; i < nbins; ++i) ; 443 { ; 444 ts2[i] = ts[offset+ i * ns]; ; 445 p[i] = 1.-p[i];; 446 lp[i] = std::log( p[i]/(1.-p[i] ) ); ; 447 }; 448 // do linear interpolation to find right lp value for given observed test staistic value; 449 //auto it = std::lower_bound(ts2.begin(), ts2.end(), tx ); ; 450 int i1 = std::distance(ts2.begin(), std::lower_bound(ts2.begin(), ts2.end(), tx ) ) - 1; ; 451 int i2 = i1+1;; 452 // if tx is before min of tabulated data; 453 if (i1 < 0) { ; 454 i1 = 0;; 455 i2 = 1;; 456 }; 457 // if tx is after max of tabulated data; 458 if (i2 >= int(ts2.size()) ) { ; 459 i1 = ts2.size()-2; ; 460 i2 = ts2.size()-1;; 461 }; 462 ; 463 //std::cout << i1 << "" , "" << i2 << std::endl;; 464 assert(i1 < (int) lp.size() && i2 < (int) lp.size() ); ; 465 double lp1 = lp[i1]; ; 466 double lp2 = lp[i2];; 467 double tx1 = ts2[i1];; 468 double tx2 = ts2[i2];; 469 ; 470 //std::cout << "" tx1,2 "" << tx1 << "" "" << tx2 << std::endl;; 471 /// find interpolated (or extrapolated value)( ; 472 double lp0 = (lp1-lp2) * (tx - tx2)/ ( tx1-tx2) + lp2; ; 473 ; 474 ; 475 double p0 = exp(lp0)/(1. + exp(lp0) );; 476 return p0; ; 477 ; 478 }; 479 ; 480 ; 481/*; 482 Taken from (2); 483*/ Double_t GoFTest::PValueAD1Sample(Double_t A2) const {; 484 Double_t pvalue = 0.0;; 485 if (A2 <= 0.0) {; 486 return pvalue;; 487 } else if (A2 < 2.) {; 488 pvalue = std::pow(A2, -0.5) * std::exp(-1.2337141 / A2) * (2.00012 + (0.247105 - (0.0649821 - (0.0347962 - (0.011672 - 0.00168691 * A2) * A2) * A2) * A2) * A2);; 489 } else {; 490 pvalue = std::exp(-1. * std::exp(1.0776 - (2.30695 - (0.43424 - (.082433 - (0.008056 - 0.0003146 * A2) * A2) * A2) * A2) * A2));; 491 }; 492 return 1. - p",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:18631,Testability,test,test,18631,"tx1 = ts2[i1];; 468 double tx2 = ts2[i2];; 469 ; 470 //std::cout << "" tx1,2 "" << tx1 << "" "" << tx2 << std::endl;; 471 /// find interpolated (or extrapolated value)( ; 472 double lp0 = (lp1-lp2) * (tx - tx2)/ ( tx1-tx2) + lp2; ; 473 ; 474 ; 475 double p0 = exp(lp0)/(1. + exp(lp0) );; 476 return p0; ; 477 ; 478 }; 479 ; 480 ; 481/*; 482 Taken from (2); 483*/ Double_t GoFTest::PValueAD1Sample(Double_t A2) const {; 484 Double_t pvalue = 0.0;; 485 if (A2 <= 0.0) {; 486 return pvalue;; 487 } else if (A2 < 2.) {; 488 pvalue = std::pow(A2, -0.5) * std::exp(-1.2337141 / A2) * (2.00012 + (0.247105 - (0.0649821 - (0.0347962 - (0.011672 - 0.00168691 * A2) * A2) * A2) * A2) * A2);; 489 } else {; 490 pvalue = std::exp(-1. * std::exp(1.0776 - (2.30695 - (0.43424 - (.082433 - (0.008056 - 0.0003146 * A2) * A2) * A2) * A2) * A2));; 491 }; 492 return 1. - pvalue;; 493 }; 494 ; 495 ; 496// code from kSamples (R) F. Scholz; 497 ; 498/* computes the k-sample Anderson-Darling test statistics in both original ; 499 and alternative versions for the nonparametric (rank) test described in; 500 Scholz F.W. and Stephens M.A. (1987), K-sample Anderson-Darling Tests,; 501 Journal of the American Statistical Association, Vol 82, No. 399,; 502 pp. 918-924; 503 ; 504 Arguments:; 505 adk: double array with length 2, stores AkN2 and AakN2; 506 k: integer, number of samples being compared; 507 x: double array storing the concatenated samples in the same order as ns; 508 ns: integer array storing the k sample sizes, corresponding to x; 509 zstar: double array storing the l distinct ordered observations in the; 510 pooled sample; 511 l: integer, length of zstar; 512 ; 513 Outputs:; 514 when the computation ends, AkN2 and AakN2 are stored in the given memory; 515 pointed by adk; 516*/; 517 ; 518/* counts and returns the number of occurrence of a given number ; 519 in a double array */; 520int getCount(double z, const double *dat, int n) {; 521 int i;; 522 int count = 0;; 523 ; 524 for (i = 0; i < n; i++) {",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:18724,Testability,test,test,18724,"tx1 = ts2[i1];; 468 double tx2 = ts2[i2];; 469 ; 470 //std::cout << "" tx1,2 "" << tx1 << "" "" << tx2 << std::endl;; 471 /// find interpolated (or extrapolated value)( ; 472 double lp0 = (lp1-lp2) * (tx - tx2)/ ( tx1-tx2) + lp2; ; 473 ; 474 ; 475 double p0 = exp(lp0)/(1. + exp(lp0) );; 476 return p0; ; 477 ; 478 }; 479 ; 480 ; 481/*; 482 Taken from (2); 483*/ Double_t GoFTest::PValueAD1Sample(Double_t A2) const {; 484 Double_t pvalue = 0.0;; 485 if (A2 <= 0.0) {; 486 return pvalue;; 487 } else if (A2 < 2.) {; 488 pvalue = std::pow(A2, -0.5) * std::exp(-1.2337141 / A2) * (2.00012 + (0.247105 - (0.0649821 - (0.0347962 - (0.011672 - 0.00168691 * A2) * A2) * A2) * A2) * A2);; 489 } else {; 490 pvalue = std::exp(-1. * std::exp(1.0776 - (2.30695 - (0.43424 - (.082433 - (0.008056 - 0.0003146 * A2) * A2) * A2) * A2) * A2));; 491 }; 492 return 1. - pvalue;; 493 }; 494 ; 495 ; 496// code from kSamples (R) F. Scholz; 497 ; 498/* computes the k-sample Anderson-Darling test statistics in both original ; 499 and alternative versions for the nonparametric (rank) test described in; 500 Scholz F.W. and Stephens M.A. (1987), K-sample Anderson-Darling Tests,; 501 Journal of the American Statistical Association, Vol 82, No. 399,; 502 pp. 918-924; 503 ; 504 Arguments:; 505 adk: double array with length 2, stores AkN2 and AakN2; 506 k: integer, number of samples being compared; 507 x: double array storing the concatenated samples in the same order as ns; 508 ns: integer array storing the k sample sizes, corresponding to x; 509 zstar: double array storing the l distinct ordered observations in the; 510 pooled sample; 511 l: integer, length of zstar; 512 ; 513 Outputs:; 514 when the computation ends, AkN2 and AakN2 are stored in the given memory; 515 pointed by adk; 516*/; 517 ; 518/* counts and returns the number of occurrence of a given number ; 519 in a double array */; 520int getCount(double z, const double *dat, int n) {; 521 int i;; 522 int count = 0;; 523 ; 524 for (i = 0; i < n; i++) {",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:22549,Testability,test,test,22549," paper; 600 adk[0] = adk[1] = 0;; 601 for (i = 0; i < k; i++) {; 602 mij = 0;; 603 maij = 0;; 604 innerSum = 0;; 605 aInnerSum = 0;; 606 ; 607 for (j = 0; j < l; j++) {; 608 mij += fij[i + j*k];; 609 maij = mij - (double) fij[i + j*k] / 2.0;; 610 bj = getSum(&lvec[0], j + 1);; 611 baj = bj - (double) lvec[j] / 2.0;; 612 ; 613 if (j < l - 1) {; 614 tmp = (double) nsum * mij - (double) ns[i] * bj;; 615 innerSum = innerSum + (double) lvec[j] * tmp * tmp /; 616 (bj * ((double) nsum - bj));; 617 }; 618 ; 619 tmp = (double) nsum * maij - (double) ns[i] * baj;; 620 aInnerSum = aInnerSum + (double) lvec[j] * tmp * tmp /; 621 (baj * (nsum - baj) - nsum * (double) lvec[j] / 4.0);; 622 }; 623 ; 624 adk[0] = adk[0] + innerSum / ns[i]; /* AkN2*/; 625 adk[1] = adk[1] + aInnerSum / ns[i]; /* AakN2 */; 626 }; 627 ; 628 /* k-sample Anderson-Darling test statistics in both original and; 629 alternative versions, AkN2 and AakN2, are stored in the given; 630 double array adk */; 631 adk[0] = adk[0] / (double) nsum; /* AkN2*/; 632 adk[1] = (nsum - 1) * adk[1] / ((double) nsum * (double) nsum); /* AakN2 */; 633 ; 634 // /* free pointers */; 635 // for (i = 0; i < k; i++) {; 636 // free(samples[i]);; 637 // }; 638 // free(samples);; 639 ; 640}; 641 ; 642 ; 643/*; 644 Taken from (1) -- Named for 2 samples but implemented for K. Restricted to K = 2 by the class's constructors; 645*/; 646void GoFTest::AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 647 pvalue = -1;; 648 testStat = -1;; 649 if (fTestSampleFromH0) {; 650 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 651 return;; 652 }; 653 std::vector<Double_t> z(fCombinedSamples);; 654 // unique removes all consecutives duplicates elements. This is exactly what we wants ; 655 // for example unique of v={1,2,2,3,1,2,3,3} results in {1,2,3,1,2,3} which is exactly what we wants ; 656 std::vector<Double_t>::iterator endUnique = std::uniqu",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:23160,Testability,test,testStat,23160,"0 aInnerSum = aInnerSum + (double) lvec[j] * tmp * tmp /; 621 (baj * (nsum - baj) - nsum * (double) lvec[j] / 4.0);; 622 }; 623 ; 624 adk[0] = adk[0] + innerSum / ns[i]; /* AkN2*/; 625 adk[1] = adk[1] + aInnerSum / ns[i]; /* AakN2 */; 626 }; 627 ; 628 /* k-sample Anderson-Darling test statistics in both original and; 629 alternative versions, AkN2 and AakN2, are stored in the given; 630 double array adk */; 631 adk[0] = adk[0] / (double) nsum; /* AkN2*/; 632 adk[1] = (nsum - 1) * adk[1] / ((double) nsum * (double) nsum); /* AakN2 */; 633 ; 634 // /* free pointers */; 635 // for (i = 0; i < k; i++) {; 636 // free(samples[i]);; 637 // }; 638 // free(samples);; 639 ; 640}; 641 ; 642 ; 643/*; 644 Taken from (1) -- Named for 2 samples but implemented for K. Restricted to K = 2 by the class's constructors; 645*/; 646void GoFTest::AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 647 pvalue = -1;; 648 testStat = -1;; 649 if (fTestSampleFromH0) {; 650 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 651 return;; 652 }; 653 std::vector<Double_t> z(fCombinedSamples);; 654 // unique removes all consecutives duplicates elements. This is exactly what we wants ; 655 // for example unique of v={1,2,2,3,1,2,3,3} results in {1,2,3,1,2,3} which is exactly what we wants ; 656 std::vector<Double_t>::iterator endUnique = std::unique(z.begin(), z.end()); //z_j's in (1); 657 z.erase(endUnique, z.end() ); ; 658 std::vector<size_t> h; // h_j's in (1); 659 std::vector<Double_t> H; // H_j's in (1); 660 size_t N = fCombinedSamples.size();; 661 Double_t A2 = 0.0; // Anderson-Darling A^2 Test Statistic; 662 ; 663#ifdef USE_OLDIMPL ; 664 ; 665 TStopwatch w; w.Start();; 666 ; 667 unsigned int nSamples = fSamples.size();; 668 ; 669 // old implementation ; 670 for (std::vector<Double_t>::iterator data = z.begin(); data != endUnique; ++data) {; 671 size_t n = std::count(fCombinedSamples.begin(), fC",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:23201,Testability,test,testStat,23201,"0 aInnerSum = aInnerSum + (double) lvec[j] * tmp * tmp /; 621 (baj * (nsum - baj) - nsum * (double) lvec[j] / 4.0);; 622 }; 623 ; 624 adk[0] = adk[0] + innerSum / ns[i]; /* AkN2*/; 625 adk[1] = adk[1] + aInnerSum / ns[i]; /* AakN2 */; 626 }; 627 ; 628 /* k-sample Anderson-Darling test statistics in both original and; 629 alternative versions, AkN2 and AakN2, are stored in the given; 630 double array adk */; 631 adk[0] = adk[0] / (double) nsum; /* AkN2*/; 632 adk[1] = (nsum - 1) * adk[1] / ((double) nsum * (double) nsum); /* AakN2 */; 633 ; 634 // /* free pointers */; 635 // for (i = 0; i < k; i++) {; 636 // free(samples[i]);; 637 // }; 638 // free(samples);; 639 ; 640}; 641 ; 642 ; 643/*; 644 Taken from (1) -- Named for 2 samples but implemented for K. Restricted to K = 2 by the class's constructors; 645*/; 646void GoFTest::AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 647 pvalue = -1;; 648 testStat = -1;; 649 if (fTestSampleFromH0) {; 650 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 651 return;; 652 }; 653 std::vector<Double_t> z(fCombinedSamples);; 654 // unique removes all consecutives duplicates elements. This is exactly what we wants ; 655 // for example unique of v={1,2,2,3,1,2,3,3} results in {1,2,3,1,2,3} which is exactly what we wants ; 656 std::vector<Double_t>::iterator endUnique = std::unique(z.begin(), z.end()); //z_j's in (1); 657 z.erase(endUnique, z.end() ); ; 658 std::vector<size_t> h; // h_j's in (1); 659 std::vector<Double_t> H; // H_j's in (1); 660 size_t N = fCombinedSamples.size();; 661 Double_t A2 = 0.0; // Anderson-Darling A^2 Test Statistic; 662 ; 663#ifdef USE_OLDIMPL ; 664 ; 665 TStopwatch w; w.Start();; 666 ; 667 unsigned int nSamples = fSamples.size();; 668 ; 669 // old implementation ; 670 for (std::vector<Double_t>::iterator data = z.begin(); data != endUnique; ++data) {; 671 size_t n = std::count(fCombinedSamples.begin(), fC",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:23312,Testability,test,tests,23312,"0 aInnerSum = aInnerSum + (double) lvec[j] * tmp * tmp /; 621 (baj * (nsum - baj) - nsum * (double) lvec[j] / 4.0);; 622 }; 623 ; 624 adk[0] = adk[0] + innerSum / ns[i]; /* AkN2*/; 625 adk[1] = adk[1] + aInnerSum / ns[i]; /* AakN2 */; 626 }; 627 ; 628 /* k-sample Anderson-Darling test statistics in both original and; 629 alternative versions, AkN2 and AakN2, are stored in the given; 630 double array adk */; 631 adk[0] = adk[0] / (double) nsum; /* AkN2*/; 632 adk[1] = (nsum - 1) * adk[1] / ((double) nsum * (double) nsum); /* AakN2 */; 633 ; 634 // /* free pointers */; 635 // for (i = 0; i < k; i++) {; 636 // free(samples[i]);; 637 // }; 638 // free(samples);; 639 ; 640}; 641 ; 642 ; 643/*; 644 Taken from (1) -- Named for 2 samples but implemented for K. Restricted to K = 2 by the class's constructors; 645*/; 646void GoFTest::AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 647 pvalue = -1;; 648 testStat = -1;; 649 if (fTestSampleFromH0) {; 650 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 651 return;; 652 }; 653 std::vector<Double_t> z(fCombinedSamples);; 654 // unique removes all consecutives duplicates elements. This is exactly what we wants ; 655 // for example unique of v={1,2,2,3,1,2,3,3} results in {1,2,3,1,2,3} which is exactly what we wants ; 656 std::vector<Double_t>::iterator endUnique = std::unique(z.begin(), z.end()); //z_j's in (1); 657 z.erase(endUnique, z.end() ); ; 658 std::vector<size_t> h; // h_j's in (1); 659 std::vector<Double_t> H; // H_j's in (1); 660 size_t N = fCombinedSamples.size();; 661 Double_t A2 = 0.0; // Anderson-Darling A^2 Test Statistic; 662 ; 663#ifdef USE_OLDIMPL ; 664 ; 665 TStopwatch w; w.Start();; 666 ; 667 unsigned int nSamples = fSamples.size();; 668 ; 669 // old implementation ; 670 for (std::vector<Double_t>::iterator data = z.begin(); data != endUnique; ++data) {; 671 size_t n = std::count(fCombinedSamples.begin(), fC",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:26451,Testability,test,test,26451,"j;; 696 }; 697 std::cout << ""time for sum_result""; ; 698 w.Print(); ; 699 std::cout << ""sum_result "" << sum_result << std::endl;; 700 A2 += 1.0 / fSamples[i].size() * sum_result;; 701 }; 702 A2 *= (N - 1) / (TMath::Power(N, 2)); // A2_akN in (1); 703 ; 704 std::cout << ""A2 - old Bartolomeo code "" << A2 << std::endl;; 705#endif; 706 // w.Reset();; 707 // w.Start();; 708 ; 709 double adk[2] = {0,0};; 710 ; 711 //debug; 712 // std::cout << ""combined samples\n"";; 713 // for (int i = 0; i < fCombinedSamples.size(); ++i); 714 // std::cout << fCombinedSamples[i] << "" ,"";; 715 // std::cout << std::endl;; 716 // std::cout << ns[0] << "" "" << ns[1] << std::endl;; 717 // std::cout << ""Z\n"";; 718 // for (int i = 0; i < z.size(); ++i); 719 // std::cout << z[i] << "" ,"";; 720 // std::cout << std::endl;; 721 ; 722 // use function from kSamples code; 723 adkTestStat(adk, fSamples, z );; 724 // w.Print();; 725 // std::cout << ""A2 - new kSamples code "" << adk[0] << "" "" << adk[1] << std::endl;; 726 ; 727 A2 = adk[0]; ; 728 ; 729 // compute the normalized test statistic ; 730 ; 731 std::vector<size_t> ns(fSamples.size());; 732 for (unsigned int k = 0; k < ns.size(); ++k) ns[k] = fSamples[k].size();; 733 Double_t sigmaN = GetSigmaN(ns, N);; 734 A2 -= fSamples.size() - 1;; 735 A2 /= sigmaN; // standardized test statistic; 736 ; 737 pvalue = PValueADKSamples(2,A2); ; 738 testStat = A2;; 739 return;; 740 }; 741 ; 742 ; 743/*; 744 Compute Anderson Darling test for two binned data set. ; 745 A binned data set can be seen as many identical observation happening at the center of the bin; 746 In this way it is trivial to apply the formula (6) in the paper of W. Scholz, M. Stephens, ""K-Sample Anderson-Darling Tests""; 747 to the case of histograms. See also http://arxiv.org/pdf/0804.0380v1.pdf paragraph 3.3.5; 748 It is important that empty bins are not present ; 749*/; 750 void GoFTest::AndersonDarling2SamplesTest(const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData & data2, Double_t& pvalue,",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:26705,Testability,test,test,26705,"08 ; 709 double adk[2] = {0,0};; 710 ; 711 //debug; 712 // std::cout << ""combined samples\n"";; 713 // for (int i = 0; i < fCombinedSamples.size(); ++i); 714 // std::cout << fCombinedSamples[i] << "" ,"";; 715 // std::cout << std::endl;; 716 // std::cout << ns[0] << "" "" << ns[1] << std::endl;; 717 // std::cout << ""Z\n"";; 718 // for (int i = 0; i < z.size(); ++i); 719 // std::cout << z[i] << "" ,"";; 720 // std::cout << std::endl;; 721 ; 722 // use function from kSamples code; 723 adkTestStat(adk, fSamples, z );; 724 // w.Print();; 725 // std::cout << ""A2 - new kSamples code "" << adk[0] << "" "" << adk[1] << std::endl;; 726 ; 727 A2 = adk[0]; ; 728 ; 729 // compute the normalized test statistic ; 730 ; 731 std::vector<size_t> ns(fSamples.size());; 732 for (unsigned int k = 0; k < ns.size(); ++k) ns[k] = fSamples[k].size();; 733 Double_t sigmaN = GetSigmaN(ns, N);; 734 A2 -= fSamples.size() - 1;; 735 A2 /= sigmaN; // standardized test statistic; 736 ; 737 pvalue = PValueADKSamples(2,A2); ; 738 testStat = A2;; 739 return;; 740 }; 741 ; 742 ; 743/*; 744 Compute Anderson Darling test for two binned data set. ; 745 A binned data set can be seen as many identical observation happening at the center of the bin; 746 In this way it is trivial to apply the formula (6) in the paper of W. Scholz, M. Stephens, ""K-Sample Anderson-Darling Tests""; 747 to the case of histograms. See also http://arxiv.org/pdf/0804.0380v1.pdf paragraph 3.3.5; 748 It is important that empty bins are not present ; 749*/; 750 void GoFTest::AndersonDarling2SamplesTest(const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData & data2, Double_t& pvalue, Double_t& testStat) {; 751 pvalue = -1;; 752 testStat = -1;; 753 // ; 754 // compute cumulative sum of bin counts ; 755 // std::vector<double> sum1(data1.Size() ); ; 756 // std::vector<double> sum2(data2.Size() ); ; 757 // std::vector<double> sumAll(data1.Size() + data2.Size() ); ; 758 ; 759 if (data1.NDim() != 1 && data2.NDim() != 1) {; 760 MATH_ERROR_MSG(""AndersonD",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:26770,Testability,test,testStat,26770,"08 ; 709 double adk[2] = {0,0};; 710 ; 711 //debug; 712 // std::cout << ""combined samples\n"";; 713 // for (int i = 0; i < fCombinedSamples.size(); ++i); 714 // std::cout << fCombinedSamples[i] << "" ,"";; 715 // std::cout << std::endl;; 716 // std::cout << ns[0] << "" "" << ns[1] << std::endl;; 717 // std::cout << ""Z\n"";; 718 // for (int i = 0; i < z.size(); ++i); 719 // std::cout << z[i] << "" ,"";; 720 // std::cout << std::endl;; 721 ; 722 // use function from kSamples code; 723 adkTestStat(adk, fSamples, z );; 724 // w.Print();; 725 // std::cout << ""A2 - new kSamples code "" << adk[0] << "" "" << adk[1] << std::endl;; 726 ; 727 A2 = adk[0]; ; 728 ; 729 // compute the normalized test statistic ; 730 ; 731 std::vector<size_t> ns(fSamples.size());; 732 for (unsigned int k = 0; k < ns.size(); ++k) ns[k] = fSamples[k].size();; 733 Double_t sigmaN = GetSigmaN(ns, N);; 734 A2 -= fSamples.size() - 1;; 735 A2 /= sigmaN; // standardized test statistic; 736 ; 737 pvalue = PValueADKSamples(2,A2); ; 738 testStat = A2;; 739 return;; 740 }; 741 ; 742 ; 743/*; 744 Compute Anderson Darling test for two binned data set. ; 745 A binned data set can be seen as many identical observation happening at the center of the bin; 746 In this way it is trivial to apply the formula (6) in the paper of W. Scholz, M. Stephens, ""K-Sample Anderson-Darling Tests""; 747 to the case of histograms. See also http://arxiv.org/pdf/0804.0380v1.pdf paragraph 3.3.5; 748 It is important that empty bins are not present ; 749*/; 750 void GoFTest::AndersonDarling2SamplesTest(const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData & data2, Double_t& pvalue, Double_t& testStat) {; 751 pvalue = -1;; 752 testStat = -1;; 753 // ; 754 // compute cumulative sum of bin counts ; 755 // std::vector<double> sum1(data1.Size() ); ; 756 // std::vector<double> sum2(data2.Size() ); ; 757 // std::vector<double> sumAll(data1.Size() + data2.Size() ); ; 758 ; 759 if (data1.NDim() != 1 && data2.NDim() != 1) {; 760 MATH_ERROR_MSG(""AndersonD",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:26854,Testability,test,test,26854,"08 ; 709 double adk[2] = {0,0};; 710 ; 711 //debug; 712 // std::cout << ""combined samples\n"";; 713 // for (int i = 0; i < fCombinedSamples.size(); ++i); 714 // std::cout << fCombinedSamples[i] << "" ,"";; 715 // std::cout << std::endl;; 716 // std::cout << ns[0] << "" "" << ns[1] << std::endl;; 717 // std::cout << ""Z\n"";; 718 // for (int i = 0; i < z.size(); ++i); 719 // std::cout << z[i] << "" ,"";; 720 // std::cout << std::endl;; 721 ; 722 // use function from kSamples code; 723 adkTestStat(adk, fSamples, z );; 724 // w.Print();; 725 // std::cout << ""A2 - new kSamples code "" << adk[0] << "" "" << adk[1] << std::endl;; 726 ; 727 A2 = adk[0]; ; 728 ; 729 // compute the normalized test statistic ; 730 ; 731 std::vector<size_t> ns(fSamples.size());; 732 for (unsigned int k = 0; k < ns.size(); ++k) ns[k] = fSamples[k].size();; 733 Double_t sigmaN = GetSigmaN(ns, N);; 734 A2 -= fSamples.size() - 1;; 735 A2 /= sigmaN; // standardized test statistic; 736 ; 737 pvalue = PValueADKSamples(2,A2); ; 738 testStat = A2;; 739 return;; 740 }; 741 ; 742 ; 743/*; 744 Compute Anderson Darling test for two binned data set. ; 745 A binned data set can be seen as many identical observation happening at the center of the bin; 746 In this way it is trivial to apply the formula (6) in the paper of W. Scholz, M. Stephens, ""K-Sample Anderson-Darling Tests""; 747 to the case of histograms. See also http://arxiv.org/pdf/0804.0380v1.pdf paragraph 3.3.5; 748 It is important that empty bins are not present ; 749*/; 750 void GoFTest::AndersonDarling2SamplesTest(const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData & data2, Double_t& pvalue, Double_t& testStat) {; 751 pvalue = -1;; 752 testStat = -1;; 753 // ; 754 // compute cumulative sum of bin counts ; 755 // std::vector<double> sum1(data1.Size() ); ; 756 // std::vector<double> sum2(data2.Size() ); ; 757 // std::vector<double> sumAll(data1.Size() + data2.Size() ); ; 758 ; 759 if (data1.NDim() != 1 && data2.NDim() != 1) {; 760 MATH_ERROR_MSG(""AndersonD",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:27412,Testability,test,testStat,27412,"::endl;; 726 ; 727 A2 = adk[0]; ; 728 ; 729 // compute the normalized test statistic ; 730 ; 731 std::vector<size_t> ns(fSamples.size());; 732 for (unsigned int k = 0; k < ns.size(); ++k) ns[k] = fSamples[k].size();; 733 Double_t sigmaN = GetSigmaN(ns, N);; 734 A2 -= fSamples.size() - 1;; 735 A2 /= sigmaN; // standardized test statistic; 736 ; 737 pvalue = PValueADKSamples(2,A2); ; 738 testStat = A2;; 739 return;; 740 }; 741 ; 742 ; 743/*; 744 Compute Anderson Darling test for two binned data set. ; 745 A binned data set can be seen as many identical observation happening at the center of the bin; 746 In this way it is trivial to apply the formula (6) in the paper of W. Scholz, M. Stephens, ""K-Sample Anderson-Darling Tests""; 747 to the case of histograms. See also http://arxiv.org/pdf/0804.0380v1.pdf paragraph 3.3.5; 748 It is important that empty bins are not present ; 749*/; 750 void GoFTest::AndersonDarling2SamplesTest(const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData & data2, Double_t& pvalue, Double_t& testStat) {; 751 pvalue = -1;; 752 testStat = -1;; 753 // ; 754 // compute cumulative sum of bin counts ; 755 // std::vector<double> sum1(data1.Size() ); ; 756 // std::vector<double> sum2(data2.Size() ); ; 757 // std::vector<double> sumAll(data1.Size() + data2.Size() ); ; 758 ; 759 if (data1.NDim() != 1 && data2.NDim() != 1) {; 760 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Bin Data set must be one-dimensional "");; 761 return;; 762 }; 763 unsigned int n1 = data1.Size(); ; 764 unsigned int n2 = data2.Size(); ; 765 double ntot1 = 0; ; 766 double ntot2 = 0;; 767 ; 768 ; 769 // make a combined data set and sort it ; 770 std::vector<double> xdata(n1+n2); ; 771 for (unsigned int i = 0; i < n1; ++i) {; 772 double value = 0; ; 773 const double * x = data1.GetPoint(i, value);; 774 xdata[i] = *x; ; 775 ntot1 += value; ; 776 }; 777 for (unsigned int i = 0; i < n2; ++i) {; 778 double value = 0;; 779 const double * x = data2.GetPoint(i, value);; 780 xdata[n1+i] = *",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:27447,Testability,test,testStat,27447,"::endl;; 726 ; 727 A2 = adk[0]; ; 728 ; 729 // compute the normalized test statistic ; 730 ; 731 std::vector<size_t> ns(fSamples.size());; 732 for (unsigned int k = 0; k < ns.size(); ++k) ns[k] = fSamples[k].size();; 733 Double_t sigmaN = GetSigmaN(ns, N);; 734 A2 -= fSamples.size() - 1;; 735 A2 /= sigmaN; // standardized test statistic; 736 ; 737 pvalue = PValueADKSamples(2,A2); ; 738 testStat = A2;; 739 return;; 740 }; 741 ; 742 ; 743/*; 744 Compute Anderson Darling test for two binned data set. ; 745 A binned data set can be seen as many identical observation happening at the center of the bin; 746 In this way it is trivial to apply the formula (6) in the paper of W. Scholz, M. Stephens, ""K-Sample Anderson-Darling Tests""; 747 to the case of histograms. See also http://arxiv.org/pdf/0804.0380v1.pdf paragraph 3.3.5; 748 It is important that empty bins are not present ; 749*/; 750 void GoFTest::AndersonDarling2SamplesTest(const ROOT::Fit::BinData &data1, const ROOT::Fit::BinData & data2, Double_t& pvalue, Double_t& testStat) {; 751 pvalue = -1;; 752 testStat = -1;; 753 // ; 754 // compute cumulative sum of bin counts ; 755 // std::vector<double> sum1(data1.Size() ); ; 756 // std::vector<double> sum2(data2.Size() ); ; 757 // std::vector<double> sumAll(data1.Size() + data2.Size() ); ; 758 ; 759 if (data1.NDim() != 1 && data2.NDim() != 1) {; 760 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Bin Data set must be one-dimensional "");; 761 return;; 762 }; 763 unsigned int n1 = data1.Size(); ; 764 unsigned int n2 = data2.Size(); ; 765 double ntot1 = 0; ; 766 double ntot2 = 0;; 767 ; 768 ; 769 // make a combined data set and sort it ; 770 std::vector<double> xdata(n1+n2); ; 771 for (unsigned int i = 0; i < n1; ++i) {; 772 double value = 0; ; 773 const double * x = data1.GetPoint(i, value);; 774 xdata[i] = *x; ; 775 ntot1 += value; ; 776 }; 777 for (unsigned int i = 0; i < n2; ++i) {; 778 double value = 0;; 779 const double * x = data2.GetPoint(i, value);; 780 xdata[n1+i] = *",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:28623,Testability,test,tests,28623,"a2.NDim() != 1) {; 760 MATH_ERROR_MSG(""AndersonDarling2SamplesTest"", ""Bin Data set must be one-dimensional "");; 761 return;; 762 }; 763 unsigned int n1 = data1.Size(); ; 764 unsigned int n2 = data2.Size(); ; 765 double ntot1 = 0; ; 766 double ntot2 = 0;; 767 ; 768 ; 769 // make a combined data set and sort it ; 770 std::vector<double> xdata(n1+n2); ; 771 for (unsigned int i = 0; i < n1; ++i) {; 772 double value = 0; ; 773 const double * x = data1.GetPoint(i, value);; 774 xdata[i] = *x; ; 775 ntot1 += value; ; 776 }; 777 for (unsigned int i = 0; i < n2; ++i) {; 778 double value = 0;; 779 const double * x = data2.GetPoint(i, value);; 780 xdata[n1+i] = *x;; 781 ntot2 += value; ; 782 }; 783 double nall = ntot1+ntot2; ; 784 // sort the combined data ; 785 std::vector<unsigned int> index(n1+n2);; 786 TMath::Sort(n1+n2, &xdata[0], &index[0], false ); ; 787 ; 788 // now compute the sums for the tests ; 789 double sum1 = 0; ; 790 double sum2 = 0;; 791 double sumAll = 0; ; 792 double adsum = 0;; 793 unsigned int j = 0; ; 794 ; 795 while( j < n1+n2 ) { ; 796// for (unsigned int j = 0; j < n1+n2; ++j) { ; 797 // skip equal observations; 798 double x = xdata[ index[j] ]; ; 799 unsigned int k = j; ; 800 // loop on the bins with the same center value ; 801 double t = 0;; 802 do { ; 803 unsigned int i = index[k];; 804 double value = 0; ; 805 if (i < n1 ) {; 806 value = data1.Value(i); ; 807 sum1 += value;; 808 }; 809 else { ; 810 // from data2; 811 i -= n1;; 812 assert(i < n2);; 813 value = data2.Value(i); ; 814 sum2 += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:29194,Testability,assert,assert,29194," data1.GetPoint(i, value);; 774 xdata[i] = *x; ; 775 ntot1 += value; ; 776 }; 777 for (unsigned int i = 0; i < n2; ++i) {; 778 double value = 0;; 779 const double * x = data2.GetPoint(i, value);; 780 xdata[n1+i] = *x;; 781 ntot2 += value; ; 782 }; 783 double nall = ntot1+ntot2; ; 784 // sort the combined data ; 785 std::vector<unsigned int> index(n1+n2);; 786 TMath::Sort(n1+n2, &xdata[0], &index[0], false ); ; 787 ; 788 // now compute the sums for the tests ; 789 double sum1 = 0; ; 790 double sum2 = 0;; 791 double sumAll = 0; ; 792 double adsum = 0;; 793 unsigned int j = 0; ; 794 ; 795 while( j < n1+n2 ) { ; 796// for (unsigned int j = 0; j < n1+n2; ++j) { ; 797 // skip equal observations; 798 double x = xdata[ index[j] ]; ; 799 unsigned int k = j; ; 800 // loop on the bins with the same center value ; 801 double t = 0;; 802 do { ; 803 unsigned int i = index[k];; 804 double value = 0; ; 805 if (i < n1 ) {; 806 value = data1.Value(i); ; 807 sum1 += value;; 808 }; 809 else { ; 810 // from data2; 811 i -= n1;; 812 assert(i < n2);; 813 value = data2.Value(i); ; 814 sum2 += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Do",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30007,Testability,test,test,30007,,MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30252,Testability,test,test,30252," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30442,Testability,test,testStat,30442," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30592,Testability,test,testStat,30592," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30643,Testability,test,testStat,30643," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30740,Testability,test,testStat,30740," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30859,Testability,test,testStat,30859," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:30900,Testability,test,testStat,30900," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:31004,Testability,test,tests,31004," += value; ; 815 }; 816 sumAll += value;; 817 t += value; ; 818 //std::cout << ""j "" << j << "" k "" << k << "" data "" << x << "" index "" << index[k] << "" value "" << value << std::endl;; 819 k++;; 820 } while ( k < n1+n2 && xdata[ index[k] ] == x );; 821 ; 822 ; 823 j = k; ; 824 // skip last point; 825 if (j < n1+n2) {; 826 double tmp1 = ( nall * sum1 - ntot1 * sumAll );; 827 double tmp2 = ( nall * sum2 - ntot2 * sumAll );; 828 adsum += t * (tmp1*tmp1/ntot1 + tmp2*tmp2/ntot2) / ( sumAll * (nall - sumAll) ) ;; 829 ; 830 //std::cout << ""comp sum "" << adsum << "" "" << t << "" "" << sumAll << "" s1 "" << sum1 << "" s2 "" << sum2 << "" tmp1 "" << tmp1 << "" tmp2 "" << tmp2 << std::endl;; 831 }; 832 }; 833 double A2 = adsum / nall; ; 834 ; 835 // compute the normalized test statistic ; 836 std::vector<size_t> ns(2); ; 837 ns[0] = ntot1; ; 838 ns[1] = ntot2;; 839 //std::cout << "" ad2 = "" << A2 << "" nall "" << nall;; 840 ; 841 Double_t sigmaN = GetSigmaN(ns,nall);; 842 A2 -= 1;; 843 A2 /= sigmaN; // standardized test statistic; 844 ; 845 //std::cout << "" sigmaN "" << sigmaN << "" new A2 "" << A2;; 846 ; 847 pvalue = PValueADKSamples(2,A2); ; 848 //std::cout << "" pvalue = "" << pvalue << std::endl;; 849 testStat = A2;; 850 return;; 851 }; 852 ; 853 ; 854 Double_t GoFTest::AndersonDarling2SamplesTest(const Char_t* option) const {; 855 Double_t pvalue, testStat;; 856 AndersonDarling2SamplesTest(pvalue, testStat);; 857 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 858 }; 859 ; 860/*; 861 Taken from (3); 862*/ void GoFTest::AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const {; 863 pvalue = -1;; 864 testStat = -1;; 865 if (!fTestSampleFromH0) {; 866 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 867 return;; 868 }; 869 if (fDist == kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution).",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:31821,Testability,test,testStat,31821," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:31944,Testability,test,testStat,31944," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:31987,Testability,test,testStat,31987," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:32084,Testability,test,testStat,32084," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:32184,Testability,test,testStat,32184," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:32225,Testability,test,testStat,32225," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:32338,Testability,test,tests,32338," kUndefined) {; 870 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 871 return;; 872 }; 873 Double_t A2 = 0.0;; 874 Int_t n = fSamples[0].size();; 875 for (Int_t i = 0; i < n ; ++i) {; 876 Double_t x1 = fSamples[0][i];; 877 Double_t w1 = (*fCDF)(x1);; 878 Double_t result = (2 * (i + 1) - 1) * TMath::Log(w1) + (2 * (n - (i + 1)) + 1) * TMath::Log(1 - w1);; 879 A2 += result;; 880 }; 881 (A2 /= -n) -= n;; 882 if (A2 != A2) {; 883 MATH_ERROR_MSG(""AndersonDarlingTest"", ""Cannot compute p-value: data below or above the distribution's thresholds. Check sample consistency."");; 884 return;; 885 }; 886 pvalue = PValueAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1)",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:32792,Testability,test,testStat,32792,"eAD1Sample(A2);; 887 testStat = A2;; 888 }; 889 ; 890 Double_t GoFTest::AndersonDarlingTest(const Char_t* option) const {; 891 Double_t pvalue, testStat;; 892 AndersonDarlingTest(pvalue, testStat);; 893 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 894 }; 895 ; 896 void GoFTest::KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const {; 897 pvalue = -1;; 898 testStat = -1;; 899 if (fTestSampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 93",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:32977,Testability,test,testStat,32977,"ampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirno",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:33030,Testability,test,testStat,33030,"ampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirno",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:33127,Testability,test,testStat,33127,"ampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirno",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:33270,Testability,test,testStat,33270,"ampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirno",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:33311,Testability,test,testStat,33311,"ampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirno",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:33417,Testability,test,tests,33417,"ampleFromH0) {; 900 MATH_ERROR_MSG(""KolmogorovSmirnov2SamplesTest"", ""Only 1-sample tests can be issued with a 1-sample constructed GoFTest object!"");; 901 return;; 902 }; 903 const size_t na = fSamples[0].size();; 904 const size_t nb = fSamples[1].size();; 905 std::vector<Double_t> a(na);; 906 std::vector<Double_t> b(nb);; 907 std::copy(fSamples[0].begin(), fSamples[0].end(), a.begin());; 908 std::copy(fSamples[1].begin(), fSamples[1].end(), b.begin());; 909 pvalue = TMath::KolmogorovTest(na, a.data(), nb, b.data(), nullptr);; 910 testStat = TMath::KolmogorovTest(na, a.data(), nb, b.data(), ""M"");; 911 }; 912 ; 913 Double_t GoFTest::KolmogorovSmirnov2SamplesTest(const Char_t* option) const {; 914 Double_t pvalue, testStat;; 915 KolmogorovSmirnov2SamplesTest(pvalue, testStat);; 916 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 917 }; 918 ; 919/*; 920 Algorithm taken from (3) in page 737; 921*/ void GoFTest::KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirno",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:34099,Testability,test,testStat,34099,"tStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirnovTest(pvalue, testStat);; 948 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 949 }; 950 ; 951 ; 952 ; 953 ; 954 ; 955} // ROOT namespace; 956} // Math namespace; 957 ; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; GoFTest.h; IFunction.h; IFunctionfwd.h; Integrator.h; Math.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; M_PI#define M_PIDefinition Rotated.cxx:105; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEcons",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:34224,Testability,test,testStat,34224,"tStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirnovTest(pvalue, testStat);; 948 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 949 }; 950 ; 951 ; 952 ; 953 ; 954 ; 955} // ROOT namespace; 956} // Math namespace; 957 ; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; GoFTest.h; IFunction.h; IFunctionfwd.h; Integrator.h; Math.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; M_PI#define M_PIDefinition Rotated.cxx:105; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEcons",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:34269,Testability,test,testStat,34269,"tStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirnovTest(pvalue, testStat);; 948 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 949 }; 950 ; 951 ; 952 ; 953 ; 954 ; 955} // ROOT namespace; 956} // Math namespace; 957 ; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; GoFTest.h; IFunction.h; IFunctionfwd.h; Integrator.h; Math.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; M_PI#define M_PIDefinition Rotated.cxx:105; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEcons",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:34366,Testability,test,testStat,34366,"tStat) const {; 922 pvalue = -1;; 923 testStat = -1;; 924 if (!fTestSampleFromH0) {; 925 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Only 2-sample tests can be issued with a 2-sample constructed GoFTest object!"");; 926 return;; 927 }; 928 if (fDist == kUndefined) {; 929 MATH_ERROR_MSG(""KolmogorovSmirnovTest"", ""Distribution type is undefined! Please use SetDistribution(GoFTest::EDistribution)."");; 930 return;; 931 }; 932 Double_t Fo = 0.0, Dn = 0.0;; 933 size_t n = fSamples[0].size();; 934 for (size_t i = 0; i < n; ++i) {; 935 Double_t Fn = (i + 1.0) / n;; 936 Double_t F = (*fCDF)(fSamples[0][i]);; 937 Double_t result = std::max(TMath::Abs(Fn - F), TMath::Abs(Fo - F));; 938 if (result > Dn) Dn = result;; 939 Fo = Fn;; 940 }; 941 pvalue = TMath::KolmogorovProb(Dn * (TMath::Sqrt(n) + 0.12 + 0.11 / TMath::Sqrt(n)));; 942 testStat = Dn;; 943 }; 944 ; 945 Double_t GoFTest::KolmogorovSmirnovTest(const Char_t* option) const {; 946 Double_t pvalue, testStat;; 947 KolmogorovSmirnovTest(pvalue, testStat);; 948 return (strncmp(option, ""p"", 1) == 0 || strncmp(option, ""t"", 1) != 0) ? pvalue : testStat;; 949 }; 950 ; 951 ; 952 ; 953 ; 954 ; 955} // ROOT namespace; 956} // Math namespace; 957 ; BinData.h; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; GoFTest.h; IFunction.h; IFunctionfwd.h; Integrator.h; Math.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; M_PI#define M_PIDefinition Rotated.cxx:105; Char_tchar Char_tDefinition RtypesCore.h:37; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEcons",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:38482,Testability,test,test,38482,"e binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoF",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:38516,Testability,test,testStat,38516,"e binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoF",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:38578,Testability,test,test,38578,"e binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::GetPointconst double * GetPoint(unsigned int ipoint, double &value) constretrieve at the same time a pointer to the coordinate data and the fit value More efficient than call...Definition BinData.h:381; ROOT::Fit::BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoF",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:38909,Testability,test,test,38909,":BinData::Valuedouble Value(unsigned int ipoint) constreturn the value for the given fit pointDefinition BinData.h:220; ROOT::Fit::FitData::Sizeunsigned int Size() constreturn number of fit pointsDefinition FitData.h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoFTest.h:73; ROOT::Math::GoFTest::kUserDefined@ kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution.Definition GoFTest.h:72; ROOT::Math::GoFTest::kUndefined@ kUndefinedDefinition GoFTest.h:71; ROOT::Math::GoFTest::fDistEDistribution fDistType of distribution.Definition GoFTest.h:238; ROOT::Math::GoFTest::Instant",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:39121,Testability,test,tests,39121,".h:293; ROOT::Fit::FitData::NDimunsigned int NDim() constreturn coordinate data dimensionDefinition FitData.h:301; ROOT::Math::GoFTest::GetSigmaNstatic Double_t GetSigmaN(const std::vector< size_t > &ns, size_t N)Computation of sigma_N as described in (1)Definition GoFTest.cxx:311; ROOT::Math::GoFTest::SetCDFvoid SetCDF()Definition GoFTest.cxx:244; ROOT::Math::GoFTest::operator()void operator()(ETestType test, Double_t &pvalue, Double_t &testStat) constThe class's unary functions performing the gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoFTest.h:73; ROOT::Math::GoFTest::kUserDefined@ kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution.Definition GoFTest.h:72; ROOT::Math::GoFTest::kUndefined@ kUndefinedDefinition GoFTest.h:71; ROOT::Math::GoFTest::fDistEDistribution fDistType of distribution.Definition GoFTest.h:238; ROOT::Math::GoFTest::Instantiatevoid Instantiate(const Double_t *sample, size_t sampleSize)Definition GoFTest.cxx:279; ROOT::Math::GoFTest::fCombinedSamplesstd::vector< Double_t > fCombinedSamplesThe combined data.Definition GoFTest.h:241; R",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:39617,Testability,test,test,39617,"e gif test according to the ETestType provided.Definition GoFTest.cxx:208; ROOT::Math::GoFTest::SetDistributionFunctionvoid SetDistributionFunction(const IGenFunction &cdf, Bool_t isPDF, Double_t xmin, Double_t xmax)Definition GoFTest.cxx:267; ROOT::Math::GoFTest::fCDFstd::unique_ptr< IGenFunction > fCDFPointer to CDF used in 1-sample test.Definition GoFTest.h:235; ROOT::Math::GoFTest::fTestSampleFromH0Bool_t fTestSampleFromH0Definition GoFTest.h:245; ROOT::Math::GoFTest::EDistributionEDistributionH0 distributions for using only with 1-sample tests.Definition GoFTest.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoFTest.h:73; ROOT::Math::GoFTest::kUserDefined@ kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution.Definition GoFTest.h:72; ROOT::Math::GoFTest::kUndefined@ kUndefinedDefinition GoFTest.h:71; ROOT::Math::GoFTest::fDistEDistribution fDistType of distribution.Definition GoFTest.h:238; ROOT::Math::GoFTest::Instantiatevoid Instantiate(const Double_t *sample, size_t sampleSize)Definition GoFTest.cxx:279; ROOT::Math::GoFTest::fCombinedSamplesstd::vector< Double_t > fCombinedSamplesThe combined data.Definition GoFTest.h:241; ROOT::Math::GoFTest::KolmogorovSmirnovTestvoid KolmogorovSmirnovTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 1-Sample Test.Definition GoFTest.cxx:921; ROOT::Math::GoFTest::fParamsstd::vector< Double_t > fParamsThe distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition G",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:40170,Testability,test,testStat,40170,"est.h:70; ROOT::Math::GoFTest::kLogNormal@ kLogNormalGaussian distribution with default mean=0, sigma=1.Definition GoFTest.h:74; ROOT::Math::GoFTest::kExponential@ kExponentialLognormal distribution with default meanlog=0, sigmalog=1.Definition GoFTest.h:75; ROOT::Math::GoFTest::kGaussian@ kGaussianFor internal use only within the class's template constructor.Definition GoFTest.h:73; ROOT::Math::GoFTest::kUserDefined@ kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution.Definition GoFTest.h:72; ROOT::Math::GoFTest::kUndefined@ kUndefinedDefinition GoFTest.h:71; ROOT::Math::GoFTest::fDistEDistribution fDistType of distribution.Definition GoFTest.h:238; ROOT::Math::GoFTest::Instantiatevoid Instantiate(const Double_t *sample, size_t sampleSize)Definition GoFTest.cxx:279; ROOT::Math::GoFTest::fCombinedSamplesstd::vector< Double_t > fCombinedSamplesThe combined data.Definition GoFTest.h:241; ROOT::Math::GoFTest::KolmogorovSmirnovTestvoid KolmogorovSmirnovTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 1-Sample Test.Definition GoFTest.cxx:921; ROOT::Math::GoFTest::fParamsstd::vector< Double_t > fParamsThe distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition GoFTest.h:85; ROOT::Math::GoFTest::kKS@ kKSAnderson-Darling 2-Samples Test.Definition GoFTest.h:88; ROOT::Math::GoFTest::kAD@ kADDefinition GoFTest.h:86; ROOT::Math::GoFTest::kKS2s@ kKS2sKolmogorov-Smirnov Test.Definition GoFTest.h:89; ROOT::Math::GoFTest::kAD2s@ kAD2sAnderson-Darling Test. Default value.Definition GoFTest.h:87; ROOT::Math::GoFTest::SetSamplesvoid SetSamples(std::vector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValue",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:40473,Testability,test,test,40473,"mplate constructor.Definition GoFTest.h:73; ROOT::Math::GoFTest::kUserDefined@ kUserDefinedDefault value for non templated 1-sample test. Set with SetDistribution.Definition GoFTest.h:72; ROOT::Math::GoFTest::kUndefined@ kUndefinedDefinition GoFTest.h:71; ROOT::Math::GoFTest::fDistEDistribution fDistType of distribution.Definition GoFTest.h:238; ROOT::Math::GoFTest::Instantiatevoid Instantiate(const Double_t *sample, size_t sampleSize)Definition GoFTest.cxx:279; ROOT::Math::GoFTest::fCombinedSamplesstd::vector< Double_t > fCombinedSamplesThe combined data.Definition GoFTest.h:241; ROOT::Math::GoFTest::KolmogorovSmirnovTestvoid KolmogorovSmirnovTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 1-Sample Test.Definition GoFTest.cxx:921; ROOT::Math::GoFTest::fParamsstd::vector< Double_t > fParamsThe distribution parameters (e.g. fParams[0] = mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition GoFTest.h:85; ROOT::Math::GoFTest::kKS@ kKSAnderson-Darling 2-Samples Test.Definition GoFTest.h:88; ROOT::Math::GoFTest::kAD@ kADDefinition GoFTest.h:86; ROOT::Math::GoFTest::kKS2s@ kKS2sKolmogorov-Smirnov Test.Definition GoFTest.h:89; ROOT::Math::GoFTest::kAD2s@ kAD2sAnderson-Darling Test. Default value.Definition GoFTest.h:87; ROOT::Math::GoFTest::SetSamplesvoid SetSamples(std::vector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValueADKSamples(size_t nsamples, Double_t A2)Computation of the K-Sample Anderson-Darling Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirt",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:41347,Testability,log,logarithm,41347,"mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition GoFTest.h:85; ROOT::Math::GoFTest::kKS@ kKSAnderson-Darling 2-Samples Test.Definition GoFTest.h:88; ROOT::Math::GoFTest::kAD@ kADDefinition GoFTest.h:86; ROOT::Math::GoFTest::kKS2s@ kKS2sKolmogorov-Smirnov Test.Definition GoFTest.h:89; ROOT::Math::GoFTest::kAD2s@ kAD2sAnderson-Darling Test. Default value.Definition GoFTest.h:87; ROOT::Math::GoFTest::SetSamplesvoid SetSamples(std::vector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValueADKSamples(size_t nsamples, Double_t A2)Computation of the K-Sample Anderson-Darling Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirtual ~GoFTest()Definition GoFTest.cxx:179; ROOT::Math::GoFTest::SetDistributionvoid SetDistribution(EDistribution dist, const std::vector< double > &distParams={})Sets the distribution for the predefined distribution types and optionally its parameters for 1-sampl...Definition GoFTest.cxx:124; ROOT::Math::GoFTest::GaussianCDFDouble_t GaussianCDF(Double_t x) constDefinition GoFTest.cxx:295; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::GoFTest::GoFTestGoFTest()Disallowed default constructor.; ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTestvoid KolmogorovSmirnov2SamplesTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:41406,Testability,test,test,41406,"mean, fParams[1] = sigma for a Gaussian)Definition GoFTest.h:239; ROOT::Math::GoFTest::ETestTypeETestTypeGoodness of Fit test types for using with the class's unary functions as a shorthand for the in-built...Definition GoFTest.h:85; ROOT::Math::GoFTest::kKS@ kKSAnderson-Darling 2-Samples Test.Definition GoFTest.h:88; ROOT::Math::GoFTest::kAD@ kADDefinition GoFTest.h:86; ROOT::Math::GoFTest::kKS2s@ kKS2sKolmogorov-Smirnov Test.Definition GoFTest.h:89; ROOT::Math::GoFTest::kAD2s@ kAD2sAnderson-Darling Test. Default value.Definition GoFTest.h:87; ROOT::Math::GoFTest::SetSamplesvoid SetSamples(std::vector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValueADKSamples(size_t nsamples, Double_t A2)Computation of the K-Sample Anderson-Darling Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirtual ~GoFTest()Definition GoFTest.cxx:179; ROOT::Math::GoFTest::SetDistributionvoid SetDistribution(EDistribution dist, const std::vector< double > &distParams={})Sets the distribution for the predefined distribution types and optionally its parameters for 1-sampl...Definition GoFTest.cxx:124; ROOT::Math::GoFTest::GaussianCDFDouble_t GaussianCDF(Double_t x) constDefinition GoFTest.cxx:295; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::GoFTest::GoFTestGoFTest()Disallowed default constructor.; ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTestvoid KolmogorovSmirnov2SamplesTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:41986,Testability,test,testStat,41986,"ector< const Double_t * > samples, const std::vector< size_t > samplesSizes)set a vector of samplesDefinition GoFTest.cxx:181; ROOT::Math::GoFTest::PValueADKSamplesstatic Double_t PValueADKSamples(size_t nsamples, Double_t A2)Computation of the K-Sample Anderson-Darling Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirtual ~GoFTest()Definition GoFTest.cxx:179; ROOT::Math::GoFTest::SetDistributionvoid SetDistribution(EDistribution dist, const std::vector< double > &distParams={})Sets the distribution for the predefined distribution types and optionally its parameters for 1-sampl...Definition GoFTest.cxx:124; ROOT::Math::GoFTest::GaussianCDFDouble_t GaussianCDF(Double_t x) constDefinition GoFTest.cxx:295; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::GoFTest::GoFTestGoFTest()Disallowed default constructor.; ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTestvoid KolmogorovSmirnov2SamplesTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest::fSamplesstd::vector< std::vector< Double_t > > fSamplesThe input data.Definition GoFTest.h:243; ROOT::Math::GoFTest::PValueAD1SampleDouble_t PValueAD1Sample(Double_t A2) constComputation of the 1-Sample Anderson-Darling Test's p-value.Definition GoFTest.cxx:483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(con",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:42256,Testability,test,testStat,42256,"ing Test's p-value as described in (1)Definition GoFTest.cxx:353; ROOT::Math::GoFTest::LogSamplevoid LogSample()Applies the logarithm to the sample when the specified distribution to test is LogNormal.Definition GoFTest.cxx:303; ROOT::Math::GoFTest::~GoFTestvirtual ~GoFTest()Definition GoFTest.cxx:179; ROOT::Math::GoFTest::SetDistributionvoid SetDistribution(EDistribution dist, const std::vector< double > &distParams={})Sets the distribution for the predefined distribution types and optionally its parameters for 1-sampl...Definition GoFTest.cxx:124; ROOT::Math::GoFTest::GaussianCDFDouble_t GaussianCDF(Double_t x) constDefinition GoFTest.cxx:295; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::GoFTest::GoFTestGoFTest()Disallowed default constructor.; ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTestvoid KolmogorovSmirnov2SamplesTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest::fSamplesstd::vector< std::vector< Double_t > > fSamplesThe input data.Definition GoFTest.h:243; ROOT::Math::GoFTest::PValueAD1SampleDouble_t PValueAD1Sample(Double_t A2) constComputation of the 1-Sample Anderson-Darling Test's p-value.Definition GoFTest.cxx:483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Mat",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:42710,Testability,test,testStat,42710,"distribution types and optionally its parameters for 1-sampl...Definition GoFTest.cxx:124; ROOT::Math::GoFTest::GaussianCDFDouble_t GaussianCDF(Double_t x) constDefinition GoFTest.cxx:295; ROOT::Math::GoFTest::AndersonDarling2SamplesTestvoid AndersonDarling2SamplesTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 2-Sample Test.Definition GoFTest.cxx:646; ROOT::Math::GoFTest::GoFTestGoFTest()Disallowed default constructor.; ROOT::Math::GoFTest::KolmogorovSmirnov2SamplesTestvoid KolmogorovSmirnov2SamplesTest(Double_t &pvalue, Double_t &testStat) constKolmogorov-Smirnov 2-Samples Test.Definition GoFTest.cxx:896; ROOT::Math::GoFTest::fSamplesstd::vector< std::vector< Double_t > > fSamplesThe input data.Definition GoFTest.h:243; ROOT::Math::GoFTest::PValueAD1SampleDouble_t PValueAD1Sample(Double_t A2) constComputation of the 1-Sample Anderson-Darling Test's p-value.Definition GoFTest.cxx:483; ROOT::Math::GoFTest::AndersonDarlingTestvoid AndersonDarlingTest(Double_t &pvalue, Double_t &testStat) constPerforms the Anderson-Darling 1-Sample Test.Definition GoFTest.cxx:862; ROOT::Math::GoFTest::ExponentialCDFDouble_t ExponentialCDF(Double_t x) constDefinition GoFTest.cxx:299; ROOT::Math::GoFTest::SetParametersvoid SetParameters(const std::vector< double > &params)Sets the distribution parameters.Definition GoFTest.cxx:204; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::IntegratorOneDimUser Class for performing numerical integration of a function in one dimension.Definition Integrator.h:98; ROOT::Math::IntegratorOneDim::IntegralUpdouble IntegralUp(const IGenFunction &f, double a)evaluate the Integral of a function f over the semi-infinite interval (a,+inf)Definition Integrator.h:278; ROOT::Math::IntegratorOneDim::SetFunctionvoid SetFunction(Function &f)method to set the a generic integration functionDefinition Integrator.h:4",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:46558,Testability,test,test,46558,"finition ProbFuncMathCore.cxx:234; ROOT::Math::exponential_cdfdouble exponential_cdf(double x, double lambda, double x0=0)Cumulative distribution function of the exponential distribution (lower tail).Definition ProbFuncMathCore.cxx:161; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; F#define F(x, y, z); H#define H(x, y, z); MathNamespace for new Math classes and functions.; ROOT::Math::adkTestStatvoid adkTestStat(double *adk, const std::vector< std::vector< double > > &samples, const std::vector< double > &zstar)Definition GoFTest.cxx:546; ROOT::Math::getCountint getCount(double z, const double *dat, int n)Definition GoFTest.cxx:520; ROOT::Math::getSumint getSum(const int *x, int n)Definition GoFTest.cxx:534; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ROOT::Math::CDFWrapperDefinition GoFTest.cxx:40; ROOT::Math::CDFWrapper::CDFWrapperCDFWrapper(const IGenFunction &cdf, Double_t xmin=0, Doub",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/GoFTest_8cxx_source.html:46730,Testability,log,logarithm,46730," distribution (lower tail).Definition ProbFuncMathCore.cxx:161; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; F#define F(x, y, z); H#define H(x, y, z); MathNamespace for new Math classes and functions.; ROOT::Math::adkTestStatvoid adkTestStat(double *adk, const std::vector< std::vector< double > > &samples, const std::vector< double > &zstar)Definition GoFTest.cxx:546; ROOT::Math::getCountint getCount(double z, const double *dat, int n)Definition GoFTest.cxx:520; ROOT::Math::getSumint getSum(const int *x, int n)Definition GoFTest.cxx:534; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::KolmogorovTestDouble_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option)Statistical test whether two one-dimensional sets of points are compatible with coming from the same ...Definition TMath.cxx:805; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::KolmogorovProbDouble_t KolmogorovProb(Double_t z)Calculates the Kolmogorov distribution function,.Definition TMath.cxx:679; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; ROOT::Math::CDFWrapperDefinition GoFTest.cxx:40; ROOT::Math::CDFWrapper::CDFWrapperCDFWrapper(const IGenFunction &cdf, Double_t xmin=0, Double_t xmax=-1)Definition GoFTest.cxx:50; ROOT::Math::CDFWrapper::DoEvalDouble_t DoEval(Double_t x) const overrideimplementation of the evaluation function. Must be implement",MatchSource.WIKI,doc/master/GoFTest_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/GoFTest_8cxx_source.html
https://root.cern/doc/master/graph2derrorsfit_8C.html:3086,Availability,error,errors,3086,"The Canvas class.Definition TCanvas.h:23; TF1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Set the maximum value along Y for this function In case the function is already drawn,...Definition TF1.cxx:3394; TF1::SetTitlevoid SetTitle(const char *title="""") overrideSet function title if title has the form ""fffffff;xxxx;yyyy"", it is assumed that the function title i...Definition TF1.cxx:3558; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetRandom2virtual void GetRandom2(Double_t &xrandom, Double_t &yrandom, TRandom *rng=nullptr)Return 2 random numbers following this function shape.Definition TF2.cxx:547; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2D::FindObjectTObject * FindObject(const char *name) const overridesearch object named name in the list of functionsDefinition TGraph2D.cxx:791; TGraph2D::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""")Fits this graph with function with name fname Predefined functions such as gaus, expo and poln are au...Definition TGraph2D.cxx:815; TGraph2D::Drawvoid Draw(Option_t *option=""P0"") overrideSpecific drawing options can be used to paint a TGraph2D:Definition TGraph2D.cxx:762; TRandomThis is the base class for the ROOT Random number generators",MatchSource.WIKI,doc/master/graph2derrorsfit_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph2derrorsfit_8C.html
https://root.cern/doc/master/graph2derrorsfit_8C_source.html:3325,Availability,error,errors,3325,"The Canvas class.Definition TCanvas.h:23; TF1::SetMaximumvirtual void SetMaximum(Double_t maximum=-1111)Set the maximum value along Y for this function In case the function is already drawn,...Definition TF1.cxx:3394; TF1::SetTitlevoid SetTitle(const char *title="""") overrideSet function title if title has the form ""fffffff;xxxx;yyyy"", it is assumed that the function title i...Definition TF1.cxx:3558; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetRandom2virtual void GetRandom2(Double_t &xrandom, Double_t &yrandom, TRandom *rng=nullptr)Return 2 random numbers following this function shape.Definition TF2.cxx:547; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::SetPointErrorvirtual void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez)Set ex, ey and ez values for point number i.Definition TGraph2DErrors.cxx:446; TGraph2D::FindObjectTObject * FindObject(const char *name) const overridesearch object named name in the list of functionsDefinition TGraph2D.cxx:791; TGraph2D::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""")Fits this graph with function with name fname Predefined functions such as gaus, expo and poln are au...Definition TGraph2D.cxx:815; TGraph2D::Drawvoid Draw(Option_t *option=""P0"") overrideSpecific drawing options can be used to paint a TGraph2D:Definition TGraph2D.cxx:762; TRandomThis is the base class for the ROOT Random number generators",MatchSource.WIKI,doc/master/graph2derrorsfit_8C_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph2derrorsfit_8C_source.html
https://root.cern/doc/master/graphApply_8C.html:623,Availability,error,errorx,623,". ROOT: tutorials/graphs/graphApply.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphApply.C File ReferenceTutorials » Graphs tutorials. Detailed Description; A macro to demonstrate the functionality of TGraph::Apply() method. ; TGraph::Apply applies a function f to all the data TGraph points. f may be a 1-D function TF1 or 2-d function TF2. The Y values of the graph are replaced by the new values computed using the function. ; void graphApply(); {; const Int_t npoints=3;; Double_t xaxis[npoints] = {1.,2.,3.};; Double_t yaxis[npoints] = {10.,20.,30.};; Double_t errorx[npoints] = {0.5,0.5,0.5};; Double_t errory[npoints] = {5.,5.,5.};; ; Double_t exl[npoints] = {0.5,0.5,0.5};; Double_t exh[npoints] = {0.5,0.5,0.5};; Double_t eyl[npoints] = {5.,5.,5.};; Double_t eyh[npoints] = {5.,5.,5.};; ; TGraph *gr1 = new TGraph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overri",MatchSource.WIKI,doc/master/graphApply_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphApply_8C.html
https://root.cern/doc/master/graphApply_8C.html:666,Availability,error,errory,666,". ROOT: tutorials/graphs/graphApply.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphApply.C File ReferenceTutorials » Graphs tutorials. Detailed Description; A macro to demonstrate the functionality of TGraph::Apply() method. ; TGraph::Apply applies a function f to all the data TGraph points. f may be a 1-D function TF1 or 2-d function TF2. The Y values of the graph are replaced by the new values computed using the function. ; void graphApply(); {; const Int_t npoints=3;; Double_t xaxis[npoints] = {1.,2.,3.};; Double_t yaxis[npoints] = {10.,20.,30.};; Double_t errorx[npoints] = {0.5,0.5,0.5};; Double_t errory[npoints] = {5.,5.,5.};; ; Double_t exl[npoints] = {0.5,0.5,0.5};; Double_t exh[npoints] = {0.5,0.5,0.5};; Double_t eyl[npoints] = {5.,5.,5.};; Double_t eyh[npoints] = {5.,5.,5.};; ; TGraph *gr1 = new TGraph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overri",MatchSource.WIKI,doc/master/graphApply_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphApply_8C.html
https://root.cern/doc/master/graphApply_8C.html:960,Availability,error,errorx,960,". ROOT: tutorials/graphs/graphApply.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphApply.C File ReferenceTutorials » Graphs tutorials. Detailed Description; A macro to demonstrate the functionality of TGraph::Apply() method. ; TGraph::Apply applies a function f to all the data TGraph points. f may be a 1-D function TF1 or 2-d function TF2. The Y values of the graph are replaced by the new values computed using the function. ; void graphApply(); {; const Int_t npoints=3;; Double_t xaxis[npoints] = {1.,2.,3.};; Double_t yaxis[npoints] = {10.,20.,30.};; Double_t errorx[npoints] = {0.5,0.5,0.5};; Double_t errory[npoints] = {5.,5.,5.};; ; Double_t exl[npoints] = {0.5,0.5,0.5};; Double_t exh[npoints] = {0.5,0.5,0.5};; Double_t eyl[npoints] = {5.,5.,5.};; Double_t eyh[npoints] = {5.,5.,5.};; ; TGraph *gr1 = new TGraph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overri",MatchSource.WIKI,doc/master/graphApply_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphApply_8C.html
https://root.cern/doc/master/graphApply_8C.html:967,Availability,error,errory,967,". ROOT: tutorials/graphs/graphApply.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphApply.C File ReferenceTutorials » Graphs tutorials. Detailed Description; A macro to demonstrate the functionality of TGraph::Apply() method. ; TGraph::Apply applies a function f to all the data TGraph points. f may be a 1-D function TF1 or 2-d function TF2. The Y values of the graph are replaced by the new values computed using the function. ; void graphApply(); {; const Int_t npoints=3;; Double_t xaxis[npoints] = {1.,2.,3.};; Double_t yaxis[npoints] = {10.,20.,30.};; Double_t errorx[npoints] = {0.5,0.5,0.5};; Double_t errory[npoints] = {5.,5.,5.};; ; Double_t exl[npoints] = {0.5,0.5,0.5};; Double_t exh[npoints] = {0.5,0.5,0.5};; Double_t eyl[npoints] = {5.,5.,5.};; Double_t eyh[npoints] = {5.,5.,5.};; ; TGraph *gr1 = new TGraph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overri",MatchSource.WIKI,doc/master/graphApply_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphApply_8C.html
https://root.cern/doc/master/graphApply_8C.html:1700,Availability,error,error,1700,"= {5.,5.,5.};; ; Double_t exl[npoints] = {0.5,0.5,0.5};; Double_t exh[npoints] = {0.5,0.5,0.5};; Double_t eyl[npoints] = {5.,5.,5.};; Double_t eyh[npoints] = {5.,5.,5.};; ; TGraph *gr1 = new TGraph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Applyvirtual void Apply(TF1 *f)Apply function f to all the data points f may be a 1-D function TF1 or 2-d function TF2 The Y values ...Definition TGraph.cxx:638; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; c1return c1Definition legend1.C:",MatchSource.WIKI,doc/master/graphApply_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphApply_8C.html
https://root.cern/doc/master/graphApply_8C.html:1916,Availability,error,error,1916,"Graph(npoints,xaxis,yaxis);; TGraphErrors *gr2 = new TGraphErrors(npoints,xaxis,yaxis,errorx,errory);; TGraphAsymmErrors *gr3 = new TGraphAsymmErrors(npoints,xaxis,yaxis,exl,exh,eyl,eyh);; TF2 *ff = new TF2(""ff"",""-1./y"");; ; TCanvas *c1 = new TCanvas(""c1"",""c1"");; c1->Divide(2,3);; ; // TGraph; c1->cd(1);; gr1->DrawClone(""A*"");; c1->cd(2);; gr1->Apply(ff);; gr1->Draw(""A*"");; ; // TGraphErrors; c1->cd(3);; gr2->DrawClone(""A*"");; c1->cd(4);; gr2->Apply(ff);; gr2->Draw(""A*"");; ; // TGraphAsymmErrors; c1->cd(5);; gr3->DrawClone(""A*"");; c1->cd(6);; gr3->Apply(ff);; gr3->Draw(""A*"");; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TCanvasThe Canvas class.Definition TCanvas.h:23; TF2A 2-Dim function with parameters.Definition TF2.h:29; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphAsymmErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphAsymmErrors.cxx:468; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::Applyvoid Apply(TF1 *f) overrideApply function to all the data points .Definition TGraphErrors.cxx:396; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Applyvirtual void Apply(TF1 *f)Apply function f to all the data points f may be a 1-D function TF1 or 2-d function TF2 The Y values ...Definition TGraph.cxx:638; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; c1return c1Definition legend1.C:41; AuthorMiro Helbich ; Definition in file graphApply.C. tutorialsgraphsgraphApply.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graphApply_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphApply_8C.html
https://root.cern/doc/master/graphreverse_8C.html:2455,Availability,error,error,2455,"s()->SetMoreLogLabels();; graphe->GetYaxis()->SetMoreLogLabels();; graphe->Draw(""a pl rx ry"");; ; // TGraphAsymmErrors; auto graphae = new TGraphAsymmErrors();; graphae->GetXaxis()->SetNdivisions(514);; graphae->GetYaxis()->SetNdivisions(514);; graphae->SetMarkerStyle(kCircle);; graphae->SetPoint(0,5,5);; graphae->SetPointError(0,1,3,3,1);; graphae->SetPoint(1,9,9);; graphae->SetPointError(1,1,3,1,3);; ; c->cd(4);; gPad->SetGrid();; graphae->Draw(""a pl "");; ; c->cd(5);; gPad->SetGrid();; graphae->Draw(""a pl rx ry "");; ; c->cd(6);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphae->GetXaxis()->SetMoreLogLabels();; graphae->GetYaxis()->SetMoreLogLabels();; graphae->Draw(""a pl rx ry"");; ; // TGraphBentErrors; auto graphbe = new TGraphBentErrors();; graphbe->GetXaxis()->SetNdivisions(514);; graphbe->GetYaxis()->SetNdivisions(514);; graphbe->SetMarkerStyle(kCircle);; graphbe->SetPoint(0,5,5);; graphbe->SetPointError(0,1,3,3,1,.5,.2,.5,.2);; graphbe->SetPoint(1,9,9);; graphbe->SetPointError(1,1,3,1,3,-.5,-.2,-.5,-.2);; ; c->cd(7);; gPad->SetGrid();; graphbe->Draw(""a pl "");; ; c->cd(8);; gPad->SetGrid();; graphbe->Draw(""a pl rx ry "");; ; c->cd(9);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphbe->GetXaxis()->SetMoreLogLabels();; graphbe->GetYaxis()->SetMoreLogLabels();; graphbe->Draw(""a pl rx ry"");; }; c#define c(i)Definition RSha256.hxx:101; kCircle@ kCircleDefinition TAttMarker.h:53; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; AuthorOlivier Couet ; Definition in file graphreverse.C. tutorialsgraphsgraphreverse.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graphreverse_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphreverse_8C.html
https://root.cern/doc/master/graphreverse_8C.html:2570,Availability,error,error,2570,"s()->SetMoreLogLabels();; graphe->GetYaxis()->SetMoreLogLabels();; graphe->Draw(""a pl rx ry"");; ; // TGraphAsymmErrors; auto graphae = new TGraphAsymmErrors();; graphae->GetXaxis()->SetNdivisions(514);; graphae->GetYaxis()->SetNdivisions(514);; graphae->SetMarkerStyle(kCircle);; graphae->SetPoint(0,5,5);; graphae->SetPointError(0,1,3,3,1);; graphae->SetPoint(1,9,9);; graphae->SetPointError(1,1,3,1,3);; ; c->cd(4);; gPad->SetGrid();; graphae->Draw(""a pl "");; ; c->cd(5);; gPad->SetGrid();; graphae->Draw(""a pl rx ry "");; ; c->cd(6);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphae->GetXaxis()->SetMoreLogLabels();; graphae->GetYaxis()->SetMoreLogLabels();; graphae->Draw(""a pl rx ry"");; ; // TGraphBentErrors; auto graphbe = new TGraphBentErrors();; graphbe->GetXaxis()->SetNdivisions(514);; graphbe->GetYaxis()->SetNdivisions(514);; graphbe->SetMarkerStyle(kCircle);; graphbe->SetPoint(0,5,5);; graphbe->SetPointError(0,1,3,3,1,.5,.2,.5,.2);; graphbe->SetPoint(1,9,9);; graphbe->SetPointError(1,1,3,1,3,-.5,-.2,-.5,-.2);; ; c->cd(7);; gPad->SetGrid();; graphbe->Draw(""a pl "");; ; c->cd(8);; gPad->SetGrid();; graphbe->Draw(""a pl rx ry "");; ; c->cd(9);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphbe->GetXaxis()->SetMoreLogLabels();; graphbe->GetYaxis()->SetMoreLogLabels();; graphbe->Draw(""a pl rx ry"");; }; c#define c(i)Definition RSha256.hxx:101; kCircle@ kCircleDefinition TAttMarker.h:53; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; AuthorOlivier Couet ; Definition in file graphreverse.C. tutorialsgraphsgraphreverse.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graphreverse_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphreverse_8C.html
https://root.cern/doc/master/graphreverse_8C.html:2659,Availability,error,error,2659,"s()->SetMoreLogLabels();; graphe->GetYaxis()->SetMoreLogLabels();; graphe->Draw(""a pl rx ry"");; ; // TGraphAsymmErrors; auto graphae = new TGraphAsymmErrors();; graphae->GetXaxis()->SetNdivisions(514);; graphae->GetYaxis()->SetNdivisions(514);; graphae->SetMarkerStyle(kCircle);; graphae->SetPoint(0,5,5);; graphae->SetPointError(0,1,3,3,1);; graphae->SetPoint(1,9,9);; graphae->SetPointError(1,1,3,1,3);; ; c->cd(4);; gPad->SetGrid();; graphae->Draw(""a pl "");; ; c->cd(5);; gPad->SetGrid();; graphae->Draw(""a pl rx ry "");; ; c->cd(6);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphae->GetXaxis()->SetMoreLogLabels();; graphae->GetYaxis()->SetMoreLogLabels();; graphae->Draw(""a pl rx ry"");; ; // TGraphBentErrors; auto graphbe = new TGraphBentErrors();; graphbe->GetXaxis()->SetNdivisions(514);; graphbe->GetYaxis()->SetNdivisions(514);; graphbe->SetMarkerStyle(kCircle);; graphbe->SetPoint(0,5,5);; graphbe->SetPointError(0,1,3,3,1,.5,.2,.5,.2);; graphbe->SetPoint(1,9,9);; graphbe->SetPointError(1,1,3,1,3,-.5,-.2,-.5,-.2);; ; c->cd(7);; gPad->SetGrid();; graphbe->Draw(""a pl "");; ; c->cd(8);; gPad->SetGrid();; graphbe->Draw(""a pl rx ry "");; ; c->cd(9);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphbe->GetXaxis()->SetMoreLogLabels();; graphbe->GetYaxis()->SetMoreLogLabels();; graphbe->Draw(""a pl rx ry"");; }; c#define c(i)Definition RSha256.hxx:101; kCircle@ kCircleDefinition TAttMarker.h:53; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphAsymmErrorsTGraph with asymmetric error bars.Definition TGraphAsymmErrors.h:26; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; AuthorOlivier Couet ; Definition in file graphreverse.C. tutorialsgraphsgraphreverse.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graphreverse_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphreverse_8C.html
https://root.cern/doc/master/graphreverse_8C.html:231,Testability,test,test,231,". ROOT: tutorials/graphs/graphreverse.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphreverse.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example test all the various case of reverse graphs combined with logarithmic scale. . ; void graphreverse() {; auto c = new TCanvas(""c"",""Reversed graphs"",0,0,900,900);; c->Divide(3,3);; ; // TGraphErrors; auto graphe = new TGraphErrors();; graphe->GetXaxis()->SetNdivisions(514);; graphe->GetYaxis()->SetNdivisions(514);; graphe->SetMarkerStyle(kCircle);; graphe->SetPoint(0,5,5);; graphe->SetPointError(0,1,3);; graphe->SetPoint(1,9,9);; graphe->SetPointError(1,1,3);; ; c->cd(1);; gPad->SetGrid();; graphe->Draw(""a pl "");; ; c->cd(2);; gPad->SetGrid();; graphe->Draw(""a pl rx ry "");; ; c->cd(3);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphe->GetXaxis()->SetMoreLogLabels();; graphe->GetYaxis()->SetMoreLogLabels();; graphe->Draw(""a pl rx ry"");; ; // TGraphAsymmErrors; auto graphae = new TGraphAsymmErrors();; graphae->GetXaxis()->SetNdivisions(514);; graphae->GetYaxis()->SetNdivisions(514);; graphae->SetMarkerStyle(kCircle);; graphae->SetPoint(0,5,5);; graphae->SetPointError(0,1,3,3,1);; graphae->SetPoint(1,9,9);; graphae->SetPointError(1,1,3,1,3);; ; c->cd(4);; gPad->SetGrid();; graphae->Draw(""a pl "");; ; c->cd(5);; gPad->SetGrid();; graphae->Draw(""a pl rx ry "");; ; c->cd(6);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphae->GetXaxis()->SetMoreLogLabels();; graphae->GetYaxis()->SetMoreLogLabels();; graphae->Draw(""a pl rx ry"");; ; // TGraphBentErrors; auto graphbe = new TGraphBentErrors();; graphbe->GetXaxis()->SetNdivisions(514);; graphbe->GetYaxis()->SetNdivisions(514);; graphbe->SetMarkerStyle(kCircle);; graphbe->SetPoint(0,5,5);; graphbe->SetPointError(0,1,3,3,1,.5,.2,.5,.2);; graphbe->SetPoint(1,9,9);; graphbe->SetPointError(1,1,3,1,3,-.5,-.2,-.5,-.2);; ; c->cd(7);; gPad->SetGrid();; graphbe->Draw(""a pl "");; ; c->cd(8);;",MatchSource.WIKI,doc/master/graphreverse_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphreverse_8C.html
https://root.cern/doc/master/graphreverse_8C.html:289,Testability,log,logarithmic,289,". ROOT: tutorials/graphs/graphreverse.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphreverse.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This example test all the various case of reverse graphs combined with logarithmic scale. . ; void graphreverse() {; auto c = new TCanvas(""c"",""Reversed graphs"",0,0,900,900);; c->Divide(3,3);; ; // TGraphErrors; auto graphe = new TGraphErrors();; graphe->GetXaxis()->SetNdivisions(514);; graphe->GetYaxis()->SetNdivisions(514);; graphe->SetMarkerStyle(kCircle);; graphe->SetPoint(0,5,5);; graphe->SetPointError(0,1,3);; graphe->SetPoint(1,9,9);; graphe->SetPointError(1,1,3);; ; c->cd(1);; gPad->SetGrid();; graphe->Draw(""a pl "");; ; c->cd(2);; gPad->SetGrid();; graphe->Draw(""a pl rx ry "");; ; c->cd(3);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphe->GetXaxis()->SetMoreLogLabels();; graphe->GetYaxis()->SetMoreLogLabels();; graphe->Draw(""a pl rx ry"");; ; // TGraphAsymmErrors; auto graphae = new TGraphAsymmErrors();; graphae->GetXaxis()->SetNdivisions(514);; graphae->GetYaxis()->SetNdivisions(514);; graphae->SetMarkerStyle(kCircle);; graphae->SetPoint(0,5,5);; graphae->SetPointError(0,1,3,3,1);; graphae->SetPoint(1,9,9);; graphae->SetPointError(1,1,3,1,3);; ; c->cd(4);; gPad->SetGrid();; graphae->Draw(""a pl "");; ; c->cd(5);; gPad->SetGrid();; graphae->Draw(""a pl rx ry "");; ; c->cd(6);; gPad->SetGrid();; gPad->SetLogx();; gPad->SetLogy();; graphae->GetXaxis()->SetMoreLogLabels();; graphae->GetYaxis()->SetMoreLogLabels();; graphae->Draw(""a pl rx ry"");; ; // TGraphBentErrors; auto graphbe = new TGraphBentErrors();; graphbe->GetXaxis()->SetNdivisions(514);; graphbe->GetYaxis()->SetNdivisions(514);; graphbe->SetMarkerStyle(kCircle);; graphbe->SetPoint(0,5,5);; graphbe->SetPointError(0,1,3,3,1,.5,.2,.5,.2);; graphbe->SetPoint(1,9,9);; graphbe->SetPointError(1,1,3,1,3,-.5,-.2,-.5,-.2);; ; c->cd(7);; gPad->SetGrid();; graphbe->Draw(""a pl "");; ; c->cd(8);;",MatchSource.WIKI,doc/master/graphreverse_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphreverse_8C.html
https://root.cern/doc/master/graphstruct_8C.html:485,Deployability,install,installed,485,". ROOT: tutorials/graphs/graphstruct.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphstruct.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a simple graph structure. ; The graph layout is made using graphviz. This macro creates some nodes and edges and change a few graphical attributes on some of them. ; TCanvas* graphstruct(); {; #if __has_include(""TGraphStruct.h"") // handy check on whether gviz was installed; TGraphStruct *gs = new TGraphStruct();; ; // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");; ; n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);; ; n3->SetTextFont(132);; ; n0->SetTextColor(kRed);; ; n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);; ; // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge(n3,n9);; gs->AddEdge(n6,n8);; gs->AddEdge(n7,n2);; gs->AddEdge(n8,n3);; gs->AddEdge(n2,n3);; gs->AddEdge(n9,n0);; gs->AddEdge(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);; ; TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; #else; return new TCanvas(""c"",""c"",800,600);; #endif; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; kViolet@",MatchSource.WIKI,doc/master/graphstruct_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphstruct_8C.html
https://root.cern/doc/master/graphstruct_8C.html:2977,Integrability,interface,interface,2977,"gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);; ; TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; #else; return new TCanvas(""c"",""c"",800,600);; #endif; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; kViolet@ kVioletDefinition Rtypes.h:67; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttText::SetTextColorvirtual void SetTextColor(Color_t tcolor=1)Set the text color.Definition TAttText.h:44; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphEdgeAn edge object connecting two nodes which can be added in a TGraphStruct.Definition TGraphEdge.h:25; TGraphNodeA graph node object which can be added in a TGraphStruct.Definition TGraphNode.h:27; TGraphStructThe Graph Structure is an interface to the graphviz package.Definition TGraphStruct.h:24; TGraphStruct::AddNodevoid AddNode(TGraphNode *node)Add the node ""node"" in this TGraphStruct.Definition TGraphStruct.cxx:114; TGraphStruct::Drawvoid Draw(Option_t *option="""") overrideDraw the graph.Definition TGraphStruct.cxx:158; TGraphStruct::AddEdgevoid AddEdge(TGraphEdge *edge)Add the edge ""edge"" in this TGraphStruct.Definition TGraphStruct.cxx:88; NoteFor this to work, ROOT has to be compiled with gviz ON ; AuthorOlivier Couet ; Definition in file graphstruct.C. tutorialsgraphsgraphstruct.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graphstruct_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphstruct_8C.html
https://root.cern/doc/master/graphstruct_8C.html:223,Usability,simpl,simple,223,". ROOT: tutorials/graphs/graphstruct.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphstruct.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a simple graph structure. ; The graph layout is made using graphviz. This macro creates some nodes and edges and change a few graphical attributes on some of them. ; TCanvas* graphstruct(); {; #if __has_include(""TGraphStruct.h"") // handy check on whether gviz was installed; TGraphStruct *gs = new TGraphStruct();; ; // create some nodes and put them in the graph in one go ...; TGraphNode *n0 = gs->AddNode(""n0"",""Node 0"");; TGraphNode *n1 = gs->AddNode(""n1"",""First node"");; TGraphNode *n2 = gs->AddNode(""n2"",""Second node"");; TGraphNode *n3 = gs->AddNode(""n3"",""Third node"");; TGraphNode *n4 = gs->AddNode(""n4"",""Fourth node"");; TGraphNode *n5 = gs->AddNode(""n5"",""5th node"");; TGraphNode *n6 = gs->AddNode(""n6"",""Node number six"");; TGraphNode *n7 = gs->AddNode(""n7"",""Node 7"");; TGraphNode *n8 = gs->AddNode(""n8"",""Node 8"");; TGraphNode *n9 = gs->AddNode(""n9"",""Node 9"");; ; n4->SetTextSize(0.03);; n6->SetTextSize(0.03);; n2->SetTextSize(0.04);; ; n3->SetTextFont(132);; ; n0->SetTextColor(kRed);; ; n9->SetFillColor(kRed-10);; n0->SetFillColor(kYellow-9);; n7->SetFillColor(kViolet-9);; ; // some edges ...; gs->AddEdge(n0,n1)->SetLineColor(kRed);; TGraphEdge *e06 = gs->AddEdge(n0,n6);; e06->SetLineColor(kRed-3);; e06->SetLineWidth(4);; gs->AddEdge(n1,n7);; gs->AddEdge(n4,n6);; gs->AddEdge(n3,n9);; gs->AddEdge(n6,n8);; gs->AddEdge(n7,n2);; gs->AddEdge(n8,n3);; gs->AddEdge(n2,n3);; gs->AddEdge(n9,n0);; gs->AddEdge(n1,n4);; gs->AddEdge(n1,n6);; gs->AddEdge(n2,n5);; gs->AddEdge(n3,n6);; gs->AddEdge(n4,n5);; ; TCanvas *c = new TCanvas(""c"",""c"",800,600);; c->SetFillColor(38);; gs->Draw();; return c;; #else; return new TCanvas(""c"",""c"",800,600);; #endif; }; c#define c(i)Definition RSha256.hxx:101; kRed@ kRedDefinition Rtypes.h:66; kYellow@ kYellowDefinition Rtypes.h:66; kViolet@",MatchSource.WIKI,doc/master/graphstruct_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphstruct_8C.html
https://root.cern/doc/master/graphtext_8C.html:411,Deployability,update,updated,411,". ROOT: tutorials/graphs/graphtext.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graphtext.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a graph with text attached to each point. ; The text is drawn in a TExec function attached to the TGraph, therefore if the a graph's point is moved interactively, the text will be automatically updated. ; void graphtext() {; TCanvas *c = new TCanvas(""c"",""A Simple Graph Example with Text"",700,500);; c->SetGrid();; ; const Int_t n = 10;; auto gr = new TGraph(n);; gr->SetTitle(""A Simple Graph Example with Text"");; gr->SetMarkerStyle(20);; auto ex = new TExec(""ex"",""drawtext();"");; gr->GetListOfFunctions()->Add(ex);; ; Double_t x, y;; for (Int_t i=0;i<n;i++) {; x = i*0.1;; y = 10*sin(x+0.2);; gr->SetPoint(i,x,y);; ; }; gr->Draw(""ALP"");; }; ; void drawtext(); {; Int_t i,n;; Double_t x,y;; TLatex l;; ; l.SetTextSize(0.025);; l.SetTextFont(42);; l.SetTextAlign(21);; l.SetTextColor(kBlue);; ; auto g = (TGraph*)gPad->GetListOfPrimitives()->FindObject(""Graph"");; n = g->GetN();; ; for (i=0; i<n; i++) {; g->GetPoint(i,x,y);; l.PaintText(x,y+0.2,Form(""(%4.2f,%4.2f)"",x,y));; }; }; ; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; kBlue@ kBlueDefinition Rtypes.h:66; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; gPad#define gPadDefinition TVirtualPad.h:308; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad.Definition TExec.h:26; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoin",MatchSource.WIKI,doc/master/graphtext_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graphtext_8C.html
https://root.cern/doc/master/graph_8C.html:211,Usability,simpl,simple,211,". ROOT: tutorials/graphs/graph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a simple graph. . ; void graph() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; ; c1->SetGrid();; ; const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; printf("" i %i %f %f \n"",i,x[i],y[i]);; }; TGraph *gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->SetTitle(""a simple graph"");; gr->GetXaxis()->SetTitle(""X title"");; gr->GetYaxis()->SetTitle(""Y title"");; gr->Draw(""ACP"");; ; // TCanvas::Update() draws the frame, after which one can change it; c1->Update();; c1->GetFrame()->SetBorderSize(12);; c1->Modified();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TNamed::SetTit",MatchSource.WIKI,doc/master/graph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_8C.html
https://root.cern/doc/master/graph_8C.html:634,Usability,simpl,simple,634,". ROOT: tutorials/graphs/graph.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph.C File ReferenceTutorials » Graphs tutorials. Detailed Description; Draw a simple graph. . ; void graph() {; TCanvas *c1 = new TCanvas(""c1"",""A Simple Graph Example"",200,10,700,500);; ; c1->SetGrid();; ; const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; printf("" i %i %f %f \n"",i,x[i],y[i]);; }; TGraph *gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->SetTitle(""a simple graph"");; gr->GetXaxis()->SetTitle(""X title"");; gr->GetYaxis()->SetTitle(""Y title"");; gr->Draw(""ACP"");; ; // TCanvas::Update() draws the frame, after which one can change it; c1->Update();; c1->GetFrame()->SetBorderSize(12);; c1->Modified();; }; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerColorvirtual void SetMarkerColor(Color_t mcolor=1)Set the marker color.Definition TAttMarker.h:38; TAttMarker::SetMarkerStylevirtual void SetMarkerStyle(Style_t mstyle=1)Set the marker style.Definition TAttMarker.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::Drawvoid Draw(Option_t *chopt="""") overrideDraw this graph with its current attributes.Definition TGraph.cxx:831; TGraph::GetXaxisTAxis * GetXaxis() constGet x axis of the graph.Definition TGraph.cxx:1566; TGraph::GetYaxisTAxis * GetYaxis() constGet y axis of the graph.Definition TGraph.cxx:1575; TGraph::SetTitlevoid SetTitle(const char *title="""") overrideChange (i.e.Definition TGraph.cxx:2397; TNamed::SetTit",MatchSource.WIKI,doc/master/graph_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_8C.html
https://root.cern/doc/master/graph_8py.html:1668,Security,access,access,1668,"e Graph Example . i 0 0.000000 1.986693 ; i 1 0.100000 2.955202 ; i 2 0.200000 3.894183 ; i 3 0.300000 4.794255 ; i 4 0.400000 5.646425 ; i 5 0.500000 6.442177 ; i 6 0.600000 7.173561 ; i 7 0.700000 7.833269 ; i 8 0.800000 8.414710 ; i 9 0.900000 8.912074 ; i 10 1.000000 9.320391 ; i 11 1.100000 9.635582 ; i 12 1.200000 9.854497 ; i 13 1.300000 9.974950 ; i 14 1.400000 9.995736 ; i 15 1.500000 9.916648 ; i 16 1.600000 9.738476 ; i 17 1.700000 9.463001 ; i 18 1.800000 9.092974 ; i 19 1.900000 8.632094 ; ; from __future__ import print_function; from ROOT import TCanvas, TGraph; from ROOT import gROOT; from math import sin; from array import array; ; ; c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); ; c1.SetFillColor( 42 ); c1.SetGrid(); ; n = 20; x, y = array( 'd' ), array( 'd' ); ; for i in range( n ):; x.append( 0.1*i ); y.append( 10*sin( x[i]+0.2 ) ); print(' i %i %f %f ' % (i,x[i],y[i])); ; gr = TGraph( n, x, y ); gr.SetLineColor( 2 ); gr.SetLineWidth( 4 ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.SetTitle( 'a simple graph' ); gr.GetXaxis().SetTitle( 'X title' ); gr.GetYaxis().SetTitle( 'Y title' ); gr.Draw( 'ACP' ); ; # TCanvas.Update() draws the frame, after which one can change it; c1.Update(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); c1.Modified(); c1.Update(); # If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; # This will access the interactive mode after executing the script, and thereby persist; # long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file graph.py. tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_8py.html
https://root.cern/doc/master/graph_8py.html:1284,Usability,simpl,simple,1284,"e Graph Example . i 0 0.000000 1.986693 ; i 1 0.100000 2.955202 ; i 2 0.200000 3.894183 ; i 3 0.300000 4.794255 ; i 4 0.400000 5.646425 ; i 5 0.500000 6.442177 ; i 6 0.600000 7.173561 ; i 7 0.700000 7.833269 ; i 8 0.800000 8.414710 ; i 9 0.900000 8.912074 ; i 10 1.000000 9.320391 ; i 11 1.100000 9.635582 ; i 12 1.200000 9.854497 ; i 13 1.300000 9.974950 ; i 14 1.400000 9.995736 ; i 15 1.500000 9.916648 ; i 16 1.600000 9.738476 ; i 17 1.700000 9.463001 ; i 18 1.800000 9.092974 ; i 19 1.900000 8.632094 ; ; from __future__ import print_function; from ROOT import TCanvas, TGraph; from ROOT import gROOT; from math import sin; from array import array; ; ; c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); ; c1.SetFillColor( 42 ); c1.SetGrid(); ; n = 20; x, y = array( 'd' ), array( 'd' ); ; for i in range( n ):; x.append( 0.1*i ); y.append( 10*sin( x[i]+0.2 ) ); print(' i %i %f %f ' % (i,x[i],y[i])); ; gr = TGraph( n, x, y ); gr.SetLineColor( 2 ); gr.SetLineWidth( 4 ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.SetTitle( 'a simple graph' ); gr.GetXaxis().SetTitle( 'X title' ); gr.GetYaxis().SetTitle( 'Y title' ); gr.Draw( 'ACP' ); ; # TCanvas.Update() draws the frame, after which one can change it; c1.Update(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); c1.Modified(); c1.Update(); # If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; # This will access the interactive mode after executing the script, and thereby persist; # long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file graph.py. tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_8py.html
https://root.cern/doc/master/graph_8py_source.html:1375,Security,access,access,1375,". ROOT: tutorials/pyroot/graph.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook; 4## A Simple Graph Example; 5##; 6## \macro_image; 7## \macro_output; 8## \macro_code; 9##; 10## \author Wim Lavrijsen; 11 ; 12from __future__ import print_function; 13from ROOT import TCanvas, TGraph; 14from ROOT import gROOT; 15from math import sin; 16from array import array; 17 ; 18 ; 19c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); 20 ; 21c1.SetFillColor( 42 ); 22c1.SetGrid(); 23 ; 24n = 20; 25x, y = array( 'd' ), array( 'd' ); 26 ; 27for i in range( n ):; 28 x.append( 0.1*i ); 29 y.append( 10*sin( x[i]+0.2 ) ); 30 print(' i %i %f %f ' % (i,x[i],y[i])); 31 ; 32gr = TGraph( n, x, y ); 33gr.SetLineColor( 2 ); 34gr.SetLineWidth( 4 ); 35gr.SetMarkerColor( 4 ); 36gr.SetMarkerStyle( 21 ); 37gr.SetTitle( 'a simple graph' ); 38gr.GetXaxis().SetTitle( 'X title' ); 39gr.GetYaxis().SetTitle( 'Y title' ); 40gr.Draw( 'ACP' ); 41 ; 42# TCanvas.Update() draws the frame, after which one can change it; 43c1.Update(); 44c1.GetFrame().SetFillColor( 21 ); 45c1.GetFrame().SetBorderSize( 12 ); 46c1.Modified(); 47c1.Update(); 48# If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; 49# This will access the interactive mode after executing the script, and thereby persist; 50# long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2). tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_8py_source.html
https://root.cern/doc/master/graph_8py_source.html:966,Usability,simpl,simple,966,". ROOT: tutorials/pyroot/graph.py Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph.py. Go to the documentation of this file. 1## \file; 2## \ingroup tutorial_pyroot; 3## \notebook; 4## A Simple Graph Example; 5##; 6## \macro_image; 7## \macro_output; 8## \macro_code; 9##; 10## \author Wim Lavrijsen; 11 ; 12from __future__ import print_function; 13from ROOT import TCanvas, TGraph; 14from ROOT import gROOT; 15from math import sin; 16from array import array; 17 ; 18 ; 19c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); 20 ; 21c1.SetFillColor( 42 ); 22c1.SetGrid(); 23 ; 24n = 20; 25x, y = array( 'd' ), array( 'd' ); 26 ; 27for i in range( n ):; 28 x.append( 0.1*i ); 29 y.append( 10*sin( x[i]+0.2 ) ); 30 print(' i %i %f %f ' % (i,x[i],y[i])); 31 ; 32gr = TGraph( n, x, y ); 33gr.SetLineColor( 2 ); 34gr.SetLineWidth( 4 ); 35gr.SetMarkerColor( 4 ); 36gr.SetMarkerStyle( 21 ); 37gr.SetTitle( 'a simple graph' ); 38gr.GetXaxis().SetTitle( 'X title' ); 39gr.GetYaxis().SetTitle( 'Y title' ); 40gr.Draw( 'ACP' ); 41 ; 42# TCanvas.Update() draws the frame, after which one can change it; 43c1.Update(); 44c1.GetFrame().SetFillColor( 21 ); 45c1.GetFrame().SetBorderSize( 12 ); 46c1.Modified(); 47c1.Update(); 48# If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; 49# This will access the interactive mode after executing the script, and thereby persist; 50# long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2). tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_8py_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_8py_source.html
https://root.cern/doc/master/graph_legend.html:1840,Energy Efficiency,green,green,1840,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:319,Modifiability,inherit,inheritance,319,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:492,Modifiability,inherit,inherited,492,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:515,Modifiability,inherit,inheritance,515,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:656,Modifiability,inherit,inherited,656,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:682,Modifiability,inherit,inheritance,682,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:744,Modifiability,inherit,inherited,744,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:768,Modifiability,inherit,inheritance,768,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:900,Modifiability,inherit,inherits,900,". ROOT: Graph Legend. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Graph Legend. This page explains how to interpret the graphs that are generated by doxygen.; Consider the following example: /*! Invisible class because of truncation */; class Invisible { };; ; /*! Truncated class, inheritance relation is hidden */; class Truncated : public Invisible { };; ; /* Class not documented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or use",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:1585,Modifiability,inherit,inheritance,1585,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:1789,Modifiability,inherit,inheritance,1789,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:1874,Modifiability,inherit,inheritance,1874,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:1926,Modifiability,inherit,inheritance,1926,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:2052,Modifiability,variab,variable,2052,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:2109,Security,access,accessible,2109,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph_legend.html:1475,Usability,undo,undocumented,1475,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph_legend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph_legend.html
https://root.cern/doc/master/graph__edit__playback_8C.html:2201,Integrability,interface,interface,2201,"gle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRecorderClass provides direct recorder/replayer interface for a user.Definition TRecorder.h:266; TRecorder::Stopvoid Stop(Bool_t guiCommand=kFALSE)Stopps recording events.Definition TRecorder.cxx:230; TRecorder::Startvoid Start(const char *filename, Option_t *option=""RECREATE"", Window_t *w=nullptr, Int_t winCount=0)Starts recording events.Definition TRecorder.cxx:221; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; Note: The previous commands should be copy/pasted into a ROOT session, not executed as a macro. The interactive editing shows. Object editing using object editors; Direct editing on the graphics canvas; Saving PS and bitmap files.; Saving as a .C file: C++ code corresponding to the modifications is saved. The sketch of the recorded actions is; On the canvas c1. Open View/Editor; Select histogram; Change ",MatchSource.WIKI,doc/master/graph__edit__playback_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph__edit__playback_8C.html
https://root.cern/doc/master/graph__edit__playback_8C.html:292,Performance,perform,perform,292,". ROOT: tutorials/graphics/graph_edit_playback.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. graph_edit_playback.C File ReferenceTutorials » Graphics tutorials. Detailed Description; This macro plays a recorded ROOT session showing how to perform various interactive graphical editing operations. ; The initial graphics setup was created using the following root commands: TRecorder *t = new TRecorder();; t->Start(""graphedit_playback.root"");; gStyle->SetPalette(1);; TCanvas *c2 = new TCanvas(""c2"",""c2"",0,0,700,500);; TH2F* h2 = new TH2F(""h2"",""Random 2D Gaussian"",40,-4,4,40,-4,4);; h2->SetDirectory(0);; TRandom r;; for (int i=0;i<50000;i++) h2->Fill(r.Gaus(),r.Gaus());; h2->Draw();; gPad->Update();; TCanvas *c1 = new TCanvas(""c1"",""c1"",0,0,700,500);; TH1F* h1 = new TH1F(""h1"",""Random 1D Gaussian"",100,-4,4);; h1->SetDirectory(0);; h1->FillRandom(""gaus"",10000);; h1->Draw();; gPad->Update();; ; // Here the following ""sketch"" was done.; ; t->Stop();; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TCanvasThe Canvas class.Definition TCanvas.h:23; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::SetDirectoryvirtual void SetDirectory(TDirectory *dir)By default, when a histogram is created, it is added to the list of histogram objects in the current ...Definition TH1.cxx:8937; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float",MatchSource.WIKI,doc/master/graph__edit__playback_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph__edit__playback_8C.html
https://root.cern/doc/master/graph__edit__playback_8C.html:3510,Testability,log,log,3510,"r/replayer interface for a user.Definition TRecorder.h:266; TRecorder::Stopvoid Stop(Bool_t guiCommand=kFALSE)Stopps recording events.Definition TRecorder.cxx:230; TRecorder::Startvoid Start(const char *filename, Option_t *option=""RECREATE"", Window_t *w=nullptr, Int_t winCount=0)Starts recording events.Definition TRecorder.cxx:221; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; c1return c1Definition legend1.C:41; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; Note: The previous commands should be copy/pasted into a ROOT session, not executed as a macro. The interactive editing shows. Object editing using object editors; Direct editing on the graphics canvas; Saving PS and bitmap files.; Saving as a .C file: C++ code corresponding to the modifications is saved. The sketch of the recorded actions is; On the canvas c1. Open View/Editor; Select histogram; Change fill style; Change fill color; Move stat box; Change fill color; Move title; Change fill color using wheel color; Select Y axis; Change axis title; Select X axis; Change axis title; Select histogram; Go in binning; Change range; Move range; On the canvas menu set grid Y; On the canvas menu set grid X; On the canvas menu set log Y; Increase the range; Close View/Editor; Open the Tool Bar; Create a text ""Comment""; Create an arrow; Change the arrow size; Close the Tool Bar; Save as PS file; Save as C file; Close c1 On the canvas c2. Open View/Editor; Select histogram; Select COL; Select Palette; Move Stats; Select Overflows; Select histogram; Select 3D; Select SURF1; Rotate Surface; Go in binning; Change X range; Change Y range; Close View/Editor; Save as GIF file; Save as C file; Close c2 AuthorOlivier Couet . Definition in file graph_edit_playback.C. tutorialsgraphicsgraph_edit_playback.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/graph__edit__playback_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/graph__edit__playback_8C.html
https://root.cern/doc/master/group__Base.html:270,Availability,avail,available,270,". ROOT: Base ROOT classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Base ROOT classesCore ROOT classes. ; The Base classes of ROOT. ; The base classes of the ROOT system provide the core of the system. They are available to all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:1099,Availability,error,error,1099,"e Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Base ROOT classesCore ROOT classes. ; The Base classes of ROOT. ; The base classes of the ROOT system provide the core of the system. They are available to all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for element",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:1434,Availability,error,error,1434,"ervices like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TBase64;  This code implements the Base64 encoding",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:336,Integrability,interface,interfaces,336,". ROOT: Base ROOT classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Base ROOT classesCore ROOT classes. ; The Base classes of ROOT. ; The base classes of the ROOT system provide the core of the system. They are available to all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:1320,Integrability,wrap,wraps,1320," all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:1581,Integrability,interface,interfaces,1581,"rce processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TBase64;  This code implements the Base64 encoding and decoding. More...;  ; class  TBenchmark;  This class is a ROOT utility to help benchmarking applications. More...;  ; class  TBrowser;  ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:1740,Integrability,protocol,protocol,1740,ectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TBase64;  This code implements the Base64 encoding and decoding. More...;  ; class  TBenchmark;  This class is a ROOT utility to help benchmarking applications. More...;  ; class  TBrowser;  Using a TBrowser one can browse all ROOT objects. More...;  ; class  TBrowserImp;  ABC describing GUI independent browser implemen,MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:2708,Integrability,protocol,protocol,2708,"tionImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TBase64;  This code implements the Base64 encoding and decoding. More...;  ; class  TBenchmark;  This class is a ROOT utility to help benchmarking applications. More...;  ; class  TBrowser;  Using a TBrowser one can browse all ROOT objects. More...;  ; class  TBrowserImp;  ABC describing GUI independent browser implementation protocol. More...;  ; class  TBuffer;  Buffer base class used for serializing objects. More...;  ; class  TBuffer3D;  Generic 3D primitive description class. More...;  ; class  TCanvasImp;  ABC describing GUI independent main window (with menubar, scrollbars and a drawing area). More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class provides an interface to GUI independent context sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDati",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:3405,Integrability,interface,interface,3405,"mplements the Base64 encoding and decoding. More...;  ; class  TBenchmark;  This class is a ROOT utility to help benchmarking applications. More...;  ; class  TBrowser;  Using a TBrowser one can browse all ROOT objects. More...;  ; class  TBrowserImp;  ABC describing GUI independent browser implementation protocol. More...;  ; class  TBuffer;  Buffer base class used for serializing objects. More...;  ; class  TBuffer3D;  Generic 3D primitive description class. More...;  ; class  TCanvasImp;  ABC describing GUI independent main window (with menubar, scrollbars and a drawing area). More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class provides an interface to GUI independent context sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDatime;  This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559). More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  ; class  TFileCollection;  Class that contains a list of TFileInfo's and accumulated meta data information about its entries. More...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:3509,Integrability,interface,interface,3509,"p benchmarking applications. More...;  ; class  TBrowser;  Using a TBrowser one can browse all ROOT objects. More...;  ; class  TBrowserImp;  ABC describing GUI independent browser implementation protocol. More...;  ; class  TBuffer;  Buffer base class used for serializing objects. More...;  ; class  TBuffer3D;  Generic 3D primitive description class. More...;  ; class  TCanvasImp;  ABC describing GUI independent main window (with menubar, scrollbars and a drawing area). More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class provides an interface to GUI independent context sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDatime;  This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559). More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  ; class  TFileCollection;  Class that contains a list of TFileInfo's and accumulated meta data information about its entries. More...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depend",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:4365,Integrability,interface,interface,4365,"TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class provides an interface to GUI independent context sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDatime;  This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559). More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  ; class  TFileCollection;  Class that contains a list of TFileInfo's and accumulated meta data information about its entries. More...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A collection of TDataType designed to hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:4506,Integrability,depend,depending,4506,"ontext sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDatime;  This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559). More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  ; class  TFileCollection;  Class that contains a list of TFileInfo's and accumulated meta data information about its entries. More...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A collection of TDataType designed to hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; class  TNamed;  The TNamed class is the base class for all named ROOT classes. More...;  ; class  TNotifyLink< Type >;  A node in a doubly linked list of subscribers to TCh",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:5136,Integrability,message,message-digest,5136,"contains a list of TFileInfo's and accumulated meta data information about its entries. More...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A collection of TDataType designed to hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; class  TNamed;  The TNamed class is the base class for all named ROOT classes. More...;  ; class  TNotifyLink< Type >;  A node in a doubly linked list of subscribers to TChain notifications. More...;  ; class  TObject;  Mother of all ROOT objects. More...;  ; class  TObjectSpy;  Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. More...;  ; class  TObjString;  Collectable string class. More...;  ; class  TParameter< AParamType >;  Named parameter, streamable and storable. More...;  ; class  TPluginManager;  This class implements a plugin library manager. More...;  ; class  TProcessID;  A TProcessID identifies a ROOT job in a unique way in time and space. More...;  ; class  TProcessUUID;  This class is",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:5307,Integrability,message,messages,5307," ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A collection of TDataType designed to hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; class  TNamed;  The TNamed class is the base class for all named ROOT classes. More...;  ; class  TNotifyLink< Type >;  A node in a doubly linked list of subscribers to TChain notifications. More...;  ; class  TObject;  Mother of all ROOT objects. More...;  ; class  TObjectSpy;  Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. More...;  ; class  TObjString;  Collectable string class. More...;  ; class  TParameter< AParamType >;  Named parameter, streamable and storable. More...;  ; class  TPluginManager;  This class implements a plugin library manager. More...;  ; class  TProcessID;  A TProcessID identifies a ROOT job in a unique way in time and space. More...;  ; class  TProcessUUID;  This class is a specialized TProcessID managing the list of UUIDs. More...;  ; class  TQCommand;  The Command design pattern is based on the idea, that all editing in an application is done by creatin",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:6957,Integrability,protocol,protocol,6957,"n library manager. More...;  ; class  TProcessID;  A TProcessID identifies a ROOT job in a unique way in time and space. More...;  ; class  TProcessUUID;  This class is a specialized TProcessID managing the list of UUIDs. More...;  ; class  TQCommand;  The Command design pattern is based on the idea, that all editing in an application is done by creating instances of command objects. More...;  ; class  TQConnection;  TQConnection class is an internal class, used in the object communication mechanism. More...;  ; class  TQObject;  This is the ROOT implementation of the Qt object communication mechanism (see also http://www.troll.no/qt/metaobjects.html) More...;  ; class  TRef;  Persistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject. More...;  ; class  TRefCnt;  Definitions for TRefCnt, base class for reference counted objects. More...;  ; class  TRegexp;  Regular expression class. More...;  ; class  TRemoteObject;  The TRemoteObject class provides protocol for browsing ROOT objects from a remote ROOT session. More...;  ; class  TROOT;  ROOT top level object description. More...;  ; class  TStopwatch;  Stopwatch class. More...;  ; class  TStorage;  Storage manager. More...;  ; class  TString;  Basic string class. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  ; class  TSysEvtHandler;  Abstract base class for handling system events. More...;  ; class  TSystem;  Abstract base class defining a generic interface to the underlying Operating System. More...;  ; class  TSystemDirectory;  Describes an Operating System directory for the browser. More...;  ; class  TSystemFile;  A TSystemFile describes an operating system file. More...;  ; class  TTask;   Legacy Code TTask is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. M",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:7463,Integrability,interface,interface,7463,"hanism. More...;  ; class  TQObject;  This is the ROOT implementation of the Qt object communication mechanism (see also http://www.troll.no/qt/metaobjects.html) More...;  ; class  TRef;  Persistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject. More...;  ; class  TRefCnt;  Definitions for TRefCnt, base class for reference counted objects. More...;  ; class  TRegexp;  Regular expression class. More...;  ; class  TRemoteObject;  The TRemoteObject class provides protocol for browsing ROOT objects from a remote ROOT session. More...;  ; class  TROOT;  ROOT top level object description. More...;  ; class  TStopwatch;  Stopwatch class. More...;  ; class  TStorage;  Storage manager. More...;  ; class  TString;  Basic string class. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  ; class  TSysEvtHandler;  Abstract base class for handling system events. More...;  ; class  TSystem;  Abstract base class defining a generic interface to the underlying Operating System. More...;  ; class  TSystemDirectory;  Describes an Operating System directory for the browser. More...;  ; class  TSystemFile;  A TSystemFile describes an operating system file. More...;  ; class  TTask;   Legacy Code TTask is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globall",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:7745,Integrability,interface,interface,7745," class  TRefCnt;  Definitions for TRefCnt, base class for reference counted objects. More...;  ; class  TRegexp;  Regular expression class. More...;  ; class  TRemoteObject;  The TRemoteObject class provides protocol for browsing ROOT objects from a remote ROOT session. More...;  ; class  TROOT;  ROOT top level object description. More...;  ; class  TStopwatch;  Stopwatch class. More...;  ; class  TStorage;  Storage manager. More...;  ; class  TString;  Basic string class. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  ; class  TSysEvtHandler;  Abstract base class for handling system events. More...;  ; class  TSystem;  Abstract base class defining a generic interface to the underlying Operating System. More...;  ; class  TSystemDirectory;  Describes an Operating System directory for the browser. More...;  ; class  TSystemFile;  A TSystemFile describes an operating system file. More...;  ; class  TTask;   Legacy Code TTask is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract b",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:7886,Integrability,depend,depending,7886,"ect;  The TRemoteObject class provides protocol for browsing ROOT objects from a remote ROOT session. More...;  ; class  TROOT;  ROOT top level object description. More...;  ; class  TStopwatch;  Stopwatch class. More...;  ; class  TStorage;  Storage manager. More...;  ; class  TString;  Basic string class. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  ; class  TSysEvtHandler;  Abstract base class for handling system events. More...;  ; class  TSystem;  Abstract base class defining a generic interface to the underlying Operating System. More...;  ; class  TSystemDirectory;  Describes an Operating System directory for the browser. More...;  ; class  TSystemFile;  A TSystemFile describes an operating system file. More...;  ; class  TTask;   Legacy Code TTask is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:8657,Integrability,interface,interface,8657,"bes an operating system file. More...;  ; class  TTask;   Legacy Code TTask is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:8826,Integrability,interface,interface,8826,"herefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:8926,Integrability,interface,interface,8926,"herefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:9285,Integrability,interface,interface,9285,"herefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:9419,Integrability,interface,interface,9419,"herefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:9594,Integrability,interface,interface,9594,"herefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:538,Modifiability,plugin,plugin,538,". ROOT: Base ROOT classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Base ROOT classesCore ROOT classes. ; The Base classes of ROOT. ; The base classes of the ROOT system provide the core of the system. They are available to all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:558,Modifiability,config,config,558,". ROOT: Base ROOT classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Base ROOT classesCore ROOT classes. ; The Base classes of ROOT. ; The base classes of the ROOT system provide the core of the system. They are available to all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:3108,Modifiability,extend,extends,3108,"  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TBase64;  This code implements the Base64 encoding and decoding. More...;  ; class  TBenchmark;  This class is a ROOT utility to help benchmarking applications. More...;  ; class  TBrowser;  Using a TBrowser one can browse all ROOT objects. More...;  ; class  TBrowserImp;  ABC describing GUI independent browser implementation protocol. More...;  ; class  TBuffer;  Buffer base class used for serializing objects. More...;  ; class  TBuffer3D;  Generic 3D primitive description class. More...;  ; class  TCanvasImp;  ABC describing GUI independent main window (with menubar, scrollbars and a drawing area). More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class provides an interface to GUI independent context sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDatime;  This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559). More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  ; class  TF",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:3908,Modifiability,config,config,3908,"scribing GUI independent main window (with menubar, scrollbars and a drawing area). More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class provides an interface to GUI independent context sensitive popup menus. More...;  ; class  TControlBarImp;  ABC describing GUI independent control bar. More...;  ; class  TDatime;  This class stores the date and time with a precision of one second in an unsigned 32 bit word (950130 124559). More...;  ; class  TDirectory;  Describe directory structure in memory. More...;  ; class  TEnv;  The TEnv class reads config files, by default named .rootrc. More...;  ; class  TExec;  TExec is a utility class that can be used to execute a C++ command when some event happens in a pad. More...;  ; class  TFileCollection;  Class that contains a list of TFileInfo's and accumulated meta data information about its entries. More...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A co",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:5952,Modifiability,plugin,plugin,5952," hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; class  TNamed;  The TNamed class is the base class for all named ROOT classes. More...;  ; class  TNotifyLink< Type >;  A node in a doubly linked list of subscribers to TChain notifications. More...;  ; class  TObject;  Mother of all ROOT objects. More...;  ; class  TObjectSpy;  Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. More...;  ; class  TObjString;  Collectable string class. More...;  ; class  TParameter< AParamType >;  Named parameter, streamable and storable. More...;  ; class  TPluginManager;  This class implements a plugin library manager. More...;  ; class  TProcessID;  A TProcessID identifies a ROOT job in a unique way in time and space. More...;  ; class  TProcessUUID;  This class is a specialized TProcessID managing the list of UUIDs. More...;  ; class  TQCommand;  The Command design pattern is based on the idea, that all editing in an application is done by creating instances of command objects. More...;  ; class  TQConnection;  TQConnection class is an internal class, used in the object communication mechanism. More...;  ; class  TQObject;  This is the ROOT implementation of the Qt object communication mechanism (see also http://www.troll.no/qt/metaobjects.html) More...;  ; class  TRef;  Persistent Reference link to a TObject A TRef is a lightweight object pointing to any TObject. More...;  ; class  TRefCnt;  Definitions for TRefCnt, base class for reference counted objects. More...;  ; class  TRegexp;  Regular expression class. More...;  ; class  TRemoteObject;  The TRemoteOb",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:8551,Modifiability,plugin,plugin,8551,";  Describes an Operating System directory for the browser. More...;  ; class  TSystemFile;  A TSystemFile describes an operating system file. More...;  ; class  TTask;   Legacy Code TTask is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtua",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:9318,Performance,perform,performance,9318,"herefore it is not recommended to use it in new long-term production code. But, depending on the context, using TTask might still be a valid solution. More...;  ; class  TTime;  Basic time type with millisecond precision. More...;  ; class  TTimer;  Handles synchronous and a-synchronous timer events. More...;  ; class  TTimeStamp;  The TTimeStamp encapsulates seconds and ns since EPOCH. More...;  ; class  TUri;  This class represents a RFC 3986 compatible URI. More...;  ; class  TUrl;  This class represents a WWW compatible URL. More...;  ; class  TUUID;  This class defines a UUID (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier). More...;  ; class  TVersionCheck;  Used to check if the shared library or plugin is compatible with the current version of ROOT. More...;  ; class  TVirtualFFT;  TVirtualFFT is an interface class for Fast Fourier Transforms. More...;  ; class  TVirtualMapFile;  Abstract base class for TMapFile. More...;  ; class  TVirtualMonitoring;  Provides the interface for externel Monitoring. More...;  ; class  TVirtualMutex;  This class implements a mutex interface. More...;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  ; class  TVirtualPadEditor;  Abstract base class used by ROOT graphics editor. More...;  ; class  TVirtualPadPainter;  To make it possible to use GL for 2D graphic in a TPad/TCanvas. More...;  ; class  TVirtualPerfStats;  Provides the interface for the PROOF internal performance measurement and event tracing. More...;  ; class  TVirtualPS;  TVirtualPS is an abstract interface to Postscript, PDF, SVG. More...;  ; class  TVirtualViewer3D;  Abstract 3D shapes viewer. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:495,Security,checksum,checksumming,495,". ROOT: Base ROOT classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Base ROOT classesCore ROOT classes. ; The Base classes of ROOT. ; The base classes of the ROOT system provide the core of the system. They are available to all other classes. They range from a set of abstract interfaces (TVirtualXXXXX classes), to a wide range of basic utility classes providing basic services like strings, regular expression, timers, date/time, md5 checksumming, signal/slots event handling, plugin handler, run-config resource processor, etc. etc. . Files; file  RConversionRuleParser.cxx;  ; file  RDirectory.cxx;  ; file  RDirectory.hxx;  ; file  RDirectoryEntry.hxx;  ; file  RError.cxx;  ; file  RError.hxx;  ; file  RFile.cxx;  ; file  RFile.hxx;  ; file  RIndexIter.hxx;  ; file  RLogger.cxx;  ; file  RLogger.hxx;  ; file  RNotFn.hxx;  ; file  RRangeCast.hxx;  ; file  RSpan.hxx;  ; file  span.hxx;  ; file  StringUtils.hxx;  ; file  TClassEdit.cxx;  . Classes; class  ROOT::Experimental::RError;  Captures diagnostics related to a ROOT runtime error. More...;  ; class  ROOT::Experimental::RException;  Base class for all ROOT issued exceptions. More...;  ; class  ROOT::Experimental::RResult< T >;  The class is used as a return type for operations that can fail; wraps a value of type T or an RError. More...;  ; class  ROOT::Experimental::RResultBase;  Common handling of the error case for RResult<T> (T != void) and RResult<void> More...;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:5224,Security,access,accessing,5224,"e...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A collection of TDataType designed to hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; class  TNamed;  The TNamed class is the base class for all named ROOT classes. More...;  ; class  TNotifyLink< Type >;  A node in a doubly linked list of subscribers to TChain notifications. More...;  ; class  TObject;  Mother of all ROOT objects. More...;  ; class  TObjectSpy;  Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. More...;  ; class  TObjString;  Collectable string class. More...;  ; class  TParameter< AParamType >;  Named parameter, streamable and storable. More...;  ; class  TPluginManager;  This class implements a plugin library manager. More...;  ; class  TProcessID;  A TProcessID identifies a ROOT job in a unique way in time and space. More...;  ; class  TProcessUUID;  This class is a specialized TProcessID managing the list of UUIDs. More...;  ; class  TQCommand;  The Co",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__Base.html:2514,Testability,benchmark,benchmarking,2514,".;  ; class  TApplication;  This class creates the ROOT Application Environment that interfaces to the windowing system eventloop and eventhandlers. More...;  ; class  TApplicationImp;  ABC describing GUI independent application implementation protocol. More...;  ; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TBase64;  This code implements the Base64 encoding and decoding. More...;  ; class  TBenchmark;  This class is a ROOT utility to help benchmarking applications. More...;  ; class  TBrowser;  Using a TBrowser one can browse all ROOT objects. More...;  ; class  TBrowserImp;  ABC describing GUI independent browser implementation protocol. More...;  ; class  TBuffer;  Buffer base class used for serializing objects. More...;  ; class  TBuffer3D;  Generic 3D primitive description class. More...;  ; class  TCanvasImp;  ABC describing GUI independent main window (with menubar, scrollbars and a drawing area). More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TDirectory::TContext;  TDirectory::TContext keeps track and restore the current directory. More...;  ; class  TContextMenu;  This class provides an interface to context sensitive popup menus. More...;  ; class  TContextMenuImp;  This class",MatchSource.WIKI,doc/master/group__Base.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Base.html
https://root.cern/doc/master/group__BasicGraphics.html:1222,Integrability,interface,interface,1222,c. More...;  ; class  TArrow;  Draw all kinds of Arrows. More...;  ; class  TAttImage;  TImage attributes. More...;  ; class  TAxisModLab;  TAxis helper class used to store the modified labels. More...;  ; class  TBox;  Create a Box. More...;  ; class  TCandle;  The candle plot painter class. More...;  ; class  TCrown;  To draw a Crown. More...;  ; class  TCurlyArc;  Implements curly or wavy arcs used to draw Feynman diagrams. More...;  ; class  TCurlyLine;  Implements curly or wavy polylines used to draw Feynman diagrams. More...;  ; class  TCutG;  Graphical cut class. More...;  ; class  TDiamond;  Draw a Diamond. More...;  ; class  TEllipse;  Draw Ellipses. More...;  ; class  TFrame;  Define a Frame. More...;  ; class  TGaxis;  The axis painter class. More...;  ; class  TGraphPolar;  To draw a polar graph. More...;  ; class  TGraphPolargram;  To draw polar axis. More...;  ; class  TGraphQQ;  This class allows to draw quantile-quantile plots. More...;  ; class  TImage;  An abstract interface to image processing library. More...;  ; class  TImagePalette;  A class to define a conversion from pixel values to pixel color. More...;  ; class  TLatex;  To draw Mathematical Formula. More...;  ; class  TLegend;  This class displays a legend box (TPaveText) containing several legend entries. More...;  ; class  TLegendEntry;  Storage class for one entry of a TLegend. More...;  ; class  TLine;  Use the TLine constructor to create a simple line. More...;  ; class  TLink;  Special TText object used to show hyperlinks. More...;  ; class  TMarker;  Manages Markers. More...;  ; class  TMathText;  To draw TeX Mathematical Formula. More...;  ; class  TPaletteEditor;  Edit the palette via a GUI. More...;  ; class  TPave;  A TBox with a bordersize and a shadow option. More...;  ; class  TPaveLabel;  A Pave (see TPave) with a text centered in the Pave. More...;  ; class  TPaveStats;  The histogram statistics painter class. More...;  ; class  TPavesText;  A PaveText (see TPaveText) with s,MatchSource.WIKI,doc/master/group__BasicGraphics.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__BasicGraphics.html
https://root.cern/doc/master/group__BasicGraphics.html:1669,Usability,simpl,simple,1669,"iagrams. More...;  ; class  TCurlyLine;  Implements curly or wavy polylines used to draw Feynman diagrams. More...;  ; class  TCutG;  Graphical cut class. More...;  ; class  TDiamond;  Draw a Diamond. More...;  ; class  TEllipse;  Draw Ellipses. More...;  ; class  TFrame;  Define a Frame. More...;  ; class  TGaxis;  The axis painter class. More...;  ; class  TGraphPolar;  To draw a polar graph. More...;  ; class  TGraphPolargram;  To draw polar axis. More...;  ; class  TGraphQQ;  This class allows to draw quantile-quantile plots. More...;  ; class  TImage;  An abstract interface to image processing library. More...;  ; class  TImagePalette;  A class to define a conversion from pixel values to pixel color. More...;  ; class  TLatex;  To draw Mathematical Formula. More...;  ; class  TLegend;  This class displays a legend box (TPaveText) containing several legend entries. More...;  ; class  TLegendEntry;  Storage class for one entry of a TLegend. More...;  ; class  TLine;  Use the TLine constructor to create a simple line. More...;  ; class  TLink;  Special TText object used to show hyperlinks. More...;  ; class  TMarker;  Manages Markers. More...;  ; class  TMathText;  To draw TeX Mathematical Formula. More...;  ; class  TPaletteEditor;  Edit the palette via a GUI. More...;  ; class  TPave;  A TBox with a bordersize and a shadow option. More...;  ; class  TPaveLabel;  A Pave (see TPave) with a text centered in the Pave. More...;  ; class  TPaveStats;  The histogram statistics painter class. More...;  ; class  TPavesText;  A PaveText (see TPaveText) with several stacked paves. More...;  ; class  TPaveText;  A Pave (see TPave) with text, lines or/and boxes inside. More...;  ; class  TPie;  Draw a Pie Chart,. More...;  ; class  TPieSlice;  A slice of a piechart, see the TPie class. More...;  ; class  TPoints;  2-D graphics point (world coordinates). More...;  ; class  TPolyLine;  Defined by an array on N points in a 2-D space. More...;  ; class  TText;  Base class for se",MatchSource.WIKI,doc/master/group__BasicGraphics.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__BasicGraphics.html
https://root.cern/doc/master/group__Containers.html:2482,Energy Efficiency,efficient,efficient,2482," Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More...;  ; class  TSeqCollection;  Sequenceable collection abstract base class. More...;  ; class  TSortedList;  A sorted doubly linked list. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:339,Modifiability,polymorphi,polymorphic,339,". ROOT: Containers. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ContainersCore ROOT classes. ; The containers and generators the ROOT framework offers. ; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used polymorphic C++ collections before, some of this material will be review. However, much of this tutorial covers aspects of collections specific to the ROOT system. In this tutorial the following features will be demonstrated:. Using collections; How to create instances of collections; The difference between lists, ordered collections, hash-tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TColl",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:676,Security,hash,hash-tables,676,". ROOT: Containers. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ContainersCore ROOT classes. ; The containers and generators the ROOT framework offers. ; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used polymorphic C++ collections before, some of this material will be review. However, much of this tutorial covers aspects of collections specific to the ROOT system. In this tutorial the following features will be demonstrated:. Using collections; How to create instances of collections; The difference between lists, ordered collections, hash-tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TColl",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:807,Security,access,access,807,". ROOT: Containers. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ContainersCore ROOT classes. ; The containers and generators the ROOT framework offers. ; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used polymorphic C++ collections before, some of this material will be review. However, much of this tutorial covers aspects of collections specific to the ROOT system. In this tutorial the following features will be demonstrated:. Using collections; How to create instances of collections; The difference between lists, ordered collections, hash-tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TColl",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:1111,Security,hash,hashed,1111,". ROOT: Containers. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ContainersCore ROOT classes. ; The containers and generators the ROOT framework offers. ; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used polymorphic C++ collections before, some of this material will be review. However, much of this tutorial covers aspects of collections specific to the ROOT system. In this tutorial the following features will be demonstrated:. Using collections; How to create instances of collections; The difference between lists, ordered collections, hash-tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TColl",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:1130,Security,hash,hash,1130,". ROOT: Containers. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ContainersCore ROOT classes. ; The containers and generators the ROOT framework offers. ; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used polymorphic C++ collections before, some of this material will be review. However, much of this tutorial covers aspects of collections specific to the ROOT system. In this tutorial the following features will be demonstrated:. Using collections; How to create instances of collections; The difference between lists, ordered collections, hash-tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TColl",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:1892,Security,hash,hash,1892,"; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of referenc",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:2136,Security,hash,hash,2136,"shed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:2234,Security,hash,hash,2234," Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More...;  ; class  TSeqCollection;  Sequenceable collection abstract base class. More...;  ; class  TSortedList;  A ",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:2725,Security,hash,hash,2725," Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TCollection;  Collection abstract base class. More...;  ; class  THashList;  THashList implements a hybrid collection class consisting of a hash table and a list to store TObject's. More...;  ; class  THashTable;  THashTable implements a hash table to store TObject's. More...;  ; class  TIterator;  Iterator abstract base class. More...;  ; class  TList;  A doubly linked list. More...;  ; class  TMap;  TMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries). More...;  ; class  TObjArray;  An array of TObjects. More...;  ; class  TObjectTable;  This class registers all instances of TObject and its derived classes in a hash table. More...;  ; class  TOrdCollection;  Ordered collection. More...;  ; class  TRefArray;  An array of references to TObjects. More...;  ; class  TRefTable;  A TRefTable maintains the association between a referenced object and the parent object supporting this referenced object. More...;  ; class  ROOT::TSeq< T >;  A pseudo container class which is a generator of indices. More...;  ; class  TSeqCollection;  Sequenceable collection abstract base class. More...;  ; class  TSortedList;  A sorted doubly linked list. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__Containers.html:970,Testability,test,tested,970,". ROOT: Containers. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ContainersCore ROOT classes. ; The containers and generators the ROOT framework offers. ; Collections are a key feature of the ROOT system. Many, if not most, of the applications you write will use collections. If you have used polymorphic C++ collections before, some of this material will be review. However, much of this tutorial covers aspects of collections specific to the ROOT system. In this tutorial the following features will be demonstrated:. Using collections; How to create instances of collections; The difference between lists, ordered collections, hash-tables, maps, etc.; How to add and remove elements of a collection; How to search a collection for a specific element; How to access and modify collection elements; How to iterate over a collection; How to manage memory for collections and collection elements; How collection elements are tested for equality (IsEqual()); How collection elements are compared (Compare()) in case of sorted collections; How collection elements are hashed (Hash()) in hash tables . Classes; class  TArray;  Abstract array base class. More...;  ; class  TArrayC;  Array of chars or bytes (8 bits per element). More...;  ; class  TArrayD;  Array of doubles (64 bits per element). More...;  ; class  TArrayF;  Array of floats (32 bits per element). More...;  ; class  TArrayI;  Array of integers (32 bits per element). More...;  ; class  TArrayL;  Array of longs (32 or 64 bits per element). More...;  ; class  TArrayL64;  Array of long64s (64 bits per element). More...;  ; class  TArrayS;  Array of shorts (16 bits per element). More...;  ; class  TBits;  Container of bits. More...;  ; class  TBtree;  B-tree class. More...;  ; class  TClassTable;  This class registers for all classes their name, id and dictionary function in a hash table. More...;  ; class  TClonesArray;  An array of clone (identical) objects. More...;  ; class  TColl",MatchSource.WIKI,doc/master/group__Containers.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Containers.html
https://root.cern/doc/master/group__CppFunctions.html:526,Energy Efficiency,adapt,adapter,526,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:526,Integrability,adapter,adapter,526,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:564,Integrability,wrap,wrap,564,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:613,Integrability,interface,interface,613,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:1008,Integrability,interface,interface,1008,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:1199,Integrability,interface,interface,1199,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:1281,Integrability,wrap,wrapper,1281,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:1366,Integrability,wrap,wrapper,1366,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__CppFunctions.html:526,Modifiability,adapt,adapter,526,". ROOT: Function Classes and Interfaces. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Function Classes and InterfacesMath » MathCore. ; Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ; They define function and gradient evaluation and as well the functionality for dealing with parameters in the case of parametric functions which are used for fitting and data modeling. Included are also adapter classes, such as functors, to wrap generic callable C++ objects in the desired interface. . Modules;  Generic Function Evaluation Interfaces;  Interface classes for evaluation of function object classes in one or multi-dimensions. ;  ;  Parametric Function Evaluation Interfaces.;  Interfaces classes for evaluation of parametric functions. ;  . Classes; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  ; class  ROOT::Math::WrappedTF1;  Class to Wrap a ROOT Function class (like TF1) in a IParamFunction interface of one dimensions to be used in the ROOT::Math numerical algorithms The wrapper does not own bby default the TF1 pointer, so it assumes it exists during the wrapper lifetime. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__CppFunctions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__CppFunctions.html
https://root.cern/doc/master/group__dataframe.html:208,Integrability,interface,interface,208,". ROOT: Dataframe. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Dataframe. ; ROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface. . Files; file  ActionHelpers.hxx;  ; file  RMergeableValue.hxx;  . Classes; class  GraphCreatorHelper;  Helper class that provides the operation graph nodes. More...;  ; class  ROOT::Internal::RDF::GraphDrawing::GraphNode;  Class used to create the operation graph to be printed in the dot representation. More...;  ; class  ROOT::Internal::RDF::RAction< Helper, PrevNode, ColumnTypes_t >;  A RDataFrame node that produces a result. More...;  ; class  ROOT::RDF::RArrowDS;  RDataFrame data source class to interface with Apache Arrow. More...;  ; class  RColumnReaderBase;  Pure virtual base class for all column reader types. More...;  ; class  ROOT::Internal::RDF::RColumnRegister;  A binder for user-defined columns, variations and aliases. More...;  ; class  ROOT::RDF::RCsvDS;  RDataFrame data source class for reading CSV files. More...;  ; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROOT::RDF::Experimental::RDatasetSpec;  The dataset specification for RDataFrame. More...;  ; class  ROOT::RDF::RDataSource;  RDataSource defines an API that RDataFrame can use to read arbitrary data formats. More...;  ; class  ROOT::RDF::RDFDescription;  A DFDescription contains useful information about a given RDataFrame computation graph. More...;  ; class  ROOT::RDF::RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  ROOT::Internal::RDF::RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  ROOT::RDF::RInterface< Proxied, DataSource >;  The public interface to the RDataFrame federation of classes. More...;  ; class ",MatchSource.WIKI,doc/master/group__dataframe.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__dataframe.html
https://root.cern/doc/master/group__dataframe.html:725,Integrability,interface,interface,725,". ROOT: Dataframe. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Files |; Classes ; Dataframe. ; ROOT's RDataFrame allows to analyse data stored in TTrees with a high level interface. . Files; file  ActionHelpers.hxx;  ; file  RMergeableValue.hxx;  . Classes; class  GraphCreatorHelper;  Helper class that provides the operation graph nodes. More...;  ; class  ROOT::Internal::RDF::GraphDrawing::GraphNode;  Class used to create the operation graph to be printed in the dot representation. More...;  ; class  ROOT::Internal::RDF::RAction< Helper, PrevNode, ColumnTypes_t >;  A RDataFrame node that produces a result. More...;  ; class  ROOT::RDF::RArrowDS;  RDataFrame data source class to interface with Apache Arrow. More...;  ; class  RColumnReaderBase;  Pure virtual base class for all column reader types. More...;  ; class  ROOT::Internal::RDF::RColumnRegister;  A binder for user-defined columns, variations and aliases. More...;  ; class  ROOT::RDF::RCsvDS;  RDataFrame data source class for reading CSV files. More...;  ; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROOT::RDF::Experimental::RDatasetSpec;  The dataset specification for RDataFrame. More...;  ; class  ROOT::RDF::RDataSource;  RDataSource defines an API that RDataFrame can use to read arbitrary data formats. More...;  ; class  ROOT::RDF::RDFDescription;  A DFDescription contains useful information about a given RDataFrame computation graph. More...;  ; class  ROOT::RDF::RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  ROOT::Internal::RDF::RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  ROOT::RDF::RInterface< Proxied, DataSource >;  The public interface to the RDataFrame federation of classes. More...;  ; class ",MatchSource.WIKI,doc/master/group__dataframe.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__dataframe.html
https://root.cern/doc/master/group__dataframe.html:1138,Integrability,interface,interface,1138,"ame allows to analyse data stored in TTrees with a high level interface. . Files; file  ActionHelpers.hxx;  ; file  RMergeableValue.hxx;  . Classes; class  GraphCreatorHelper;  Helper class that provides the operation graph nodes. More...;  ; class  ROOT::Internal::RDF::GraphDrawing::GraphNode;  Class used to create the operation graph to be printed in the dot representation. More...;  ; class  ROOT::Internal::RDF::RAction< Helper, PrevNode, ColumnTypes_t >;  A RDataFrame node that produces a result. More...;  ; class  ROOT::RDF::RArrowDS;  RDataFrame data source class to interface with Apache Arrow. More...;  ; class  RColumnReaderBase;  Pure virtual base class for all column reader types. More...;  ; class  ROOT::Internal::RDF::RColumnRegister;  A binder for user-defined columns, variations and aliases. More...;  ; class  ROOT::RDF::RCsvDS;  RDataFrame data source class for reading CSV files. More...;  ; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROOT::RDF::Experimental::RDatasetSpec;  The dataset specification for RDataFrame. More...;  ; class  ROOT::RDF::RDataSource;  RDataSource defines an API that RDataFrame can use to read arbitrary data formats. More...;  ; class  ROOT::RDF::RDFDescription;  A DFDescription contains useful information about a given RDataFrame computation graph. More...;  ; class  ROOT::RDF::RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  ROOT::Internal::RDF::RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  ROOT::RDF::RInterface< Proxied, DataSource >;  The public interface to the RDataFrame federation of classes. More...;  ; class  RInterfaceBase;  The public interface to the RDataFrame federation of classes. More...;  ; class  ROOT::Detail::RDF::RMergeableCount;  Specializa",MatchSource.WIKI,doc/master/group__dataframe.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__dataframe.html
https://root.cern/doc/master/group__dataframe.html:1932,Integrability,interface,interface,1932,"defined columns, variations and aliases. More...;  ; class  ROOT::RDF::RCsvDS;  RDataFrame data source class for reading CSV files. More...;  ; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROOT::RDF::Experimental::RDatasetSpec;  The dataset specification for RDataFrame. More...;  ; class  ROOT::RDF::RDataSource;  RDataSource defines an API that RDataFrame can use to read arbitrary data formats. More...;  ; class  ROOT::RDF::RDFDescription;  A DFDescription contains useful information about a given RDataFrame computation graph. More...;  ; class  ROOT::RDF::RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  ROOT::Internal::RDF::RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  ROOT::RDF::RInterface< Proxied, DataSource >;  The public interface to the RDataFrame federation of classes. More...;  ; class  RInterfaceBase;  The public interface to the RDataFrame federation of classes. More...;  ; class  ROOT::Detail::RDF::RMergeableCount;  Specialization of RMergeableValue for the Count action. More...;  ; class  ROOT::Detail::RDF::RMergeableFill< T >;  Specialization of RMergeableValue for histograms and statistics. More...;  ; class  ROOT::Detail::RDF::RMergeableMean;  Specialization of RMergeableValue for the Mean action. More...;  ; class  ROOT::Detail::RDF::RMergeableStdDev;  Specialization of RMergeableValue for the StdDev action. More...;  ; class  ROOT::Detail::RDF::RMergeableValue< T >;  A result of an RDataFrame execution, that knows how to merge with other results of the same type. More...;  ; class  ROOT::Detail::RDF::RMergeableValueBase;  Base class of RMergeableValue. More...;  ; class  ROOT::Detail::RDF::RMergeableVariations< T >;  A container for variation names and variation results that knows",MatchSource.WIKI,doc/master/group__dataframe.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__dataframe.html
https://root.cern/doc/master/group__dataframe.html:2030,Integrability,interface,interface,2030,"reading CSV files. More...;  ; class  ROOT::RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROOT::RDF::Experimental::RDatasetSpec;  The dataset specification for RDataFrame. More...;  ; class  ROOT::RDF::RDataSource;  RDataSource defines an API that RDataFrame can use to read arbitrary data formats. More...;  ; class  ROOT::RDF::RDFDescription;  A DFDescription contains useful information about a given RDataFrame computation graph. More...;  ; class  ROOT::RDF::RDisplay;  This class is the textual representation of the content of a columnar dataset. More...;  ; class  ROOT::Internal::RDF::RDisplayElement;  Helper class to let Display print compact tabular representations of the events. More...;  ; class  ROOT::RDF::RInterface< Proxied, DataSource >;  The public interface to the RDataFrame federation of classes. More...;  ; class  RInterfaceBase;  The public interface to the RDataFrame federation of classes. More...;  ; class  ROOT::Detail::RDF::RMergeableCount;  Specialization of RMergeableValue for the Count action. More...;  ; class  ROOT::Detail::RDF::RMergeableFill< T >;  Specialization of RMergeableValue for histograms and statistics. More...;  ; class  ROOT::Detail::RDF::RMergeableMean;  Specialization of RMergeableValue for the Mean action. More...;  ; class  ROOT::Detail::RDF::RMergeableStdDev;  Specialization of RMergeableValue for the StdDev action. More...;  ; class  ROOT::Detail::RDF::RMergeableValue< T >;  A result of an RDataFrame execution, that knows how to merge with other results of the same type. More...;  ; class  ROOT::Detail::RDF::RMergeableValueBase;  Base class of RMergeableValue. More...;  ; class  ROOT::Detail::RDF::RMergeableVariations< T >;  A container for variation names and variation results that knows how to merge with others of the same type. More...;  ; class  ROOT::Detail::RDF::RMergeableVariationsBase;  A co",MatchSource.WIKI,doc/master/group__dataframe.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__dataframe.html
https://root.cern/doc/master/group__FitData.html:367,Availability,error,error,367,". ROOT: Fit Data Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Fit Data ClassesMath » MathCore » Fitting and Parameter Estimation. ; Classes for describing the input data for fitting. . Classes; class  ROOT::Fit::BinData;  Class describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: More...;  ; struct  ROOT::Fit::DataOptions;  DataOptions : simple structure holding the options on how the data are filled. More...;  ; class  ROOT::Fit::DataRange;  class describing the range in the coordinates it supports multiple range in a coordinate. More...;  ; class  ROOT::Fit::FitData;  Base class for all the fit data types: Stores the coordinates and the DataOptions. More...;  ; class  ROOT::Fit::SparseData;  SparseData class representing the data of a THNSparse histogram The data needs to be converted to a BinData class before fitting using the GetBinData functions. More...;  ; class  ROOT::Fit::UnBinData;  Class describing the un-binned data sets (just x coordinates values) of any dimensions. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitData.html
https://root.cern/doc/master/group__FitData.html:389,Availability,error,error,389,". ROOT: Fit Data Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Fit Data ClassesMath » MathCore » Fitting and Parameter Estimation. ; Classes for describing the input data for fitting. . Classes; class  ROOT::Fit::BinData;  Class describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: More...;  ; struct  ROOT::Fit::DataOptions;  DataOptions : simple structure holding the options on how the data are filled. More...;  ; class  ROOT::Fit::DataRange;  class describing the range in the coordinates it supports multiple range in a coordinate. More...;  ; class  ROOT::Fit::FitData;  Base class for all the fit data types: Stores the coordinates and the DataOptions. More...;  ; class  ROOT::Fit::SparseData;  SparseData class representing the data of a THNSparse histogram The data needs to be converted to a BinData class before fitting using the GetBinData functions. More...;  ; class  ROOT::Fit::UnBinData;  Class describing the un-binned data sets (just x coordinates values) of any dimensions. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitData.html
https://root.cern/doc/master/group__FitData.html:540,Usability,simpl,simple,540,". ROOT: Fit Data Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Fit Data ClassesMath » MathCore » Fitting and Parameter Estimation. ; Classes for describing the input data for fitting. . Classes; class  ROOT::Fit::BinData;  Class describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: More...;  ; struct  ROOT::Fit::DataOptions;  DataOptions : simple structure holding the options on how the data are filled. More...;  ; class  ROOT::Fit::DataRange;  class describing the range in the coordinates it supports multiple range in a coordinate. More...;  ; class  ROOT::Fit::FitData;  Base class for all the fit data types: Stores the coordinates and the DataOptions. More...;  ; class  ROOT::Fit::SparseData;  SparseData class representing the data of a THNSparse histogram The data needs to be converted to a BinData class before fitting using the GetBinData functions. More...;  ; class  ROOT::Fit::UnBinData;  Class describing the un-binned data sets (just x coordinates values) of any dimensions. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitData.html
https://root.cern/doc/master/group__FitMain.html:777,Availability,error,error,777,". ROOT: User Fitting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes ; User Fitting classesMath » MathCore » Fitting and Parameter Estimation. ; Main Classes used for fitting a given data set. . Namespaces; namespace  ROOT::Fit::FitUtil;  namespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ;  . Classes; class  ROOT::Fit::FitConfig;  Class describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class. More...;  ; class  ROOT::Fit::FitResult;  class containing the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values. More...;  ; class  ROOT::Fit::Fitter;  Fitter class, entry point for performing all type of fits. More...;  ; class  ROOT::Fit::ParameterSettings;  Class, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMain.html
https://root.cern/doc/master/group__FitMain.html:535,Deployability,configurat,configuration,535,". ROOT: User Fitting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes ; User Fitting classesMath » MathCore » Fitting and Parameter Estimation. ; Main Classes used for fitting a given data set. . Namespaces; namespace  ROOT::Fit::FitUtil;  namespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ;  . Classes; class  ROOT::Fit::FitConfig;  Class describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class. More...;  ; class  ROOT::Fit::FitResult;  class containing the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values. More...;  ; class  ROOT::Fit::Fitter;  Fitter class, entry point for performing all type of fits. More...;  ; class  ROOT::Fit::ParameterSettings;  Class, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMain.html
https://root.cern/doc/master/group__FitMain.html:535,Modifiability,config,configuration,535,". ROOT: User Fitting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes ; User Fitting classesMath » MathCore » Fitting and Parameter Estimation. ; Main Classes used for fitting a given data set. . Namespaces; namespace  ROOT::Fit::FitUtil;  namespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ;  . Classes; class  ROOT::Fit::FitConfig;  Class describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class. More...;  ; class  ROOT::Fit::FitResult;  class containing the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values. More...;  ; class  ROOT::Fit::Fitter;  Fitter class, entry point for performing all type of fits. More...;  ; class  ROOT::Fit::ParameterSettings;  Class, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMain.html
https://root.cern/doc/master/group__FitMain.html:1001,Performance,perform,performing,1001,". ROOT: User Fitting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces |; Classes ; User Fitting classesMath » MathCore » Fitting and Parameter Estimation. ; Main Classes used for fitting a given data set. . Namespaces; namespace  ROOT::Fit::FitUtil;  namespace defining utility free functions using in Fit for evaluating the various fit method functions (chi2, likelihood, etc..) given the data and the model function ;  . Classes; class  ROOT::Fit::FitConfig;  Class describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class. More...;  ; class  ROOT::Fit::FitResult;  class containing the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values. More...;  ; class  ROOT::Fit::Fitter;  Fitter class, entry point for performing all type of fits. More...;  ; class  ROOT::Fit::ParameterSettings;  Class, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMain.html
https://root.cern/doc/master/group__FitMethodFunc.html:435,Integrability,interface,interface,435,". ROOT: Fit Method Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Fit Method ClassesMath » MathCore » Fitting and Parameter Estimation. ; Classes describing Fit Method functions. . Classes; class  ROOT::Math::BasicFitMethodFunction< FunctionType >;  FitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) In addition to normal function interface provide interface for calculating each data contribution to the function which is required by some algorithm (like Fumili) More...;  ; class  ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >;  Chi2FCN class for binned fits using the least square methods. More...;  ; class  ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >;  LogLikelihoodFCN class for likelihood fits. More...;  ; class  ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >;  class evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMethodFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMethodFunc.html
https://root.cern/doc/master/group__FitMethodFunc.html:453,Integrability,interface,interface,453,". ROOT: Fit Method Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Fit Method ClassesMath » MathCore » Fitting and Parameter Estimation. ; Classes describing Fit Method functions. . Classes; class  ROOT::Math::BasicFitMethodFunction< FunctionType >;  FitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) In addition to normal function interface provide interface for calculating each data contribution to the function which is required by some algorithm (like Fumili) More...;  ; class  ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >;  Chi2FCN class for binned fits using the least square methods. More...;  ; class  ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >;  LogLikelihoodFCN class for likelihood fits. More...;  ; class  ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >;  class evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMethodFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMethodFunc.html
https://root.cern/doc/master/group__FitMethodFunc.html:927,Testability,log,log,927,". ROOT: Fit Method Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Fit Method ClassesMath » MathCore » Fitting and Parameter Estimation. ; Classes describing Fit Method functions. . Classes; class  ROOT::Math::BasicFitMethodFunction< FunctionType >;  FitMethodFunction class Interface for objective functions (like chi2 and likelihood used in the fit) In addition to normal function interface provide interface for calculating each data contribution to the function which is required by some algorithm (like Fumili) More...;  ; class  ROOT::Fit::Chi2FCN< DerivFunType, ModelFunType >;  Chi2FCN class for binned fits using the least square methods. More...;  ; class  ROOT::Fit::LogLikelihoodFCN< DerivFunType, ModelFunType >;  LogLikelihoodFCN class for likelihood fits. More...;  ; class  ROOT::Fit::PoissonLikelihoodFCN< DerivFunType, ModelFunType >;  class evaluating the log likelihood for binned Poisson likelihood fits it is template to distinguish gradient and non-gradient case More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__FitMethodFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__FitMethodFunc.html
https://root.cern/doc/master/group__Functions.html:302,Integrability,wrap,wrapping,302,. ROOT: Function classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Function classes.Histogram Library. . Classes; class  TF1;  1-Dim function class More...;  ; class  TF12;  A projection of a TF2 along X or Y. More...;  ; class  TF1Convolution;  Class wrapping convolution of two functions. More...;  ; class  TF1NormSum;  Class adding two functions: c1*f1+c2*f2. More...;  ; class  TF2;  A 2-Dim function with parameters. More...;  ; class  TF3;  A 3-Dim function with parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Functions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Functions.html
https://root.cern/doc/master/group__g3d.html:928,Safety,detect,detector,928,. ROOT: Basic 3D graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Basic 3D graphics.Graphics » 3D Graphics. ; The basic 3D classes. . Shapes.; TPolyMarker3D example. . Classes; class  TAxis3D;  The 3D axis painter class. More...;  ; class  TBRIK;  A box with faces perpendicular to the axes. More...;  ; class  TCONE;  A conical tube. More...;  ; class  TCONS;  A segment of a conical tube. More...;  ; class  TCTUB;  A cut tube with 11 parameters. More...;  ; class  TELTU;  A cylinder with an elliptical section. More...;  ; class  TGeometry;  TGeometry description. More...;  ; class  TGTRA;  A general twisted trapezoid. More...;  ; class  THelix;  THelix has two different constructors. More...;  ; class  THYPE;  An hyperboloid (not implemented) More...;  ; class  TMarker3DBox;  A special 3-D marker designed for event display. More...;  ; class  TMaterial;  Manages a detector material. More...;  ; class  TMixture;  Manages a detector mixture. More...;  ; class  TNode;  TNode description. More...;  ; class  TNodeDiv;  Description of parameters to divide a 3-D geometry object. More...;  ; class  TPARA;  A parallelepiped. More...;  ; class  TPCON;  A polycone. More...;  ; class  TPGON;  A polygon. More...;  ; class  TPoints3DABC;  Abstract class to define Arrays of 3D points. More...;  ; class  TPointSet3D;  TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering. More...;  ; class  TPolyLine3D;  A 3-dimensional polyline. More...;  ; class  TPolyMarker3D;  A 3D polymarker. More...;  ; class  TRotMatrix;  Manages a detector rotation matrix. More...;  ; class  TShape;  This is the base class for all geometry shapes. More...;  ; class  TSPHE;  A Sphere. More...;  ; class  TTRAP;  A general trapezoid. More...;  ; class  TTRD1;  A trapezoid with the x dimension varying along z. More...;  ; class  TTRD2;  A trapezoid with both x and y dimensions varying along z. More...;  ; class  TTUBE;  A tube. More...;  ; class  TTUBS; ,MatchSource.WIKI,doc/master/group__g3d.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__g3d.html
https://root.cern/doc/master/group__g3d.html:987,Safety,detect,detector,987,. ROOT: Basic 3D graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Basic 3D graphics.Graphics » 3D Graphics. ; The basic 3D classes. . Shapes.; TPolyMarker3D example. . Classes; class  TAxis3D;  The 3D axis painter class. More...;  ; class  TBRIK;  A box with faces perpendicular to the axes. More...;  ; class  TCONE;  A conical tube. More...;  ; class  TCONS;  A segment of a conical tube. More...;  ; class  TCTUB;  A cut tube with 11 parameters. More...;  ; class  TELTU;  A cylinder with an elliptical section. More...;  ; class  TGeometry;  TGeometry description. More...;  ; class  TGTRA;  A general twisted trapezoid. More...;  ; class  THelix;  THelix has two different constructors. More...;  ; class  THYPE;  An hyperboloid (not implemented) More...;  ; class  TMarker3DBox;  A special 3-D marker designed for event display. More...;  ; class  TMaterial;  Manages a detector material. More...;  ; class  TMixture;  Manages a detector mixture. More...;  ; class  TNode;  TNode description. More...;  ; class  TNodeDiv;  Description of parameters to divide a 3-D geometry object. More...;  ; class  TPARA;  A parallelepiped. More...;  ; class  TPCON;  A polycone. More...;  ; class  TPGON;  A polygon. More...;  ; class  TPoints3DABC;  Abstract class to define Arrays of 3D points. More...;  ; class  TPointSet3D;  TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering. More...;  ; class  TPolyLine3D;  A 3-dimensional polyline. More...;  ; class  TPolyMarker3D;  A 3D polymarker. More...;  ; class  TRotMatrix;  Manages a detector rotation matrix. More...;  ; class  TShape;  This is the base class for all geometry shapes. More...;  ; class  TSPHE;  A Sphere. More...;  ; class  TTRAP;  A general trapezoid. More...;  ; class  TTRD1;  A trapezoid with the x dimension varying along z. More...;  ; class  TTRD2;  A trapezoid with both x and y dimensions varying along z. More...;  ; class  TTUBE;  A tube. More...;  ; class  TTUBS; ,MatchSource.WIKI,doc/master/group__g3d.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__g3d.html
https://root.cern/doc/master/group__g3d.html:1591,Safety,detect,detector,1591,ss  TAxis3D;  The 3D axis painter class. More...;  ; class  TBRIK;  A box with faces perpendicular to the axes. More...;  ; class  TCONE;  A conical tube. More...;  ; class  TCONS;  A segment of a conical tube. More...;  ; class  TCTUB;  A cut tube with 11 parameters. More...;  ; class  TELTU;  A cylinder with an elliptical section. More...;  ; class  TGeometry;  TGeometry description. More...;  ; class  TGTRA;  A general twisted trapezoid. More...;  ; class  THelix;  THelix has two different constructors. More...;  ; class  THYPE;  An hyperboloid (not implemented) More...;  ; class  TMarker3DBox;  A special 3-D marker designed for event display. More...;  ; class  TMaterial;  Manages a detector material. More...;  ; class  TMixture;  Manages a detector mixture. More...;  ; class  TNode;  TNode description. More...;  ; class  TNodeDiv;  Description of parameters to divide a 3-D geometry object. More...;  ; class  TPARA;  A parallelepiped. More...;  ; class  TPCON;  A polycone. More...;  ; class  TPGON;  A polygon. More...;  ; class  TPoints3DABC;  Abstract class to define Arrays of 3D points. More...;  ; class  TPointSet3D;  TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering. More...;  ; class  TPolyLine3D;  A 3-dimensional polyline. More...;  ; class  TPolyMarker3D;  A 3D polymarker. More...;  ; class  TRotMatrix;  Manages a detector rotation matrix. More...;  ; class  TShape;  This is the base class for all geometry shapes. More...;  ; class  TSPHE;  A Sphere. More...;  ; class  TTRAP;  A general trapezoid. More...;  ; class  TTRD1;  A trapezoid with the x dimension varying along z. More...;  ; class  TTRD2;  A trapezoid with both x and y dimensions varying along z. More...;  ; class  TTUBE;  A tube. More...;  ; class  TTUBS;  A segment of a tube. More...;  ; class  TView3D;  The 3D view class. More...;  ; class  TXTRU;  A poly-extrusion. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__g3d.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__g3d.html
https://root.cern/doc/master/group__GenVector.html:2710,Availability,avail,available,2710,"sses exist to describe the various coordinates systems:; 2D coordinate system classes:; ROOT::Math::Cartesian2D, based on (x,y) ;; ROOT::Math::Polar2D, based on (r, phi) ;. 3D coordinate system classes:; ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r, theta, phi);; ROOT::Math::Cylindrical3D, based on (rho, z, phi); ROOT::Math::CylindricalEta3D, based on (rho, eta, phi);. 4D coordinate system classes:; ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. The angle theta is defined between [0, \(\pi\)] and phi between [- \(\pi\), \(\pi\)]. The angles are expressed in radians. The eta component is known as pseudo-rapidity.; Users can define the Vectors according to the coordinate type which is most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment operator =. The coordinate system classes are templated on the scalar type for maximum flexibility, and to minimize memory usage for some use cases. Coordinate System Tag; The 2D and 3D point and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D (and ROOT::Math::DisplacementVector2D) and ROOT::Math::PositionVector3D (and ROOT::Math::PositionVector2D) classes. A default tag, ROOT::Math::DefaultCoordinateSystemTag, exists for users who don't need this functionality. Concrete Vector typedefs; To avoid exposing templated parameters to the users, typedefs are defined for all types of vectors based an doubles and floats. The table below lists the double versions; the float counterpart ends on an extra F, such as ROOT::Mat",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:7463,Availability,error,errors,7463,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:7887,Availability,avail,available,7887,"v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotation described by a quaternion (4 numbers); ROOT::Math::RotationX, specialized rotation along the X axis; ROOT::Math::RotationY, specialized rotation along the Y axis; ROOT::Math::RotationZ, specialized rotation along the Z axis. 3D Transformation. ROOT::Math::Translation3D, (only translation) described by a 3D vector; ROOT::Math::Transform3D, (rotations and then translation) described by a 3x4 matrix (12 numbers). Lorentz Rotation. ROOT::Math::LorentzRotation , 4D rotation (3D rota",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:9727,Availability,avail,available,9727," a 3D vector; ROOT::Math::Transform3D, (rotations and then translation) described by a 3x4 matrix (12 numbers). Lorentz Rotation. ROOT::Math::LorentzRotation , 4D rotation (3D rotation plus a boost) described by a 4x4 matrix; ROOT::Math::Boost, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetric matrix (10 numbers); ROOT::Math::BoostX, a boost in the X axis direction; ROOT::Math::BoostY, a boost in the Y axis direction; ROOT::Math::BoostZ, a boost in the Z axis direction. Compatibility with CLHEP Vector classes; For compatibility with CLHEP, the vector classes can be constructed easily from a CLHEP Hep3Vector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessors x(), y() and z() (and t() for HepLorentzVector). The vector classes also provide member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). Additional Documentation; A more detailed description of all the GenVector classes is available in this document. . Namespaces; namespace  ROOT::Math::VectorUtil;  Global Helper functions for generic Vector classes. ;  . Classes; class  ROOT::Math::AxisAngle;  AxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotation around that axis. More...;  ; class  ROOT::Math::Boost;  Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix. More...;  ; class  ROOT::Math::BoostX;  Class representing a Lorentz Boost along the X axis, by beta. More...;  ; class  ROOT::Math::BoostY;  Class representing a Lorentz Boost along the Y axis, by beta. More...;  ; class  ROOT::Math::BoostZ;  Class representing a Lorentz Boost along the Z axis, by beta. More...;  ; class  ROOT::Math::Cartesian2D< T >;  Class describing a 2D cartesian coordinate system (x, y coordinates) More...;  ; class  ROOT::Math::Cartesian3D< T >;  Class describing a 3D cartesian coordinate system (x,",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:2626,Energy Efficiency,efficient,efficient,2626,"ses are based on a generic type of coordinate system, expressed as a template parameter of the class. Various classes exist to describe the various coordinates systems:; 2D coordinate system classes:; ROOT::Math::Cartesian2D, based on (x,y) ;; ROOT::Math::Polar2D, based on (r, phi) ;. 3D coordinate system classes:; ROOT::Math::Cartesian3D, based on (x,y,z);; ROOT::Math::Polar3D, based on (r, theta, phi);; ROOT::Math::Cylindrical3D, based on (rho, z, phi); ROOT::Math::CylindricalEta3D, based on (rho, eta, phi);. 4D coordinate system classes:; ROOT::Math::PxPyPzE4D, based on based on (px,py,pz,E);; ROOT::Math::PxPyPzM4D, based on based on (px,py,pz,M);; ROOT::Math::PtEtaPhiE4D, based on based on (pt,eta,phi,E);; ROOT::Math::PtEtaPhiM4D, based on based on (pt,eta,phi,M);. The angle theta is defined between [0, \(\pi\)] and phi between [- \(\pi\), \(\pi\)]. The angles are expressed in radians. The eta component is known as pseudo-rapidity.; Users can define the Vectors according to the coordinate type which is most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment operator =. The coordinate system classes are templated on the scalar type for maximum flexibility, and to minimize memory usage for some use cases. Coordinate System Tag; The 2D and 3D point and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D (and ROOT::Math::DisplacementVector2D) and ROOT::Math::PositionVector3D (and ROOT::Math::PositionVector2D) classes. A default tag, ROOT::Math::DefaultCoordinateSystemTag, exists for users who don't need this functionality. Concrete Vector typedefs; To avoid exposing templated parameters to the users, typedefs are defined for all types of vectors based an doubles ",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:5726,Energy Efficiency,energy,energy,5726,"olar); ROOT::Math::RhoZPhiPoint point based on rho,z,phi coordinates (cylindrical using z); ROOT::Math::RhoEtaPhiPoint point based on rho,eta,phi coordinates (cylindrical using eta instead of z). Vector3D; Type definitions for vectors in three dimensions, based on ROOT::Math::DisplacementVector3D, are defined by Math/Vector3D.h:. ROOT::Math::XYZVector vector based on x,y,z coordinates (cartesian); ROOT::Math::Polar3DVector vector based on r,theta,phi coordinates (polar); ROOT::Math::RhoZPhiVector vector based on rho, z,phi coordinates (cylindrical); ROOT::Math::RhoEtaPhiVector vector based on rho,eta,phi coordinates (cylindrical using eta instead of z). LorentzVector; Type definitions for Lorentz vectors in four dimensions, based on ROOT::Math::LorentzVector, are defined by Math/Vector4D.h:. ROOT::Math::XYZTVector vector based on x,y,z,t coordinates (cartesian); ROOT::Math::PtEtaPhiEVector vector based on pt (rho),eta,phi and E (t) coordinates; ROOT::Math::PtEtaPhiMVector vector based on pt (rho),eta,phi and M (t) coordinates; ROOT::Math::PxPyPzMVector vector based on px,py,pz and M (mass) coordinates; ROOT::Math::PxPyPzEVector vector based on px,py,pz and E (energy) coordinates. The metric used for any such LorentzVector is (-,-,-,+). Operations. Constructors and Assignment; A vector can be constructed from its coordinate representation:; ROOT::Math::PtEtaPhiMVector v1(10. /*pt*/, 0.1 /*eta*/, 0.24 /*phi*/, 5 /*M*/);; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; v1@ v1Definition rootcling_impl.cxx:3701; In addition, the vector classes can be constructed from any object that implements the accessors x(), y() and z(). This can be a vector using a different coordinate system, or even an object from a different package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1)",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:13317,Energy Efficiency,energy,energy,13317,"scribing a polar 2D coordinate system based on r and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  ROOT::Math::Polar3D< T >;  Class describing a polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  ROOT::Math::PositionVector2D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  ROOT::Math::PositionVector3D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  ROOT::Math::PtEtaPhiE4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PtEtaPhiM4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PxPyPzE4D< ScalarType >;  Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E). More...;  ; class  ROOT::Math::PxPyPzM4D< ScalarType >;  Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). More...;  ; class  ROOT::Math::Quaternion;  Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). More...;  ; class  ROOT::Math::Rotation3D;  Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. More...;  ; class  ROOT::Math::RotationX;  Rotation class representing a 3D rotation about the X axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationY;  Rotation class representing a 3D rotation about the Y axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZ;  Rotation class representing a 3D rotation about the Z axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZYX;  Rotation class with the (3D) rotation represented by angles describing first a ",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:13468,Energy Efficiency,energy,energy,13468,"polar coordinate system based on r, theta and phi Phi is restricted to be in the range [-PI,PI) More...;  ; class  ROOT::Math::PositionVector2D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 2 dimensions. More...;  ; class  ROOT::Math::PositionVector3D< CoordSystem, Tag >;  Class describing a generic position vector (point) in 3 dimensions. More...;  ; class  ROOT::Math::PtEtaPhiE4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and E (or rho, phi, eta , T) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PtEtaPhiM4D< ScalarType >;  Class describing a 4D cylindrical coordinate system using Pt , Phi, Eta and M (mass) The metric used is (-,-,-,+). More...;  ; class  ROOT::Math::PxPyPzE4D< ScalarType >;  Class describing a 4D cartesian coordinate system (x, y, z, t coordinates) or momentum-energy vectors stored as (Px, Py, Pz, E). More...;  ; class  ROOT::Math::PxPyPzM4D< ScalarType >;  Class describing a 4D coordinate system or momentum-energy vectors stored as (Px, Py, Pz, M). More...;  ; class  ROOT::Math::Quaternion;  Rotation class with the (3D) rotation represented by a unit quaternion (u, i, j, k). More...;  ; class  ROOT::Math::Rotation3D;  Rotation class with the (3D) rotation represented by a 3x3 orthogonal matrix. More...;  ; class  ROOT::Math::RotationX;  Rotation class representing a 3D rotation about the X axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationY;  Rotation class representing a 3D rotation about the Y axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZ;  Rotation class representing a 3D rotation about the Z axis by the angle of rotation. More...;  ; class  ROOT::Math::RotationZYX;  Rotation class with the (3D) rotation represented by angles describing first a rotation of an angle phi (yaw) about the Z axis, followed by a rotation of an angle theta (pitch) about the Y axis, followed by a third rotation of an angle psi (roll) a",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:3486,Safety,avoid,avoid,3486,"seudo-rapidity.; Users can define the Vectors according to the coordinate type which is most efficient for their use. Transformations between the various coordinate systems are available through copy constructors or the assignment operator =. The coordinate system classes are templated on the scalar type for maximum flexibility, and to minimize memory usage for some use cases. Coordinate System Tag; The 2D and 3D point and vector classes can be associated to a tag defining the coordinate system. This can be used to distinguish between vectors of different coordinate systems like global or local vectors. The coordinate system tag is a template parameter of the ROOT::Math::DisplacementVector3D (and ROOT::Math::DisplacementVector2D) and ROOT::Math::PositionVector3D (and ROOT::Math::PositionVector2D) classes. A default tag, ROOT::Math::DefaultCoordinateSystemTag, exists for users who don't need this functionality. Concrete Vector typedefs; To avoid exposing templated parameters to the users, typedefs are defined for all types of vectors based an doubles and floats. The table below lists the double versions; the float counterpart ends on an extra F, such as ROOT::Math::XYPointF instead of ROOT::Math::XYPoint. Point2D; Type definitions for points in two dimensions, based on ROOT::Math::PositionVector2D, are defined by Math/Point2D.h:. ROOT::Math::XYPoint vector based on x,y coordinates (cartesian); ROOT::Math::Polar2DPoint vector based on r,phi coordinates (polar). Vector2D; Type definitions for vectors in two dimensions, based on ROOT::Math::DisplacementVector2D, are defined by Math/Vector2D.h:. ROOT::Math::XYVector vector based on x,y coordinates (cartesian); ROOT::Math::Polar2DVector vector based on r,phi coordinates (polar). Point3D; Type definitions for points in three dimensions, based on ROOT::Math::PositionVector3D, are defined by Math/Point3D.h:. ROOT::Math::XYZPoint point based on x,y,z coordinates (cartesian); ROOT::Math::Polar3DPoint point based on r,theta,phi",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:7437,Safety,avoid,avoid,7437,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:6280,Security,access,accessors,6280," Lorentz vectors in four dimensions, based on ROOT::Math::LorentzVector, are defined by Math/Vector4D.h:. ROOT::Math::XYZTVector vector based on x,y,z,t coordinates (cartesian); ROOT::Math::PtEtaPhiEVector vector based on pt (rho),eta,phi and E (t) coordinates; ROOT::Math::PtEtaPhiMVector vector based on pt (rho),eta,phi and M (t) coordinates; ROOT::Math::PxPyPzMVector vector based on px,py,pz and M (mass) coordinates; ROOT::Math::PxPyPzEVector vector based on px,py,pz and E (energy) coordinates. The metric used for any such LorentzVector is (-,-,-,+). Operations. Constructors and Assignment; A vector can be constructed from its coordinate representation:; ROOT::Math::PtEtaPhiMVector v1(10. /*pt*/, 0.1 /*eta*/, 0.24 /*phi*/, 5 /*M*/);; ROOT::Math::LorentzVectorClass describing a generic LorentzVector in the 4D space-time, using the specified coordinate system ...Definition LorentzVector.h:59; v1@ v1Definition rootcling_impl.cxx:3701; In addition, the vector classes can be constructed from any object that implements the accessors x(), y() and z(). This can be a vector using a different coordinate system, or even an object from a different package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:9442,Security,access,accessors,9442,"and an angle; ROOT::Math::Quaternion, rotation described by a quaternion (4 numbers); ROOT::Math::RotationX, specialized rotation along the X axis; ROOT::Math::RotationY, specialized rotation along the Y axis; ROOT::Math::RotationZ, specialized rotation along the Z axis. 3D Transformation. ROOT::Math::Translation3D, (only translation) described by a 3D vector; ROOT::Math::Transform3D, (rotations and then translation) described by a 3x4 matrix (12 numbers). Lorentz Rotation. ROOT::Math::LorentzRotation , 4D rotation (3D rotation plus a boost) described by a 4x4 matrix; ROOT::Math::Boost, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetric matrix (10 numbers); ROOT::Math::BoostX, a boost in the X axis direction; ROOT::Math::BoostY, a boost in the Y axis direction; ROOT::Math::BoostZ, a boost in the Z axis direction. Compatibility with CLHEP Vector classes; For compatibility with CLHEP, the vector classes can be constructed easily from a CLHEP Hep3Vector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessors x(), y() and z() (and t() for HepLorentzVector). The vector classes also provide member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). Additional Documentation; A more detailed description of all the GenVector classes is available in this document. . Namespaces; namespace  ROOT::Math::VectorUtil;  Global Helper functions for generic Vector classes. ;  . Classes; class  ROOT::Math::AxisAngle;  AxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotation around that axis. More...;  ; class  ROOT::Math::Boost;  Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix. More...;  ; class  ROOT::Math::BoostX;  Class representing a Lorentz Boost along the X axis, by beta. More...;  ; class  ROOT::Math::BoostY;  Class representing a Lorentz Boost al",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__GenVector.html:7371,Usability,simpl,simple,7371,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,doc/master/group__GenVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GenVector.html
https://root.cern/doc/master/group__Geometry.html:11842,Availability,avail,available,11842,"r the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw() call for the top volume. These are explained in details in the section ""Visualization Settings and Attributes"". At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes co",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:47683,Availability,error,error,47683," axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:62952,Availability,error,error,62952,"TGeoTranslation *other)Subtracting a translation from this one.Definition TGeoMatrix.cxx:742. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psi about the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); th3auto * th3Definition textalign.C:22; th2auto * th2Definition textalign.C:18; th1auto * th1Definition textalign.C:14; This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3], TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:88913,Availability,avail,available,88913,"lows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this case, the step size is supposed to be already set by a previous TGeoManager::FindNextBoundary() call. Due to floating-point boundary uncertainties, making a step corresponding ""exactly"" to the distance to next boundary does not insure boundary crossing. If the method is called with this purpose, an extra small step will be made in order to make the crossing the most probable event (epsil=10-6cm). Even with this extra small step cannot insure 100% boundary crossing for specific crossed shapes at big incident angles. After such a step is made, additional cross-checks become available:. gGeoManager->FindNextBoundary(pstep);; Double_t snext = gGeoManager->GetStep();; // The geometrical step is taken; TGeoNode *newNode = gGeoManager->Step();; // The step=snext+epsil is made; Bool_t hasCrossed = gGeoManager->IsEntering();; // Is the boundary crossed or not?; Bool_t isOnBoundary = gGeoManager->IsOnBoundary(); // The proposed; // geometrically limited step to be made was smaller; // than epsil value.; Bool_t isOutside = gGeoManager->IsOutside();; //Did we exit geometry ?; TGeoManager::IsOnBoundaryBool_t IsOnBoundary() constDefinition TGeoManager.h:407; TGeoManager::IsEnteringBool_t IsEntering() constDefinition TGeoManager.h:402; In case the desired end-point of the step should be in the same starting volume, the input flag cross should be set to kFALSE. In this case, the epsil value will be subtracted from the current step. Making a step of arbitrary value (is_geom=kFALSE, cross=no matter). In this case, the step to be made can be either",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:91846,Availability,avail,available,91846,"{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; TGeoManager::FindNormalDouble_t * FindNormal(Bool_t forward=kTRUE)Computes normal vector to the next surface that will be or was already crossed when propagating on a ...Definition TGeoManager.cxx:2810; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC. Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track, particle - a pointer to an arbitrary particle",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:101326,Availability,error,errors,101326,"than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). Th",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:102564,Availability,reliab,reliability,102564,"en volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:104709,Availability,down,down,104709,"ol is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provid",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:106087,Availability,avail,available,106087,"e drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:107802,Availability,down,down,107802,"p-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the **TView** context menu: right-click on the picture when no object is selected;. Q: ""Every line is black! I cannot figure out what is what...""; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: ""The top volume of my geometry is a box but I see only its content.""; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: ""I do not see all volumes in my tree but just something inside.""; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You ca",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:108734,Availability,down,down,108734,"l rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the **TView** context menu: right-click on the picture when no object is selected;. Q: ""Every line is black! I cannot figure out what is what...""; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: ""The top volume of my geometry is a box but I see only its content.""; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: ""I do not see all volumes in my tree but just something inside.""; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can change this by using: gGeoManager::SetVisLevel(n);; Not only that, but none of the volumes at intermediate levels (0-2) are visible on the drawing unless they are final ‘leaves' on their branch (e.g. have no other volumes positioned inside). This behavior is the default one and corresponds to ‘leaves' global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?""; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: ""OK, but now I do not want to see all th",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:110049,Availability,avail,available,110049,"the default one and corresponds to ‘leaves' global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?""; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?""; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();. Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:111574,Availability,down,down,111574,"belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model an",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:111872,Availability,down,down,111872,"le(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128401,Availability,down,down,128401,"epest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. Finding the Distance to Next Crosse",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128700,Availability,down,downwards,128700,"epest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. Finding the Distance to Next Crosse",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:143023,Availability,down,down,143023,"tor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:33633,Deployability,A/B,A/B,33633,"om the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D, E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ""unnecessary"" volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; TGeoManager::RestoreMasterVolumevoid RestoreMasterVolume()Restore the master volume of the geometry.Definition TGeoManager.cxx:3118; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t *option="""")Check time of finding ""Where am I"" for n points.Definition TGeoManager.cxx:1942; The ptr_D is a pointer to volume D con",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:97665,Deployability,update,updated,97665,"t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; Option_tconst char Option_tDefinition RtypesCore.h:66; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGeoManager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::DrawTracksvoid DrawTracks(Option_t *option="""")Draw tracks over the geometry, according to option.Definition TGeoManager.cxx:1905; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to ""catch"" the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames. Checking the Geometry; Several checking methods are ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:124296,Deployability,update,update,124296,"en, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to TGeoVolume objects):; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; Importing will append the volume to the current TGeoManager or will create one:; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; TGeoVolume::Importstatic TGeoVolume * Import(const char *filename, const char *name="""", Option_t *option="""")Import a volume from a file.Definition TGeoVolume.cxx:873. GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (im",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:125465,Deployability,install,installation,125465,"m = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; TGeoVolume::Importstatic TGeoVolume * Import(const char *filename, const char *name="""", Option_t *option="""")Import a volume from a file.Definition TGeoVolume.cxx:873. GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call. Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms. Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable' object in the geometry hierarchy. It is represented by a path like: /TOP\_1/A\_1/B\_3/C\_1, where B\_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:126373,Deployability,update,updated,126373,"rn.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call. Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms. Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable' object in the geometry hierarchy. It is represented by a path like: /TOP\_1/A\_1/B\_3/C\_1, where B\_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (MTOP\_1, MA\_1, MB\_3, ...). Navigation in the geometry hierarchy; The elementary operations for changing the state are:; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TGeoManager::CdTop(); TGeoManager::CdUpvoid CdUp()Go one level up in geometry.Definition TGeoManager.cxx:1681; TGeoManager::CdTopvoid CdTop()Make top level node the current node.Definition TGeoManager.cxx:1672; TGeoManager::CdDownvoid CdDown(Int_t index)Make a daughter of current node current.Definition TGeoManager.cxx:1690; The current state accounting and global matrix handling after these operations are depicted in the figure below. Now let us suppose that we have a particle at position P(x,y,z). The first thing needed for transporting it is the current object our particle is into, so that we can retrieve its material properties. This task is done by:; TGeoNode *TGeo",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128320,Deployability,continuous,continuously,128320,"roperties. This task is done by:; TGeoNode *TGeoManager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the ""deepest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:134746,Deployability,update,updated,134746,"side. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/stat",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:27373,Energy Efficiency,reduce,reduce,27373,".; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat' CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positioning a volume inside another have to introduce a geometrical transformation between the two. If M defines this transformation, any point in the daughter ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:42041,Energy Efficiency,efficient,efficient,42041,"TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any o",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:104312,Energy Efficiency,green,green,104312,"f:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:105536,Energy Efficiency,power,powerful,105536,"ecking; In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volum",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:118754,Energy Efficiency,consumption,consumption,118754,"mation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; The c",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:134491,Energy Efficiency,efficient,efficient,134491,"ode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrent",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:4495,Integrability,interface,interface,4495,"ructure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:6630,Integrability,message,messages,6630,"olume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:47689,Integrability,message,message,47689," axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; When doing that, we have to remember that SLICEY represents a family, therefore all members of the family",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:56679,Integrability,interface,interface,56679," \end{array}; \right|; \]. \(r_{ij}\) are the 3x3 rotation matrix components; \(t_x\), \(t_y\), \(t_z\) are the translation components; \(s_x\), \(s_y\), \(s_z\) are arbitrary scale constants on each axis. The disadvantage in using this approach is that computation for 4x4 matrices is expensive. Even combining two translations would become a multiplication of their corresponding matrices, which is quite an undesired effect. On the other hand, it is not a good idea to store a translation as a block of 16 numbers. We have therefore chosen to implement each basic transformation type as a class deriving from the same basic abstract class and handling its specific data and point/vector transformation algorithms.; The base class TGeoMatrix defines abstract methods for:. Translation, rotation and scale getters. Every derived class stores only its specific data, e.g. a translation stores an array of 3 doubles and a rotation an array of 9. However, getting the TGeoTranslation rotation array through the base TGeoMatrix interface is a legal operation. The answer in this case is a pointer to a global constant array representing an identity rotation. Double_t *TGeoMatrix::GetTranslation() const;; Double_t *TGeoMatrix::GetRotation() const;; Double_t *TGeoMatrix::GetScale() const;; TGeoMatrix::GetTranslationvirtual const Double_t * GetTranslation() const =0; TGeoMatrix::GetScalevirtual const Double_t * GetScale() const =0. Master-to-local and local-to-master point and vector transformations:. void TGeoMatrix::MasterToLocal(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMaster(const Double_t *local,; Double_t *master); void TGeoMatrix::MasterToLocalVect(const Double_t *master,; Double_t *local); void TGeoMatrix::LocalToMasterVect(const Double_t *local,; Double_t *master); TGeoMatrix::LocalToMasterVectvirtual void LocalToMasterVect(const Double_t *local, Double_t *master) constconvert a vector by multiplying its column vector (x, y, z, 1) to matrix inverseDefinit",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:62958,Integrability,message,message,62958,"TGeoTranslation *other)Subtracting a translation from this one.Definition TGeoMatrix.cxx:742. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psi about the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); th3auto * th3Definition textalign.C:22; th2auto * th2Definition textalign.C:18; th1auto * th1Definition textalign.C:14; This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3], TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:66145,Integrability,interface,interface,66145," package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManage",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:66372,Integrability,interface,interface,66372,"sition \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManager::GetListOfNavigatorsTGeoNavigatorArray * GetListOfNavigators() constGet list of navigators for the calling thread.Definition TGeoManager.cxx:836; TObjArrayAn array of TObjects.Definition TObjArray.h:31; Upon closing the geometry a default navigator is provided as first one in this list, but one may ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:66568,Integrability,interface,interface,66568,"es. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManager::GetListOfNavigatorsTGeoNavigatorArray * GetListOfNavigators() constGet list of navigators for the calling thread.Definition TGeoManager.cxx:836; TObjArrayAn array of TObjects.Definition TObjArray.h:31; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:68853,Integrability,interface,interfaced,68853," a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; TGeoManager::SetCurrentPointvoid SetCurrentPoint(Double_t *point)Definition TGeoManager.h:515. Initializing the Direction; In order to move inside geometry starting with the current point, the modeller needs to know the current direction (nx,ny,nz). This direction is stored as Double_t fCurrentDirection[3] by the navigator and it represents a directio",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:73048,Integrability,interface,interface,73048,"oint and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; TGeoManager::InitTrackTGeoNode * InitTrack(const Double_t *point, const Double_t *dir)Initialize current point and current direction vector (normalized) in MARS.Definition TGeoManager.cxx:2856; Note that the current point coordinates can be changed and the state re-initialized at any time. This represents the ‘‘Where am I?’` geometrical query representing the basic navigation functionality provided by the modeller. Checking the Current State; The current state and all variables related to this are essential during tracking and have to be checked several times. Besides the current point and direction, the following additional information can be retrieved from TGeoManager interface:. The current path. This represents a string containing the names and copy numbers of all positioned objects in the current branch written in the /folder/folder/.../folder/file fashion. The final node pointed by the path is the deepest object containing the current point and is representative for the current state. All intermediate folders in the path are in fact also nodes ""touched"" by the current point, but having some ""touched"" containment. The current path can be retrieved only after the state was initialized and is useful for getting an idea of the current point location. const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; TGeoManager::GetPathconst char * GetPath() constGet path to the current node in the form /node0/node1/...Definition TGeoManager.cxx:2881. The current node, volume and material. In order to take decisions on post-step or further stepping actions, ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:78246,Integrability,interface,interfaces,78246,"orces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoManager.cxx:1655; ptTPaveText * ptDefinition entrylist_figure1.C:7. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; TGeoManager::GetCurrentMatrixTGeoHMatrix * GetCurrentMatrix() constDefinition TGeoManager.h:496. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the **TGeoManager** corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the mode",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:92182,Integrability,interface,interfaced,92182,"mputes normal vector to the next surface that will be or was already crossed when propagating on a ...Definition TGeoManager.cxx:2810; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC. Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track, particle - a pointer to an arbitrary particle object (may be a **TParticle**).; A track has a list of daughters that have to be filled using the following method:; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; TVirtualGeoTrack::AddDaughtervirtual TVirtualGeoTrack * AddDaughter(Int_t id, Int_t pdgcode, TObject *particle",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:100136,Integrability,depend,dependent,100136,"e used by the modeller, all points inside a volume have to be also contained by the mother therefore are overlapping in that sense. This category of overlaps is ignored due to the fact that any such point is treated as belonging to the deepest node in the hierarchy. Extruding volumes; A volume containment region is in fact the result of the subtraction of all daughters. On the other hand, there are two other categories of overlaps that are considered illegal since they lead to unpredictable results during tracking.; A) If a positioned volume contains points that are not also contained by its mother, we will call the corresponding region as an ""extrusion"". When navigating from outside to inside (trying to enter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage o",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:100637,Integrability,depend,depends,100637,"o unpredictable results during tracking.; A) If a positioned volume contains points that are not also contained by its mother, we will call the corresponding region as an ""extrusion"". When navigating from outside to inside (trying to enter such a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal o",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:124551,Integrability,depend,depending,124551,"ll always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to TGeoVolume objects):; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; Importing will append the volume to the current TGeoManager or will create one:; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; TGeoVolume::Importstatic TGeoVolume * Import(const char *filename, const char *name="""", Option_t *option="""")Import a volume from a file.Definition TGeoVolume.cxx:873. GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call. Naviga",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:136524,Integrability,interface,interface,136524,"ger->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one shou",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:136700,Integrability,interface,interfaces,136700,"olume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:138279,Integrability,interface,interface,138279,"new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allo",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:138600,Integrability,depend,depending,138600,"cessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the correspondin",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:138786,Integrability,interface,interface,138786,"to memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different for differ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:139556,Integrability,interface,interface,139556,"le name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different for different types of objects. The volume selection dialog offers the possibility to select either a volume already connected to the geometry hierarchy or non-connected ones. Selection for shapes and matrices is split into categories represented by top-level list tree items for: boxes, tubes, translations, rotations, etc. Selection dialogs for different TGeo objects; Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be dest",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:139751,Integrability,interface,interfaces,139751," by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allows creation of translations, rotations or combined transformations. Existing matrices can also be browser/edited. Editing Existing Objects; For editing an existing object from one of the categories described above, the interface imposes first a selection among all objects of the corresponding type stored in the geometry. This can be done by clicking the button next to the blue label Select <object>. The dialog interfaces are generally different for different types of objects. The volume selection dialog offers the possibility to select either a volume already connected to the geometry hierarchy or non-connected ones. Selection for shapes and matrices is split into categories represented by top-level list tree items for: boxes, tubes, translations, rotations, etc. Selection dialogs for different TGeo objects; Once a selection is made and the dialog is closed, the selected item name will appear in the corresponding label and the button Edit will start the object editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together. Editors for shapes, materials, media, matrices; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the ""Apply"" button only if t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:142085,Integrability,depend,depend,142085,"pe.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest node",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:142263,Integrability,interface,interface,142263,"d.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current select",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:143395,Integrability,interface,interface,143395,"ents in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested paramete",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:144260,Integrability,interface,interface,144260,"ing the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.; Create a volume from the ""Volumes"" category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to ""General"" category and select the newly created volume as the top one (you can do it also from the volume category). This is ju",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:145464,Integrability,interface,interface,145464,"ast one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required components are defined.; Create a volume from the ""Volumes"" category. You will notice that contrary to the other editors, the volume editor is opened in a tab, not transient - this is because it is more complex.; Go back to ""General"" category and select the newly created volume as the top one (you can do it also from the volume category). This is just for starting. To create some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:; add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the ""General"" category. . Modules;  GDML tools;  GDML tools for geometry classes. ;  ;  Geometry classes;  The Geometry related classes. ;  ;  Materials;  ;  Shapes;  Shapes are geometrical objects that provide the basic modeling functionality. ;  ;  Geometry builder;  The Geometry builder related classes. ;  ;  Geometry painter;  The Geometry painter, checker, overlap and track related classes. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:31531,Modifiability,inherit,inherit,31531,"represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ""invisible"" (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is dire",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:68183,Modifiability,variab,variables,68183,"f TObjects.Definition TObjArray.h:31; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGe",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:68524,Modifiability,variab,variables,68524,"nav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; TGeoManager::SetCurrentPointvoid SetCurrentPoint(Double_t *point)Definition TGeoManager.h:515. Initiali",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:72842,Modifiability,variab,variables,72842,":2782; In order to have more flexibility, there are in fact several alternative ways of initializing a modeller state:; // Setting the point and finding the state in one step:; gGeoManager->FindNode(Double_t x,Double_t y,Double_t z);; gGeoManager->FindNode(Double_t *point[3]);; // Setting both initial point and direction and finding the state:; gGeoManager->InitTrack(Double_t x,Double_t y,Double_t z,; Double_t nx, Double_t ny, Double_t nz);; gGeoManager->InitTrack(Double_t *point[3],Double_t *dir[3]);; TGeoManager::InitTrackTGeoNode * InitTrack(const Double_t *point, const Double_t *dir)Initialize current point and current direction vector (normalized) in MARS.Definition TGeoManager.cxx:2856; Note that the current point coordinates can be changed and the state re-initialized at any time. This represents the ‘‘Where am I?’` geometrical query representing the basic navigation functionality provided by the modeller. Checking the Current State; The current state and all variables related to this are essential during tracking and have to be checked several times. Besides the current point and direction, the following additional information can be retrieved from TGeoManager interface:. The current path. This represents a string containing the names and copy numbers of all positioned objects in the current branch written in the /folder/folder/.../folder/file fashion. The final node pointed by the path is the deepest object containing the current point and is representative for the current state. All intermediate folders in the path are in fact also nodes ""touched"" by the current point, but having some ""touched"" containment. The current path can be retrieved only after the state was initialized and is useful for getting an idea of the current point location. const char *path = gGeoManager->GetPath();; cout << ""Current path is: "" << path << endl;; /A_1/B_34/C_3/D_1; TGeoManager::GetPathconst char * GetPath() constGet path to the current node in the form /node0/node1/...Defin",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:93367,Modifiability,inherit,inheriting,93367,"tualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualGeoTrackBase class for user-defined tracks attached to a geometry.Definition TVirtualGeoTrack.h:23; Where: id is user-defined id of the track, pdg - pdg code, parent - a pointer to parent track, particle - a pointer to an arbitrary particle object (may be a **TParticle**).; A track has a list of daughters that have to be filled using the following method:; TVirtualGeoTrack *TVirtualGeoTrack::AddDaughter(Int_t id,Int_t pdg,; TObject *particle=0);; TVirtualGeoTrack::AddDaughtervirtual TVirtualGeoTrack * AddDaughter(Int_t id, Int_t pdgcode, TObject *particle=nullptr)=0; The method above is pure virtual and have to create a track daughter object. Tracks are fully customizable objects when inheriting from TVirtualGeoTrack class. We will describe the structure and functionality provided by the default implementation of these, which are TGeoTrack objects.; A TGeoTrack is storing a list of control points (x,y,z) belonging to the track, having also time information (t). The painting algorithm of such tracks allows drawing them in any time interval after their creation. The track position at a given time is computed by interpolation between control points.; myTrack->AddPoint(x,y,z,t);; The creation and management of tracks is in fact fully controlled by the TGeoManager class. This holds a list of primary tracks that is also visible during browsing as Tracks folder. Primary tracks are tracks having no parent in the tracking history (for instance the output of particle generators may be considered as primaries from tracking point of view). The manager class holds in TGeoManager::fCurrentTrack a pointer to the current track. When starting tracking a particle, one can create a ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:97195,Modifiability,variab,variable,97195,"e will be able to browse directly the list of tracks held by the manager class. Any track can be drawn using its Draw() and Animate() methods, but there are also global methods for drawing or animation that can be accessed from TGeoManager context menu:; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; Option_tconst char Option_tDefinition RtypesCore.h:66; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGeoManager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::DrawTracksvoid DrawTracks(Option_t *option="""")Draw tracks over the geometry, according to option.Definition TGeoManager.cxx:1905; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as conv",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:105784,Modifiability,plug-in,plug-in,105784,"omputes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry build",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:110723,Modifiability,inherit,inherit,110723,"bal visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();. Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there a",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:123673,Modifiability,variab,variables,123673,"nition TGeoManager.cxx:4096; Example:; // Writing to a file geometry definition ending with:; root[] gGeoManager->CloseGeometry();; // geometry is ready; root[] gGeoManager->Export(""MyGeom.root"");; // file MyGeom.root produced; root[] gGeoManager->Export(""MyGeom.C"");; // C++ macro MyGeom.C produced; root[] gGeoManager->Export(""MyGeom.gdml"");; // GDML file MyGeom.gdml produced; root[] myVolume->SaveAs(""MyVolume.C"");; // C++ macro for the branch starting; // with MyVolume; // Reading from a file; root[] gSystem->Load(""libGeom"");; root[] TGeoManager::Import(""MyGeom.root""); // geometry is ready; Note that not all-current information held by the modeller is written on the file. For instance, the painter and checker objects are not written, as well as the temporary current navigation properties: current node path, point or direction. On the other hand, all objects belonging to the geometrical hierarchy will always be written. The idea is to be able to retrieve the geometry in a ready state, ignoring what the state variables that can be always re-initialized. When the code is generated for a given TGeoVolume in the geometry, just the branch starting with that volume will be saved in the file. Executing the generated code will create a geometry that has MyVolume as top volume. In this case, only the materials/media/matrices used effectively in the MyVolume branch are exported to file.; Volumes can be made persistent in the same way the full geometry is. Exporting is straightforward (module1, 2 are pointers to TGeoVolume objects):; module1->Export(""file.root"");; // by default file is overwritten; module2->Export(""file.root"","""",""update"");; // to the same file; Importing will append the volume to the current TGeoManager or will create one:; TGeoManager *geom = new TGeoManager(""myGeom"", """");; TGeoVolume *top = geom->MakeBox(...);; geom->SetTopVolume(top);; //name of volume or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVol",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:125532,Modifiability,config,configure,125532," or key (depending on export usage); TGeoVolume *module1 = TGeoVolume::Import(""file.root"", ""MOD1"");; TGeoVolume *module2 = TGeoVolume::Import(""file.root"", ""MOD2"");; top->AddNode(module1, 1, new TGeoTranslation(0,0,100));; top->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; TGeoVolume::Importstatic TGeoVolume * Import(const char *filename, const char *name="""", Option_t *option="""")Import a volume from a file.Definition TGeoVolume.cxx:873. GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call. Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms. Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable' object in the geometry hierarchy. It is represented by a path like: /TOP\_1/A\_1/B\_3/C\_1, where B\_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (MTOP\_1, MA\_1, MB\_3,",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:136890,Modifiability,plug-in,plug-in,136890,"oundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still a",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:468,Performance,optimiz,optimize,468,". ROOT: The Geometry Package. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; The Geometry Package. ; The ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA. Quick Start: Creating the world; Example 1: Creating the World; Example 2: A Geometrical Hierarchy Look and Feel. Selecting the System of Units in ROOT; Geometry Creation; The Volume Hierarchy; Creating and Positioning Volumes; Making Volumes; Example of Volume Creation; Positioned Volumes (Nodes); Virtual Containers and Assemblies of Volumes; Examples of Volume Positioning; Overlapping Volumes; Replicating Volumes; Volume Families; Dividing Volumes; Volume Assemblies. Geometrical Transformations; Matrix Creation Example; Rule for Creation of Transformations; Available Geometrical Transformations. Ownership of Geometry Objects. Navigation and Tracking; TGeoNavigator Class; Initializing the Starting Point; Initializing the Direction; Initializing the State; Checking the Current State; Saving and Restoring the Current State; Navigation Queries; Finding If Current State Is Changed For a New Point; Finding the Distance to the Next Boundary; Computing the Safe Radius; Making a Step; The Normal Vector to the Next Crossed Surface at Crossing Point. Creating and Visualizing Tracks. Checking the Geometry; The Overlap Checker; Graphical Checking Methods. The Drawing Package; Drawing Volumes and Hierarchies of Volumes; Visualization Settings and Attributes; Colors and Line Styles; Visibility Settings. Ray Tracing; Clipping Ray-traced Images. Representing Misalignments of the Ideal Ge",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:2531,Performance,optimiz,optimize,2531,"g If Current State Is Changed For a New Point; Finding the Distance to the Next Boundary; Computing the Safe Radius; Making a Step; The Normal Vector to the Next Crossed Surface at Crossing Point. Creating and Visualizing Tracks. Checking the Geometry; The Overlap Checker; Graphical Checking Methods. The Drawing Package; Drawing Volumes and Hierarchies of Volumes; Visualization Settings and Attributes; Colors and Line Styles; Visibility Settings. Ray Tracing; Clipping Ray-traced Images. Representing Misalignments of the Ideal Geometry; Physical Nodes. Geometry I/O; GDML. Navigation Algorithms; Finding the State Corresponding to a Location (x,y,z); Finding the Distance to Next Crossed Boundary; Output Values. Geometry Graphical User Interface; Editing a Geometry; The Geometry Manager Editor; Editing Existing Objects; Creation of New Objects; Editing Volumes; How to Create a Valid Geometry with Geometry Editors. Quick Start: Creating the ""world""; This chapter will provide a detailed description on how to build valid geometries as well as the ways to optimize them. There are several components gluing together the geometrical model, but for the time being let us get used with the most basic concepts.; The basic bricks for building-up the model are called ""volumes"". These represent the un-positioned pieces of the geometry puzzle. The difference is just that the relationship between the pieces is not defined by neighbors, but by ""containment"". In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the ""world"" of the model. We will often call this ""master reference system (MARS)"". Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong... We will call these leaves (by analogy with a tree structure)",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:3977,Performance,load,load,3977,"inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the ""world"" of the model. We will often call this ""master reference system (MARS)"". Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong... We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:4418,Performance,perform,performing,4418,"ructure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:6572,Performance,optimiz,optimization,6572," and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the example",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:6600,Performance,perform,perform,6600," and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoManager.cxx:3169; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the example",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:8177,Performance,load,load,8177,"TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?""; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on ""containment"". This is accomplished by ""positioning"" some volumes ""inside"" others. Any volume is an un-positioned object in the sense that it defines only a ""local frame"" (matching the one of its ""shape""). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a ""local geometrical transformation"" of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes na",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:10937,Performance,perform,performing,10937,"rs R,; O and T. Why one have to define so many volumes to make an R?""; A: Well, in real life some objects have much more complex shapes that an ""R"". The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called ""primitive shapes""). Gluing these together in the appropriate way is the user responsibility.; Q: ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand.""; A: A volume is positioned inside another one by using this method. The relative geometrical transformation as well as a copy number must be specified. When positioned, a volume becomes a ""node"" of its container and a new object of the class TGeoNode is automatically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw() call for the top volume. These are explained in details in the section ""Visualization Settings and Attributes"". At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.De",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:12163,Performance,perform,performing,12163,"e explained in details in the section ""Visualization Settings and Attributes"". At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes insid",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:12256,Performance,perform,performed,12256,"to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37. The folders Materials, Media and Local transformations are in fact the containers where the geometry manager stores the corresponding objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:14288,Performance,perform,performed,14288," objects that are seen when visualizing or tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.; TView (mouse not selecting any volume):. Click-and-drag rotates the view.; Pressing some keys perform different actions:; J/K - zoom / unzoom; H, L, U, I - move the viewpoint; Right click + SetParallel ()/SetPerspective () - switch from parallel to perspective view.; Right click + ShowAxis() - show coordinate axes.; Right click + Centered/Left/Side/Top - change view direction. TGeoVolume (mouse selecting a volume):. Double click will focus the corresponding volume.; Right click + CheckOverlaps() - run overlap checker on current volume.; Right click + Draw () - draw that volume according current global visualization options; Right click + DrawOnly() - draw only the selected volume.; Right click + InspectShape/Material() - print info about shape or material.; Right click + Raytrace() - initiate a ray tracing algorithm on current view.; Right click + RandomPoints/Rays() - shoot random points or rays inside the bounding box of the cl",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:14445,Performance,perform,perform,14445,"a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selected will also open its context menu (picking). Note that there are several actions that can be performed both at view (no volume selected) and volume level.; TView (mouse not selecting any volume):. Click-and-drag rotates the view.; Pressing some keys perform different actions:; J/K - zoom / unzoom; H, L, U, I - move the viewpoint; Right click + SetParallel ()/SetPerspective () - switch from parallel to perspective view.; Right click + ShowAxis() - show coordinate axes.; Right click + Centered/Left/Side/Top - change view direction. TGeoVolume (mouse selecting a volume):. Double click will focus the corresponding volume.; Right click + CheckOverlaps() - run overlap checker on current volume.; Right click + Draw () - draw that volume according current global visualization options; Right click + DrawOnly() - draw only the selected volume.; Right click + InspectShape/Material() - print info about shape or material.; Right click + Raytrace() - initiate a ray tracing algorithm on current view.; Right click + RandomPoints/Rays() - shoot random points or rays inside the bounding box of the clicked volume and display only those inside visible volumes.; Right click + Weight() - estimates the weight of a volume within a given precision. Note that there are several additional methods for visibility and line attributes ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:18184,Performance,load,loaded,18184,"er::LockDefaultUnits(kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TGeoManager::LockDefaultUnitsstatic Bool_t LockDefaultUnits(Bool_t new_value)Definition TGeoManager.cxx:4307; followed later by a corresponding call to again lock the system of units:; TGeoManager::LockDefaultUnits(kTRUE);; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93. Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relative transformation matrix must be provided.; Any volume have to be positioned somewhere otherwise it will not be considered as part of the geometry.; Visibility or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see section: ""The Drawing Package"") should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).; The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame.; After building the full geometry tree, the geometry must be closed (see the method **TGeoManager::CloseGeometry()**). Voxelization can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the **TGeoManager** class will register itself to ROOT and the logical/physical structures will become immediately browsable. The Volume Hierarchy; The basic",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:23931,Performance,perform,perform,23931,"aved as a starting state for later use.; Nodes can be declared as overlapping in case they do overlap with other nodes inside the same container or extrude this container (see also ‘Checking the Geometry'). Non-overlapping nodes can be created with:; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; The creation of overlapping nodes can be done with a similar prototype:; TGeoVolume::AddNodeOverlap(/*same arguments*/);; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:1044; When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbors. These are stored and checked all the time during navigation; therefore, navigation is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Creating and Positioning Volumes; Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects havin",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:27259,Performance,perform,performances,27259,"the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat' CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:29927,Performance,optimiz,optimization,29927,"oIdentityDefinition TGeoMatrix.h:537; The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeller. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches.; In order to provide navigation features, volumes have to be able to find the proper container of any point defined in the local reference frame. This can be the volume itself, one of its positioned daughter volumes or none if the point is actually outside. On the other hand, volumes have to provide also other navigation methods such as finding the distances to its shape boundaries or which daughter will be crossed first. The implementation of these features is done at shape level, but the local mother-daughters management is handled by volumes. These build additional optimization structures upon geometry closure. In order to have navigation features properly working one has to follow some rules for building a valid geometry. The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.; The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node bu",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:31438,Performance,optimiz,optimizes,31438,"; TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ""invisible"" (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:31457,Performance,perform,performance,31457,"; TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ""invisible"" (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:32615,Performance,optimiz,optimize,32615,"e volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E or F in order to make it ""invisible"" (same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D, E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:42187,Performance,optimiz,optimization,42187,"object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:; TG",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:42372,Performance,perform,performance,42372,"object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:; TG",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:47403,Performance,perform,performed,47403,"uble_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; Here SLICEX is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the divided container - the advantage being that the navigation in such a structure is much faster. When a volume is divided, a volume family corresponding to the slices is created. In case all slices can be represented by a single shape, only one volume is added to the family and positioned N times inside the divided volume, otherwise, each slice will be represented by a distinct volume in the family.; Divisions can be also performed in a given range of one axis. For that, one has to specify also the starting coordinate value and the step:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N,start,step);; A check is always done on the resulting division range: if not fitting into the container limits, an error message is posted. If we will browse the divided volume we will notice that it will contain N nodes starting with index 1 up to N. The first one has the lower X limit at START position, while the last one will have the upper X limit at START+N*STEP. The resulting slices cannot be positioned inside another volume (they are by default positioned inside the divided one) but can be further divided and may contain other volumes:; TGeoVolume *slicey = slicex->Divide(""SLICEY"",2,N1);; slicey->AddNode(other_vol,index,some_matrix);; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t Window",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:51338,Performance,perform,performance,51338,"o be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:51519,Performance,optimiz,optimizations,51519,"rts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = n",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:51714,Performance,perform,perform,51714,"ts in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:52919,Performance,optimiz,optimizing,52919,"ly, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:52934,Performance,perform,performance,52934,"ly, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:52995,Performance,perform,performance,52995,"ment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given o",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:53064,Performance,perform,performing,53064,"ment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given o",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:53414,Performance,optimiz,optimize,53414,"omponents inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous trans",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:53423,Performance,perform,performance,53423,"omponents inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous trans",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:53883,Performance,perform,perform,53883,"emblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:54644,Performance,perform,performed,54644,"for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \]. Scale:. \[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \]. Inverse scale:. \[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:62935,Performance,perform,performed,62935,"TGeoTranslation *other)Subtracting a translation from this one.Definition TGeoMatrix.cxx:742. Rotations (TGeoRotation class) represent a pure rotation. Data members are Double_t fRotationMatrix[3*3]. Rotations can be defined either by Euler angles, either, by GEANT3 angles:. TGeoRotation *r1 = new TGeoRotation();; r1->SetAngles(phi,theta,psi); // all angles in degrees; This represents the composition of: first a rotation about Z axis with angle phi, then a rotation with theta about the rotated X axis, and finally a rotation with psi about the new Z axis.; r1->SetAngles(th1,phi1,th2,phi2,th3,phi3); th3auto * th3Definition textalign.C:22; th2auto * th2Definition textalign.C:18; th1auto * th1Definition textalign.C:14; This is a rotation defined in GEANT3 style. Theta and phi are the spherical angles of each axis of the rotated coordinate system with respect to the initial one. This construction allows definition of malformed rotations, e.g. not orthogonal. A check is performed and an error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3], TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:65059,Performance,cache,cache,65059,"l geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:65229,Performance,load,loaded,65229,"f geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:78027,Performance,perform,perform,78027,"ager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoManager.cxx:1655; ptTPaveText * ptDefinition entrylist_figure1.C:7. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. const TGeoHMatrix *global = gGeoManager->GetCurrentMatrix();; TGeoHMatrix *copy = new TGeoHMatrix(*global);; TGeoManager::GetCurrentMatrixTGeoHMatrix * GetCurrentMatrix() constDefinition TGeoManager.h:496. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the **TGeoManager** corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:78968,Performance,perform,performed,78968,"rix * GetCurrentMatrix() constDefinition TGeoManager.h:496. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the **TGeoManager** corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stac",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:81764,Performance,perform,perform,81764,"changed by the user.; Finding If Current State Is Changed For a New Point; One can find fast if a point different from the current one has or not the same location inside the geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; TGeoManager::IsSameLocationBool_t IsSameLocation() constDefinition TGeoManager.h:393; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘‘Where am I?’ `search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daugh",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:81920,Performance,perform,performing,81920," geometry tree. To do that, the new point should not be introduced by using TGeoManager::SetCurrentPoint() method, but rather by calling the specific method:; Bool_t TGeoManager::IsSameLocation(Double_t x,Double_t y,; Double_t z,Bool_t change=kFALSE);; TGeoManager::IsSameLocationBool_t IsSameLocation() constDefinition TGeoManager.h:393; In the prototype above, x, y and z are the coordinates of the new point. The modeller will check whether the current volume still contains the new point or its location has changed in the geometry hierarchy. If the new location is different, two actions are possible according to the value of change:. change = kFALSE (default) - the modeller does not change the current state but just inform the caller about this change.; change = kTRUE - the modeller will actually perform a new ‘‘Where am I?’ `search after finding out that the location has changed. The current state will be actualized accordingly. Note that even when performing a normal search on the current state after changing the current point coordinates (e.g. gGeoManager->FindNode(newX,newY,newZ)), users can always query if the previous state has changed by using a method having the same name but without parameters:; Bool_t TGeoManager::IsSameLocation();; Finding the Distance to the Next Boundary; All tracking engines need to compare the currently proposed physical step with the maximum allowed distance in the current material. The modeller provides this information by computing the distance to the first boundary starting from the current point along a straight line. The starting point and direction for this procedure are the ones corresponding to the current state. The boundary search is initialized inside the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t st",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:91712,Performance,scalab,scalability,91712,"rface. The modeller uses the following convention: we define as normal ( \(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; TGeoManager::FindNormalDouble_t * FindNormal(Bool_t forward=kTRUE)Computes normal vector to the next surface that will be or was already crossed when propagating on a ...Definition TGeoManager.cxx:2810; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC. Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualGeoTrackBase class for user-defined",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:91728,Performance,perform,performance,91728,"rface. The modeller uses the following convention: we define as normal ( \(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; TGeoManager::FindNormalDouble_t * FindNormal(Bool_t forward=kTRUE)Computes normal vector to the next surface that will be or was already crossed when propagating on a ...Definition TGeoManager.cxx:2810; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC. Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualGeoTrackBase class for user-defined",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:98248,Performance,perform,perform,98248,"SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to ""catch"" the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames. Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs. The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by the mother the",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:100845,Performance,perform,performed,100845,"ch a node) these regions are invisible since the current track has not yet reached its mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::C",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:100938,Performance,perform,perform,100938," mother. This is not the case when going the other way since the track has first to exit the extruding node before checking the mother. In other words, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geomet",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:101086,Performance,optimiz,optimize,101086,"s, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:101202,Performance,perform,performance,101202,"s, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:101463,Performance,load,loaded,101463,"ck is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:102293,Performance,perform,performed,102293,"during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is containe",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:102585,Performance,perform,perform,102585,"en volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:102684,Performance,perform,perform,102684,"en volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103460,Performance,perform,performed,103460,"for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintO",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103523,Performance,optimiz,optimized,103523,"lity, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; I",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103592,Performance,perform,performing,103592,"lity, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; I",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:105770,Performance,load,loaded,105770,"omputes the closest distance to any boundary. Random points; A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry build",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:106240,Performance,load,loads,106240,"m rays; A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node. The Drawing Package. The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:107616,Performance,perform,perform,107616,"oding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the **TView** context menu: right-click on the picture when no object is selected;. Q: ""Every line is black! I cannot figure out what is what...""; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: ""The top volume of my geometry is a box but I see only its content.""; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: ""I do not see all volumes in my tree but just som",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:109620,Performance,perform,performed,109620,").; Q: ""I do not see all volumes in my tree but just something inside.""; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can change this by using: gGeoManager::SetVisLevel(n);; Not only that, but none of the volumes at intermediate levels (0-2) are visible on the drawing unless they are final ‘leaves' on their branch (e.g. have no other volumes positioned inside). This behavior is the default one and corresponds to ‘leaves' global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: ""Volumes are highlighted when moving the mouse over their vertices. What does it mean?""; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?""; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();. Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and s",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:110397,Performance,tune,tune,110397,"By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: ""OK, but now I do not want to see all the geometry, but just a particular volume and its content. How can I do this?""; A: Once you have set a convenient global visualization option and level, what you need is just call the Draw() method of your interesting volume. You can do this either by interacting with the expanded tree of volumes in a ROOT browser (where the context menu of any volume is available), either by getting a pointer to it (e.g. by name): gGeoManager->GetVolume(""vol_name"")->Draw();. Visualization Settings and Attributes; Supposing you now understand the basic things to do for drawing the geometry or parts of it, you still might be not happy and wishing to have more control on it. We will describe below how you can fine-tune some settings. Since the corresponding attributes are flags belonging to volume and node objects, you can change them at any time (even when the picture is already drawn) and see immediately the result.; Colors and Line Styles; We have already described how to change the line colors for volumes. In fact, volume objects inherit from TAttLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:111743,Performance,tune,tune,111743,"tLine class so the line style or width can also be changed:; myVolume->SetLineColor(kRed);; myVolume->SetLineWith(2);; myVolume->SetLineStyle(kDotted);; kRed@ kRedDefinition Rtypes.h:66; kDotted@ kDottedDefinition TAttLine.h:48; When drawing in solid mode, the color of the drawn volume corresponds to the line color.; Visibility Settings; The way geometry is build forces the definition of several volumes that does not represent real objects, but just virtual containers used for grouping and positioning volumes together. One would not want to see them in the picture. Since every volume is by default visible, one has to do this sort of tuning by its own:; myVolumeContainer->SetVisibility(kFALSE);; As described before, the drawing package supports two main global options: 1 (default) - only final volume leaves; 0 - all volumes down the drawn one appear on the screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are cons",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:114902,Performance,perform,performing,114902,"ape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:121479,Performance,load,loading,121479,"gle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; TGeoManager::Exportvirtual Int_t Export(const char *filename, const char *name="""", Option_t *option=""vg"")Export this geometry to a file.Definition TGeoManager.cxx:3975. Filename is the name of the file to be written (mandatory). Depending on the extension of the file, the geometry is exported either as ,root file or .C(.cxx) macro or GDML file in case extension is .gdml.; keynameis the name of the key in the file (default """"); opt = ""v"" is an export voxelization (default), otherwise voxelization is recomputed after loading the geometry, ""g"" this option (default) is taken into account only for exporting to gdml file and it ensures compatibility with Geant4 (e.g. it adds extra plane to incorrectly set polycone, it checks whether offset of Phi division is in (-360;0> range, ...), for this gdml export there are two more option, that are not set by default: ""f"" and ""n"". If none of this two options are set, then names of solids and volumes in resulting gdml file will have incremental suffix (e.g. TGeoBBox_0x1, TGeoBBox_0x2, ...). If ""f"" option is set then then suffix will contain pointer of object (e.g. TGeoBBox_0xAAAAA01, ...). Finally if option ""n"" is set then no suffix will be added, though in this case uniqueness of the names is not ensured and it can cause that file will be invalid. Loading geometry from a root file can be done in the same way as for any other ROOT object, but a static method is also provided:; TGeoManager::Import(const char *filename,const char *keyname="""",; Option_t *opt=""""); T",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:125796,Performance,optimiz,optimization,125796,"->AddNode(module2, 1, new TGeoTranslation(0,0,-100));; // One should close oneself the geometry; geom->CloseGeometry();; TGeoVolume::Importstatic TGeoVolume * Import(const char *filename, const char *name="""", Option_t *option="""")Import a volume from a file.Definition TGeoVolume.cxx:873. GDML; Few lines above word GDML was used. GDML stands for Geometry Description Markup Language. It is an application-independent geometry description format based on XML. It is mainly used for geometry interchange between ROOT and Geant4 framework. More details about this project can be found http://gdml.web.cern.ch. This feature (importing/exporting from/to gdml file format) is disabled by default in ROOT installation. To enable this feature add --enable-gdml option to ./configure script call. Navigation Algorithms; This section will describe the main methods and algorithms used for implementing the navigation features within the geometrical modeller. This includes navigation queries at shape level, global geometrical queries and optimization mechanisms. Finding the State Corresponding to a Location (x,y,z); For reminder, a geometry state is a ‘touchable' object in the geometry hierarchy. It is represented by a path like: /TOP\_1/A\_1/B\_3/C\_1, where B\_3 for instance is a copy of volume B positioned inside volume A. A state is always associated to a transformation matrix M of the touchable with respect to the global reference frame (obtained by piling-up all local transformations of nodes in the branch with respect to their containers). The current state and the corresponding global matrix are updated whenever the geometry depth is modified. The global transformations corresponding to all nodes in the current branch are kept in an array: (MTOP\_1, MA\_1, MB\_3, ...). Navigation in the geometry hierarchy; The elementary operations for changing the state are:; TGeoManager::CdUp();; TGeoManager::CdDown(i);; TGeoManager::CdTop(); TGeoManager::CdUpvoid CdUp()Go one level up in geometry.",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128294,Performance,optimiz,optimizes,128294,"roperties. This task is done by:; TGeoNode *TGeoManager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the ""deepest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128371,Performance,perform,performed,128371,"anager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the ""deepest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway se",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128913,Performance,optimiz,optimization,128913,"OP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. Finding the Distance to Next Crossed Boundary; The most important feature provided by the modeller related to track propagation is the computation of the distance to the next boundary along a straight line.; The relevant state parameters used for this task are:. Current particle position and direction (x,y,z,nx,n",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:130997,Performance,perform,perform,130997,"anager::FindNode(x,y,z) beforehand The method computing the distance to next boundary is:. TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning ""step approved"". The default value for stepmax is TGeoShape::Big with the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary; According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big(); The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its bounda",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:133530,Performance,perform,performed,133530,"se, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:133888,Performance,perform,performed,133888,"roposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overl",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:134025,Performance,optimiz,optimization,134025,"ts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing th",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:134602,Performance,perform,performed,134602," the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method T",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:136060,Performance,perform,performs,136060,"lue of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method TGeoManager::FindNextBoundary() does not modify the current point/direction nor the current volume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry obj",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:136873,Performance,load,loaded,136873,"oundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still a",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:137786,Performance,load,loaded,137786,"aphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:141852,Performance,perform,performed,141852,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allow",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:232,Safety,detect,detector,232,". ROOT: The Geometry Package. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; The Geometry Package. ; The ROOT geometry package is a tool for building, browsing, navigating and visualizing detector geometries. The code works standalone with respect to any tracking Monte-Carlo engine; therefore, it does not contain any constraints related to physics. However, the navigation features provided by the package are designed to optimize particle transport through complex geometries, working in correlation with simulation packages such as GEANT3, GEANT4 and FLUKA. Quick Start: Creating the world; Example 1: Creating the World; Example 2: A Geometrical Hierarchy Look and Feel. Selecting the System of Units in ROOT; Geometry Creation; The Volume Hierarchy; Creating and Positioning Volumes; Making Volumes; Example of Volume Creation; Positioned Volumes (Nodes); Virtual Containers and Assemblies of Volumes; Examples of Volume Positioning; Overlapping Volumes; Replicating Volumes; Volume Families; Dividing Volumes; Volume Assemblies. Geometrical Transformations; Matrix Creation Example; Rule for Creation of Transformations; Available Geometrical Transformations. Ownership of Geometry Objects. Navigation and Tracking; TGeoNavigator Class; Initializing the Starting Point; Initializing the Direction; Initializing the State; Checking the Current State; Saving and Restoring the Current State; Navigation Queries; Finding If Current State Is Changed For a New Point; Finding the Distance to the Next Boundary; Computing the Safe Radius; Making a Step; The Normal Vector to the Next Crossed Surface at Crossing Point. Creating and Visualizing Tracks. Checking the Geometry; The Overlap Checker; Graphical Checking Methods. The Drawing Package; Drawing Volumes and Hierarchies of Volumes; Visualization Settings and Attributes; Colors and Line Styles; Visibility Settings. Ray Tracing; Clipping Ray-traced Images. Representing Misalignments of the Ideal Ge",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:4929,Safety,safe,safely,4929,"he geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeBoxTGeoVolume * MakeBox(const char *name, TGeoMedium *medium, Double_t dx, Double_t dy, Double_t dz)Make in one step a volume pointing to a box shape with given medium.Definition TGeoM",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:16723,Safety,avoid,avoid,16723,"eters, nanoseconds and MegaElectronVolts was better suited for the LHC experiments. All LHC experiments use Geant4 and effectively adopted this convention for all areas of data processing: simulation, reconstruction and data analysis. Hence experiments using the ROOT geometry toolkit to describe the geometry had two different system of units in the application code.; To allow users having the same system of units in the geometry description and the application it is now possible to choose the system of units at startup of the application:; TGeoManager::SetDefaultUnits(xx); xx = kG4Units, kRootUnits; TGeoManager::SetDefaultUnitsstatic void SetDefaultUnits(EDefaultUnits new_value)Definition TGeoManager.cxx:4319; To ensure backwards compatibility ROOT's default system of units is - as it was before - based on centimeters, seconds and GigaElectronVolts, ie. the defaults are equivalent to:; TGeoManager::SetDefaultUnits(kRootUnits);; To avoid confusion between materials described in ROOT units and materials described in Geant4 units, this switch should by all means be set once, before any element or material is constructed. If for whatever reason it is necessary to change the system of units later, this is feasible disabling the otherwise fatal exception:; TGeoManager::LockDefaultUnits(kFALSE);; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; TGeoManager::LockDefaultUnitsstatic Bool_t LockDefaultUnits(Bool_t new_value)Definition TGeoManager.cxx:4307; followed later by a corresponding call to again lock the system of units:; TGeoManager::LockDefaultUnits(kTRUE);; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93. Geometry Creation; A given geometry can be built in various ways, but one has to follow some mandatory steps. Even if we might use some terms that will be explained later, here are few general rules:. Volumes need media and shapes in order to be created.; Both containers and contained volumes must be created before linking them together, and the relat",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:25099,Safety,avoid,avoid,25099,"on is slower when embedding such nodes into geometry. Nodes have visualization attributes as the volume has. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Creating and Positioning Volumes; Making Volumes; As mentioned before, volumes are the basic objects used in building the geometrical hierarchy. They represent objects that are not positioned, but store all information about the placement of the other volumes they may contain. Therefore a volume can be replicated several times in the geometry. As it was explained, in order to create a volume, one has to put together a shape and a medium, which are already defined.; Volumes have to be named by users at creation time. Every different name may represent a unique volume object, but may also represent more general a family (class) of volume objects having the same shape type and medium, but possibly different shape parameters. It is the user's task to provide different names for different volume families in order to avoid ambiguities at tracking time.; A generic family rather than a single volume is created only in two cases: when a parametric shape is used or when a division operation is applied. Each volume in the geometry stores a unique ID corresponding to its family. In order to ease-up their creation, the manager class is providing an API that allows making a shape and a volume in a single step.; Example of Volume Creation; // Making a volume out of a shape and a medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape,ptrMed);; ; // Making a volume out of a shape but without a defined medium.; TGeoVolume *vol = new TGeoVolume(""VNAME"",ptrShape);; ; // Making a volume with a given shape in one step; TGeoVolume *vol = gGeoManager->MakeBox(""VNAME"",ptrMed,dx,dy,dz);; TGeoVolume *vol = gGeoManager->MakeTubs(""VNAME"",ptrMed,rmin,rmax,; dz,phi1,phi2);; ; // See class TGeoManager for the rest of shapes.; // Making a volume with a given shape with a unique prototype; TGeo",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:27144,Safety,detect,detector,27144,"the specific shape; // classes, nmed is the medium number, upar is an Double_t * array; // of the shape parameters and npar is the number of parameters.; // This prototype allows (npar = 0) to define volumes with shape; // defined only at positioning time (volumes defined in this way; // need to be positioned using TGeoManager::Node() method); TGeoManager::VolumeTGeoVolume * Volume(const char *name, const char *shape, Int_t nmed, Float_t *upar, Int_t npar=0)Create a volume in GEANT3 style.Definition TGeoManager.cxx:1388; TGeoManager::MakeTubsTGeoVolume * MakeTubs(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz, Double_t phi1, Double_t phi2)Make in one step a volume pointing to a tube segment shape with given medium.Definition TGeoManager.cxx:3213; Positioned Volumes (Nodes); Geometrical modeling is a difficult task when the number of different geometrical objects is 106-108. This is more or less the case for detector geometries of complex experiments, where a ‘flat' CSG model description cannot scale with the current CPU performances. This is the reason why models like GEANT [1] introduced an additional dimension (depth) in order to reduce the complexity of the problem. This concept is also preserved by the ROOT modeller and introduces a pure geometrical constraint between objects (volumes in our case) - containment. This means in fact that any positioned volume has to be contained by another. Now what means contained and positioned?. We will say that a volume contains a point if this is inside the shape associated to the volume. For instance, a volume having a box shape will contain all points P=(X,Y,Z) verifying the conditions: Abs(Pi)dXi. The points on the shape boundaries are considered as inside the volume. The volume contains a daughter if it contains all the points contained by the daughter.; The definition of containment works of course only with points defined in the local coordinate system of the considered volume. Positionin",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:33030,Safety,avoid,avoid,33030,"(same physics properties). In other words, the limitation in proceeding this way is that D,E, and F must point to the same medium. If this was not the case, we would have to define different virtual volumes for each placement: C, C' and C"", having the same shape but different media matching the corresponding containers. This might not happen so often, but when it does, it forces the creation of several extra virtual volumes. Other limitation comes from the fact that any container is directly used by navigation algorithms to optimize tracking. These must geometrically contain their belongings (positioned volumes) so that these do not extrude its shape boundaries. Not respecting this rule generally leads to unpredictable results. Therefore A and B together must fit into C that has to fit also into D, E, and F. This is not always straightforward to accomplish, especially when instead of A and B we have many more volumes.; In order to avoid these problems, one can use for the difficult cases the class TGeoVolumeAssembly, representing an assembly of volumes. This behaves like a normal container volume supporting other volumes positioned inside, but it has neither shape nor medium. It cannot be used directly as a piece of the geometry, but just as a temporary structure helping temporary assembling and positioning volumes.; If we define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ""unnecessary"" volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:38242,Safety,avoid,avoid,38242,"n will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem is that in order to reproduce the honeycomb structure out of rows of cells, we have to overlap row containers. Whoops - we have not obeyed rule No. 2 in positioning. The way out is to position our rows with a special prototype:. ptrCAL->AddNodeOverlap(""ROW"",nRow,matrixRow);; This will instruct the modeller that the daughter ROW inside CAL overlaps with something else. The modeller will check this at closure time and build a list of possibly overlapping candidates. This option is equivalent with the option MANY in GEANT3.; The modeller supports such cases ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:40837,Safety,detect,detector,40837,"we will consider few examples. We will designate non-overlapping nodes as ONLY and the others MANY as in GEANT3, where this concept was introduced:. The part of a MANY node B extruding its container A will never be ""seen"" during navigation, as if B was in fact the result of the intersection of A and B.; If we have two nodes A (ONLY) and B (MANY) inside the same container, all points in the overlapping region of A and B will be designated as belonging to A.; If A an B in the above case were both MANY, points in the overlapping part will be designated to the one defined first. Both nodes must have the same medium.; The slices of a divided MANY will be as well MANY. One needs to know that navigation inside geometry parts MANY nodes is much slower. Any overlapping part can be defined based on composite shapes - might be in some cases a better way out.; Replicating Volumes; What can we do if our chamber contains two identical wires instead of one? What if then we would need 1000 chambers in our detector? Should we create 2000 wires and 1000 chamber volumes? No, we will just need to replicate the ones that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's g",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:65924,Safety,safe,safety,65924,"class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting p",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:66027,Safety,detect,detector,66027,"ing mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:68313,Safety,safe,safety,68313,"f TObjects.Definition TObjArray.h:31; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGe",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:83694,Safety,safe,safety,83694,"the current volume and the crossed boundary can belong either to the current node or to one of its daughters. The full prototype of the method is:; TGeoNode *TGeoManager::FindNextBoundary(Double_t step=kBig);; TGeoManager::FindNextBoundaryTGeoNode * FindNextBoundary(Double_t stepmax=TGeoShape::Big(), const char *path="""", Bool_t frombdr=kFALSE)Find distance to next boundary and store it in fStep.Definition TGeoManager.cxx:2755; In the prototype above, besides the current point and direction that are supposed already initialized, the only input parameter is step. This represents the maximum step allowed by the tracking algorithm or the physical step. The modeller will search for a boundary crossing only up to a distance equal to this value. If a boundary is found, a pointer to the object (node) having it is returned; otherwise the method returns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; TGeoManager::GetSafeDistanceDouble_t GetSafeDistance() constDefinition TGeoManager.h:384; TGeoManager::GetStepDouble_t GetStep() constDefinition TGeoManager.h:386; According the step value, two use cases are possible:. step = TGeoShape::kBig (default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provi",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:84549,Safety,safe,safety,84549,"rns NULL.; The computed value for the computed distance can be subsequently retrieved from the manager class:; Double_t snext = gGeoManager->GetStep();; Double_t safety = gGeoManager->GetSafeDistance();; TGeoManager::GetSafeDistanceDouble_t GetSafeDistance() constDefinition TGeoManager.h:384; TGeoManager::GetStepDouble_t GetStep() constDefinition TGeoManager.h:386; According the step value, two use cases are possible:. step = TGeoShape::kBig (default behavior; kBig = 1030). In this case, there is no limitation on the search algorithm, the first crossed node is returned and the corresponding distance computed. If the current point is outside geometry and the top node is not crossed, the corresponding distance will be set to kBig and a NULL pointer returned. No additional quantity will be computed.; step < kBig. In this case, the progressive search starting from the current point will be stopped after a distance equal with the supplied step. In addition to the distance to the first crossed boundary, the safety radius is also computed. Whenever the information regarding the maximum required step is known it is recommended to be provided as input parameter in order to speed-up the search. In addition to the distance computation, the method sets an additional flag telling if the current track will enter inside some daughter of the current volume or it will exit inside its container:; Bool_t TGeoManager::IsStepEntering() const;; TGeoManager::IsStepEnteringBool_t IsStepEntering() constDefinition TGeoManager.h:404; A combined task is to first find the distance to the next boundary and then extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined ta",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:86162,Safety,safe,safety,86162,"en extrapolate the current point/direction with this distance making sure that the boundary was crossed. Finally the goal would be to find the next state after crossing the boundary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t sa",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:86358,Safety,safe,safe,86358,"ndary. The problem can be solved in principle using FindNextBoundary, but the boundary crossing can give unpredictable results due to numerical roundings. The manager class provides a method that allows this combined task and ensures boundary crossing. This should be used instead of the method FindNextBoundary() whenever the tracking is not imposed in association with an external MC transport engine (which provide their own algorithms for boundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a St",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:86789,Safety,safe,safety,86789,"oundary crossing).; TGeoNode *TGeoManager::FindNextBoundaryAndStep(Double_t stepmax,; Bool_t comp_safe=kFALSE);; TGeoManager::FindNextBoundaryAndStepTGeoNode * FindNextBoundaryAndStep(Double_t stepmax=TGeoShape::Big(), Bool_t compsafe=kFALSE)Compute distance to next boundary within STEPMAX.Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current dir",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:86853,Safety,safe,safe,86853,"Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoManager.cxx:3638; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:87026,Safety,safe,safety,87026,"Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoManager.cxx:3638; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:87098,Safety,safe,safety,87098,"Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoManager.cxx:3638; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:87137,Safety,safe,safety,87137,"Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoManager.cxx:3638; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:87234,Safety,safe,safe,87234,"Definition TGeoManager.cxx:2736; The meaning of the parameters here is the same as for FindNextBoundary, but the safety value is triggered by an input flag. The output is the node after the boundary crossing.; Computing the Safe Radius; Other important navigation query for tracking is the computation of the safe distance. This represents the maximum step that can be made from the current point in any direction that assures that no boundary will be crossed. Knowing this value gives additional freedom to the stepping algorithm to propagate the current track on the corresponding range without checking if the current state has changed. In other words, the modeller insures that the current state does not change in any point within the safety radius around the current point.; The computation of the safe radius is automatically computed any time when the next boundary is queried within a limited step:; TGeoNode *crossed = gGeoManager->FindNextBoundary(pstep);; Double_t safety = gGeoManager->GetSafeDistance();; Otherwise, the computation of safety can always be forced:; Double_t safety = gGeoManager->Safety();; TGeoManager::SafetyDouble_t Safety(Bool_t inside=kFALSE)Compute safe distance from the current point.Definition TGeoManager.cxx:2300; Making a Step; The modeller is able to make steps starting from the current point along the current direction and having the current step length. The new point and its corresponding state will be automatically computed:; TGeoNode *TGeoManager::Step(Bool_t is_geom = kTRUE,; Bool_t cross = kTRUE);; TGeoManager::StepTGeoNode * Step(Bool_t is_geom=kTRUE, Bool_t cross=kTRUE)Make a rectilinear step of length fStep from current point (fPoint) on current direction (fDirection)...Definition TGeoManager.cxx:3638; We will explain the method above by its use cases. The input flag is_geom allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:101013,Safety,detect,detected,101013,"s, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103078,Safety,safe,safety,103078,"lap value in centimeters (default value is 0.1). This tool checks all possible significant pairs of candidates inside a given volume (not declared as overlapping or division volumes). The check is performed by verifying the mesh representation of one candidate against the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate nod",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103346,Safety,safe,safety,103346,"inst the shape of the other. This sort of check cannot identify all possible overlapping topologies, but it works for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represen",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103536,Safety,avoid,avoid,103536,"lity, one can perform the check at the level of a single volume by using option=""`d`"" or option=""`d<number>`"" to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; I",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:103881,Safety,detect,detected,103881,"1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps. Graphical Checking Methods. Safety computation checking; In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:114480,Safety,detect,detector,114480,"e screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially f",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:114583,Safety,detect,detector,114583,"lipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:114662,Safety,detect,detector,114662,"de the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for align",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:115437,Safety,detect,detector,115437,"n in the experimental hall. This generally happens not only for the detector modules, but also for their components. The accurate knowledge of the detector real misalignments can be extremely important for getting close to its designed resolution and the expected tracking efficiency. TGeo offers tools for representing positioning misalignments, applying them to the ideal geometry and performing navigation under these conditions. Detector tracking algorithms can then directly query the geometry for navigation purposes or for retrieving actual misalignment information. Physical Nodes; Physical nodes are the actual ""touchable"" objects in the geometry, representing actually a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. The number of physical nodes is given by the total number of possible of branches in the geometry hierarchy. In case of detector geometries and specially for calorimeters this number can be of the order 106-109, therefore it is impossible to create all physical nodes as objects in memory. In TGeo, physical nodes are represented by the class TGeoPhysicalNode and can be created on demand for alignment purposes:; TGeoPhysicalNode(const char* path); TGeoPhysicalNodePhysical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned ...Definition TGeoPhysicalNode.h:35; The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. One can however create ""symbolic links"" to any complex path to make it more representable for the object it designates:; TGeoPNEntry(const char* unique_name, const char* path); void TGeoPNEntry::SetPhysicalNode(TGeoPhysicalNode *node); TGeoPNEntryThe knowledge of the path to the objects that need to be misaligned is essential since there is no ot...Definition TGeoPhysicalNode.h:100; TGeoPNEntry::SetPhysicalNodevoid SetPhysicalNode(TGeoPhysicalNode *node)Setter ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:118680,Safety,avoid,avoid,118680,"mation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_t check=kFALSE, Double_t ovlp=0.001)Align a physical node with a new relative matrix/shape.Definition TGeoPhysicalNode.cxx:135; The c",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:131067,Safety,safe,safe,131067,"anager::FindNode(x,y,z) beforehand The method computing the distance to next boundary is:. TGeoNode *TGeoManager::FindNextBoundary(stepmax, path); The output node returned by the method is the object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning ""step approved"". The default value for stepmax is TGeoShape::Big with the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary; According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big(); The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its bounda",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:131206,Safety,safe,safe,131206,"he object which shape boundary will be crossed first. The distance to the next crossing can be retrieved after the call:; Double_t TGeoManager::GetStep(). The main input parameter is stepmax, which act as a trigger for different features. The absolute value of this parameter represents the step value proposed by the user. The algorithm will never try o search for boundaries further than this distance. In case no boundary is found the returned node will be the current one and the computed step to boundary will be equal to abs (stepmax) having the meaning ""step approved"". The default value for stepmax is TGeoShape::Big with the meaning that boundaries are looked for without limitation. Finding the distance to the next crossed boundary; According the values of the input parameters the method will perform additional optional tasks:; |stepmax| < TGeoShape::Big(); The safe distance in the current volume is also computed. Moving the particle from its current location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:132151,Safety,safe,safe,132151,"ent location with this distance in any direction is safe in the sense that will never change the current state.; stepmax < 0; The global matrix for the object that will have the next crossed boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:132360,Safety,safe,safety,132360," boundary is also computed. This can be retrieved for masterlocal point or vector conversions: TGeoManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:132488,Safety,safe,safety,132488,"oManager::GetNextMatrix(); In case the computation of the normal vector to the next crossed surface is required, using a negative stepmax value is recommended. In this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:132564,Safety,safe,safety,132564,"this case one can subsequently call a method for fast normal computation:; Double_t *TGeoManager::FindNormalFast(); TGeoManager::FindNormalFastDouble_t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert th",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:132671,Safety,safe,safety,132671,"t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:132857,Safety,safe,safe,132857,"t * FindNormalFast()Computes fast normal to next crossed boundary, assuming that the current point is close enough to the...Definition TGeoManager.cxx:2799; path 0; In case a path to a given physical object is specified, the distance to its boundary is computed ignoring the rest of the geometry; Output Values; TGeoManager::GetStep(): distance to next boundary.; TGeoManager::GetSafeDistance(): safe distance (in case it was computed).; TGeoManager::IsOnBoundary(): the initial point (x,y,z) was (or was not) on a boundary within TGeoShape::Tolerance().; The algorithm checks first if the computation of safety was required. If this is the case and the global point coordinates did not change from the last query, the last computed safety is taken. Otherwise, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:133864,Safety,safe,safe,133864,"roposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overl",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:4607,Security,access,accessed,4607,"an act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:13211,Security,access,accessed,13211,"check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selecte",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:63967,Security,access,accessible,63967," error message is issued in this case.; Specific utilities: determinant, inverse. Scale transformations (TGeoScale class) - represent a scaled shrinking/enlargement, possibly different on all axes. Data members: Double_t fScale[3]. Not implemented yet.; Combined transformations - represent a rotation followed by a translation. Data members: Double_t fTranslation[3], TGeoRotation *fRotation. TGeoRotation *rot = new TGeoRotation(""rot"",10,20,30);; TGeoTranslation trans;; ...; TGeoCombiTrans *c1 = new TGeoCombiTrans(trans,rot);; TGeoCombiTrans *c2 = new TGeoCombiTrans(""somename"",10,20,30,rot). General transformations: (TGeoHMatrix class) represent combined transformations in any order.; Identity transformation: (TGeoIdentity class) is a generic identity transformation represented by a singleton class object gGeoIdentity. Ownership of Geometry Objects; The class TGeoManager class contains the entire API needed for building and tracking geometry. It defines a global pointer gGeoManager in order to be fully accessible from external code. The manager class is the owner of all geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logica",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:66166,Security,access,access,66166," package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManage",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:67065,Security,access,accessible,67065," user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManager::GetListOfNavigatorsTGeoNavigatorArray * GetListOfNavigators() constGet list of navigators for the calling thread.Definition TGeoManager.cxx:836; TObjArrayAn array of TObjects.Definition TObjArray.h:31; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TG",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:79327,Security,access,access,79327,"orresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stack index; gGeoManager->PopPath(Int_t index);; TGeoManager::PopPointBool_t PopPoint()Definition TGeoManager.h:595; TGeoManager::PushPointInt_t PushPoint(Int_t startlevel=0)Definition TGeoManager.h:594; TGeoManager::PushPathInt_t PushPath(Int_t startlevel=0)Definition TGeoManager.h:591; ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:96510,Security,access,accessed,96510,"TVirtualGeoTrack * GetTrackOfId(Int_t id) constGet track with a given ID.Definition TGeoManager.cxx:2200; TGeoManager::GetParentTrackOfIdTVirtualGeoTrack * GetParentTrackOfId(Int_t id) constGet parent track with a given ID.Definition TGeoManager.cxx:2215; Supposing a particle represented by a primary track decays or interacts, one should not create new primaries as described before, but rather add them as secondary:; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; At any step made by the current track, one is able to add control points to either primary or secondary:; track->AddPoint(x,y,z,t);; TVirtualGeoTrack::AddPointvirtual void AddPoint(Double_t x, Double_t y, Double_t z, Double_t t)=0; After tracks were defined and filled during tracking, one will be able to browse directly the list of tracks held by the manager class. Any track can be drawn using its Draw() and Animate() methods, but there are also global methods for drawing or animation that can be accessed from TGeoManager context menu:; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; Option_tconst char Option_tDefinition RtypesCore.h:66; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGeoManager::AnimateTracksvoid AnimateTracks(Double_t tmin=0, Double_t tmax=5E-8, Int_t nframes=200, Option_t *option=""/*"")Draw animation of tracks.Definition TGeoManager.cxx:1836; TGeoManager::DrawTracksvoid DrawTracks(Option_t *option="""")Draw tracks over the geometry, according to option.Definition TGeoManager.cxx:1905; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; TGeoManager::SetTminTmaxvoid SetTminTmax(Double_t tmin=0, Double_t tmax=999)Set time cut interval for drawing tracks.Definition TGeoManager.cxx:4242; Once set, the time ran",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:98647,Security,access,accessible,98647,"ically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-"").; For animating tracks, additional options can be added:; /G:Geometry animate. Generally when drawing or animating tracks, one has to first perform a normal drawing of the geometry as convenient. The tracks will be drawn over the geometry. The geometry itself will be animated (camera moving and rotating in order to ""catch"" the majority of current track segments.); /S:Save all frames in gif format in the current folder. This option allows creating a movie based on individual frames. Checking the Geometry; Several checking methods are accessible from the context menu of volume objects or of the manager class. They generally apply only to the visible parts of the drawn geometry in order to ease geometry checking, and their implementation is in the TGeoChecker class. The checking package contains an overlap checker and several utility methods that generally have visualization outputs. The Overlap Checker; An overlap is any region in the Euclidian space being contained by more than one positioned volume. Due to the containment scheme used by the modeller, all points inside a volume have to be also contained by the mother therefore are overlapping in that sense. This category of overlaps is ignored due to the fact that any such point is treated as belonging to the deepest node in the hierarchy. Extruding volumes; A volume containment region is in fact the result of the subtraction of all daughters. On the other hand, there are two other categories of overlaps that are considered illegal since they lead to unpredictable results dur",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:106598,Security,validat,validation,106598,"n. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter() loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can the",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:113255,Security,validat,validation,113255," Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gG",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:113572,Security,access,accessible,113572,"xisting quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced Images; A ray-traced view can be clipped with any shape known by the modeller. This means that the region inside the clipping shape is subtracted from the current drawn geometry (become invisible). In order to activate clipping, one has to first define the clipping shape(s):. TGeoShape *clip1, *clip2, ... One might switch between several clipping shapes. Note that these shapes are considered defined in the current MARS. Composite shapes may be used.; gGeoManager->SetClippingShape(clip1); One can activate or deactivate clipping at any time: gGeoManager->SetClipping(flag);; Perform ray-tracing:gGeoManager->GetTopVolume()->Raytrace();. One can redo the steps 2-3 as many times as needed. Let us look how the rootgeom.C example looks clipped with a tube. Ray-tracing example with box-clipping. Representing Misalignments of the Ideal Geometry; The ideal positioning of a detector does not match its position in t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:136724,Security,access,access,136724,"olume/state. The returned node is the next crossed one, but the physical path (state) AFTER crossing the boundary is not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in ""Making a Step"", but users may implement more precise methods to insure post-step boundary crossing. Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism. Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:138370,Security,access,accessed,138370,"new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. The Geometry Manager Editor. Accessing/creating different categories of editable objects; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry objects. For this, the menu entry View/Editor of the canvas containing for instance a drawn volume must be activated. For starting the volume editor one can click on a volume. The GUI of the TGeoManager class can be started by clicking on the top-right 40x40 pixels corner of the pad with a drawn geometry.; This is the main entry point for editing the geometry or creating new objects. Once the interface is created (using one of the methods described above), several categories can be accessed via a shutter GUI widget:. General. This allows changing the name/title of the geometry, setting the top volume, closing the geometry and saving the geometry in a file. The file name is formed by geometry_name.C or .root depending if the geometry need to be saved as a C macro or a .root file.; Shapes. The category provides buttons for creation of all supported shapes. The new shape name is chosen by the interface, but can be changed from the shape editor GUI. Existing shapes can be browsed and edited from the same category.; Volumes. The category allows the creation of a new volume having a given name, shape and medium. For creating a volume assembly only the name is relevant. Existing volumes can be browsed or edited from this category.; Materials. Allows creation of new materials/mixtures or editing existing ones.; Media. The same for creation/editing of tracking media (materials having a set of properties related to tracking); Matrices. Allo",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:141969,Security,access,accessible,141969,". The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visuali",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:143905,Security,validat,validate,143905,"s changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no sha",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:143956,Security,validat,validation,143956,"settings. The radio button ""All"" allows viewing all volumes down to the selected depth. ""Leaves"" will draw only the deepest nodes that have the selected depth or lower level ones that have no daughters inside. ""Only"" will allow drawing only the edited volume. The check button ""Raytrace"" will just draw the current selection in solid mode using the ray-tracing algorithm provided by TGeo. Volume visualisation settings and division interface for volumes. Division. Allows dividing the edited volume according a given pattern. The division axes that are allowed are presented in a radio-button group. The number entries labeled ""From"", ""Step"" and ""Nslices"" correspond to the divisioning parameters on the selected axis. The range of the division is between start and start+ndiv*step values and its validity is checked upon changing one of the values. NOTE: When changing a value in a number entry by typing a number, press ENTER at the end to validate. This applies for taking into account and validation of any number change in the geometry editors. How to Create a Valid Geometry with Geometry Editors. Create a new geometry manager and start the editor as described at the beginning.; Create at least one material from the ""Materials"" shutter item category. Generally, for creating objects, the interface is always in the TGeoManagerEditor in different categories - one should just provide a name and requested parameters.; Create a shape that will be used for the top volume within the ""Shapes"" category. For the moment, the shapes that have editors are Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype, Pcon, Torus and Sphere.; Create a medium from one of the existing materials from the ""Medium"" category. You will notice that some categories as ""Volume"" and ""Medium"" are inactive at the beginning because at that time there is no material yet (for making a medium) and no shape (for making a volume). These categories are dynamically activated once all the required component",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:13113,Testability,log,logical,13113," objects. The Illegal overlaps folder is empty but can be filled after performing a geometry validity check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape t",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:18965,Testability,log,logical,18965,"ity or tracking properties of volumes can be provided both at build time or after geometry is closed, but global visualization settings (see section: ""The Drawing Package"") should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).; The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame.; After building the full geometry tree, the geometry must be closed (see the method **TGeoManager::CloseGeometry()**). Voxelization can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the **TGeoManager** class will register itself to ROOT and the logical/physical structures will become immediately browsable. The Volume Hierarchy; The basic components used for building the logical hierarchy of the geometry are the positioned volumes called nodes. Volumes are fully defined geometrical objects having a given shape and medium and possibly containing a list of nodes. Nodes represent just positioned instances of volumes inside a container volume but users do not directly create them. They are automatically created as a result of adding one volume inside other or dividing a volume. The geometrical transformation held by nodes is always defined with respect to their mother (relative positioning). Reflection matrices are allowed.; A hierarchical element is not fully defined by a node since nodes are not directly linked to each other, but through volumes (a node points to a volume, which at its turn points to a list of nodes):; NodeTop VolTop NodeA VolA ...; One can therefore talk about ""the node or volume h",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:19093,Testability,log,logical,19093," Package"") should not be provided at build time, otherwise the drawing package will be loaded. There is also a list of specific rules:. Positioned volumes should not extrude their container or intersect with others within this unless it is specified (see section: Overlapping Volumes).; The top volume (containing all geometry trees) must be specified before closing the geometry and must not be positioned - it represents the global reference frame.; After building the full geometry tree, the geometry must be closed (see the method **TGeoManager::CloseGeometry()**). Voxelization can be redone per volume after this process. The list is much bigger and we will describe in more detail the geometry creation procedure in the following sections. Provided that geometry was successfully built and closed, the **TGeoManager** class will register itself to ROOT and the logical/physical structures will become immediately browsable. The Volume Hierarchy; The basic components used for building the logical hierarchy of the geometry are the positioned volumes called nodes. Volumes are fully defined geometrical objects having a given shape and medium and possibly containing a list of nodes. Nodes represent just positioned instances of volumes inside a container volume but users do not directly create them. They are automatically created as a result of adding one volume inside other or dividing a volume. The geometrical transformation held by nodes is always defined with respect to their mother (relative positioning). Reflection matrices are allowed.; A hierarchical element is not fully defined by a node since nodes are not directly linked to each other, but through volumes (a node points to a volume, which at its turn points to a list of nodes):; NodeTop VolTop NodeA VolA ...; One can therefore talk about ""the node or volume hierarchy"", but in fact, an element is made by a pair volume-node. In the line above is represented just a single branch, but of course from any volume other branc",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:20719,Testability,log,logical,20719,"r, but through volumes (a node points to a volume, which at its turn points to a list of nodes):; NodeTop VolTop NodeA VolA ...; One can therefore talk about ""the node or volume hierarchy"", but in fact, an element is made by a pair volume-node. In the line above is represented just a single branch, but of course from any volume other branches can also emerge. The index of a node in such a branch (counting only nodes) is called depth. The top node have always depth=0.; Volumes need to have their daughter nodes defined when the geometry is closed. They will build additional structures (called voxels ) in order to fasten-up the search algorithms. Finally, nodes can be regarded as bi-directional links between containers and contained volumes.; The structure defined in this way is a graph structure since volumes are replicable (same volume can become daughter node of several other volumes), every volume becoming a branch in this graph. Any volume in the logical graph can become the actual top volume at run time (see TGeoManager::SetTopVolume()). All functionalities of the modeller will behave in this case as if only the corresponding branch starting from this volume is the active geometry. A geometry hierarchy in memory; Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ... , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/.../A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transfor",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:21802,Testability,log,logical,21802,"unctionalities of the modeller will behave in this case as if only the corresponding branch starting from this volume is the active geometry. A geometry hierarchy in memory; Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ... , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/.../A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call logical graph the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique ""touchable"" objects. We will call this the ""physical tree"". Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID's that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact tha",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:21881,Testability,log,logical,21881,"this volume is the active geometry. A geometry hierarchy in memory; Nodes are never instantiated directly by users, but created as a result of volume operations. Adding a volume named A with a given user id inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ... , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/.../A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call logical graph the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique ""touchable"" objects. We will call this the ""physical tree"". Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID's that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node; therefore the location of a point in the geometry ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:22040,Testability,log,logical,22040,"inside a volume B will create a node named A_id. This will be added to the list of nodes stored by B. In addition, when applying a division operation in N slices to a volume A, a list of nodes B_1, B_2, ... , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/.../A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call logical graph the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique ""touchable"" objects. We will call this the ""physical tree"". Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID's that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node; therefore the location of a point in the geometry can be saved as a starting state for later use.; Nodes can be declared as overlapping in case they do overlap with other nodes inside the same container or extrude this container (see also ‘Checking the Geom",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:22245,Testability,log,logical,22245,"2, ... , B_N is also created. A node B_i does not represent a unique object in the geometry because its container A might be at its turn positioned as node inside several other volumes. Only when a complete branch of nodes is fully defined up to the top node in the geometry, a given path:/TOP_1/.../A_3/B_7 will represent a unique object. Its global transformation matrix can be computed as the pile-up of all local transformations in its branch. We will therefore call logical graph the hierarchy defined by nodes and volumes. The expansion of the logical graph by all possible paths defines a tree structure where all nodes are unique ""touchable"" objects. We will call this the ""physical tree"". Unlike the logical graph, the physical tree can become a huge structure with several millions of nodes in case of complex geometries; therefore, it is not always a good idea to keep it transient in memory. Since the logical and physical structures are correlated, the modeller rather keeps track only of the current branch, updating the current global matrix at each change of the level in geometry. The current physical node is not an object that can be asked for at a given moment, but rather represented by the combination: current node/current global matrix. However, physical nodes have unique ID's that can be retrieved for a given modeller state. These can be fed back to the modeller in order to force a physical node to become current. The advantage of this comes from the fact that all navigation queries check first the current node; therefore the location of a point in the geometry can be saved as a starting state for later use.; Nodes can be declared as overlapping in case they do overlap with other nodes inside the same container or extrude this container (see also ‘Checking the Geometry'). Non-overlapping nodes can be created with:; TGeoVolume::AddNode(TGeoVolume *daughter,Int_t copy_No,; TGeoMatrix *matr);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoMatrixGeometrical transfo",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:31054,Testability,log,logical,31054,"me rules for building a valid geometry. The daughter volume(s) must not extrude the mother shape. They are allowed however to have a common boundaries.; The volumes positioned in the same container must not overlap with each other. They may touch on one boundaries or shape vertex. The daughter nodes of a volume can be also removed or replaced with other nodes:; void RemoveNode(TGeoNode* node); TGeoNode*ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0,; TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); TGeoNodeA node represent a volume positioned inside another.They store links to both volumes and to the TGeoM...Definition TGeoNode.h:39; TGeoShapeBase abstract class for all shapes.Definition TGeoShape.h:25; The last method allows replacing an existing daughter of a volume with another one. Providing only the node to be replaced will just create a new volume for the node but having exactly the same parameters as the old one. This helps in case of divisions for decoupling a node from the logical hierarchy so getting new content/properties. For non-divided volumes, one can change the shape and/or the position of the daughter.; Virtual Containers and Assemblies of Volumes; Virtual containers are volumes that do not represent real objects, but they are needed for grouping and positioning together other volumes. Such grouping helps not only geometry creation, but also optimizes tracking performance; therefore, it is highly recommended. Virtual volumes need to inherit material/medium properties from the volume they are placed into in order to be ""invisible"" at tracking time.; Let us suppose that we need to group together two volumes A and B into a structure and position this into several other volumes D,E, and F. What we need to do is to create a virtual container volume C holding A and B, then position C in the other volumes.; Note that C is a volume having a determined medium. Since it is not a real volume, we need to manually set its medium the same as that of D,E ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:34579,Testability,test,test,34579,"d transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ""unnecessary"" volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; TGeoManager::RestoreMasterVolumevoid RestoreMasterVolume()Restore the master volume of the geometry.Definition TGeoManager.cxx:3118; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t *option="""")Check time of finding ""Where am I"" for n points.Definition TGeoManager.cxx:1942; The ptr_D is a pointer to volume D containing the interesting structure. The test will provide the timing for classifying 1 million random points inside D.; Examples of Volume Positioning; Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm:; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; TGeoTubeDefinition TGeoTube.h:17; One may omit the name for the shape wire_tube, if no retrieving by name is further needed during geometry building. Different volumes having different names and materials can share the same shape.; Now let's make the volume for our wire:; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,ptrCOPPER); //(*); (*) Do not bother to delete the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would have been able to create our wire with a single l",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:64945,Testability,log,logical,64945," tracking geometry. It defines a global pointer gGeoManager in order to be fully accessible from external code. The manager class is the owner of all geometry objects defined in a session; therefore, users must not try to control their deletion. It contains lists of media, materials, transformations, shapes and volumes. A special case is the one of geometrical transformations. When creating a matrix or a translation, this is by default owned by external objects. The manager class becomes owner of all transformations used for positioning volumes. In order to force the ownership for other transformations, one can use TGeoMatrix::RegisterYourself() method. Do not be therefore surprised that some transformations cannot be found by name when creating a composite shape for instance if you did not register them after creation.; Logical nodes (positioned volumes) are created and destroyed by the TGeoVolume class. Physical nodes and their global transformations are subjected to a caching mechanism due to the sometimes very large memory requirements of logical graph expansion. The total number of physical instances of volumes triggers the caching mechanism and the cache manager is a client of TGeoManager. The manager class also controls the drawing/checking package (TGeoPainter client). This is linked with ROOT graphical libraries loaded on demand in order to control visualization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the curr",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:68554,Testability,test,testing,68554,"nav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; TGeoManager::AddNavigatorTGeoNavigator * AddNavigator()Add a navigator in the list of navigators.Definition TGeoManager.cxx:789; TGeoManager::SetCurrentNavigatorBool_t SetCurrentNavigator(Int_t index)Switch to another existing navigator for the calling thread.Definition TGeoManager.cxx:849; TGeoNavigatorClass providing navigation API for TGeo geometries.Definition TGeoNavigator.h:32; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator. Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by the navigator class. This array of the three coordinates is defined in the current global reference system and can be retrieved any time:; Const Double_t *cpoint = gGeoManager->GetCurrentPoint();; TGeoManager::GetCurrentPointconst Double_t * GetCurrentPoint() constDefinition TGeoManager.h:501; Initializing this point can be done like:; gGeoManager->SetCurrentPoint(x,y,z);; // or:; gGeoManager->SetCurrentPoint(Double_t *point[3]);; TGeoManager::SetCurrentPointvoid SetCurrentPoint(Double_t *point)Definition TGeoManager.h:515. Initiali",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:74835,Testability,test,test,74835,"de0/node1/...Definition TGeoManager.cxx:2881. The current node, volume and material. In order to take decisions on post-step or further stepping actions, one has to know these. In order to get a pointer to the current node one can do:. TGeoNode *cnode = gGeoManager->GetCurrentNode();; // then:; TGeoVolume *cvol = gGeoManager->GetCurrentVolume();; // or:; cvol = cnode->GetVolume(); // (*); // then:; TGeoMaterial *cmat = cvol->GetMedium()->GetMaterial();; TGeoManager::GetCurrentVolumeTGeoVolume * GetCurrentVolume() constDefinition TGeoManager.h:503; TGeoMedium::GetMaterialTGeoMaterial * GetMaterial() constDefinition TGeoMedium.h:49; TGeoNode::GetVolumeTGeoVolume * GetVolume() constDefinition TGeoNode.h:99; TGeoVolume::GetMediumTGeoMedium * GetMedium() constDefinition TGeoVolume.h:175; (*) Note: If the current point is in fact outside the geometry, the current node pointer will not be NULL, but pointing to the top node.; In order to take decisions in such case one needs always to test:; if (gGeoManager->IsOutside()) {; // current point is actually outside; ... // corresponding action; }; TGeoManager::IsOutsideBool_t IsOutside() constDefinition TGeoManager.h:406; Specific information related to the current volume/node like ID's or shape can be then retrieved from the corresponding objects. Current state index. The number of possible different states of the modeller corresponds to the number of different objects/paths in the geometry. This has nothing to do with the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the expanded geometry tree. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is bui",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:75545,Testability,log,logical,75545,"edium() constDefinition TGeoVolume.h:175; (*) Note: If the current point is in fact outside the geometry, the current node pointer will not be NULL, but pointing to the top node.; In order to take decisions in such case one needs always to test:; if (gGeoManager->IsOutside()) {; // current point is actually outside; ... // corresponding action; }; TGeoManager::IsOutsideBool_t IsOutside() constDefinition TGeoManager.h:406; Specific information related to the current volume/node like ID's or shape can be then retrieved from the corresponding objects. Current state index. The number of possible different states of the modeller corresponds to the number of different objects/paths in the geometry. This has nothing to do with the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the expanded geometry tree. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get au",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:76314,Testability,log,logical,76314," the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the expanded geometry tree. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the curre",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:76405,Testability,log,logical,76405,"rom logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoManager.cxx:1655; ptTPaveText * ptDefinition entrylist_figure",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:76752,Testability,log,logical,76752,"cture storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gGeoManager->CdNode(istate); // forces state's re-initialization; TGeoManager::GetCurrentNodeIdInt_t GetCurrentNodeId() constGet the unique ID of the current node.Definition TGeoManager.cxx:1663; TGeoManager::CdNodevoid CdNode(Int_t nodeid)Change current path to point to the node having this id.Definition TGeoManager.cxx:1655; ptTPaveText * ptDefinition entrylist_figure1.C:7. Current global transformation. This represents the transformation from MARS to the local reference of the current node, being the product of all local mother-daughter transformations in the branch. The global transformation can be referenced or copied:. co",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:117620,Testability,log,logical,117620,"n object and replaces it with a more meaningful name. In addition, TGeoPNEntry objects are faster to search by name and they may optionally store an additional user matrix.; // Creating a symlink object.; TGeoPNEntry *TGeoManager::SetAlignableEntry(const char *unique_n,; const char*path); // Retrieving an existing alignable object.; TGeoPNEntry *TGeoManager::GetAlignableEntry(const char *name); // Retrieving an existing alignable object at a given index.; TGeoPNEntry *GetAlignableEntry(Int_t index); TGeoManager::GetAlignableEntryTGeoPNEntry * GetAlignableEntry(const char *name) constRetrieves an existing alignable object.Definition TGeoManager.cxx:3370; TGeoManager::SetAlignableEntryTGeoPNEntry * SetAlignableEntry(const char *unique_name, const char *path, Int_t uid=-1)Creates an alignable object with unique name corresponding to a path and adds it to the list of align...Definition TGeoManager.cxx:3342; Physical nodes store internally the full list of logical nodes corresponding to the elements from the string path, as well as the global transformation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:118599,Testability,log,logical,118599,"s store internally the full list of logical nodes corresponding to the elements from the string path, as well as the global transformation matrix for each of them. The top node corresponds to the level 0 in the stored array, while the last node will correspond to level n. For each level, the node, volume and global matrix can be retrieved using corresponding getters:; TGeoHMatrix *GetMatrix(Int_t level=-1) const; TGeoNode *GetNode(Int_t level=-1) const; TGeoShape *GetShape(Int_t level=-1) const; TGeoVolume *GetVolume(Int_t level=-1) const; By default the object at level n is retrieved (the align-able object).; Once created, a physical node can be misaligned, meaning that its positioning matrix or even the shape.:; void Align(TGeoMatrix* newmat=0, TGeoShape* newshape=0,; Bool_t check=kFALSE); The convention used is that newmat represents the new local matrix of the last node in the branch with respect to its mother volume. The Align() method will actually duplicate the corresponding branch within the logical hierarchy, creating new volumes and nodes. This is mandatory in order to avoid problems due to replicated volumes and can create exhaustive memory consumption if used abusively.; Once aligned, a physical node is ready to be tracked. The operation can be done only after the geometry was closed.; Important NOTE: Calling the Align() method for a physical node changes the node pointers for the stored node branch in the active geometry, Due to this the other defined physical nodes containing elements of this path will be invalid. Example:; TGeoPhysicalNode *pn1 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_2"");; TGeoPhysicalNode *pn2 =; gGeoManager->MakePhysicalNode(""/A_1/B_1/C_3"");; ...; pn1->Align(...);; TGeoManager::MakePhysicalNodeTGeoPhysicalNode * MakePhysicalNode(const char *path=nullptr)Makes a physical node corresponding to a path.Definition TGeoManager.cxx:3506; TGeoPhysicalNode::AlignBool_t Align(TGeoMatrix *newmat=nullptr, TGeoShape *newshape=nullptr, Bool_",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:128413,Testability,log,logical,128413,"epest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is declared as non-overlapping (these are anyway searched first); Has at least one daughter that contains the current point; Was already declared as containing the point at a previous step. Finding the location of a point in the geometry hierarchy. Finding the Distance to Next Crosse",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:3841,Usability,simpl,simplest,3841,"p between the pieces is not defined by neighbors, but by ""containment"". In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the ""world"" of the model. We will often call this ""master reference system (MARS)"". Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong... We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume n",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:4683,Usability,simpl,simplest,4683,"an act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:7056,Usability,simpl,simple,7056,"oVolume.h:43; The default units are in centimeters. Now we want to make this volume our world. We have to do this operation before closing the geometry.; root[] gGeoManager->SetTopVolume(top);; TGeoManager::SetTopVolumevoid SetTopVolume(TGeoVolume *vol)Set the top volume and corresponding node as starting point of the geometry.Definition TGeoManager.cxx:3655; This should be enough, but it is not since always after defining some geometry hierarchy, TGeo needs to build some optimization structures and perform some checks. Note the messages posted after the statement is executed. We will describe the corresponding operations later.; root[] gGeoManager->CloseGeometry();; TGeoManager::CloseGeometryvoid CloseGeometry(Option_t *option=""d"")Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:7842,Usability,learn,learn,7842,"fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?""; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on ""containment"". This is accomplished by ""positioning"" some volumes ""inside"" others. Any volume is an un-positioned object in the sense that it defines only a ""local frame"" (matching the one of its ""shape""). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a ""local geometrical ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:9457,Usability,simpl,simple,9457,"This is accomplished by ""positioning"" some volumes ""inside"" others. Any volume is an un-positioned object in the sense that it defines only a ""local frame"" (matching the one of its ""shape""). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a ""local geometrical transformation"" of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: ""I see the lines defining the top level volume as in the previous example,; but what about the other volumes named REPLICA and ROOT?""; A: You will also notice that several other volumes are created by using lines like:; TGeoVolume *someVolume = gGeoManager->MakeXXX(""someName"",; ptrMedium, /* parameters coresponding to XXX ...*/); In the method above XXX represent some shape name (Box, Tube, etc.). This is just a simple way of creating a volume having a given shape in one-step (see also section: ""Creating and Positioning; Volumes""). As for REPLICA and ROOT volumes, they are just some ""virtual volumes"" used for grouping and positioning together other ""real volumes"". See ""Positioned Volumes (Nodes)"". The same structure represented by (a real or) a virtual volume can be ""replicated"" several times in the geometry.; Q: ""Fine, so probably the real volumes are the ones composing the letters R,; O and T. Why one have to define so many volumes to make an R?""; A: Well, in real life some objects have much more complex shapes that an ""R"". The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called ""primitive shapes""). Gluing these together in the appropriate way is the user responsibility.; Q: ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand.""; A: A volume is positioned inside",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:10988,Usability,simpl,simple,10988,"rs R,; O and T. Why one have to define so many volumes to make an R?""; A: Well, in real life some objects have much more complex shapes that an ""R"". The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called ""primitive shapes""). Gluing these together in the appropriate way is the user responsibility.; Q: ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand.""; A: A volume is positioned inside another one by using this method. The relative geometrical transformation as well as a copy number must be specified. When positioned, a volume becomes a ""node"" of its container and a new object of the class TGeoNode is automatically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw() call for the top volume. These are explained in details in the section ""Visualization Settings and Attributes"". At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.De",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:34709,Usability,simpl,simple,34709,"and it is not. Of course, we managed to get rid of the ""unnecessary"" volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; TGeoManager::RestoreMasterVolumevoid RestoreMasterVolume()Restore the master volume of the geometry.Definition TGeoManager.cxx:3118; TGeoManager::Testvoid Test(Int_t npoints=1000000, Option_t *option="""")Check time of finding ""Where am I"" for n points.Definition TGeoManager.cxx:1942; The ptr_D is a pointer to volume D containing the interesting structure. The test will provide the timing for classifying 1 million random points inside D.; Examples of Volume Positioning; Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm:; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; TGeoTubeDefinition TGeoTube.h:17; One may omit the name for the shape wire_tube, if no retrieving by name is further needed during geometry building. Different volumes having different names and materials can share the same shape.; Now let's make the volume for our wire:; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,ptrCOPPER); //(*); (*) Do not bother to delete the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would have been able to create our wire with a single line:; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,0,0.01,1); //(*); ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:36763,Usability,simpl,simplicity,36763,"beTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; (*) The same applies for all primitive shapes, for which there can be found corresponding MakeSHAPE() methods. Their usage is much more convenient unless a shape has to be shared between more volumes.; Let us make now an aluminum wire having the same shape, supposing that we have created the copper wire with the line above:; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"",wire_co>GetShape(),; ptrAL);; We would like now to position our wire in the middle of a gas chamber. We need first to define the gas chamber:; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"",ptrGAS,; 0,1,1);; Now we can put the wire inside:; chamber->AddNode(wire_co,1);; If we inspect now the chamber volume in a browser, we will notice that it has one daughter. Of course, the gas has some container also, but let us keeps it like that for the sake of simplicity. Since we did not supply the third argument, the wire will be positioned with an identity transformation inside the chamber.; Overlapping Volumes; Positioning volumes that does not overlap their neighbors nor extrude their container is sometimes quite strong constraint. Having a limited set of geometric shapes might force sometimes overlaps. Since overlapping is contradictory to containment, a point belonging to an overlapping region will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to de",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:37632,Usability,simpl,simple,37632,"hat it has one daughter. Of course, the gas has some container also, but let us keeps it like that for the sake of simplicity. Since we did not supply the third argument, the wire will be positioned with an identity transformation inside the chamber.; Overlapping Volumes; Positioning volumes that does not overlap their neighbors nor extrude their container is sometimes quite strong constraint. Having a limited set of geometric shapes might force sometimes overlaps. Since overlapping is contradictory to containment, a point belonging to an overlapping region will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:41866,Usability,simpl,simple,41866,"nes that we have already created.; chamber->AddNode(wire_co,1,new TGeoTranslation(0.2,0,0));; chamber->AddNode(wire_co,2,new TGeoTranslation(0.2,0,0));; TGeoTranslationClass describing translations.Definition TGeoMatrix.h:116; The 2 nodes that we have created inside chamber will both point to a wire_co object, but will be completely distinct: WIRE_CO_1 and WIRE_CO_2. We will want now to place symmetrically 1000 chambers on a pad, following a pattern of 20 rows and 50 columns. One way to do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It rep",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:42439,Usability,simpl,simple,42439," do this will be to replicate our chamber by positioning it 1000 times in different positions of the pad. Unfortunately, this is far from being the optimal way of doing what we want. Imagine that we would like to find out which of the 1000 chambers is containing a (x,y,z) point defined in the pad reference. You will never have to do that, since the modeller will take care of it for you, but let's guess what it has to do. The most simple algorithm will just loop over all daughters, convert the point from mother to local reference and check if the current chamber contains the point or not. This might be efficient for pads with few chambers, but definitely not for 1000. Fortunately the modeller is smarter than that and creates for each volume some optimization structures called voxels to minimize the penalty having too many daughters, but if you have 100 pads like this in your geometry you will anyway lose a lot in your tracking performance. The way out when volumes can be arranged according to simple patterns is the usage of divisions. We will describe them in detail later on. Let's think now at a different situation: instead of 1000 chambers of the same type, we may have several types of chambers. Let's say all chambers are cylindrical and have a wire inside, but their dimensions are different. However, we would like all to be represented by a single volume family, since they have the same properties.; Volume Families; A volume family is represented by the class TGeoVolumeMulti. It represents a class of volumes having the same shape type and each member will be identified by the same name and volume ID. Any operation applied to a TGeoVolumeMulti equally affects all volumes in that family. The creation of a family is generally not a user task, but can be forced in particular cases:; TGeoManager::Volume(const char *vname,const char *shape, Int_t nmed);; Where: vname is the family name, nmed is the medium number and shape is the shape type that can be:. box for TGeoBBox;",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:45833,Usability,simpl,simplest,45833,"s. Another particular case where volume families are used is when we want that a volume positioned inside a container to match one ore more container limits. Suppose we want to position the same box inside 2 different volumes and we want the Z size to match the one of each container:; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the **TGeoVolumeMulti** class, which does not need to be instantiated by users.; Dividing Volumes; Volumes can be divided according a pattern. The simplest division can be done along one axis that can be: X,Y,Z,Phi,Rxy or Rxyz. Let's take a simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; N#define N; TGeoVolume::Dividevirtual TGeoVolume * Divide(const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Division a la G3.Definition TGeoVolume.cxx:1103; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; Here SLICEX is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means ph",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:45927,Usability,simpl,simple,45927," container to match one ore more container limits. Suppose we want to position the same box inside 2 different volumes and we want the Z size to match the one of each container:; TGeoVolume *container1 = gGeoManager->MakeBox(""C1"",imed,10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"",imed,10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"",jmed,3,3,-1);; container1->AddNode(pvol,1);; container2->AddNode(pvol,1);; Note that the third parameter of PVOL is negative, which does not make sense as half-length on Z. This is interpreted as: when positioned, create a box replacing all invalid parameters with the corresponding dimensions of the container. This is also internally handled by the **TGeoVolumeMulti** class, which does not need to be instantiated by users.; Dividing Volumes; Volumes can be divided according a pattern. The simplest division can be done along one axis that can be: X,Y,Z,Phi,Rxy or Rxyz. Let's take a simple case: we would like to divide a box in N equal slices along X coordinate, representing a new volume family. Supposing we already have created the initial box, this can be done like:; TGeoVolume *slicex = box->Divide(""SLICEX"",1,N);; N#define N; TGeoVolume::Dividevirtual TGeoVolume * Divide(const char *divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")Division a la G3.Definition TGeoVolume.cxx:1103; boxvoid box(Int_t pat, Double_t x1, Double_t y1, Double_t x2, Double_t y2)Definition fillpatterns.C:1; Here SLICEX is the name of the new family representing all slices and 1 is the slicing axis. The meaning of the axis index is the following: for all volumes having shapes like box, trd1, trd2, trap, gtraorpara -1, 2, 3 mean X, Y, Z; for tube, tubs, cone, cons -1 means Rxy, 2 means phi and 3 means Z; for pcon and pgon - 2 means phi and 3 means Z; for spheres 1 means Rand 2 means phi.; In fact, the division operation has the same effect as positioning volumes in a given order inside the",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:50516,Usability,simpl,simply,50516,"ivide(N,Xmin,Xmax,""X"");; Create a new volume by dividing an existing one (GEANT3 like).; Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER).; The behavior of the division operation can be triggered using OPTION (case insensitive):. Ndivide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NXdivide range starting with START in NDIV cells (GSDVN2 in G3); Sdivide all range with given STEP; NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SXsame as DVS, but from START position (GSDVS2, GSDVT2 in G3). Volume Assemblies; In general, geometry contains structures of positioned volumes that have to be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:53130,Usability,simpl,simple,53130,"ment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = new TGeoVolumeAssembly(name);; vol->AddNode(vdaughter1, cpy1, matrix1);; vol->AddNode(vdaughter2, cpy2, matrix2);; namechar name[80]Definition TGX11.cxx:110; TGeoVolumeAssemblyVolume assemblies.Definition TGeoVolume.h:316; Note that components cannot be declared as ""overlapping"" and that a component can be an assembly volume. For existing flat volume structures, one can define assemblies to force a hierarchical structure therefore optimizing the performance. Usage of assemblies does NOT imply penalties in performance, but in some cases, it can be observed that it is not as performing as bounding the structure in a container volume with a simple shape. Choosing a normal container is therefore recommended whenever possible. Assemblies of volumes. Geometrical Transformations; All geometrical transformations handled by the modeller are provided as a built-in package. This was designed to minimize memory requirements and optimize performance of point/vector master-to-local and local-to-master computation. We need to have in mind that a transformation in **TGeo** has two major use-cases. The first one is for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given o",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:54657,Usability,simpl,simple,54657,"for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \]. Scale:. \[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \]. Inverse scale:. \[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:66241,Usability,simpl,simple,66241,"ization actions. Navigation and Tracking; Tracking is the feature allowing the transport of a given particle knowing its kinematics. A state is determined by any combination of the position \(\vec{r}\) and direction \(\vec{n}\) with respect to the world reference frame. The direction \(\vec{n}\) must be a unit vector having as components the director cosines. The full classification of a given state will provide the following information: the deepest physical node containing the position vector, the distance to the closest boundary along the direction vector, the next physical node after propagating the current point with this distance and the safety distance to the nearest boundary. This information allows the propagation of particles inside a detector geometry by taking into account both geometrical and physical constraints.; We will hereby describe the user interface of TGeo to access tracking functionality. This allows either developing a tracker for simple navigation within a given geometry, either interfacing to an external tracking engine such as GEANT. Note that the abstract interface for external trackers can be found in $ROOTSYS/vmc folder and it can be used to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that. TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; TGeoManager::GetListOfNavigatorsTGeoNavigatorArray * GetListOfNavigators() constGet list of navigators for the calling thread.Def",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:70688,Usability,simpl,simple,70688,"ent direction (nx,ny,nz). This direction is stored as Double_t fCurrentDirection[3] by the navigator and it represents a direction in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518. Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoNavigator::fCurrentNode and can be asked from the manager class only after the ‘'Where am I?’` was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘‘Where am I?’` method:; gGe",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:70834,Usability,simpl,simple,70834,"n in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518. Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoNavigator::fCurrentNode and can be asked from the manager class only after the ‘'Where am I?’` was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘‘Where am I?’` method:; gGeoManager->FindNode();; TGeoManager::FindNodeTGeoNode * FindNode(Bool_t safe_start=kTRUE)Returns deepest node containing current p",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:76138,Usability,simpl,simple,76138," The number of possible different states of the modeller corresponds to the number of different objects/paths in the geometry. This has nothing to do with the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the expanded geometry tree. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gG",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:76173,Usability,simpl,simple,76173," The number of possible different states of the modeller corresponds to the number of different objects/paths in the geometry. This has nothing to do with the number of nodes, since the same node can be found on different branches. In other words, the number of states corresponds to the number of nodes in the expanded geometry tree. Since unfortunately this expansion from logical to physical hierarchy cannot be stored on regular basis due to the large size of the latter, one cannot directly assign state numbers. If the size of the expansion proves however to be small enough (less than about 50 million objects), a parallel structure storing these state indices is built and stored in memory. In such case each state automatically gets an index that can be retrieved after any state initialization. These indices can prove to be quite useful for being able to keep track of the navigation history and force certain states. Let's illustrate how this works with a simple example:; Suppose we have a simple geometry with a volume B positioned twice inside a container A. Then A is positioned twice in a top container T. The complete list of logical nodes is: T_1, A_1, A_2, B_1, B_2. On the other hand we will have more states than logical nodes:; /T_1- 1 state at level = 0; /T_1/A_1,/T_1/A_2- 2 states at level = 1; /T_1/A_1/B_1,/T_1/A_1/B_2,/T_1/A_2/B_1,/T_1/A_2/B_2 - 4 states at level = 2; All these states will get automatic numbers, starting with 0 corresponding to the top-level state and ending with an integer corresponding to Ntotal_states-1. The mapping from a given logical node to a state number is generally not possible, as for the node B_1 that appears as current node for 2 different states. The numbering order of states is therefore not important, but it can be used as in the following lines:. gGeoManager->InitTrack(pt,dir); // anything to initialize a state; Int_t istate = gGeoManager->GetCurrentNodeId(); // in fact state Id; {; //... code changing the current state; }; gG",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:107278,Usability,simpl,simple,107278,"t is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes. Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; TGeoManager::GetMasterVolumeTGeoVolume * GetMasterVolume() constDefinition TGeoManager.h:511; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: ""The picture is strangely rotated; where are the coordinate axes?""; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the **TView** context menu: right-click on the picture when no object is selected;. Q: ""Every line is black! I cannot figure out what is what...""; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: ""The top volume of my geometry is a box but I ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:112599,Usability,simpl,simple,112599,"he screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced ",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:134587,Usability,simpl,simple,134587," the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overlapping with something else. If this is the case, the distance is computed for all possibly overlapping candidates, taking into account the overlapping priorities (see also: "" Overlapping volumes "").; The global matrix describing the next crossed physical node is systematically computed in case the value of the proposed step is negative. In this case, one can subsequently call TGeoManager::ComputeNormalFast() to get the normal vector to the crossed surface, after propagating the current point with the TGeoManager::GetStep() value. This propagation can be done like:; Double_t *current_point = gGeoManager->GetCurrentPoint();; Double_t *current_dir = gGeoManager->GetCurrentDirection();; for (Int_t i=0; i<3; i++); current_point[i] += step * current_dir[I];; I#define I(x, y, z); Note: The method T",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:141323,Usability,undo,undoable,141323,"ect editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together. Editors for shapes, materials, media, matrices; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the ""Apply"" button only if the check button ""Delayed draw"" is checked, otherwise the changes are immediately applied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components b",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry.html:141881,Usability,undo,undoable,141881,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allow",MatchSource.WIKI,doc/master/group__Geometry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry.html
https://root.cern/doc/master/group__Geometry__classes.html:2835,Integrability,wrap,wrapper,2835,"re...;  ; class  TGeoGlobalMagField;  Global magnetic field manager. More...;  ; class  TGeoHMatrix;  Matrix class used for computing global transformations Should NOT be used for node definition. More...;  ; class  TGeoIdentity;  An identity transformation. More...;  ; class  TGeoIterator;  A geometry iterator. More...;  ; class  TGeoIteratorPlugin;  ; class  TGeoManager;  The manager class for any TGeo geometry. More...;  ; class  TGeoMatrix;  Geometrical transformation package. More...;  ; class  TGeoNavigator;  Class providing navigation API for TGeo geometries. More...;  ; class  TGeoNode;  A node represent a volume positioned inside another.They store links to both volumes and to the TGeoMatrix representing the relative positioning. More...;  ; class  TGeoNodeCache;  Special pool of reusable nodes. More...;  ; class  TGeoNodeMatrix;  A node containing local transformation. More...;  ; class  TGeoNodeOffset;  Node containing an offset. More...;  ; class  TGeoOpticalSurface;  This is a wrapper class to G4OpticalSurface. More...;  ; class  TGeoParallelWorld;  Base class for a flat parallel geometry. More...;  ; class  TGeoPatternFinder;  Base finder class for patterns. More...;  ; class  TGeoPhysicalNode;  Physical nodes are the actual 'touchable' objects in the geometry, representing a path of positioned volumes starting with the top node: path=/TOP/A_1/B_4/C_3 , where A, B, C represent names of volumes. More...;  ; class  TGeoPNEntry;  The knowledge of the path to the objects that need to be misaligned is essential since there is no other way of identifying them. More...;  ; class  TGeoRCExtension;  Reference counted extension which has a pointer to and owns a user defined TObject. More...;  ; class  TGeoRCPtr< T >;  A reference counting-managed pointer for classes derived from TGeoExtension which can be used as C pointer. More...;  ; class  TGeoRegion;  Regions are groups of volumes having a common set of user tracking cuts. More...;  ; class  TGeoRotation;  Cl",MatchSource.WIKI,doc/master/group__Geometry__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__classes.html
https://root.cern/doc/master/group__Geometry__classes.html:983,Performance,cache,cache,983,". ROOT: Geometry classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Geometry classesThe Geometry Package. ; The Geometry related classes. ; Several documents describing these classes are listed below:. The main geometry class is documented in class TGeoManager.; Presentation/article at CHEP'03; Presentation at ROOT 2004; Presentation at ROOT 2005; Presentation at ROOT 2007. See also the use of the geometry classes in AliROOT package of ALICE. . Classes; class  TGeoAtt;  Visualization and tracking attributes for volumes and nodes. More...;  ; class  TGeoBoolNode;  Base class for Boolean operations between two shapes. More...;  ; class  TGeoBranchArray;  An array of daughter indices making a geometry path. More...;  ; class  TGeoBuilder;  Utility class for creating geometry objects.These will be associated with the current selected geometry manager object: More...;  ; class  TGeoCacheState;  Class storing the state of the cache at a given moment. More...;  ; class  TGeoCombiTrans;  Class describing rotation + translation. More...;  ; class  TGeoDecayChannel;  A decay channel for a radionuclide. More...;  ; class  TGeoElementRN;  Class representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRootUnits ) { return; } else if ( gGeometryLocked ) { TError::Fatal(""TGeoManager"",""The system of units may only be changed once BEFORE any elements and materials are; created!""); } fgDefaultUnits = kRootUnits; }. More...;  ; class  TGeoElementTable;  Table of elements. More...;  ; class  TGeoElemIter;  Iterator for decay branches. More...;  ; class  TGeoExtension;  ABC for user objects attached to TGeoVolume or TGeoNode. More...;  ; class  TGeoGenTrans;  Most general transformation, holding a translation, a rotation and a scale. More...;  ; class  TGeoGlobalMagField;  Global magnetic field manager. More...;  ; class  TGeoHMatrix;  Matrix class used for computing global transformations Should NOT be ",MatchSource.WIKI,doc/master/group__Geometry__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__classes.html
https://root.cern/doc/master/group__Geometry__gdml.html:524,Deployability,integrat,integrated,524,". ROOT: GDML tools. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; GDML toolsThe Geometry Package. ; GDML tools for geometry classes. ; The $ROOTSYS/gdml directory contains a set of Python modules designed for writing out Geometry Description Markup Language (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManag",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:549,Deployability,install,installation,549,". ROOT: GDML tools. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; GDML toolsThe Geometry Package. ; GDML tools for geometry classes. ; The $ROOTSYS/gdml directory contains a set of Python modules designed for writing out Geometry Description Markup Language (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManag",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:640,Deployability,install,installation,640,". ROOT: GDML tools. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; GDML toolsThe Geometry Package. ; GDML tools for geometry classes. ; The $ROOTSYS/gdml directory contains a set of Python modules designed for writing out Geometry Description Markup Language (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManag",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:524,Integrability,integrat,integrated,524,". ROOT: GDML tools. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; GDML toolsThe Geometry Package. ; GDML tools for geometry classes. ; The $ROOTSYS/gdml directory contains a set of Python modules designed for writing out Geometry Description Markup Language (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManag",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:3027,Integrability,interface,interfaced,3027,"GeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geometry trees) as GDML files. The writer module writes a GDML file out of the 'in-memory' representation of the geometry. The actual application-specific (ROOT) binding is implemented in ROOTwriter module. It contains 'binding methods' for TGeo geometry classes which can be exported in GDML format. Please refere to the comment part of the ROOTwriter.py file for the list of presently supported TGeo classes. The ROOTwriter class contains also three methods, dumpMaterials, dumpSolids and examineVol which need to be called in order to export materials, solids and geometry tree respectively.; The TGeo to GDML converter is now interfaced to the TGeoManager::Export method which automatically calls the appropriate Python scripts whenever the geometry output file has the .gdml extension.; Alternatively, one can also use the ROOT->GDML converter directly from the Python prompt (assuming the TGeo geometry has already been loaded into memory in one or another way), for example:; from math import *; ; import ROOT; import writer; import ROOTwriter; ; # get TGeoManager and; # get the top volume of the existing (in-memory) geometry tree; geomgr = ROOT.gGeoManager; topV = geomgr.GetTopVolume(); ; # instanciate writer; gdmlwriter = writer.writer('mygeo.gdml'); binding = ROOTwriter.ROOTwriter(gdmlwriter); ; # dump materials; matlist = geomgr.GetListOfMaterials(); binding.dumpMaterials(matlist); ; # dump solids; shapelist = geomgr.GetListOfShapes(); binding.dumpSolids(shapelist); ; # dump geo tree; print 'Traversing geometry tree'; gdmlwriter.addSetup('default', '1.0', topV.GetName()); binding.examineVol(topV); ; # write file; gdmlwriter.writeFile(); ROOTwriter.ROOTwriterDefi",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:612,Modifiability,config,configure,612,". ROOT: GDML tools. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; GDML toolsThe Geometry Package. ; GDML tools for geometry classes. ; The $ROOTSYS/gdml directory contains a set of Python modules designed for writing out Geometry Description Markup Language (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManag",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:683,Modifiability,config,configure,683,". ROOT: GDML tools. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; GDML toolsThe Geometry Package. ; GDML tools for geometry classes. ; The $ROOTSYS/gdml directory contains a set of Python modules designed for writing out Geometry Description Markup Language (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManag",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:1269,Modifiability,config,configure,1269,"uage (GDML) files. There is also a C++ implementation for the import of GDML into ROOT. They act as a converter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:3323,Performance,load,loaded,3323,"xport ROOT geometries (TGeo geometry trees) as GDML files. The writer module writes a GDML file out of the 'in-memory' representation of the geometry. The actual application-specific (ROOT) binding is implemented in ROOTwriter module. It contains 'binding methods' for TGeo geometry classes which can be exported in GDML format. Please refere to the comment part of the ROOTwriter.py file for the list of presently supported TGeo classes. The ROOTwriter class contains also three methods, dumpMaterials, dumpSolids and examineVol which need to be called in order to export materials, solids and geometry tree respectively.; The TGeo to GDML converter is now interfaced to the TGeoManager::Export method which automatically calls the appropriate Python scripts whenever the geometry output file has the .gdml extension.; Alternatively, one can also use the ROOT->GDML converter directly from the Python prompt (assuming the TGeo geometry has already been loaded into memory in one or another way), for example:; from math import *; ; import ROOT; import writer; import ROOTwriter; ; # get TGeoManager and; # get the top volume of the existing (in-memory) geometry tree; geomgr = ROOT.gGeoManager; topV = geomgr.GetTopVolume(); ; # instanciate writer; gdmlwriter = writer.writer('mygeo.gdml'); binding = ROOTwriter.ROOTwriter(gdmlwriter); ; # dump materials; matlist = geomgr.GetListOfMaterials(); binding.dumpMaterials(matlist); ; # dump solids; shapelist = geomgr.GetListOfShapes(); binding.dumpSolids(shapelist); ; # dump geo tree; print 'Traversing geometry tree'; gdmlwriter.addSetup('default', '1.0', topV.GetName()); binding.examineVol(topV); ; # write file; gdmlwriter.writeFile(); ROOTwriter.ROOTwriterDefinition ROOTwriter.py:58; ROOTwriter.ROOTwriter.dumpMaterialsdumpMaterials(self, matlist)Definition ROOTwriter.py:279; writer.writerDefinition writer.py:16; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPol",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:1427,Safety,detect,detecting,1427,"nverter between the GDML geometry files and the TGeo geometry structures (and vice versa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geomet",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:1507,Testability,test,test,1507,"rsa). GDML->ROOT; As this binding is integrated into the ROOT installation, you need to enable the use of the binding at the configure point of the ROOT installation. This can be done like so:; ./configure --enable-gdml; On doing this the libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geometry trees) as GDML files. The writer module writes a GDML file out of the 'in-memory'",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__gdml.html:1730,Testability,test,test,1730,"he libraries will be built by issuing the standard ROOT make command. The GDML to TGeo converter uses the TXMLEngine to parse the GDML files. This XML parser is a DOM parser and returns the DOM tree to the class TGDMLParse. This class then interprets the GDML file and adds the bindings in their TGeo equivalent.; The GDML schema is fully supported with a few exceptions:. Replica Volumes are not supported; Loops are not supported; Matrices are not supported. These will hopefully be added in the near future.; Once you have enabled GDML in the configure process for ROOT, to import a GDML file, this can be done using TGeoManager::Import. This automatically calls the right method to parse the GDML by detecting the .gdml file extension. Here is how to do it:; TGeoManager::Import(""test.gdml"");; TGeoManager::Importstatic TGeoManager * Import(const char *filename, const char *name="""", Option_t *option="""")static function Import a geometry from a gdml or ROOT fileDefinition TGeoManager.cxx:4096; Replace test.gdml with the gdml filename you want to import. Once the GDML file has been successfully imported, you can view the geometry by calling:; gGeoManager->GetTopVolume()->Draw(""ogl"");; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::GetTopVolumeTGeoVolume * GetTopVolume() constDefinition TGeoManager.h:512; TGeoVolume::Drawvoid Draw(Option_t *option="""") overridedraw top volume according to optionDefinition TGeoVolume.cxx:1206; For any questions or comments about the GDML->ROOT binding please contact ben.l.nosp@m.loyd.nosp@m.@cern.nosp@m..ch. ROOT->GDML; The TGeo to GDML converter allows to export ROOT geometries (TGeo geometry trees) as GDML files. The writer module writes a GDML file out of the 'in-memory' representation of the geometry. The actual application-specific (ROOT) binding is implemented in ROOTwriter module. It contains 'binding methods' for TGeo geometry classes which can be exported in GDML format. Please refere to the comme",MatchSource.WIKI,doc/master/group__Geometry__gdml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__gdml.html
https://root.cern/doc/master/group__Geometry__painter.html:417,Integrability,interface,interfaces,417,". ROOT: Geometry painter. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Geometry painterThe Geometry Package. ; The Geometry painter, checker, overlap and track related classes. . Classes; class  TGeoChecker;  Geometry checking package. More...;  ; class  TGeoOverlap;  Base class describing geometry overlaps. More...;  ; class  TGeoPainter;  Class implementing all draw interfaces for a generic 3D viewer using TBuffer3D mechanism. More...;  ; class  TGeoTrack;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Geometry__painter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Geometry__painter.html
https://root.cern/doc/master/group__gpad.html:612,Integrability,interface,interface,612,". ROOT: Graphics pad. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics padGraphics » 2D Graphics. ; The TPad related classes. ; TPad and TPad's related classes' usages are illustrated by the following examples:. The Graphics Pad.; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The mo",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:1444,Integrability,wrap,wrap,1444,"; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The moving box in a TSlider. More...;  ; class  TView;  See TView3D. More...;  ; class  TViewer3DPad;  Provides 3D viewer interface (TVirtualViewer3D) support on a pad. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:1478,Integrability,inject,inject,1478,"; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The moving box in a TSlider. More...;  ; class  TView;  See TView3D. More...;  ; class  TViewer3DPad;  Provides 3D viewer interface (TVirtualViewer3D) support on a pad. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:2117,Integrability,interface,interface,2117,"; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The moving box in a TSlider. More...;  ; class  TView;  See TView3D. More...;  ; class  TViewer3DPad;  Provides 3D viewer interface (TVirtualViewer3D) support on a pad. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:714,Modifiability,inherit,inheritance,714,". ROOT: Graphics pad. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics padGraphics » 2D Graphics. ; The TPad related classes. ; TPad and TPad's related classes' usages are illustrated by the following examples:. The Graphics Pad.; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The mo",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:897,Modifiability,config,configurable,897,". ROOT: Graphics pad. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics padGraphics » 2D Graphics. ; The TPad related classes. ; TPad and TPad's related classes' usages are illustrated by the following examples:. The Graphics Pad.; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The mo",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:935,Security,access,access,935,". ROOT: Graphics pad. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics padGraphics » 2D Graphics. ; The TPad related classes. ; TPad and TPad's related classes' usages are illustrated by the following examples:. The Graphics Pad.; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The mo",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__gpad.html:1478,Security,inject,inject,1478,"; How to Draw objects.; How to Pick objects.; Dividing a canvas with no margins between pads.; Using transparent pads. . Classes; class  TAnnotation;  An annotation is a TLatex which can be drawn in a 2D or 3D space. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TButton;  A TButton object is a user interface object. More...;  ; class  TCanvas;  The Canvas class. More...;  ; class  TClassTree;  Draw inheritance tree and their relations for a list of classes. More...;  ; class  TColorWheel;  Draw the ROOT Color Wheel. More...;  ; class  TControlBar;  A Control Bar is a fully user configurable tool which provides fast access to frequently used operations. More...;  ; class  TControlBarButton;  This class defines the control bar buttons. More...;  ; class  TCreatePrimitives;  Creates new primitives. More...;  ; class  TDialogCanvas;  A canvas specialized to set attributes. More...;  ; class  TGroupButton;  A specialized TButton used in a group of Buttons. More...;  ; class  TInspectCanvas;  A TInspectCanvas is a canvas specialized to inspect Root objects. More...;  ; class  TInspectorObject;  This class is designed to wrap a Foreign object in order to inject it into the Browse sub-system. More...;  ; class  TPad;  The most important graphics class in the ROOT system. More...;  ; class  TPadPainter;  Implement TVirtualPadPainter which abstracts painting operations. More...;  ; class  TPaveClass;  A TPaveLabel specialized to process classes inside a TClassTree. More...;  ; class  TRatioPlot;  Class for displaying ratios, differences and fit residuals. More...;  ; class  TSlider;  A specialized TPad including a TSliderBox object. More...;  ; class  TSliderBox;  The moving box in a TSlider. More...;  ; class  TView;  See TView3D. More...;  ; class  TViewer3DPad;  Provides 3D viewer interface (TVirtualViewer3D) support on a pad. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__gpad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__gpad.html
https://root.cern/doc/master/group__GpadROOT7.html:4578,Integrability,interface,interface,4578,"e itself. More...;  ; class  ROOT::Experimental::Internal::RIOSharedBase;  ; class  ROOT::Experimental::Detail::RMenuArgument;  Argument description for menu item which should invoke class method. More...;  ; class  ROOT::Experimental::Detail::RMenuItem;  Base class for menu items, shown on JS side. More...;  ; class  ROOT::Experimental::RMenuItems;  List of items for object context menu. More...;  ; class  ROOT::Experimental::ROnFrameDrawable;  Base class for drawable which can be drawn on frame or on pad. More...;  ; class  ROOT::Experimental::RPad;  Graphic container for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBase;  Base class for graphic containers for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBaseDisplayItem;  class RPadBaseDisplayItem More...;  ; class  ROOT::Experimental::RPadDisplayItem;  class RPadDisplayItem More...;  ; class  ROOT::Experimental::RPadExtent;  An extent / size (horizontal and vertical) in a RPad. More...;  ; class  ROOT::Experimental::RPadPos;  A position (horizontal and vertical) in a RPad. More...;  ; class  ROOT::Experimental::RPalette;  A set of colors. More...;  ; class  ROOT::Experimental::RStyle;  A set of defaults for graphics attributes, e.g. More...;  ; class  ROOT::Experimental::Internal::RVirtualCanvasPainter;  Abstract interface for painting a canvas. More...;  ; struct  ROOT::Experimental::RPadExtent::ScaleFactor;  A scale factor (separate factors for horizontal and vertical) for scaling a RPadLength. More...;  ; class  ROOT::Experimental::RPadPos::ScaleFactor;  A scale factor (separate factors for horizontal and vertical) for scaling a RPadLength. More...;  ; class  ROOT::Experimental::TObjectDisplayItem;  Display item for TObject with drawing options. More...;  ; class  ROOT::Experimental::TObjectDrawable;  Provides v7 drawing facilities for TObject types (TGraph, TH1, TH2, etc). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GpadROOT7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html
https://root.cern/doc/master/group__GpadROOT7.html:3124,Performance,perform,performed,3124," ROOT::Experimental::Detail::RCheckedMenuItem;  Menu item with check box. More...;  ; class  ROOT::Experimental::RColor;  The color class. More...;  ; class  ROOT::Experimental::RDisplayItem;  Base class for painting data for JS. More...;  ; class  ROOT::Experimental::RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  ROOT::Experimental::RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  ROOT::Experimental::RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  ROOT::Experimental::RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  ROOT::Experimental::RDrawableReply;  Base class for replies on RDrawableRequest. More...;  ; class  ROOT::Experimental::RDrawableRequest;  Base class for requests which can be submitted from the clients. More...;  ; class  ROOT::Experimental::RFrame;  Holds an area where drawing on user coordinate-system can be performed. More...;  ; class  ROOT::Experimental::RIndirectDisplayItem;  Extract (reference) only basic attributes from drawable, but not drawable itself. More...;  ; class  ROOT::Experimental::Internal::RIOSharedBase;  ; class  ROOT::Experimental::Detail::RMenuArgument;  Argument description for menu item which should invoke class method. More...;  ; class  ROOT::Experimental::Detail::RMenuItem;  Base class for menu items, shown on JS side. More...;  ; class  ROOT::Experimental::RMenuItems;  List of items for object context menu. More...;  ; class  ROOT::Experimental::ROnFrameDrawable;  Base class for drawable which can be drawn on frame or on pad. More...;  ; class  ROOT::Experimental::RPad;  Graphic container for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBase;  Base class for graphic containers for RDrawable-s. More...;  ; class  ROOT::Experimental::RPadBaseDisplayItem;  class RPadBaseDisplayItem More...;  ; class  ROOT::Ex",MatchSource.WIKI,doc/master/group__GpadROOT7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html
https://root.cern/doc/master/group__GpadROOT7.html:1846,Security,access,access,1846,"itle and its drawing attributes. More...;  ; class  ROOT::Experimental::RAttrBase;  Base class for all attributes, used with RDrawable. More...;  ; class  ROOT::Experimental::RAttrBorder;  Drawing line attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrFill;  Drawing fill attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrFont;  A font attributes, used together with text attributes. More...;  ; class  ROOT::Experimental::RAttrLine;  Drawing line attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrLineEnding;  Attributes for line ending. More...;  ; class  ROOT::Experimental::RAttrMap;  ; class  ROOT::Experimental::RAttrMargins;  A margins attributes. Only relative and pixel coordinates are allowed. More...;  ; class  ROOT::Experimental::RAttrMarker;  A marker attributes. More...;  ; class  ROOT::Experimental::RAttrText;  A text attributes. More...;  ; class  ROOT::Experimental::RAttrValue< T >;  Template class to access single value from drawable or other attributes. More...;  ; class  ROOT::Experimental::RCanvas;  A window's topmost RPad. More...;  ; class  ROOT::Experimental::RCanvasDisplayItem;  class RCanvasDisplayItem More...;  ; class  ROOT::Experimental::Detail::RCheckedMenuItem;  Menu item with check box. More...;  ; class  ROOT::Experimental::RColor;  The color class. More...;  ; class  ROOT::Experimental::RDisplayItem;  Base class for painting data for JS. More...;  ; class  ROOT::Experimental::RDrawable;  Base class for drawable entities: objects that can be painted on a RPad. More...;  ; class  ROOT::Experimental::RDrawableDisplayItem;  Generic display item for RDrawable, just reference drawable itself. More...;  ; class  ROOT::Experimental::RDrawableExecRequest;  Request execution of method of referenced drawable, no reply. More...;  ; class  ROOT::Experimental::RDrawableMenuRequest;  Request menu items for the drawable object. More...;  ; class  ROOT::Experimental::RDrawabl",MatchSource.WIKI,doc/master/group__GpadROOT7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html
https://root.cern/doc/master/group__GpadROOT7.html:591,Testability,log,log,591,". ROOT: ROOT7 Pad related classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; ROOT7 Pad related classesGraphics » ROOT7 Graphics. ; The ROOT7 Pad related classes. . Classes; class  ROOT::Experimental::Detail::RArgsMenuItem;  Menu item which requires extra arguments for invoked class method. More...;  ; class  ROOT::Experimental::RAttrAggregation;  Base class for attributes aggregations like lines or fill attributes. More...;  ; class  ROOT::Experimental::RAttrAxis;  All supported axes attributes for: line, ticks, labels, title, min/max, log, reverse, ... More...;  ; class  ROOT::Experimental::RAttrAxisLabels;  Axis labels drawing attributes. More...;  ; class  ROOT::Experimental::RAttrAxisTicks;  Axis ticks attributes. More...;  ; class  ROOT::Experimental::RAttrAxisTitle;  Axis title and its drawing attributes. More...;  ; class  ROOT::Experimental::RAttrBase;  Base class for all attributes, used with RDrawable. More...;  ; class  ROOT::Experimental::RAttrBorder;  Drawing line attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrFill;  Drawing fill attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrFont;  A font attributes, used together with text attributes. More...;  ; class  ROOT::Experimental::RAttrLine;  Drawing line attributes for different objects. More...;  ; class  ROOT::Experimental::RAttrLineEnding;  Attributes for line ending. More...;  ; class  ROOT::Experimental::RAttrMap;  ; class  ROOT::Experimental::RAttrMargins;  A margins attributes. Only relative and pixel coordinates are allowed. More...;  ; class  ROOT::Experimental::RAttrMarker;  A marker attributes. More...;  ; class  ROOT::Experimental::RAttrText;  A text attributes. More...;  ; class  ROOT::Experimental::RAttrValue< T >;  Template class to access single value from drawable or other attributes. More...;  ; class  ROOT::Experimental::RCanvas;  A window's topmost RPad. More...;  ; class  ROOT::E",MatchSource.WIKI,doc/master/group__GpadROOT7.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GpadROOT7.html
https://root.cern/doc/master/group__Graphics.html:203,Integrability,interface,interface,203,. ROOT: Graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Graphics. ; The graphics related classes. . Modules;  Graphics' Backends;  Graphics' Backends interface classes. ;  ;  2D Graphics;  The 2D graphics related classes. ;  ;  Graphics attributes;  The graphics attributes related classes. ;  ;  ROOT7 Graphics;  Classes for ROOT7 graphics. ;  ;  3D Graphics;  The 3D graphics related classes. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Graphics.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphics.html
https://root.cern/doc/master/group__Graphics2D.html:194,Integrability,interface,interface,194,. ROOT: 2D Graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; 2D GraphicsGraphics. ; The 2D graphics related classes. . Modules;  libAfterImage interface;  Classes interfacing to libAfterImage. ;  ;  FITS file;  Interface to FITS file. ;  ;  Graphics pad;  The TPad related classes. ;  ;  Basic graphics;  The low level graphics classes. ;  ;  graphviz interface;  Interface to the graphing package graphviz ;  ;  Graphics file output;  Interfaces to various file output formats. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Graphics2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphics2D.html
https://root.cern/doc/master/group__Graphics2D.html:403,Integrability,interface,interface,403,. ROOT: 2D Graphics. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; 2D GraphicsGraphics. ; The 2D graphics related classes. . Modules;  libAfterImage interface;  Classes interfacing to libAfterImage. ;  ;  FITS file;  Interface to FITS file. ;  ;  Graphics pad;  The TPad related classes. ;  ;  Basic graphics;  The low level graphics classes. ;  ;  graphviz interface;  Interface to the graphing package graphviz ;  ;  Graphics file output;  Interfaces to various file output formats. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Graphics2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphics2D.html
https://root.cern/doc/master/group__GraphicsAtt.html:327,Modifiability,inherit,inheritance,327,". ROOT: Graphics attributes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics attributesGraphics. ; The graphics attributes related classes. ; Graphics attributes, are parameters that affect the way graphics primitives are displayed.; A ROOT object get graphics attributes by inheritance from the TAttXXX classes.; For example, lines can be dotted or dashed, fat or thin, blue or orange. If an object inherits form the class TAttLine it will get these attributes. Areas might be filled with one color or with a multicolor pattern. If an object inherits form the class TAttFill it will get these attribute. Text can appear with an angle, displayed in different fonts, colors, and sizes. If an object inherits form the class TAttText it will get these attribute. . Classes; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttImage;  TImage attributes. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsAtt.html
https://root.cern/doc/master/group__GraphicsAtt.html:452,Modifiability,inherit,inherits,452,". ROOT: Graphics attributes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics attributesGraphics. ; The graphics attributes related classes. ; Graphics attributes, are parameters that affect the way graphics primitives are displayed.; A ROOT object get graphics attributes by inheritance from the TAttXXX classes.; For example, lines can be dotted or dashed, fat or thin, blue or orange. If an object inherits form the class TAttLine it will get these attributes. Areas might be filled with one color or with a multicolor pattern. If an object inherits form the class TAttFill it will get these attribute. Text can appear with an angle, displayed in different fonts, colors, and sizes. If an object inherits form the class TAttText it will get these attribute. . Classes; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttImage;  TImage attributes. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsAtt.html
https://root.cern/doc/master/group__GraphicsAtt.html:595,Modifiability,inherit,inherits,595,". ROOT: Graphics attributes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics attributesGraphics. ; The graphics attributes related classes. ; Graphics attributes, are parameters that affect the way graphics primitives are displayed.; A ROOT object get graphics attributes by inheritance from the TAttXXX classes.; For example, lines can be dotted or dashed, fat or thin, blue or orange. If an object inherits form the class TAttLine it will get these attributes. Areas might be filled with one color or with a multicolor pattern. If an object inherits form the class TAttFill it will get these attribute. Text can appear with an angle, displayed in different fonts, colors, and sizes. If an object inherits form the class TAttText it will get these attribute. . Classes; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttImage;  TImage attributes. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsAtt.html
https://root.cern/doc/master/group__GraphicsAtt.html:750,Modifiability,inherit,inherits,750,". ROOT: Graphics attributes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics attributesGraphics. ; The graphics attributes related classes. ; Graphics attributes, are parameters that affect the way graphics primitives are displayed.; A ROOT object get graphics attributes by inheritance from the TAttXXX classes.; For example, lines can be dotted or dashed, fat or thin, blue or orange. If an object inherits form the class TAttLine it will get these attributes. Areas might be filled with one color or with a multicolor pattern. If an object inherits form the class TAttFill it will get these attribute. Text can appear with an angle, displayed in different fonts, colors, and sizes. If an object inherits form the class TAttText it will get these attribute. . Classes; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttImage;  TImage attributes. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsAtt.html
https://root.cern/doc/master/group__GraphicsAtt.html:1651,Modifiability,extend,extends,1651,". ROOT: Graphics attributes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graphics attributesGraphics. ; The graphics attributes related classes. ; Graphics attributes, are parameters that affect the way graphics primitives are displayed.; A ROOT object get graphics attributes by inheritance from the TAttXXX classes.; For example, lines can be dotted or dashed, fat or thin, blue or orange. If an object inherits form the class TAttLine it will get these attributes. Areas might be filled with one color or with a multicolor pattern. If an object inherits form the class TAttFill it will get these attribute. Text can appear with an angle, displayed in different fonts, colors, and sizes. If an object inherits form the class TAttText it will get these attribute. . Classes; class  TAtt3D;  Use this attribute class when an object should have 3D capabilities. More...;  ; class  TAttAxis;  Manages histogram axis attributes. More...;  ; class  TAttBBox;  Helper for management of bounding-box information. More...;  ; class  TAttBBox2D;  Abstract base class for elements drawn in the editor. More...;  ; class  TAttCanvas;  Manages canvas attributes. More...;  ; class  TAttFill;  Fill Area Attributes class. More...;  ; class  TAttImage;  TImage attributes. More...;  ; class  TAttLine;  Line Attributes class. More...;  ; class  TAttMarker;  Marker Attributes class. More...;  ; class  TAttPad;  Manages default Pad attributes. More...;  ; class  TAttText;  Text Attributes class. More...;  ; class  TColor;  The color creation and management class. More...;  ; class  TColorGradient;  TColorGradient extends basic TColor. More...;  ; class  TStyle;  TStyle objects may be created to define special styles. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsAtt.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsAtt.html
https://root.cern/doc/master/group__GraphicsBackends.html:179,Integrability,interface,interface,179,". ROOT: Graphics' Backends. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Graphics' BackendsGraphics. ; Graphics' Backends interface classes. ; Graphics classes interfacing ROOT graphics with the low level native graphics backends(s) like X11, Cocoa, Win32 etc... These classes are not meant to be used directly by ROOT users. . Modules;  Cocoa backend;  Interface to MacOS native graphics system. ;  ;  Win32 backend;  Interface to Windows graphics. ;  ;  X11 backend;  Interface to X11 graphics. ;  . Classes; class  TTFX11Init;  Small utility class that takes care of switching the current gVirtualX to the new TGX11TTF class as soon as the shared library containing this class is loaded. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsBackends.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsBackends.html
https://root.cern/doc/master/group__GraphicsBackends.html:823,Integrability,interface,interface,823,". ROOT: Graphics' Backends. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Graphics' BackendsGraphics. ; Graphics' Backends interface classes. ; Graphics classes interfacing ROOT graphics with the low level native graphics backends(s) like X11, Cocoa, Win32 etc... These classes are not meant to be used directly by ROOT users. . Modules;  Cocoa backend;  Interface to MacOS native graphics system. ;  ;  Win32 backend;  Interface to Windows graphics. ;  ;  X11 backend;  Interface to X11 graphics. ;  . Classes; class  TTFX11Init;  Small utility class that takes care of switching the current gVirtualX to the new TGX11TTF class as soon as the shared library containing this class is loaded. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsBackends.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsBackends.html
https://root.cern/doc/master/group__GraphicsBackends.html:740,Performance,load,loaded,740,". ROOT: Graphics' Backends. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Graphics' BackendsGraphics. ; Graphics' Backends interface classes. ; Graphics classes interfacing ROOT graphics with the low level native graphics backends(s) like X11, Cocoa, Win32 etc... These classes are not meant to be used directly by ROOT users. . Modules;  Cocoa backend;  Interface to MacOS native graphics system. ;  ;  Win32 backend;  Interface to Windows graphics. ;  ;  X11 backend;  Interface to X11 graphics. ;  . Classes; class  TTFX11Init;  Small utility class that takes care of switching the current gVirtualX to the new TGX11TTF class as soon as the shared library containing this class is loaded. More...;  ; class  TVirtualX;  Semi-Abstract base class defining a generic interface to the underlying, low level, native graphics backend (X11, Win32, MacOS, OpenGL...). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__GraphicsBackends.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__GraphicsBackends.html
https://root.cern/doc/master/group__Graphs.html:418,Availability,error,errors,418,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:482,Availability,error,errors,482,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:552,Availability,error,error,552,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:655,Availability,error,error,655,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:939,Availability,error,error,939,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:1013,Availability,error,error,1013,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:1039,Availability,error,error,1039,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Graphs.html:1506,Modifiability,variab,variables,1506,". ROOT: Graph classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Graph classes.Histogram Library. . Classes; class  TGraph;  A TGraph is an object made of two arrays X and Y with npoints each. More...;  ; class  TGraph2D;  Graphics object made of three arrays X, Y and Z with the same number of points each. More...;  ; class  TGraph2DAsymmErrors;  Graph 2D class with errors. More...;  ; class  TGraph2DErrors;  Graph 2D class with errors. More...;  ; class  TGraphAsymmErrors;  TGraph with asymmetric error bars. More...;  ; class  TGraphBentErrors;  A TGraphBentErrors is a TGraph with bent, asymmetric error bars. More...;  ; class  TGraphDelaunay;  TGraphDelaunay generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphDelaunay2D;  TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D. More...;  ; class  TGraphErrors;  A TGraphErrors is a TGraph with error bars. More...;  ; class  TGraphMultiErrors;  TGraph with asymmetric error bars and multiple y error dimensions. More...;  ; class  TGraphSmooth;  A helper class to smooth TGraph. More...;  ; class  TGraphTime;  TGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax. More...;  ; class  TMultiGraph;  A TMultiGraph is a collection of TGraph (or derived) objects. More...;  ; class  TPolyMarker;  A PolyMarker is defined by an array on N points in a 2-D space. More...;  ; class  TScatter;  A TScatter is able to draw four variables scatter plot on a single plot. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Graphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Graphs.html
https://root.cern/doc/master/group__Hist.html:2981,Integrability,interface,interface,2981,"grams; How to convert Hbook/PAW files to ROOT . Modules;  Painting classes;  ;  Histogram classes.;  ;  Graph classes.;  ;  Function classes.;  ;  ROOT 7 histogram classes.;  ;  Advanced spectra processing classes.;  ;  TUnfold classes;  . Classes; class  TBackCompFitter;  Backward compatible implementation of TVirtualFitter. More...;  ; class  TBinomialEfficiencyFitter;  Binomial fitter for the division of two histograms. More...;  ; class  TConfidenceLevel;  Class to compute 95% CL limits. More...;  ; class  TEfficiency;  Class to handle efficiency histograms. More...;  ; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  ; class  TFormula;  The Formula class. More...;  ; class  ROOT::v5::TFormula;  The FORMULA class (ROOT version 5) More...;  ; class  ROOT::v5::TFormulaPrimitive;  The Formula Primitive class. More...;  ; class  THbookBranch;  HBOOK Branch. More...;  ; class  THbookFile;  This class is an interface to the Hbook objects in Hbook files. More...;  ; class  THbookKey;  HBOOK Key. More...;  ; class  THbookTree;  A wrapper class supporting Hbook ntuples (CWN and RWN). More...;  ; class  THnBase;  Multidimensional histogram base. More...;  ; class  THnSparse;  Efficient multidimensional histogram. More...;  ; class  TKDE;  Kernel Density Estimation class. More...;  ; class  TLimit;   Legacy Code TLimit is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TLimit might still be a valid solution. Consider switching to RooStats.Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. More...;  ; class  TMultiDimFit;  Multidimensional Fits in ROOT. More...;  ; class  TPrincipal;  Principal Components Analysis (PCA) More...;  ; class  TProfile2PolyBin;  Helper class to represent a bin in the TProfile2Poly histogram. More...;  ; ",MatchSource.WIKI,doc/master/group__Hist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Hist.html
https://root.cern/doc/master/group__Hist.html:3104,Integrability,wrap,wrapper,3104,"lasses.;  ;  ROOT 7 histogram classes.;  ;  Advanced spectra processing classes.;  ;  TUnfold classes;  . Classes; class  TBackCompFitter;  Backward compatible implementation of TVirtualFitter. More...;  ; class  TBinomialEfficiencyFitter;  Binomial fitter for the division of two histograms. More...;  ; class  TConfidenceLevel;  Class to compute 95% CL limits. More...;  ; class  TEfficiency;  Class to handle efficiency histograms. More...;  ; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  ; class  TFormula;  The Formula class. More...;  ; class  ROOT::v5::TFormula;  The FORMULA class (ROOT version 5) More...;  ; class  ROOT::v5::TFormulaPrimitive;  The Formula Primitive class. More...;  ; class  THbookBranch;  HBOOK Branch. More...;  ; class  THbookFile;  This class is an interface to the Hbook objects in Hbook files. More...;  ; class  THbookKey;  HBOOK Key. More...;  ; class  THbookTree;  A wrapper class supporting Hbook ntuples (CWN and RWN). More...;  ; class  THnBase;  Multidimensional histogram base. More...;  ; class  THnSparse;  Efficient multidimensional histogram. More...;  ; class  TKDE;  Kernel Density Estimation class. More...;  ; class  TLimit;   Legacy Code TLimit is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TLimit might still be a valid solution. Consider switching to RooStats.Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. More...;  ; class  TMultiDimFit;  Multidimensional Fits in ROOT. More...;  ; class  TPrincipal;  Principal Components Analysis (PCA) More...;  ; class  TProfile2PolyBin;  Helper class to represent a bin in the TProfile2Poly histogram. More...;  ; class  TSpline;  Base class for spline implementation containing the Draw/Paint methods. More...;  ; class  TSpline3;  Class to create",MatchSource.WIKI,doc/master/group__Hist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Hist.html
https://root.cern/doc/master/group__Hist.html:3408,Integrability,interface,interface,3408,"ore...;  ; class  TConfidenceLevel;  Class to compute 95% CL limits. More...;  ; class  TEfficiency;  Class to handle efficiency histograms. More...;  ; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  ; class  TFormula;  The Formula class. More...;  ; class  ROOT::v5::TFormula;  The FORMULA class (ROOT version 5) More...;  ; class  ROOT::v5::TFormulaPrimitive;  The Formula Primitive class. More...;  ; class  THbookBranch;  HBOOK Branch. More...;  ; class  THbookFile;  This class is an interface to the Hbook objects in Hbook files. More...;  ; class  THbookKey;  HBOOK Key. More...;  ; class  THbookTree;  A wrapper class supporting Hbook ntuples (CWN and RWN). More...;  ; class  THnBase;  Multidimensional histogram base. More...;  ; class  THnSparse;  Efficient multidimensional histogram. More...;  ; class  TKDE;  Kernel Density Estimation class. More...;  ; class  TLimit;   Legacy Code TLimit is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TLimit might still be a valid solution. Consider switching to RooStats.Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. More...;  ; class  TMultiDimFit;  Multidimensional Fits in ROOT. More...;  ; class  TPrincipal;  Principal Components Analysis (PCA) More...;  ; class  TProfile2PolyBin;  Helper class to represent a bin in the TProfile2Poly histogram. More...;  ; class  TSpline;  Base class for spline implementation containing the Draw/Paint methods. More...;  ; class  TSpline3;  Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives at beginning and ending points. More...;  ; class  TSpline5;  Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced for first and second der",MatchSource.WIKI,doc/master/group__Hist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Hist.html
https://root.cern/doc/master/group__Hist.html:3549,Integrability,depend,depending,3549,";  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  ; class  TFormula;  The Formula class. More...;  ; class  ROOT::v5::TFormula;  The FORMULA class (ROOT version 5) More...;  ; class  ROOT::v5::TFormulaPrimitive;  The Formula Primitive class. More...;  ; class  THbookBranch;  HBOOK Branch. More...;  ; class  THbookFile;  This class is an interface to the Hbook objects in Hbook files. More...;  ; class  THbookKey;  HBOOK Key. More...;  ; class  THbookTree;  A wrapper class supporting Hbook ntuples (CWN and RWN). More...;  ; class  THnBase;  Multidimensional histogram base. More...;  ; class  THnSparse;  Efficient multidimensional histogram. More...;  ; class  TKDE;  Kernel Density Estimation class. More...;  ; class  TLimit;   Legacy Code TLimit is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TLimit might still be a valid solution. Consider switching to RooStats.Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. More...;  ; class  TMultiDimFit;  Multidimensional Fits in ROOT. More...;  ; class  TPrincipal;  Principal Components Analysis (PCA) More...;  ; class  TProfile2PolyBin;  Helper class to represent a bin in the TProfile2Poly histogram. More...;  ; class  TSpline;  Base class for spline implementation containing the Draw/Paint methods. More...;  ; class  TSpline3;  Class to create third splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives at beginning and ending points. More...;  ; class  TSpline5;  Class to create quintic natural splines to interpolate knots Arbitrary conditions can be introduced for first and second derivatives using double knots (see BuildCoeff) for more on this. More...;  ; class  TSplinePoly;  Base class for TSpline knot. More...;  ; class  TSplinePoly3;  Class for TS",MatchSource.WIKI,doc/master/group__Hist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Hist.html
https://root.cern/doc/master/group__Hist.html:2634,Modifiability,inherit,inheritance,2634,"aximum precision 7 digits; TH3D : histograms with one double per channel. Maximum precision 14 digits. See also:; The Chapter about the Histogram classes in the Users Guide; The Chapter about Fitting Histogram in the Users Guide; How to use the Histogram classes; How to Merge files with histograms and Trees; How to Fit Histograms; How to Fit find peaks in histograms; How to convert Hbook/PAW files to ROOT . Modules;  Painting classes;  ;  Histogram classes.;  ;  Graph classes.;  ;  Function classes.;  ;  ROOT 7 histogram classes.;  ;  Advanced spectra processing classes.;  ;  TUnfold classes;  . Classes; class  TBackCompFitter;  Backward compatible implementation of TVirtualFitter. More...;  ; class  TBinomialEfficiencyFitter;  Binomial fitter for the division of two histograms. More...;  ; class  TConfidenceLevel;  Class to compute 95% CL limits. More...;  ; class  TEfficiency;  Class to handle efficiency histograms. More...;  ; class  TFitResult;  Extends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O. More...;  ; class  TFormula;  The Formula class. More...;  ; class  ROOT::v5::TFormula;  The FORMULA class (ROOT version 5) More...;  ; class  ROOT::v5::TFormulaPrimitive;  The Formula Primitive class. More...;  ; class  THbookBranch;  HBOOK Branch. More...;  ; class  THbookFile;  This class is an interface to the Hbook objects in Hbook files. More...;  ; class  THbookKey;  HBOOK Key. More...;  ; class  THbookTree;  A wrapper class supporting Hbook ntuples (CWN and RWN). More...;  ; class  THnBase;  Multidimensional histogram base. More...;  ; class  THnSparse;  Efficient multidimensional histogram. More...;  ; class  TKDE;  Kernel Density Estimation class. More...;  ; class  TLimit;   Legacy Code TLimit is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TLimit might still be a valid solution.",MatchSource.WIKI,doc/master/group__Hist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Hist.html
https://root.cern/doc/master/group__Histograms.html:2469,Availability,error,error,2469,"ntation) More...;  ; class  TH2C;  2-D histogram with a byte per channel (see TH1 documentation) More...;  ; class  TH2D;  2-D histogram with a double per channel (see TH1 documentation) More...;  ; class  TH2F;  2-D histogram with a float per channel (see TH1 documentation) More...;  ; class  TH2I;  2-D histogram with an int per channel (see TH1 documentation) More...;  ; class  TH2L;  2-D histogram with a long64 per channel (see TH1 documentation) More...;  ; class  TH2Poly;  2D Histogram with Polygonal Bins More...;  ; class  TH2PolyBin;  Helper class to represent a bin in the TH2Poly histogram. More...;  ; class  TH2S;  2-D histogram with a short per channel (see TH1 documentation) More...;  ; class  TH3;  The 3-D histogram classes derived from the 1-D histogram classes. More...;  ; class  TH3C;  3-D histogram with a byte per channel (see TH1 documentation) More...;  ; class  TH3D;  3-D histogram with a double per channel (see TH1 documentation) More...;  ; class  TH3F;  3-D histogram with a float per channel (see TH1 documentation) More...;  ; class  TH3I;  3-D histogram with an int per channel (see TH1 documentation) More...;  ; class  TH3L;  3-D histogram with a long64 per channel (see TH1 documentation) More...;  ; class  TH3S;  3-D histogram with a short per channel (see TH1 documentation) More...;  ; class  THLimitsFinder;  Class to compute nice axis limits. More...;  ; class  THn;  Multidimensional histogram. More...;  ; class  THStack;  The Histogram stack class. More...;  ; class  TProfile;  Profile Histogram. More...;  ; class  TProfile2D;  Profile2D histograms are used to display the mean value of Z and its error for each cell in X,Y. More...;  ; class  TProfile2Poly;  2D Profile Histogram with Polygonal Bins. More...;  ; class  TProfile3D;  Profile3D histograms are used to display the mean value of T and its RMS for each cell in X,Y,Z. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Histograms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Histograms.html
https://root.cern/doc/master/group__Histpainter.html:437,Availability,error,errors,437,. ROOT: Histograms and graphs painting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Histograms and graphs painting classes.Histogram Library » Painting classes. ; The histograms and graphs plotting options are described in details in the THistPainter and TGraphPainter classes. Some related tutorials:. graph.C: Using and drawing a simple TGraph.; graph2derrorsfit.C: TGraph2D with errors drawing.; h1draw.C: Drawing Options for 1D Histograms.; hbars.C: Demo of option bar with histograms.; hsimple.C: Simple drawing of a 1D Histograms.; hsum.C: Filling several histograms and some graphics options.; surfaces.C: Drawing a TH2 as a 2-D surface. Some related HowTos:; How to Draw objects ?; How to change the position of the statistics box on histogram plot ?; How to draw several TGraph in one common axis system ? . Classes; class  TGraph2DPainter;  The TGraphDelaunay painting class. More...;  ; class  TGraphPainter;  The graph painter class. More...;  ; class  THistPainter;  The histogram painter class. More...;  ; class  TPainter3dAlgorithms;  The Legos and Surfaces painter class. More...;  ; class  TPaletteAxis;  The palette painting class. More...;  ; class  TVirtualGraphPainter;  Abstract interface to a histogram painter. More...;  ; class  TVirtualHistPainter;  Abstract interface to a histogram painter. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Histpainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Histpainter.html
https://root.cern/doc/master/group__Histpainter.html:1257,Integrability,interface,interface,1257,. ROOT: Histograms and graphs painting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Histograms and graphs painting classes.Histogram Library » Painting classes. ; The histograms and graphs plotting options are described in details in the THistPainter and TGraphPainter classes. Some related tutorials:. graph.C: Using and drawing a simple TGraph.; graph2derrorsfit.C: TGraph2D with errors drawing.; h1draw.C: Drawing Options for 1D Histograms.; hbars.C: Demo of option bar with histograms.; hsimple.C: Simple drawing of a 1D Histograms.; hsum.C: Filling several histograms and some graphics options.; surfaces.C: Drawing a TH2 as a 2-D surface. Some related HowTos:; How to Draw objects ?; How to change the position of the statistics box on histogram plot ?; How to draw several TGraph in one common axis system ? . Classes; class  TGraph2DPainter;  The TGraphDelaunay painting class. More...;  ; class  TGraphPainter;  The graph painter class. More...;  ; class  THistPainter;  The histogram painter class. More...;  ; class  TPainter3dAlgorithms;  The Legos and Surfaces painter class. More...;  ; class  TPaletteAxis;  The palette painting class. More...;  ; class  TVirtualGraphPainter;  Abstract interface to a histogram painter. More...;  ; class  TVirtualHistPainter;  Abstract interface to a histogram painter. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Histpainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Histpainter.html
https://root.cern/doc/master/group__Histpainter.html:1341,Integrability,interface,interface,1341,. ROOT: Histograms and graphs painting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Histograms and graphs painting classes.Histogram Library » Painting classes. ; The histograms and graphs plotting options are described in details in the THistPainter and TGraphPainter classes. Some related tutorials:. graph.C: Using and drawing a simple TGraph.; graph2derrorsfit.C: TGraph2D with errors drawing.; h1draw.C: Drawing Options for 1D Histograms.; hbars.C: Demo of option bar with histograms.; hsimple.C: Simple drawing of a 1D Histograms.; hsum.C: Filling several histograms and some graphics options.; surfaces.C: Drawing a TH2 as a 2-D surface. Some related HowTos:; How to Draw objects ?; How to change the position of the statistics box on histogram plot ?; How to draw several TGraph in one common axis system ? . Classes; class  TGraph2DPainter;  The TGraphDelaunay painting class. More...;  ; class  TGraphPainter;  The graph painter class. More...;  ; class  THistPainter;  The histogram painter class. More...;  ; class  TPainter3dAlgorithms;  The Legos and Surfaces painter class. More...;  ; class  TPaletteAxis;  The palette painting class. More...;  ; class  TVirtualGraphPainter;  Abstract interface to a histogram painter. More...;  ; class  TVirtualHistPainter;  Abstract interface to a histogram painter. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Histpainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Histpainter.html
https://root.cern/doc/master/group__Histpainter.html:387,Usability,simpl,simple,387,. ROOT: Histograms and graphs painting classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Histograms and graphs painting classes.Histogram Library » Painting classes. ; The histograms and graphs plotting options are described in details in the THistPainter and TGraphPainter classes. Some related tutorials:. graph.C: Using and drawing a simple TGraph.; graph2derrorsfit.C: TGraph2D with errors drawing.; h1draw.C: Drawing Options for 1D Histograms.; hbars.C: Demo of option bar with histograms.; hsimple.C: Simple drawing of a 1D Histograms.; hsum.C: Filling several histograms and some graphics options.; surfaces.C: Drawing a TH2 as a 2-D surface. Some related HowTos:; How to Draw objects ?; How to change the position of the statistics box on histogram plot ?; How to draw several TGraph in one common axis system ? . Classes; class  TGraph2DPainter;  The TGraphDelaunay painting class. More...;  ; class  TGraphPainter;  The graph painter class. More...;  ; class  THistPainter;  The histogram painter class. More...;  ; class  TPainter3dAlgorithms;  The Legos and Surfaces painter class. More...;  ; class  TPaletteAxis;  The palette painting class. More...;  ; class  TVirtualGraphPainter;  Abstract interface to a histogram painter. More...;  ; class  TVirtualHistPainter;  Abstract interface to a histogram painter. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__Histpainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Histpainter.html
https://root.cern/doc/master/group__http.html:171,Integrability,protocol,protocol,171,". ROOT: HTTP server. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; HTTP server. ; THttpServer-related classes to provide HTTP protocol to ROOT application. . Classes; class  TCivetweb;  THttpEngine implementation, based on civetweb embedded server. More...;  ; class  TFastCgi;  THttpEngine implementation, based on fastcgi package. More...;  ; class  THttpCallArg;  Contains arguments for single HTTP call. More...;  ; class  THttpEngine;  Abstract class for implementing http protocol for THttpServer. More...;  ; class  THttpLongPollEngine;  Emulation of websocket with long poll requests. More...;  ; class  THttpServer;  Online http server for arbitrary ROOT application. More...;  ; class  THttpWSHandler;  Class for user-side handling of websocket with THttpServer. More...;  ; class  TRootSniffer;  Sniffer of ROOT objects, data provider for THttpServer. More...;  ; class  TRootSnifferFull;  Extends TRootSniffer for many ROOT classes. More...;  ; class  TRootSnifferScanRec;  Structure used to scan hierarchies of ROOT objects. More...;  ; class  TRootSnifferStore;  Abstract interface for storage of hierarchy scan in TRootSniffer. More...;  ; class  TRootSnifferStoreJson;  Storage of hierarchy scan in TRootSniffer in JSON format. More...;  ; class  TRootSnifferStoreXml;  Storage of hierarchy scan in TRootSniffer in XML format. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__http.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__http.html
https://root.cern/doc/master/group__http.html:523,Integrability,protocol,protocol,523,". ROOT: HTTP server. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; HTTP server. ; THttpServer-related classes to provide HTTP protocol to ROOT application. . Classes; class  TCivetweb;  THttpEngine implementation, based on civetweb embedded server. More...;  ; class  TFastCgi;  THttpEngine implementation, based on fastcgi package. More...;  ; class  THttpCallArg;  Contains arguments for single HTTP call. More...;  ; class  THttpEngine;  Abstract class for implementing http protocol for THttpServer. More...;  ; class  THttpLongPollEngine;  Emulation of websocket with long poll requests. More...;  ; class  THttpServer;  Online http server for arbitrary ROOT application. More...;  ; class  THttpWSHandler;  Class for user-side handling of websocket with THttpServer. More...;  ; class  TRootSniffer;  Sniffer of ROOT objects, data provider for THttpServer. More...;  ; class  TRootSnifferFull;  Extends TRootSniffer for many ROOT classes. More...;  ; class  TRootSnifferScanRec;  Structure used to scan hierarchies of ROOT objects. More...;  ; class  TRootSnifferStore;  Abstract interface for storage of hierarchy scan in TRootSniffer. More...;  ; class  TRootSnifferStoreJson;  Storage of hierarchy scan in TRootSniffer in JSON format. More...;  ; class  TRootSnifferStoreXml;  Storage of hierarchy scan in TRootSniffer in XML format. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__http.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__http.html
https://root.cern/doc/master/group__http.html:1131,Integrability,interface,interface,1131,". ROOT: HTTP server. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; HTTP server. ; THttpServer-related classes to provide HTTP protocol to ROOT application. . Classes; class  TCivetweb;  THttpEngine implementation, based on civetweb embedded server. More...;  ; class  TFastCgi;  THttpEngine implementation, based on fastcgi package. More...;  ; class  THttpCallArg;  Contains arguments for single HTTP call. More...;  ; class  THttpEngine;  Abstract class for implementing http protocol for THttpServer. More...;  ; class  THttpLongPollEngine;  Emulation of websocket with long poll requests. More...;  ; class  THttpServer;  Online http server for arbitrary ROOT application. More...;  ; class  THttpWSHandler;  Class for user-side handling of websocket with THttpServer. More...;  ; class  TRootSniffer;  Sniffer of ROOT objects, data provider for THttpServer. More...;  ; class  TRootSnifferFull;  Extends TRootSniffer for many ROOT classes. More...;  ; class  TRootSnifferScanRec;  Structure used to scan hierarchies of ROOT objects. More...;  ; class  TRootSnifferStore;  Abstract interface for storage of hierarchy scan in TRootSniffer. More...;  ; class  TRootSnifferStoreJson;  Storage of hierarchy scan in TRootSniffer in JSON format. More...;  ; class  TRootSnifferStoreXml;  Storage of hierarchy scan in TRootSniffer in XML format. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__http.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__http.html
https://root.cern/doc/master/group__Integration.html:252,Deployability,integrat,integration,252,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:317,Deployability,integrat,integration,317,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:414,Deployability,integrat,integration,414,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1128,Deployability,integrat,integration,1128,"odules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneD",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1267,Deployability,integrat,integration,1267,"rovide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) I",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1482,Deployability,integrat,integration,1482,nction using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines th,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1587,Deployability,integrat,integration,1587,Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim; ,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1678,Deployability,integrat,integration,1678,egratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator cla,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1817,Deployability,integrat,integration,1817,he default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1917,Deployability,integrat,integration,1917,:IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Ma,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2024,Deployability,integrat,integration,2024, for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUS,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2151,Deployability,integrat,integration,2151,"ture integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration:",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2256,Deployability,integrat,integration,2256,"rnal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  RO",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2351,Deployability,integrat,integrator,2351,"rnal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  RO",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2480,Deployability,integrat,integration,2480,"rnal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  RO",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2599,Deployability,integrat,integration,2599,"ore...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESING",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2804,Deployability,integrat,integration,2804,"mensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3269,Deployability,integrat,integration,3269,"ods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. .",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3299,Deployability,integrat,integration,3299,"ods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. .",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3685,Deployability,integrat,integration,3685,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3837,Deployability,integrat,integration,3837,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3867,Deployability,integrat,integration,3867,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4089,Deployability,integrat,integration,4089,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4196,Deployability,integrat,integration,4196,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4258,Deployability,integrat,integration,4258,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4375,Deployability,integrat,integration,4375,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:372,Energy Efficiency,adapt,adaptive,372,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:389,Energy Efficiency,adapt,adaptive,389,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:465,Energy Efficiency,adapt,adaptive,465,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1108,Energy Efficiency,adapt,adaptive,1108,"odules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneD",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4366,Energy Efficiency,adapt,adaptive,4366,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:252,Integrability,integrat,integration,252,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:317,Integrability,integrat,integration,317,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:414,Integrability,integrat,integration,414,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:591,Integrability,interface,interface,591,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:693,Integrability,interface,interface,693,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1128,Integrability,integrat,integration,1128,"odules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneD",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1267,Integrability,integrat,integration,1267,"rovide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) I",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1482,Integrability,integrat,integration,1482,nction using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines th,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1587,Integrability,integrat,integration,1587,Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim; ,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1678,Integrability,integrat,integration,1678,egratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator cla,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1817,Integrability,integrat,integration,1817,he default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1917,Integrability,integrat,integration,1917,:IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Ma,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2024,Integrability,integrat,integration,2024, for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUS,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2151,Integrability,integrat,integration,2151,"ture integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration:",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2256,Integrability,integrat,integration,2256,"rnal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  RO",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2351,Integrability,integrat,integrator,2351,"rnal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  RO",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2480,Integrability,integrat,integration,2480,"rnal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  RO",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2599,Integrability,integrat,integration,2599,"ore...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESING",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2804,Integrability,integrat,integration,2804,"mensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3269,Integrability,integrat,integration,3269,"ods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. .",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3299,Integrability,integrat,integration,3299,"ods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. .",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3685,Integrability,integrat,integration,3685,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3837,Integrability,integrat,integration,3837,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:3867,Integrability,integrat,integration,3867,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4089,Integrability,integrat,integration,4089,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4196,Integrability,integrat,integration,4196,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4258,Integrability,integrat,integration,4258,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4375,Integrability,integrat,integration,4375,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:372,Modifiability,adapt,adaptive,372,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:389,Modifiability,adapt,adaptive,389,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:465,Modifiability,adapt,adaptive,465,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:754,Modifiability,config,configured,754,". ROOT: Numerical Integration. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class fo",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1108,Modifiability,adapt,adaptive,1108,"odules |; Classes |; Enumerations ; Numerical IntegrationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for numerical integration of functions. ; These classes provide algorithms for integration of one-dimensional functions, with several adaptive and non-adaptive methods and for integration of multi-dimensional function using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneD",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4366,Modifiability,adapt,adaptive,4366,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1462,Performance,perform,performing,1462,nction using an adaptive method or MonteCarlo Integration (GSLMCIntegrator). The basic classes ROOT::Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines th,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1567,Performance,perform,performing,1567,Math::IntegratorOneDim provides a common interface for the one-dimensional methods while the class ROOT::Math::IntegratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim; ,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1657,Performance,perform,performing,1657,egratorMultiDim provides the interface for the multi-dimensional ones. The methods can be configured (e.g setting the default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator cla,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:1789,Performance,perform,performing,1789,he default method with its default parameters) using the ROOT::Math::IntegratorOneDimOptions and ROOT::Math::IntegratorMultiDimOptions classes. . Modules;  Numerical Monte Carlo Integration Classes;  Classes implementing method for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:2003,Performance,perform,performing,2003, for Monte Carlo Integration. ;  . Classes; class  ROOT::Math::AdaptiveIntegratorMultiDim;  Class for adaptive quadrature integration in multi-dimensions using rectangular regions. More...;  ; class  ROOT::Math::BaseIntegratorOptions;  Base class for Numerical integration options common in 1D and multi-dimension This is an internal class and is not supposed to be instantiated by the user. More...;  ; class  ROOT::Math::GaussIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GaussLegendreIntegrator;  User class for performing function integration. More...;  ; class  ROOT::Math::GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorMultiDim;  User class for performing multidimensional integration. More...;  ; class  ROOT::Math::IntegratorMultiDimOptions;  Numerical multi dimensional integration options. More...;  ; class  ROOT::Math::IntegratorOneDim;  User Class for performing numerical integration of a function in one dimension. More...;  ; class  ROOT::Math::IntegratorOneDimOptions;  Numerical one dimensional integration options. More...;  ; class  ROOT::Math::VirtualIntegrator;  Abstract class for all numerical integration methods (1D and multi-dim) Interface defining the common methods for the numerical integrator classes of one and multi dimensions The derived class VirtualIntegratorOneDim defines the methods for one-dimensional integration. More...;  ; class  ROOT::Math::VirtualIntegratorMultiDim;  Interface (abstract) class for multi numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUS,MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Integration.html:4183,Usability,simpl,simple,4183,"lasses like ROOT::Math::GSLMCIntegrator. More...;  ; class  ROOT::Math::VirtualIntegratorOneDim;  Interface (abstract) class for 1D numerical integration It must be implemented by the concrete Integrator classes like ROOT::Math::GSLIntegrator. More...;  . Enumerations; enum  ROOT::Math::Integration::GKRule { ;   ROOT::Math::Integration::kGAUSS15 = 1; , ROOT::Math::Integration::kGAUSS21 = 2; , ROOT::Math::Integration::kGAUSS31 = 3; , ROOT::Math::Integration::kGAUSS41 = 4; , ;   ROOT::Math::Integration::kGAUSS51 = 5; , ROOT::Math::Integration::kGAUSS61 = 6. };  enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type More...;  ; enum  ROOT::Math::IntegrationOneDim::Type { ;   ROOT::Math::IntegrationOneDim::kDEFAULT = -1; , ROOT::Math::IntegrationOneDim::kGAUSS; , ROOT::Math::IntegrationOneDim::kLEGENDRE; , ROOT::Math::IntegrationOneDim::kADAPTIVE; , ;   ROOT::Math::IntegrationOneDim::kADAPTIVESINGULAR; , ROOT::Math::IntegrationOneDim::kNONADAPTIVE. };  enumeration specifying the integration types. More...;  . Enumeration Type Documentation. ◆ GKRule. enum ROOT::Math::Integration::GKRule. enumeration specifying the Gauss-KronRod integration rule for ADAPTIVE integration type . EnumeratorkGAUSS15 ; kGAUSS21 ; kGAUSS31 ; kGAUSS41 ; kGAUSS51 ; kGAUSS61 . Definition at line 58 of file IntegrationTypes.h. ◆ Type. enum ROOT::Math::IntegrationOneDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static options . kGAUSS simple Gauss integration method with fixed rule . kLEGENDRE Gauss-Legendre integration. . kADAPTIVE to be used for general functions without singularities . kADAPTIVESINGULAR default adaptive integration type which can be used in the case of the presence of singularities. . kNONADAPTIVE to be used for smooth functions . Definition at line 32 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Integration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Integration.html
https://root.cern/doc/master/group__Interpolation.html:845,Availability,avail,availables,845,". ROOT: Interpolation Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Interpolation ClassesMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for interpolation of points. . Classes; class  ROOT::Math::GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  ROOT::Math::Interpolator;  Class for performing function interpolation of points. More...;  . Enumerations; enum  ROOT::Math::Interpolation::Type { ;   ROOT::Math::Interpolation::kLINEAR; , ROOT::Math::Interpolation::kPOLYNOMIAL; , ROOT::Math::Interpolation::kCSPLINE; , ROOT::Math::Interpolation::kCSPLINE_PERIODIC; , ;   ROOT::Math::Interpolation::kAKIMA; , ROOT::Math::Interpolation::kAKIMA_PERIODIC. };  Enumeration defining the types of interpolation methods availables. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Interpolation::Type. Enumeration defining the types of interpolation methods availables. ; Passed as argument to instantiate mathlib::Interpolator objects. The types available are (more information is available in the GSL manual): . LINEAR interpolation; . POLYNOMIAL interpolation, to be used for small number of points since introduces large oscillations; . CSPLINE cubic spline with natural boundary conditions; . CSPLINE_PERIODIC cubic spline with periodic boundary conditions; . AKIMA, Akima spline with natural boundary conditions ( requires a minimum of 5 points); . AKIMA_PERIODIC, Akima spline with periodic boundaries ( requires a minimum of 5 points); . EnumeratorkLINEAR ; kPOLYNOMIAL ; kCSPLINE ; kCSPLINE_PERIODIC ; kAKIMA ; kAKIMA_PERIODIC . Definition at line 60 of file InterpolationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Interpolation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Interpolation.html
https://root.cern/doc/master/group__Interpolation.html:1003,Availability,avail,availables,1003,". ROOT: Interpolation Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Interpolation ClassesMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for interpolation of points. . Classes; class  ROOT::Math::GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  ROOT::Math::Interpolator;  Class for performing function interpolation of points. More...;  . Enumerations; enum  ROOT::Math::Interpolation::Type { ;   ROOT::Math::Interpolation::kLINEAR; , ROOT::Math::Interpolation::kPOLYNOMIAL; , ROOT::Math::Interpolation::kCSPLINE; , ROOT::Math::Interpolation::kCSPLINE_PERIODIC; , ;   ROOT::Math::Interpolation::kAKIMA; , ROOT::Math::Interpolation::kAKIMA_PERIODIC. };  Enumeration defining the types of interpolation methods availables. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Interpolation::Type. Enumeration defining the types of interpolation methods availables. ; Passed as argument to instantiate mathlib::Interpolator objects. The types available are (more information is available in the GSL manual): . LINEAR interpolation; . POLYNOMIAL interpolation, to be used for small number of points since introduces large oscillations; . CSPLINE cubic spline with natural boundary conditions; . CSPLINE_PERIODIC cubic spline with periodic boundary conditions; . AKIMA, Akima spline with natural boundary conditions ( requires a minimum of 5 points); . AKIMA_PERIODIC, Akima spline with periodic boundaries ( requires a minimum of 5 points); . EnumeratorkLINEAR ; kPOLYNOMIAL ; kCSPLINE ; kCSPLINE_PERIODIC ; kAKIMA ; kAKIMA_PERIODIC . Definition at line 60 of file InterpolationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Interpolation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Interpolation.html
https://root.cern/doc/master/group__Interpolation.html:1092,Availability,avail,available,1092,". ROOT: Interpolation Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Interpolation ClassesMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for interpolation of points. . Classes; class  ROOT::Math::GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  ROOT::Math::Interpolator;  Class for performing function interpolation of points. More...;  . Enumerations; enum  ROOT::Math::Interpolation::Type { ;   ROOT::Math::Interpolation::kLINEAR; , ROOT::Math::Interpolation::kPOLYNOMIAL; , ROOT::Math::Interpolation::kCSPLINE; , ROOT::Math::Interpolation::kCSPLINE_PERIODIC; , ;   ROOT::Math::Interpolation::kAKIMA; , ROOT::Math::Interpolation::kAKIMA_PERIODIC. };  Enumeration defining the types of interpolation methods availables. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Interpolation::Type. Enumeration defining the types of interpolation methods availables. ; Passed as argument to instantiate mathlib::Interpolator objects. The types available are (more information is available in the GSL manual): . LINEAR interpolation; . POLYNOMIAL interpolation, to be used for small number of points since introduces large oscillations; . CSPLINE cubic spline with natural boundary conditions; . CSPLINE_PERIODIC cubic spline with periodic boundary conditions; . AKIMA, Akima spline with natural boundary conditions ( requires a minimum of 5 points); . AKIMA_PERIODIC, Akima spline with periodic boundaries ( requires a minimum of 5 points); . EnumeratorkLINEAR ; kPOLYNOMIAL ; kCSPLINE ; kCSPLINE_PERIODIC ; kAKIMA ; kAKIMA_PERIODIC . Definition at line 60 of file InterpolationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Interpolation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Interpolation.html
https://root.cern/doc/master/group__Interpolation.html:1127,Availability,avail,available,1127,". ROOT: Interpolation Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Interpolation ClassesMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for interpolation of points. . Classes; class  ROOT::Math::GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  ROOT::Math::Interpolator;  Class for performing function interpolation of points. More...;  . Enumerations; enum  ROOT::Math::Interpolation::Type { ;   ROOT::Math::Interpolation::kLINEAR; , ROOT::Math::Interpolation::kPOLYNOMIAL; , ROOT::Math::Interpolation::kCSPLINE; , ROOT::Math::Interpolation::kCSPLINE_PERIODIC; , ;   ROOT::Math::Interpolation::kAKIMA; , ROOT::Math::Interpolation::kAKIMA_PERIODIC. };  Enumeration defining the types of interpolation methods availables. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Interpolation::Type. Enumeration defining the types of interpolation methods availables. ; Passed as argument to instantiate mathlib::Interpolator objects. The types available are (more information is available in the GSL manual): . LINEAR interpolation; . POLYNOMIAL interpolation, to be used for small number of points since introduces large oscillations; . CSPLINE cubic spline with natural boundary conditions; . CSPLINE_PERIODIC cubic spline with periodic boundary conditions; . AKIMA, Akima spline with natural boundary conditions ( requires a minimum of 5 points); . AKIMA_PERIODIC, Akima spline with periodic boundaries ( requires a minimum of 5 points); . EnumeratorkLINEAR ; kPOLYNOMIAL ; kCSPLINE ; kCSPLINE_PERIODIC ; kAKIMA ; kAKIMA_PERIODIC . Definition at line 60 of file InterpolationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Interpolation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Interpolation.html
https://root.cern/doc/master/group__Interpolation.html:418,Performance,perform,performing,418,". ROOT: Interpolation Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Interpolation ClassesMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for interpolation of points. . Classes; class  ROOT::Math::GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  ROOT::Math::Interpolator;  Class for performing function interpolation of points. More...;  . Enumerations; enum  ROOT::Math::Interpolation::Type { ;   ROOT::Math::Interpolation::kLINEAR; , ROOT::Math::Interpolation::kPOLYNOMIAL; , ROOT::Math::Interpolation::kCSPLINE; , ROOT::Math::Interpolation::kCSPLINE_PERIODIC; , ;   ROOT::Math::Interpolation::kAKIMA; , ROOT::Math::Interpolation::kAKIMA_PERIODIC. };  Enumeration defining the types of interpolation methods availables. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Interpolation::Type. Enumeration defining the types of interpolation methods availables. ; Passed as argument to instantiate mathlib::Interpolator objects. The types available are (more information is available in the GSL manual): . LINEAR interpolation; . POLYNOMIAL interpolation, to be used for small number of points since introduces large oscillations; . CSPLINE cubic spline with natural boundary conditions; . CSPLINE_PERIODIC cubic spline with periodic boundary conditions; . AKIMA, Akima spline with natural boundary conditions ( requires a minimum of 5 points); . AKIMA_PERIODIC, Akima spline with periodic boundaries ( requires a minimum of 5 points); . EnumeratorkLINEAR ; kPOLYNOMIAL ; kCSPLINE ; kCSPLINE_PERIODIC ; kAKIMA ; kAKIMA_PERIODIC . Definition at line 60 of file InterpolationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Interpolation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Interpolation.html
https://root.cern/doc/master/group__IO.html:568,Availability,avail,available,568,". ROOT: Input/Output Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Input/Output Library. ; The library collecting the ROOT classes dedicated to data input and output.; For an overview of I/O in ROOT, see the following pages in the ROOT manual:. ROOT files; Trees: ROOT's columnar storage; I/O concepts: a collection of more advanced I/O-related topics; I/O of custom classes: how to read and write user-defined C++ objects. For ROOT I/O developers, a detailed internal description of the ROOT files layout is also available. . Classes; class  ROOT::Internal::RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  ROOT::Internal::RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  ROOT::Internal::RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  ROOT::Internal::RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  TArchiveFile;  Class describing an archive file containing multiple sub-files, like a ZIP or TAR archive. More...;  ; class  TBufferFile;  The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket. More...;  ; class  TBufferIO;  Direct subclass of TBuffer, implements common methods for TBufferFile and TBufferText classes. More...;  ; class  TBufferJSON;  Class for serializing object to and from JavaScript Object Notation (JSON) format. More...;  ; class  ROOT::TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  ROOT::TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TBufferSQL2;  Converts data to SQL statements or read data from SQL tables. More...;  ; class  TBufferTex",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:6710,Deployability,release,release,6710,". More...;  ; class  TSAXParser;  TSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TVirtualCollectionIterators;  Small helper class to generically acquire and release iterators. More...;  ; class  TVirtualCollectionPtrIterators;  ; class  TVirtualObject;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TXMLAttr;  TXMLAttribute is the attribute of an Element. More...;  ; class  TXMLDocument;  TXMLDocument contains a pointer to an xmlDoc structure, after the parser returns a tree built during the document analysis. More...;  ; class  TXMLNode;  TXMLNode contains a pointer to xmlNode, which is a node under the DOM tree. More...;  ; class  TXMLParser;  TXMLParser is an abstract class which interfaces with Libxml2. More...;  ; class  TZIPFile;  Describes a ZIP archive file containing multiple sub-files. More...;  ; class  TZIPMember;  A ZIP archive consists of files compressed with the popular ZLIB compression algorithm; this class records the information about a single archive member. More...;  . ROOT maste",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:759,Integrability,wrap,wraps,759,". ROOT: Input/Output Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Input/Output Library. ; The library collecting the ROOT classes dedicated to data input and output.; For an overview of I/O in ROOT, see the following pages in the ROOT manual:. ROOT files; Trees: ROOT's columnar storage; I/O concepts: a collection of more advanced I/O-related topics; I/O of custom classes: how to read and write user-defined C++ objects. For ROOT I/O developers, a detailed internal description of the ROOT files layout is also available. . Classes; class  ROOT::Internal::RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  ROOT::Internal::RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  ROOT::Internal::RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  ROOT::Internal::RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  TArchiveFile;  Class describing an archive file containing multiple sub-files, like a ZIP or TAR archive. More...;  ; class  TBufferFile;  The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket. More...;  ; class  TBufferIO;  Direct subclass of TBuffer, implements common methods for TBufferFile and TBufferText classes. More...;  ; class  TBufferJSON;  Class for serializing object to and from JavaScript Object Notation (JSON) format. More...;  ; class  ROOT::TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  ROOT::TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TBufferSQL2;  Converts data to SQL statements or read data from SQL tables. More...;  ; class  TBufferTex",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:5667,Integrability,protocol,protocol,5667,"l optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space in a file, create I/O buffers, to fill them, (un)compress them. More...;  ; class  TKeyMapFile;  Utility class for browsing TMapFile objects. More...;  ; class  TKeySQL;  TKeySQL represents meta-information about object, which was written to SQL database. More...;  ; class  TLockFile;  A scoped lock based on files. More...;  ; class  TMapFile;  This class implements a shared memory region mapped to a file. More...;  ; class  TMapRec;  Keep track of an object in the mapped file. More...;  ; class  TMemFile;  A TMemFile is like a normal TFile except that it reads and writes only from memory. More...;  ; class  TNetFile;  A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). More...;  ; class  TS3WebFile;  A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of the Amazon S3 protocol. More...;  ; class  TSAXParser;  TSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Re",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:5757,Integrability,wrap,wraper,5757,"e I/O buffers, to fill them, (un)compress them. More...;  ; class  TKeyMapFile;  Utility class for browsing TMapFile objects. More...;  ; class  TKeySQL;  TKeySQL represents meta-information about object, which was written to SQL database. More...;  ; class  TLockFile;  A scoped lock based on files. More...;  ; class  TMapFile;  This class implements a shared memory region mapped to a file. More...;  ; class  TMapRec;  Keep track of an object in the mapped file. More...;  ; class  TMemFile;  A TMemFile is like a normal TFile except that it reads and writes only from memory. More...;  ; class  TNetFile;  A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). More...;  ; class  TS3WebFile;  A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of the Amazon S3 protocol. More...;  ; class  TSAXParser;  TSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TVirtualCollectionIterators;  Small helper class to generically acquire and release iterators. More...",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:5980,Integrability,interface,interface,5980,"h was written to SQL database. More...;  ; class  TLockFile;  A scoped lock based on files. More...;  ; class  TMapFile;  This class implements a shared memory region mapped to a file. More...;  ; class  TMapRec;  Keep track of an object in the mapped file. More...;  ; class  TMemFile;  A TMemFile is like a normal TFile except that it reads and writes only from memory. More...;  ; class  TNetFile;  A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). More...;  ; class  TS3WebFile;  A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of the Amazon S3 protocol. More...;  ; class  TSAXParser;  TSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TVirtualCollectionIterators;  Small helper class to generically acquire and release iterators. More...;  ; class  TVirtualCollectionPtrIterators;  ; class  TVirtualObject;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. Mor",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:7352,Integrability,interface,interfaces,7352," to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TVirtualCollectionIterators;  Small helper class to generically acquire and release iterators. More...;  ; class  TVirtualCollectionPtrIterators;  ; class  TVirtualObject;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TXMLAttr;  TXMLAttribute is the attribute of an Element. More...;  ; class  TXMLDocument;  TXMLDocument contains a pointer to an xmlDoc structure, after the parser returns a tree built during the document analysis. More...;  ; class  TXMLNode;  TXMLNode contains a pointer to xmlNode, which is a node under the DOM tree. More...;  ; class  TXMLParser;  TXMLParser is an abstract class which interfaces with Libxml2. More...;  ; class  TZIPFile;  Describes a ZIP archive file containing multiple sub-files. More...;  ; class  TZIPMember;  A ZIP archive consists of files compressed with the popular ZLIB compression algorithm; this class records the information about a single archive member. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:1011,Modifiability,portab,portable,1011,". ROOT: Input/Output Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Input/Output Library. ; The library collecting the ROOT classes dedicated to data input and output.; For an overview of I/O in ROOT, see the following pages in the ROOT manual:. ROOT files; Trees: ROOT's columnar storage; I/O concepts: a collection of more advanced I/O-related topics; I/O of custom classes: how to read and write user-defined C++ objects. For ROOT I/O developers, a detailed internal description of the ROOT files layout is also available. . Classes; class  ROOT::Internal::RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  ROOT::Internal::RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  ROOT::Internal::RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  ROOT::Internal::RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  TArchiveFile;  Class describing an archive file containing multiple sub-files, like a ZIP or TAR archive. More...;  ; class  TBufferFile;  The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket. More...;  ; class  TBufferIO;  Direct subclass of TBuffer, implements common methods for TBufferFile and TBufferText classes. More...;  ; class  TBufferJSON;  Class for serializing object to and from JavaScript Object Notation (JSON) format. More...;  ; class  ROOT::TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  ROOT::TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TBufferSQL2;  Converts data to SQL statements or read data from SQL tables. More...;  ; class  TBufferTex",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:1870,Performance,queue,queue,1870," ownership. More...;  ; class  ROOT::Internal::RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  ROOT::Internal::RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  TArchiveFile;  Class describing an archive file containing multiple sub-files, like a ZIP or TAR archive. More...;  ; class  TBufferFile;  The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket. More...;  ; class  TBufferIO;  Direct subclass of TBuffer, implements common methods for TBufferFile and TBufferText classes. More...;  ; class  TBufferJSON;  Class for serializing object to and from JavaScript Object Notation (JSON) format. More...;  ; class  ROOT::TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  ROOT::TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TBufferSQL2;  Converts data to SQL statements or read data from SQL tables. More...;  ; class  TBufferText;  Base class for text-based streamers like TBufferJSON or TBufferXML Special actions list will use methods, introduced in this class. More...;  ; class  TBufferXML;  Class for serializing/deserializing object to/from xml. More...;  ; class  TCollectionClassStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TCollectionMemberStreamer;  Class streamer object to implement TMemberStreamer functionality for I/O emulation. More...;  ; class  TCollectionStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TStreamerInfoActions::TConfiguration;  Base class of the Configurations. More...;  ; class  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClo",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:3713,Performance,cache,cache,3713,"  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClonesArray into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:3795,Performance,cache,cache,3795,"Array into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space in a file, create I/O buffers, to fill them, (un)compress them. More...;  ; clas",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:4600,Performance,optimiz,optimization,4600,"in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space in a file, create I/O buffers, to fill them, (un)compress them. More...;  ; class  TKeyMapFile;  Utility class for browsing TMapFile objects. More...;  ; class  TKeySQL;  TKeySQL represents meta-information about object, which was written to SQL database. More...;  ; class  TLockFile;  A scoped lock based on files. More...;  ; class  TMapFile;  This class implements a shared memory region mapped to a file. More...;  ; class  TMapRec;  Keep track of an object in the mapped file. More...;  ; class  TMemFile;  A TMemFile is like a normal TFile except that it reads and writes only from memory. More...;  ; class  TNetFile;  A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). More...;  ; class  TS3WebFile;  A TS3WebFile is a TWebFile which retrieves th",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:4663,Performance,optimiz,optimization,4663,"rectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space in a file, create I/O buffers, to fill them, (un)compress them. More...;  ; class  TKeyMapFile;  Utility class for browsing TMapFile objects. More...;  ; class  TKeySQL;  TKeySQL represents meta-information about object, which was written to SQL database. More...;  ; class  TLockFile;  A scoped lock based on files. More...;  ; class  TMapFile;  This class implements a shared memory region mapped to a file. More...;  ; class  TMapRec;  Keep track of an object in the mapped file. More...;  ; class  TMemFile;  A TMemFile is like a normal TFile except that it reads and writes only from memory. More...;  ; class  TNetFile;  A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). More...;  ; class  TS3WebFile;  A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of th",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:656,Security,access,access,656,". ROOT: Input/Output Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Input/Output Library. ; The library collecting the ROOT classes dedicated to data input and output.; For an overview of I/O in ROOT, see the following pages in the ROOT manual:. ROOT files; Trees: ROOT's columnar storage; I/O concepts: a collection of more advanced I/O-related topics; I/O of custom classes: how to read and write user-defined C++ objects. For ROOT I/O developers, a detailed internal description of the ROOT files layout is also available. . Classes; class  ROOT::Internal::RRawFile;  The RRawFile provides read-only access to local and remote files. More...;  ; class  ROOT::Internal::RRawFileTFile;  The RRawFileTFile wraps an open TFile, but does not take ownership. More...;  ; class  ROOT::Internal::RRawFileUnix;  The RRawFileUnix class uses POSIX calls to read from a mounted file system. More...;  ; class  ROOT::Internal::RRawFileWin;  The RRawFileWin class uses portable C I/O calls to read from a drive. More...;  ; class  TArchiveFile;  Class describing an archive file containing multiple sub-files, like a ZIP or TAR archive. More...;  ; class  TBufferFile;  The concrete implementation of TBuffer for writing/reading to/from a ROOT file or socket. More...;  ; class  TBufferIO;  Direct subclass of TBuffer, implements common methods for TBufferFile and TBufferText classes. More...;  ; class  TBufferJSON;  Class for serializing object to and from JavaScript Object Notation (JSON) format. More...;  ; class  ROOT::TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  ROOT::TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TBufferSQL2;  Converts data to SQL statements or read data from SQL tables. More...;  ; class  TBufferTex",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:3221,Security,access,accessing,3221,"izing object to/from xml. More...;  ; class  TCollectionClassStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TCollectionMemberStreamer;  Class streamer object to implement TMemberStreamer functionality for I/O emulation. More...;  ; class  TCollectionStreamer;  Class streamer object to implement TClassStreamer functionality for I/O emulation. More...;  ; class  TStreamerInfoActions::TConfiguration;  Base class of the Configurations. More...;  ; class  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClonesArray into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This cl",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:6525,Security,access,access,6525,"S3WebFile;  A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of the Amazon S3 protocol. More...;  ; class  TSAXParser;  TSAXParser is a subclass of TXMLParser, it is a wraper class to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TVirtualCollectionIterators;  Small helper class to generically acquire and release iterators. More...;  ; class  TVirtualCollectionPtrIterators;  ; class  TVirtualObject;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TXMLAttr;  TXMLAttribute is the attribute of an Element. More...;  ; class  TXMLDocument;  TXMLDocument contains a pointer to an xmlDoc structure, after the parser returns a tree built during the document analysis. More...;  ; class  TXMLNode;  TXMLNode contains a pointer to xmlNode, which is a node under the DOM tree. More...;  ; class  TXMLParser;  TXMLParser is an abstract class which interfaces with Libxml2. More...;  ; class  TZIPFile;  Describes a ZIP archive file containing multiple sub-files. More...;  ; class  TZIPMember;  A ZIP archive consists of files co",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:6852,Security,access,access,6852," to libxml library. More...;  ; class  TSQLClassInfo;  Contains information about tables specific to one class and version. More...;  ; class  TSQLColumnData;  ; class  TSQLFile;  Access an SQL db via the TFile interface. More...;  ; class  TSQLObjectData;  TSQLObjectData is used in TBufferSQL2 class in reading procedure. More...;  ; class  TSQLObjectDataPool;  XML object keeper class. More...;  ; class  TSQLObjectInfo;  Info (classname, version) about object in database. More...;  ; class  TSQLStructure;  This is hierarchical structure, which is created when data is written by TBufferSQL2. More...;  ; class  TStreamerInfo;  Describes a persistent version of a class. More...;  ; class  TVirtualArray;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TVirtualCollectionIterators;  Small helper class to generically acquire and release iterators. More...;  ; class  TVirtualCollectionPtrIterators;  ; class  TVirtualObject;  Wrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary. More...;  ; class  TXMLAttr;  TXMLAttribute is the attribute of an Element. More...;  ; class  TXMLDocument;  TXMLDocument contains a pointer to an xmlDoc structure, after the parser returns a tree built during the document analysis. More...;  ; class  TXMLNode;  TXMLNode contains a pointer to xmlNode, which is a node under the DOM tree. More...;  ; class  TXMLParser;  TXMLParser is an abstract class which interfaces with Libxml2. More...;  ; class  TZIPFile;  Describes a ZIP archive file containing multiple sub-files. More...;  ; class  TZIPMember;  A ZIP archive consists of files compressed with the popular ZLIB compression algorithm; this class records the information about a single archive member. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__IO.html:3611,Testability,log,logical,3611," ; class  TStreamerInfoActions::TConfiguration;  Base class of the Configurations. More...;  ; class  TConvertClonesArrayToProxy;  Small helper to read a TBuffer containing a TClonesArray into any valid collection. More...;  ; class  TDCacheFile;  A TDCacheFile is like a normal TFile except that it may read and write its data via a dCache server (for more on the dCache daemon see http://www-dcache.desy.de/. More...;  ; class  TDirectoryFile;  A ROOT file is structured in Directories (like a file system). More...;  ; class  TDomParser;  DOM stands for the Document Object Model; this is an API for accessing XML or HTML structured documents. More...;  ; class  TEmulatedCollectionProxy;  Streamer around an arbitrary STL like container, which implements basic container functionality. More...;  ; class  TEmulatedMapProxy;  Streamer around a map container. More...;  ; class  TFile;  A ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-like logical structure, possibly including subdirectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class.",MatchSource.WIKI,doc/master/group__IO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__IO.html
https://root.cern/doc/master/group__Materials__classes.html:2211,Energy Efficiency,charge,charge,2211,"order to make easier material and mixture creation, one can use the pre-built table of elements owned by TGeoManager class:; TGeoElementTable *table = gGeoManager->GetElementTable();; TGeoElement *element1 = table->GetElement(Int_t Z);; TGeoElement *element2 = table->FindElement(""Copper"");; Int_tint Int_tDefinition RtypesCore.h:45; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoElementTableTable of elements.Definition TGeoElement.h:398; TGeoElementTable::GetElementTGeoElement * GetElement(Int_t z)Definition TGeoElement.h:435; TGeoElementTable::FindElementTGeoElement * FindElement(const char *name) constSearch an element by symbol or full name Exact matching.Definition TGeoElement.cxx:1334; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoManager::GetElementTableTGeoElementTable * GetElementTable()Returns material table. Creates it if not existing.Definition TGeoManager.cxx:3624; Materials made of single elements can be defined by their atomic mass (A), charge (Z) and density (rho). One can also create a material by specifying the element that it is made of. Optionally the radiation and absorption lengths can be also provided; otherwise they can be computed on-demand [G3]. The class representing them is TGeoMaterial:; TGeoMaterial(const char *name,Double_t a,Double_t z,; Double_t density, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); a#define a(i)Definition RSha256.hxx:99; Double_tdouble Double_tDefinition RtypesCore.h:59; namechar name[80]Definition TGX11.cxx:110; STP_temperaturestatic const Double_t STP_temperatureDefinition TGeoMaterial.h:31; STP_pressurestatic const Double_t STP_pressureDefinition TGeoMaterial.h:32; TGeoMaterialBase class describing materia",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:5495,Energy Efficiency,charge,charge,5495,"f several elements. They are represented by the class TGeoMixture, deriving from TGeoMaterial and defined by their number of components and the density:; TGeoMixture(const char *name,Int_t nel,Double_t rho);; TGeoMixtureMixtures of elements.Definition TGeoMaterial.h:159; Elements have to be further defined one by one:; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *g",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:6122,Energy Efficiency,energy,energy,6122,"_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info a",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:7520,Energy Efficiency,charge,charge,7520,"s and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; N#define N; TGeoElemIterI",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:7656,Energy Efficiency,energy,energy,7656,"rint();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; N#define N; TGeoElemIterIterator for decay branches.Definition TGeoElement.h:358; T1#define T1Definition md5.inl:146; To create a radioactive material based on a radionuclide, one should use the constructor:; TGeoMaterial(const char *name, TGeoElement *elem,",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:3598,Integrability,interface,interfaced,3598,"y, Double_t radlen=0,Double_t intlen=0);; TGeoMaterial(const char *name, TGeoElement *elem,; Double_t density);; TGeoMaterial(const char* name, Double_t a, Double_t z,; Double_t rho,; TGeoMaterial::EGeoMaterialState state,; Double_t temperature = STP_temperature,; Double_t pressure = STP_pressure); a#define a(i)Definition RSha256.hxx:99; Double_tdouble Double_tDefinition RtypesCore.h:59; namechar name[80]Definition TGX11.cxx:110; STP_temperaturestatic const Double_t STP_temperatureDefinition TGeoMaterial.h:31; STP_pressurestatic const Double_t STP_pressureDefinition TGeoMaterial.h:32; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::EGeoMaterialStateEGeoMaterialStateDefinition TGeoMaterial.h:37; Any material or derived class is automatically indexed after creation. The assigned index is corresponding to the last entry in the list of materials owned by TGeoManager class. This can be changed using the TGeoMaterial::SetIndex() method, however it is not recommended while using the geometry package interfaced with a transport MC. Radiation and absorption lengths can be set using:; TGeoMaterial::SetRadLen(Double_t radlen, Double_t intlen);; TGeoMaterial::SetRadLenvoid SetRadLen(Double_t radlen, Double_t intlen=0.)Set radiation/absorption lengths.Definition TGeoMaterial.cxx:496. radlen: radiation length. If radlen<=0 the value is computed using GSMATE algorithm in GEANT3; intlen: absorption length. Material state, temperature and pressure can be changed via setters. Another material property is transparency. It can be defined and used while viewing the geometry with OpenGL.; void SetTransparency (Char_t transparency = 0); Char_tchar Char_tDefinition RtypesCore.h:37. transparency: between 0 (opaque default) to 100 (fully transparent). One can attach to a material a user-defined object storing Cerenkov properties. Another hook for material shading properties is currently not in use. Mixtures are materials made of several elements. They ",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:5825,Integrability,interface,interfaces,5825,"ial.h:159; Elements have to be further defined one by one:; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV]",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:6014,Integrability,depend,depend,6014,"_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:10068,Integrability,depend,depending,10068,"t to the mixture using fraction by weight Check if the element is already definedDefinition TGeoMaterial.cxx:869; Once defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the next two methods:; Method 1; TGeoMaterial::FillMaterialEvolution(TObjArray *population, Double_t precision=0.001); TGeoMaterial::FillMaterialEvolutionvirtual void FillMaterialEvolution(TObjArray *population, Double_t precision=0.001)Fills a user array with all the elements deriving from the possible decay of the top element composin...Definition TGeoMaterial.cxx:742; TObjArrayAn array of TObjects.Definition TObjArray.h:31; To use this method, one has to provide an empty TObjArray object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered. The population list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:; Bool_t TGeoElement::IsRadioNuclide() const; Bool_tbool Bool_tDefinition RtypesCore.h:63; TGeoElement::IsRadioNuclidevirtual Bool_t IsRadioNuclide() constDefinition TGeoElement.h:82; All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoBatemanSol::Drawvoid Draw(Option_t *option="""") overrideDraw the solution of Bateman equation versus time.Definition TGeoElement.cxx:1612; TGeoElementRN::RatioTGeoBatemanSol * Ratio() constDefinition TGeoElement.h:188; Method 2; Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:; TGeoMate",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:12517,Integrability,interface,interface,12517,"ure that result from the decay of a initial material/mixture at time, while all resulting elements having a fractional weight less than precision are excluded.; A demo macro for radioactive material features is $ROOTSYS/tutorials/geom/RadioNuclides.C It demonstrates also the decay of a mixture made of radionuclides. Tracking Media; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial; ",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:5811,Modifiability,evolve,evolve,5811,"ial.h:159; Elements have to be further defined one by one:; void TGeoMixture::DefineElement(Int_t iel,Double_t a,Double_t z,; Double_t weigth);; void TGeoMixture::DefineElement(Int_t iel, TGeoElement *elem,; Double_t weight);; void TGeoMixture::DefineElement(Int_t iel, Int_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV]",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:6031,Performance,perform,performing,6031,"_t z, Int_t natoms);; TGeoMixture::DefineElementvoid DefineElement(Int_t iel, Double_t a, Double_t z, Double_t weight)Definition TGeoMaterial.h:226; or:; void AddElement(TGeoMaterial* mat, Double_t weight);; void AddElement(TGeoElement* elem, Double_t weight);; void AddElement(TGeoElement* elem, Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:6341,Performance,load,loaded,6341,", Int_t natoms);; void AddElement(Double_t a, Double_t z, Double_t weight). iel: index of the element[0,nel-1]; a and z: the atomic mass and charge; weight: proportion by mass of the elements; natoms: number of atoms of the element in the molecule making the mixture. The radiation length is automatically computed when all elements are defined. Since tracking MC provide several other ways to create materials/mixtures, the materials classes are likely to evolve as the interfaces to these engines are being developed. Generally in the process of tracking material properties are not enough and more specific media properties have to be defined. These highly depend on the MC performing tracking and sometimes allow the definition of different media properties (e.g. energy or range cuts) for the same material. Radionuclides; A new class TGeoElementRN was introduced in this version to provide support for radioactive nuclides and their decays. A database of 3162 radionuclides can be loaded on demand via the table of elements (TGeoElementTable class). One can make then materials/mixtures based on these radionuclides and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat ",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:12797,Performance,perform,performing,12797,"ties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMedium;  Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC). More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:7452,Security,access,accessed,7452,"s and use them in a geometry; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; TGeoElementRNClass representing a radionuclidevoid TGeoManager::SetDefaultRootUnits() { if ( fgDefaultUnits == kRo...Definition TGeoElement.h:132; TGeoElementRN::Printvoid Print(Option_t *option="""") const overridePrint info about the element;.Definition TGeoElement.cxx:594; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; One can make materials or mixtures from radionuclides:; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; The following properties of radionuclides can be currently accessed via getters in the TGeoElementRN class:; Atomic number and charge (from the base class TGeoElement). Isomeric number (ISO); ENDF code - following the convention: ENDF=10000*Z+100*A+ISO; Isomeric energy level [MeV]; Mass excess [MeV]; Half life [s]; Spin/Parity - can be retrieved with: TGeoElementRN::GetTitle(); Hynalation and ingestion toxicities; List of decays - TGeoElementRN::GetDecays(). The radioactive decays of a radionuclide are represented by the class TGeoDecayChannel and they are stored in a TObjArray. Decay provides:. Decay mode; Variation of isomeric number; Q value for the decay [GeV]; Parent element; Daughter element. Radionuclides are linked one to each other via their decays, until the last element in the decay chain which must be stable. One can iterate decay chains using the iterator TGeoElemIter:; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] while ((elem=next())) next.Print();; 6-C-014 (100% BetaMinus) T1/2=1.81e+11; 7-N-014 stable; N#define N; TGeoElemIterI",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:13019,Security,access,accessing,13019,"ties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMedium;  Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC). More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:10106,Testability,test,test,10106," defined, one can retrieve the time evolution for the radioactive materials/mixtures by using one of the next two methods:; Method 1; TGeoMaterial::FillMaterialEvolution(TObjArray *population, Double_t precision=0.001); TGeoMaterial::FillMaterialEvolutionvirtual void FillMaterialEvolution(TObjArray *population, Double_t precision=0.001)Fills a user array with all the elements deriving from the possible decay of the top element composin...Definition TGeoMaterial.cxx:742; TObjArrayAn array of TObjects.Definition TObjArray.h:31; To use this method, one has to provide an empty TObjArray object that will be filled with all elements coming from the decay chain of the initial radionuclides contained by the material/mixture. The precision represent the cumulative branching ratio for which decay products are still considered. The population list may contain stable elements as well as radionuclides, depending on the initial elements. To test if an element is a radionuclide:; Bool_t TGeoElement::IsRadioNuclide() const; Bool_tbool Bool_tDefinition RtypesCore.h:63; TGeoElement::IsRadioNuclidevirtual Bool_t IsRadioNuclide() constDefinition TGeoElement.h:82; All radionuclides in the output population list have attached objects that represent the time evolution of their fraction of nuclei with respect to the top radionuclide in the decay chain. These objects (Bateman solutions) can be retrieved and drawn:; TGeoBatemanSol *TGeoElementRN::Ratio();; void TGeoBatemanSol::Draw();; TGeoBatemanSolDefinition TGeoElement.h:286; TGeoBatemanSol::Drawvoid Draw(Option_t *option="""") overrideDraw the solution of Bateman equation versus time.Definition TGeoElement.cxx:1612; TGeoElementRN::RatioTGeoBatemanSol * Ratio() constDefinition TGeoElement.h:188; Method 2; Another method allows to create the evolution of a given radioactive material/mixture at a given moment in time:; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); TGeoMaterial::DecayMaterialvirtual TGeoMaterial * Decay",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Materials__classes.html:12647,Usability,simpl,simple,12647,"edia; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMedium;  Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC). More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . ROOT master - Reference Guide Generated on Tue",MatchSource.WIKI,doc/master/group__Materials__classes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html
https://root.cern/doc/master/group__Math.html:4063,Availability,avail,available,4063,"n and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical library providing some advanced functionality and based on GSL. ;  ;  Matrix Linear Algebra;  The ROOT Matrix Linear Algebra package. ;  ;  TMinuit;  The Minuit Minimization package. ;  ;  Minuit2 Minimization Library;  New Object-oriented implementation of the MINUIT minimization package. ;  ;  Legacy Physics Classes;  Legacy physics classes. ;  ;  SMatrix Package;  ;  Unuran;  Universal Non Uniform Random number generator for generating non uniform pseudo-random numbers. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:587,Deployability,integrat,integration,587,". ROOT: Math. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving line",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:3416,Deployability,continuous,continuous,3416," algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / L",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:3554,Deployability,integrat,integrator,3554,"ses:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical l",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:3791,Deployability,install,installation,3791,"ge optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical library providing some advanced functionality and based on GSL. ;  ;  Matrix Linear Algebra;  The ROOT Matrix Linear Algebra package. ;  ;  TMinuit;  The Minuit Minimization package. ;  ;  Minuit2 Minimization Library;  New Object-oriented implementation of the MINUIT",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:460,Integrability,interface,interfaces,460,". ROOT: Math. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving line",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:587,Integrability,integrat,integration,587,". ROOT: Math. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving line",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:784,Integrability,depend,dependent,784,". ROOT: Math. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving line",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:1007,Integrability,interface,interfaces,1007,". ROOT: Math. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules ; Math. ; The ROOT Mathematical Libraries. ; They consist of the following components:. MathCore: a self-consistent minimal set of tools required for the basic numerical computing. It provides the major mathematical functions in the namespaces ROOT::Math and TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving line",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:1302,Integrability,interface,interface,1302," TMath, classes for random number generators, TRandom, class for complex numbers, TComplex, common interfaces for function evaluation and numerical algorithms. Basic implementations of some of the numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of ",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:1637,Integrability,interface,interface,1637,"e numerical algorithms such as integration or derivation, are also provided by MathCore. together with the core classes needed to fit any generic data set.; MathMore: a package incorporating advanced numerical functionality and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix pack",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:1756,Integrability,interface,interface,1756,"ty and dependent on external libraries like the GNU Scientific Library (GSL). It complements the MathCore library by providing a more complete sets of special mathematical functions and implementations of the numerical algorithms interfaces defined in MathCore using GSL.; Minimization and Fitting Libraries Libraries required for numerical minimization and fitting. The minimization libraries include the numerical methods for solving the fitting problem by finding minimum of multi-dimensional function. The current common interface for minimization is the class ROOT::Math::Minimizer and implemented by derived classes in the minimization and fitting libraries. The fitting in ROOT is organized in fitting classes present in MathCore in the (ROOT::Fit namespace) for providing the fitting functionality and the use the minimization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMa",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:3554,Integrability,integrat,integrator,3554,"ses:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp Optimization library with linear and quadratic programming methods. It is based on the Matrix package. Further information is available at the following links:. The Math page in the manual; The Linear Algebra section in the manual; The Fitting histograms page in the manual; [Inventory of Math functions and algorithms] (http://project-mathlibs.web.cern.ch/project-mathlibs/mathTable.html) . Modules;  Physics Vectors;  Vector classes (2D, 3D and 4D / Lorentz vector) and their transformations. ;  ;  MathCore;  The Core Mathematical Library of ROOT. ;  ;  MathMore;  The Mathematical l",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:2684,Performance,perform,perform,2684,"imization libraries via the common interface (ROOT::Math::Minimizer). In detail the minimization libraries, implementing all the new and old minimization interface, include:; Minuit: library providing via a class TMinuit an implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vector",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:2792,Performance,optimiz,optimized,2792,"implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library ",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:2811,Performance,perform,performances,2811,"implementation of the popular MINUIT minimization package. In addition the library contains also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library ",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__Math.html:2941,Performance,optimiz,optimization,2941,"s also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlp",MatchSource.WIKI,doc/master/group__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Math.html
https://root.cern/doc/master/group__MathCore.html:597,Availability,error,error,597,". ROOT: MathCore. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files |; Classes ; MathCoreMath. ; The Core Mathematical Library of ROOT. ; MathCore provides a collection of functions and C++ classes for HEP numerical computing. This library provides only the basic mathematical functions and algorithms and not all the functionality required by the HEP community. More advanced mathematical functionalities is provided by the MathMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tre",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:810,Deployability,continuous,continuous,810,". ROOT: MathCore. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files |; Classes ; MathCoreMath. ; The Core Mathematical Library of ROOT. ; MathCore provides a collection of functions and C++ classes for HEP numerical computing. This library provides only the basic mathematical functions and algorithms and not all the functionality required by the HEP community. More advanced mathematical functionalities is provided by the MathMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tre",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:1403,Deployability,release,release,1403,"hMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests fo",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:2926,Deployability,continuous,continuous,2926,",3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:952,Integrability,wrap,wrap,952,". ROOT: MathCore. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files |; Classes ; MathCoreMath. ; The Core Mathematical Library of ROOT. ; MathCore provides a collection of functions and C++ classes for HEP numerical computing. This library provides only the basic mathematical functions and algorithms and not all the functionality required by the HEP community. More advanced mathematical functionalities is provided by the MathMore. The current set includes classes and functions for:. Basic special functions used in HEP like the gamma, beta and error function;; Statistical functions : mathematical functions used in statistics, such as the probability density functions and the cumulative distributions functions (lower and upper integral of the pdf's) for continuous and discrete distributions.;; Function Classes and Interfaces :; Generic Function Evaluation Interfaces, including helper class to wrap free (static) and non-static member functions; Parametric Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tre",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:3294,Modifiability,variab,variable,3294,",3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:2095,Testability,test,tests,2095," Function Evaluation Interfaces. Numerical algorithms: user classes with (in some cases) basic implementations for:; Numerical Integration; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization and Multi-dimensional Minimization. Fitting and Parameter Estimation :classes for fitting and parameter estimation from a given data set. Note that in this latest release the GenVector (physics and geometry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . ",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathCore.html:2469,Testability,test,tests,2469,"ry vectors for 2,3 and 4 dimensions with their transformations) is not anymore part of MathCore, but is built as a separate library. MathCore contains instead now classes which were originally part of libCore. These include:. TMath : namespace with mathematical functions and basic function algorithms.; TComplex: class for complex numbers.; Random classes: base class TRandom and the derived classes TRandom1, TRandom2 and TRandom3, implementing the pseudo-random number generators.; Other classes, such as; TKDTree for partitioning the data using a kd-Tree and TKDTreeBinning for binning data using a kdTree; ROOT::Math::GoFTest for goodness of fit tests . Modules;  Fitting and Parameter Estimation;  Classes used for fitting (regression analysis) and estimation of parameter values given a data sample. ;  ;  Interface classes for Random number generation;  Pseudo-random numbers generator classes and for generation of random number distributions. ;  ;  Goodness of Fit Tests;  Classical one-dimensional goodness of git tests for unbinned data. ;  ;  Function Classes and Interfaces;  Interfaces (abstract classes) and Base classes used in MathCore and MathMore numerical methods for describing function classes. ;  ;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  . Files; file  RFit.hxx;  . Classes; class  ROOT::Math::Delaunay2D;  Class to generate a Delaunay triangulation of a 2D set of points. More...;  ; class  TKDTreeBinning;  <- TKDTreeBinning - A class providing multidimensional binning -> More...;  ; class  TStatistic;  Statistical variable, defined by its mean and variance (RMS). More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxyg",MatchSource.WIKI,doc/master/group__MathCore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathCore.html
https://root.cern/doc/master/group__MathMore.html:1521,Availability,down,downloaded,1521,"l functions, Mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom num",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MathMore.html:1645,Availability,down,downloaded,1645,"nctions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT master - Referen",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MathMore.html:1410,Deployability,install,installed,1410,"ses and functions for:. Special functions, with all the major functions (Bessel functions, Legendre polynomial, etc..); Statistical functions, Mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various sta",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MathMore.html:2429,Deployability,continuous,continuous,2429,"; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MathMore.html:1315,Integrability,wrap,wrapping,1315,"ension of the functionality provided by the MathCore. The current set includes classes and functions for:. Special functions, with all the major functions (Bessel functions, Legendre polynomial, etc..); Statistical functions, Mathematical functions used in statistics such as probability density functions, cumulative distributions functions and their inverse (quantiles).; Numerical algorithms:; Numerical Integration; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functio",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MathMore.html:1870,Modifiability,config,configure,1870,"; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MathMore.html:1892,Modifiability,config,configure,1892,"; Numerical Monte Carlo Integration Classes; Numerical Differentiation; One-dimensional Root-Finding; One-dimensional Minimization; Multi-dimensional Minimization. Interpolation Classes; Function Approximation (ChebyshevApprox), based on Chebyshev polynomials; Interface classes for Random number generation. The mathematical functions are implemented as a set of free functions in the namespace ROOT::Math. The naming used for the special functions is the same proposed for the C++ standard (see C++ standard extension proposal document). The MathMore library is implemented wrapping in C++ the GNU Scientific Library (GSL). To build MathMore you need to have first GSL installed somewhere in your system. A version of GSL larger or equal 1.8 is required. A tar file of GSL can be downloaded from the GSL Web site, or (for version 1.8) from here. Windows binaries, compiled using Visual Studio 7.1 can be downloaded from this location.; MathMore (and its ROOT CINT dictionary) can be built within ROOT whenever a GSL library is found in the system. Optionally the GSL library and header file location can be specified in the ROOT configure script with configure –with-gsl-incdir=... –with-gsl-libdir=... MathMore links with the GSL static libraries. On some platform (like Linux x86-64) GSL needs to be compiled with the option –with-pic. The source code of MathMore is distributed under the GNU General Public License . Modules;  Numerical Algorithms;  Numerical Algorithm classes from the MathCore and MathMore libraries. ;  ;  Statistical functions;  Probability density functions, cumulative distribution functions and their inverses (quantiles) for various statistical distributions (continuous and discrete). ;  ;  Special functions;  Special mathematical functions. ;  ;  QuasiRandom number generators and distributions;  Classes for generating QuasiRandom numbers and based on GSL. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MathMore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MathMore.html
https://root.cern/doc/master/group__MCIntegration.html:385,Deployability,integrat,integration,385,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:451,Deployability,integrat,integration,451,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:550,Deployability,integrat,integration,550,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:617,Deployability,integrat,integration,617,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:658,Deployability,integrat,integration,658,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1016,Deployability,integrat,integration,1016,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1147,Deployability,integrat,integration,1147,"..; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1270,Deployability,integrat,integration,1270," Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1578,Deployability,integrat,integration,1578,"lements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. E",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1929,Deployability,integrat,integration,1929,"pper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2186,Deployability,integrat,integration,2186,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2603,Deployability,integrat,integration,2603,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2726,Deployability,integrat,integration,2726,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2750,Deployability,integrat,integration,2750,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2775,Deployability,integrat,integration,2775,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2800,Deployability,integrat,integration,2800,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1485,Energy Efficiency,adapt,adapting,1485,"lements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. E",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2093,Energy Efficiency,adapt,adapting,2093,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2699,Energy Efficiency,adapt,adaptive,2699,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:385,Integrability,integrat,integration,385,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:451,Integrability,integrat,integration,451,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:550,Integrability,integrat,integration,550,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:617,Integrability,integrat,integration,617,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:658,Integrability,integrat,integration,658,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:740,Integrability,interface,interface,740,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:929,Integrability,wrap,wrapper,929,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1016,Integrability,integrat,integration,1016,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1147,Integrability,integrat,integration,1147,"..; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1270,Integrability,integrat,integration,1270," Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1578,Integrability,integrat,integration,1578,"lements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. E",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1929,Integrability,integrat,integration,1929,"pper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2186,Integrability,integrat,integration,2186,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2603,Integrability,integrat,integration,2603,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2726,Integrability,integrat,integration,2726,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2750,Integrability,integrat,integration,2750,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2775,Integrability,integrat,integration,2775,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2800,Integrability,integrat,integration,2800,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:823,Modifiability,plugin,plugin,823,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:839,Modifiability,plugin,plugin,839,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:1485,Modifiability,adapt,adapting,1485,"lements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. E",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2093,Modifiability,adapt,adapting,2093,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:2699,Modifiability,adapt,adaptive,2699,"rivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPointer. typedef double(* ROOT::Math::GSLMonteFuncPointer)(double *, size_t, void *). Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ; The templated C++ function class must implement:; double operator( const double * x); This class defines static methods with will be used to fill the gsl_monte_function used by GSL. See for examples the GSL online manual ; Definition at line 56 of file GSLMonteFunctionAdapter.h. Enumeration Type Documentation. ◆ Type. enum ROOT::Math::IntegrationMultiDim::Type. enumeration specifying the integration types. . EnumeratorkDEFAULT default type specified in the static option . kADAPTIVE adaptive multi-dimensional integration . kVEGAS MC integration. . kMISER MC integration. . kPLAIN MC integration. . Definition at line 47 of file AllIntegrationTypes.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__MCIntegration.html:364,Performance,perform,performing,364,". ROOT: Numerical Monte Carlo Integration Classes. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs |; Enumerations ; Numerical Monte Carlo Integration ClassesMath » MathCore | Math » MathMore » Numerical Algorithms » Numerical Integration. ; Classes implementing method for Monte Carlo Integration. ; Class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran.; Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges.; GSL Manual.; It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be instantiate using the plugin manager (plugin name is ""GSLMCIntegrator"") . Classes; class  ROOT::Math::GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; struct  ROOT::Math::MiserParameters;  Structure collecting parameters for MISER multidimensional integration. More...;  ; struct  ROOT::Math::VegasParameters;  Structures collecting parameters for VEGAS multidimensional integration For implementation of default parameters see file mathmore/src/GSLMCIntegrationWorkspace.h. More...;  . Typedefs; typedef double(* ROOT::Math::GSLMonteFuncPointer) (double *, size_t, void *);  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MonteCarlo integration algorithms. ;  . Enumerations; enum  ROOT::Math::IntegrationMultiDim::Type { ;   ROOT::Math::IntegrationMultiDim::kDEFAULT = -1; , ROOT::Math::IntegrationMultiDim::kADAPTIVE; , ROOT::Math::IntegrationMultiDim::kVEGAS; , ROOT::Math::IntegrationMultiDim::kMISER; , ;   ROOT::Math::IntegrationMultiDim::kPLAIN. };  enumeration specifying the integration types. More...;  . Typedef Documentation. ◆ GSLMonteFuncPoin",MatchSource.WIKI,doc/master/group__MCIntegration.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MCIntegration.html
https://root.cern/doc/master/group__Min1D.html:1098,Availability,avail,available,1098,". ROOT: One-dimensional Minimization. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; One-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for one-dimensional minimization. . Classes; class  ROOT::Math::BrentMinimizer1D;  User class for performing function minimization. More...;  ; class  ROOT::Math::GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  ROOT::Math::GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  ROOT::Math::IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  . Enumerations; enum  ROOT::Math::Minim1D::Type { ROOT::Math::Minim1D::kGOLDENSECTION; , ROOT::Math::Minim1D::kBRENT; };  Enumeration with One Dimensional Minimizer Algorithms. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Minim1D::Type. Enumeration with One Dimensional Minimizer Algorithms. ; The algorithms are implemented using GSL, see the GSL manual.; The algorithms available are: . Golden Section Algorithm, simplest method of bracketing the minimum of a function . Brent Algorithm, which combines a parabolic interpolation with the golden section algorithm . EnumeratorkGOLDENSECTION ; kBRENT . Definition at line 56 of file GSLMinimizer1D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Min1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Min1D.html
https://root.cern/doc/master/group__Min1D.html:428,Integrability,wrap,wrapper,428,". ROOT: One-dimensional Minimization. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; One-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for one-dimensional minimization. . Classes; class  ROOT::Math::BrentMinimizer1D;  User class for performing function minimization. More...;  ; class  ROOT::Math::GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  ROOT::Math::GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  ROOT::Math::IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  . Enumerations; enum  ROOT::Math::Minim1D::Type { ROOT::Math::Minim1D::kGOLDENSECTION; , ROOT::Math::Minim1D::kBRENT; };  Enumeration with One Dimensional Minimizer Algorithms. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Minim1D::Type. Enumeration with One Dimensional Minimizer Algorithms. ; The algorithms are implemented using GSL, see the GSL manual.; The algorithms available are: . Golden Section Algorithm, simplest method of bracketing the minimum of a function . Brent Algorithm, which combines a parabolic interpolation with the golden section algorithm . EnumeratorkGOLDENSECTION ; kBRENT . Definition at line 56 of file GSLMinimizer1D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Min1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Min1D.html
https://root.cern/doc/master/group__Min1D.html:339,Performance,perform,performing,339,". ROOT: One-dimensional Minimization. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; One-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for one-dimensional minimization. . Classes; class  ROOT::Math::BrentMinimizer1D;  User class for performing function minimization. More...;  ; class  ROOT::Math::GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  ROOT::Math::GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  ROOT::Math::IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  . Enumerations; enum  ROOT::Math::Minim1D::Type { ROOT::Math::Minim1D::kGOLDENSECTION; , ROOT::Math::Minim1D::kBRENT; };  Enumeration with One Dimensional Minimizer Algorithms. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Minim1D::Type. Enumeration with One Dimensional Minimizer Algorithms. ; The algorithms are implemented using GSL, see the GSL manual.; The algorithms available are: . Golden Section Algorithm, simplest method of bracketing the minimum of a function . Brent Algorithm, which combines a parabolic interpolation with the golden section algorithm . EnumeratorkGOLDENSECTION ; kBRENT . Definition at line 56 of file GSLMinimizer1D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Min1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Min1D.html
https://root.cern/doc/master/group__Min1D.html:1141,Usability,simpl,simplest,1141,". ROOT: One-dimensional Minimization. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; One-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes for one-dimensional minimization. . Classes; class  ROOT::Math::BrentMinimizer1D;  User class for performing function minimization. More...;  ; class  ROOT::Math::GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  ROOT::Math::GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  ROOT::Math::IMinimizer1D;  Interface class for numerical methods for one-dimensional minimization. More...;  . Enumerations; enum  ROOT::Math::Minim1D::Type { ROOT::Math::Minim1D::kGOLDENSECTION; , ROOT::Math::Minim1D::kBRENT; };  Enumeration with One Dimensional Minimizer Algorithms. More...;  . Enumeration Type Documentation. ◆ Type. enum ROOT::Math::Minim1D::Type. Enumeration with One Dimensional Minimizer Algorithms. ; The algorithms are implemented using GSL, see the GSL manual.; The algorithms available are: . Golden Section Algorithm, simplest method of bracketing the minimum of a function . Brent Algorithm, which combines a parabolic interpolation with the golden section algorithm . EnumeratorkGOLDENSECTION ; kBRENT . Definition at line 56 of file GSLMinimizer1D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Min1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Min1D.html
https://root.cern/doc/master/group__Minuit.html:258,Availability,avail,available,258,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:408,Energy Efficiency,adapt,adapting,408,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:679,Energy Efficiency,adapt,adapting,679,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:1285,Energy Efficiency,adapt,adapting,1285,"able at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions,",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:390,Integrability,wrap,wrapped,390,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:661,Integrability,wrap,wrapped,661,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:1267,Integrability,wrap,wrapped,1267,"able at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions,",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:2388,Integrability,interface,interface,2388," class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions, inherit. More...;  ; class  ROOT::Minuit2::Minuit2Minimizer;  Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. More...;  ; class  ROOT::Minuit2::MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  ROOT::Minuit2::MnParabola;  This class defines a parabola of the form a*x*x + b*x + c. More...;  ; class  ROOT::Minuit2::MnParabolaPoint;  A point of a parabola. More...;  ; class  ROOT::Minuit2::ParametricFunction;  Function which has parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:408,Modifiability,adapt,adapting,408,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:679,Modifiability,adapt,adapting,679,". ROOT: Minuit2 Minimization Library. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; Minuit2 Minimization LibraryMath. ; New Object-oriented implementation of the MINUIT minimization package. ; More information is available at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; clas",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:1285,Modifiability,adapt,adapting,1285,"able at the home page of the Minuit2 minimization package"". . Classes; class  ROOT::Minuit2::FCNAdapter< Function >;  template wrapped class for adapting to FCNBase signature More...;  ; class  ROOT::Minuit2::FCNBase;  Interface (abstract class) defining the function to be minimized, which has to be implemented by the user. More...;  ; class  ROOT::Minuit2::FCNGradAdapter< Function >;  template wrapped class for adapting to FCNBase signature a IGradFunction More...;  ; class  ROOT::Minuit2::FumiliBuilder;  Builds the FunctionMinimum using the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions,",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:2264,Modifiability,inherit,inherit,2264," class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions, inherit. More...;  ; class  ROOT::Minuit2::Minuit2Minimizer;  Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. More...;  ; class  ROOT::Minuit2::MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  ROOT::Minuit2::MnParabola;  This class defines a parabola of the form a*x*x + b*x + c. More...;  ; class  ROOT::Minuit2::MnParabolaPoint;  A point of a parabola. More...;  ; class  ROOT::Minuit2::ParametricFunction;  Function which has parameters. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__Minuit.html:1926,Safety,predict,predicted,1926,"e...;  ; class  ROOT::Minuit2::FumiliChi2FCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliErrorUpdator;  In the case of the Fumili algorithm the Error matrix (or the Hessian matrix containing the (approximate) second derivatives) is calculated using a linearization of the model function negleting second derivatives. More...;  ; class  ROOT::Minuit2::FumiliFCNAdapter< Function >;  template wrapped class for adapting to FumiliFCNBase signature More...;  ; class  ROOT::Minuit2::FumiliFCNBase;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMaximumLikelihoodFCN;  Extension of the FCNBase for the Fumili method. More...;  ; class  ROOT::Minuit2::FumiliMinimizer;  Instantiates the seed generator and Minimum builder for the Fumili minimization method. More...;  ; class  ROOT::Minuit2::FumiliStandardChi2FCN;  Class implementing the standard chi square function, which is the sum of the squares of the figures-of-merit calculated for each measurement point, the individual figures-of-merit being: (the Value predicted by the model-measured Value)/standard deviation. More...;  ; class  ROOT::Minuit2::FumiliStandardMaximumLikelihoodFCN;  Class implementing the Elements member function for the standard maximum likelihood method. More...;  ; class  ROOT::Minuit2::GenericFunction;  Class from which all the other classes, representing functions, inherit. More...;  ; class  ROOT::Minuit2::Minuit2Minimizer;  Minuit2Minimizer class implementing the ROOT::Math::Minimizer interface for Minuit2 minimization algorithm. More...;  ; class  ROOT::Minuit2::MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  ROOT::Minuit2::MnParabola;  This class defines a parabola of the form a*x*x + b*x + c. More...;  ; class  ROOT::Minuit2::MnParabolaPoint;  A point of a parabola. More...;  ; class  ROOT::Minuit2::ParametricFunction;  Function which has parameters. More...;  .",MatchSource.WIKI,doc/master/group__Minuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Minuit.html
https://root.cern/doc/master/group__MinuitOld.html:356,Deployability,patch,patch,356,". ROOT: TMinuit. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TMinuitMath. ; The Minuit Minimization package. ; See alsoMinuit2 for a newer version of this package; Direct C++ implementation of the Minuit minimization package.; This package was originally written in Fortran by Fred James and part of PACKLIB (patch D506).; It has been converted to a C++ class, TMinuit, by R.Brun.; See also:. The main documentation is in the class TMinuit; The Chapter about Fitting Histogram in the Users Guide; The MINUIT documentation in CERNLIB; How to Fit Histograms; peaks.C How to Fit find peaks in histograms . Classes; class  TLinearFitter;  ; class  TMinuit;  ; class  TMinuitMinimizer;  TMinuitMinimizer class: ROOT::Math::Minimizer implementation based on TMinuit. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MinuitOld.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MinuitOld.html
https://root.cern/doc/master/group__MultiMin.html:3533,Availability,error,error,3533,"th::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDe",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:921,Energy Efficiency,adapt,adapting,921,". ROOT: Multi-dimensional Minimization. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Multi-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes implementing algorithms for multi-dimensional minimization. . Classes; class  ROOT::Math::BasicMinimizer;  Base Minimizer class, which defines the basic functionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt a",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:1462,Energy Efficiency,adapt,adapting,1462,"uit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  s",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:1113,Integrability,wrap,wrapper,1113,"ations ; Multi-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes implementing algorithms for multi-dimensional minimization. . Classes; class  ROOT::Math::BasicMinimizer;  Base Minimizer class, which defines the basic functionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:1625,Integrability,wrap,wrapper,1625,"; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Mi",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:2699,Integrability,interface,interface,2699,"onal minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFuncti",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3708,Integrability,wrap,wrap,3708,"2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDescent. };  enumeration specifying the types of GSL minimizers More...;  . Enumeration Type Documentation. ◆ EGSLMinimizerType. enum ROOT::Math::EGSLMinimizerType. enumeration specifying the types of GSL minimizers . EnumeratorkConjugateFR ; kConjugatePR ; kVectorBFGS ; kVectorBFGS2 ; kSteepestD",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:921,Modifiability,adapt,adapting,921,". ROOT: Multi-dimensional Minimization. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Enumerations ; Multi-dimensional MinimizationMath » MathCore | Math » MathMore » Numerical Algorithms. ; Classes implementing algorithms for multi-dimensional minimization. . Classes; class  ROOT::Math::BasicMinimizer;  Base Minimizer class, which defines the basic functionality of various minimizer implementations (apart from Minuit and Minuit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt a",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:1462,Modifiability,adapt,adapting,1462,"uit2) It provides support for storing parameter values, step size, parameter transformation etc. More...;  ; class  ROOT::Math::GeneticMinimizer;  GeneticMinimizer. More...;  ; class  ROOT::Math::GSLMinimizer;  GSLMinimizer class. More...;  ; class  ROOT::Math::GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  ROOT::Math::GSLMultiFitFunctionAdapter< FuncVector >;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  ROOT::Math::GSLMultiFitFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinDerivFunctionWrapper;  Wrapper for a multi-dimensional function with derivatives used in GSL multidim minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  s",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3139,Modifiability,variab,variables,3139,"OOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::Sq",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3179,Modifiability,variab,variables,3179,"OOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::Sq",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3394,Modifiability,variab,variables,3394,"th::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDe",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3467,Modifiability,variab,variable,3467,"th::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDe",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3547,Modifiability,variab,variable,3547,"th::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDe",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3975,Modifiability,variab,variables,3975,"ion;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDescent. };  enumeration specifying the types of GSL minimizers More...;  . Enumeration Type Documentation. ◆ EGSLMinimizerType. enum ROOT::Math::EGSLMinimizerType. enumeration specifying the types of GSL minimizers . EnumeratorkConjugateFR ; kConjugatePR ; kVectorBFGS ; kVectorBFGS2 ; kSteepestDescent . Definition at line 49 of file GSLMinimizer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:4106,Modifiability,variab,variables,4106,"ion;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDescent. };  enumeration specifying the types of GSL minimizers More...;  . Enumeration Type Documentation. ◆ EGSLMinimizerType. enum ROOT::Math::EGSLMinimizerType. enumeration specifying the types of GSL minimizers . EnumeratorkConjugateFR ; kConjugatePR ; kVectorBFGS ; kVectorBFGS2 ; kSteepestDescent . Definition at line 49 of file GSLMinimizer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:4236,Modifiability,variab,variables,4236,"ion;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::SqrtUpVariableTransformation;  Sqrt Transformation class for dealing with upper bounded variables. More...;  . Enumerations; enum  ROOT::Math::EGSLMinimizerType { ;   ROOT::Math::kConjugateFR; , ROOT::Math::kConjugatePR; , ROOT::Math::kVectorBFGS; , ROOT::Math::kVectorBFGS2; , ;   ROOT::Math::kSteepestDescent. };  enumeration specifying the types of GSL minimizers More...;  . Enumeration Type Documentation. ◆ EGSLMinimizerType. enum ROOT::Math::EGSLMinimizerType. enumeration specifying the types of GSL minimizers . EnumeratorkConjugateFR ; kConjugatePR ; kVectorBFGS ; kVectorBFGS2 ; kSteepestDescent . Definition at line 49 of file GSLMinimizer.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:2353,Performance,perform,performing,2353," minimization algorithm. More...;  ; struct  ROOT::Math::GSLMultiMinFunctionAdapter< UserFunc >;  Class for adapting any multi-dimension C++ functor class to C function pointers used by GSL MultiMin algorithms. More...;  ; class  ROOT::Math::GSLMultiMinFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm More...;  ; class  ROOT::Math::GSLMultiMinimizer;  GSLMultiMinimizer class , for minimizing multi-dimensional function using derivatives. More...;  ; class  ROOT::Math::GSLNLSMinimizer;  GSLNLSMinimizer class for Non Linear Least Square fitting It Uses the Levemberg-Marquardt algorithm from GSL Non Linear Least Square fitting. More...;  ; class  ROOT::Math::GSLSimAnFunc;  GSLSimAnFunc class description. More...;  ; class  ROOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable ",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__MultiMin.html:3106,Performance,perform,perform,3106,"OOT::Math::GSLSimAnMinimizer;  GSLSimAnMinimizer class for minimization using simulated annealing using the algorithm from GSL. More...;  ; class  ROOT::Math::GSLSimAnnealing;  GSLSimAnnealing class for performing a simulated annealing search of a multidimensional function. More...;  ; struct  ROOT::Math::GSLSimAnParams;  structure holding the simulated annealing parameters More...;  ; class  ROOT::Math::LSResidualFunc< Func >;  LSResidualFunc class description. More...;  ; class  ROOT::Math::Minimizer;  Abstract Minimizer class, defining the interface for the various minimizer (like Minuit2, Minuit, GSL, etc..) in ROOT. More...;  ; class  ROOT::Math::MinimizerOptions;  Minimizer options. More...;  ; class  ROOT::Math::MinimizerVariableTransformation;  Base class for MinimizerVariable transformations defining the functions to deal with bounded parameters. More...;  ; class  ROOT::Math::MinimTransformFunction;  MinimTransformFunction class to perform a transformations on the variables to deal with fixed or limited variables (support both double and single bounds) The class manages the passed function pointer. More...;  ; class  ROOT::Math::MinimTransformVariable;  MinimTransformVariable class Contains meta information of the variables such as bounds, fix flags and deals with transformation of the variable The class does not contain the values and the step size (error) of the variable This is an internal class used by the MinimTransformFunction class. More...;  ; class  ROOT::Math::MultiNumGradFunction;  MultiNumGradFunction class to wrap a normal function in a gradient function using numerical gradient calculation provided by the class Derivator (based on GSL numerical derivation) More...;  ; class  ROOT::Math::SinVariableTransformation;  Sin Transformation class for dealing with double bounded variables. More...;  ; class  ROOT::Math::SqrtLowVariableTransformation;  Sqrt Transformation class for dealing with lower bounded variables. More...;  ; class  ROOT::Math::Sq",MatchSource.WIKI,doc/master/group__MultiMin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__MultiMin.html
https://root.cern/doc/master/group__NTuple.html:2422,Availability,avail,available,2422,"r.hxx;  ; file  RNTupleProcessor.cxx;  ; file  RNTupleProcessor.hxx;  ; file  RNTupleReader.cxx;  ; file  RNTupleReader.hxx;  ; file  RNTupleReadOptions.hxx;  ; file  RNTupleSerialize.cxx;  ; file  RNTupleSerialize.hxx;  ; file  RNTupleUtil.cxx;  ; file  RNTupleUtil.hxx;  ; file  RNTupleView.cxx;  ; file  RNTupleView.hxx;  ; file  RNTupleWriteOptions.cxx;  ; file  RNTupleWriteOptions.hxx;  ; file  RNTupleWriteOptionsDaos.hxx;  ; file  RNTupleWriter.hxx;  ; file  RNTupleZip.hxx;  ; file  RPage.cxx;  ; file  RPage.hxx;  ; file  RPageAllocator.cxx;  ; file  RPageAllocator.hxx;  ; file  RPageNullSink.hxx;  ; file  RPagePool.cxx;  ; file  RPagePool.hxx;  ; file  RPageSinkBuf.cxx;  ; file  RPageSinkBuf.hxx;  ; file  RPageSourceFriends.cxx;  ; file  RPageSourceFriends.hxx;  ; file  RPageStorage.cxx;  ; file  RPageStorage.hxx;  ; file  RPageStorageDaos.cxx;  ; file  RPageStorageDaos.hxx;  ; file  RPageStorageFile.cxx;  ; file  RPageStorageFile.hxx;  . Classes; class  EColumnType;  The available trivial, native content types of a column. More...;  ; class  ROOT::Experimental::RArrayAsRVecField;  Additional classes related to sequence containers. More...;  ; class  ROOT::Experimental::Internal::RCluster;  An in-memory subset of the packed and compressed pages of a cluster. More...;  ; class  ROOT::Experimental::RClusterDescriptor;  Meta-data for a set of ntuple clusters. More...;  ; class  ROOT::Experimental::Internal::RClusterDescriptorBuilder;  A helper class for piece-wise construction of an RClusterDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RClusterDescriptorIterable;  Used to loop over all the clusters of an ntuple (in unspecified order) More...;  ; class  ROOT::Experimental::RClusterGroupDescriptor;  Clusters are bundled in cluster groups. More...;  ; class  ROOT::Experimental::Internal::RClusterGroupDescriptorBuilder;  A helper class for piece-wise construction of an RClusterGroupDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescri",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:11779,Deployability,release,release,11779,"es read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesc",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:11523,Energy Efficiency,allocate,allocated,11523,"imeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPag",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:11766,Energy Efficiency,allocate,allocate,11766,"es read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesc",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:11753,Integrability,interface,interface,11753,"es read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesc",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:12610,Integrability,interface,interface,12610,al::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  ROOT::Experimental::Internal::RPageStorage;  Common functi,MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:13094,Integrability,interface,interface,13094,gePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider that reads ntuple pages from a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFile;  Storage provider that reads ntuple pages from a file. More...;  ; class  ROOT::Experimental::Internal::RPageSourceFriends;  Virtual storage that combines several other sources horizontally. More...;  ; class  ROOT::Experimental::Internal::RPageStorage;  Common functionality of an ntuple storage for both reading and writing. More...;  ; class  ROOT::Experimental::RPrepareVisitor;  Visitor used for a pre-processing run to collect information needed by another visitor class. More...;  ; class  ROOT::Experimental::RPrintSchemaVisitor;  Contains settings for printing and prints a summary of an RField instance. More...;  ; class  ROOT::Experimental::RPrintValueVisitor;  Renders a JSON value corresponding to the field. More...;  ; class  ROOT::Exp,MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:6585,Performance,perform,performance,6585,"l::Internal::RFieldDescriptorBuilder;  A helper class for piece-wise construction of an RFieldDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RFieldDescriptorIterable;  Used to loop over a field's child fields. More...;  ; class  ROOT::Experimental::Detail::RFieldVisitor;  Abstract base class for classes implementing the visitor design pattern. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RHeaderExtension;  Summarizes information about fields and the corresponding columns that were added after the header has been serialized. More...;  ; class  ROOT::Experimental::RNTupleProcessor::RIterator;  Iterator over the entries of an RNTuple, or vertical concatenation thereof. More...;  ; class  ROOT::Experimental::Internal::RMiniFileReader;  Read RNTuple data blocks from a TFile container, provided by a RRawFile. More...;  ; class  ROOT::RNTuple;  Representation of an RNTuple data set in a ROOT file. More...;  ; class  ROOT::Experimental::Detail::RNTupleAtomicCounter;  A thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::Detail::RNTupleCalcPerf;  A metric element that computes its floating point value from other counters. More...;  ; class  ROOT::Experimental::RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  ROOT::Experimental::RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  ROOT::Experimental::Internal::RNTupleCompressor;  Helper class to compress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::Internal::RNTupleDecompressor;  Helper class to uncompress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::RNTupleDescriptor;  The on-storage meta-data of an ntuple. Mo",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:9549,Performance,perform,performance,9549,"uple. More...;  ; class  ROOT::Experimental::Internal::RNTupleIndex;  Builds an index on one or several fields of an RNTuple so it can be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleMerger;  Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...;  ; class  ROOT::Experimental::Detail::RNTupleMetrics;  A collection of Counter objects with a name, a unit, and a description. More...;  ; class  ROOT::Experimental::RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and dest",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:9723,Performance,perform,performance,9723,"an be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleMerger;  Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...;  ; class  ROOT::Experimental::Detail::RNTupleMetrics;  A collection of Counter objects with a name, a unit, and a description. More...;  ; class  ROOT::Experimental::RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experime",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:12229,Performance,cache,cache,12229,";  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider ",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:12244,Performance,load,loaded,12244,";  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider ",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:6571,Safety,safe,safe,6571,"l::Internal::RFieldDescriptorBuilder;  A helper class for piece-wise construction of an RFieldDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RFieldDescriptorIterable;  Used to loop over a field's child fields. More...;  ; class  ROOT::Experimental::Detail::RFieldVisitor;  Abstract base class for classes implementing the visitor design pattern. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RHeaderExtension;  Summarizes information about fields and the corresponding columns that were added after the header has been serialized. More...;  ; class  ROOT::Experimental::RNTupleProcessor::RIterator;  Iterator over the entries of an RNTuple, or vertical concatenation thereof. More...;  ; class  ROOT::Experimental::Internal::RMiniFileReader;  Read RNTuple data blocks from a TFile container, provided by a RRawFile. More...;  ; class  ROOT::RNTuple;  Representation of an RNTuple data set in a ROOT file. More...;  ; class  ROOT::Experimental::Detail::RNTupleAtomicCounter;  A thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::Detail::RNTupleCalcPerf;  A metric element that computes its floating point value from other counters. More...;  ; class  ROOT::Experimental::RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  ROOT::Experimental::RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  ROOT::Experimental::Internal::RNTupleCompressor;  Helper class to compress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::Internal::RNTupleDecompressor;  Helper class to uncompress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::RNTupleDescriptor;  The on-storage meta-data of an ntuple. Mo",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:9709,Safety,safe,safe,9709,"an be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNTupleInspector;  Inspect on-disk and storage-related information of an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleMerger;  Given a set of RPageSources merge them into an RPageSink, optionally changing their compression. More...;  ; class  ROOT::Experimental::Detail::RNTupleMetrics;  A collection of Counter objects with a name, a unit, and a description. More...;  ; class  ROOT::Experimental::RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleModelChangeset;  The incremental changes to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experime",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:10365,Safety,safe,safe,10365,"nges to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPag",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:10384,Safety,safe,safe,10384,"nges to a RNTupleModel More...;  ; class  ROOT::Experimental::RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  ROOT::Experimental::Detail::RNTuplePerfCounter;  A performance counter with a name and a unit, which can be activated on demand. More...;  ; class  ROOT::Experimental::Detail::RNTuplePlainCounter;  A non thread-safe integral performance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPag",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:12224,Safety,safe,safe,12224,";  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::RPageAllocator;  Abstract interface to allocate and release pages. More...;  ; class  ROOT::Experimental::Internal::RPageAllocatorHeap;  Uses standard C++ memory allocation for the column data pages. More...;  ; class  ROOT::Experimental::Internal::RPageNullSink;  Dummy sink that discards all pages. More...;  ; class  ROOT::Experimental::Internal::RPagePersistentSink;  Base class for a sink with a physical storage backend. More...;  ; class  ROOT::Experimental::Internal::RPagePool;  A thread-safe cache of pages loaded from the page source. More...;  ; class  ROOT::Experimental::RClusterDescriptor::RPageRange;  Records the partition of data into pages for a particular column in a particular cluster. More...;  ; class  ROOT::Experimental::Internal::RPageRef;  Reference to a page stored in the page pool. More...;  ; class  ROOT::Experimental::Internal::RPageSink;  Abstract interface to write data into an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSinkBuf;  Wrapper sink that coalesces cluster column page writes. More...;  ; class  ROOT::Experimental::Internal::RPageSinkDaos;  Storage provider that writes ntuple pages to into a DAOS container. More...;  ; class  ROOT::Experimental::Internal::RPageSinkFile;  Storage provider that write ntuple pages into a file. More...;  ; class  ROOT::Experimental::Internal::RPageSource;  Abstract interface to read data from an ntuple. More...;  ; class  ROOT::Experimental::Internal::RPageSourceDaos;  Storage provider ",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:7800,Security,access,access,7800,"ss  ROOT::Experimental::RNTupleChainProcessor;  Processor specializiation for vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleClusterRange;  Used to loop over entries of collections in a single cluster. More...;  ; class  ROOT::Experimental::RNTupleCollectionView;  A view for a collection, that can itself generate new ntuple views for its nested fields. More...;  ; class  ROOT::Experimental::Internal::RNTupleCompressor;  Helper class to compress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::Internal::RNTupleDecompressor;  Helper class to uncompress data blocks in the ROOT compression frame format. More...;  ; class  ROOT::Experimental::RNTupleDescriptor;  The on-storage meta-data of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleDescriptorBuilder;  A helper class for piece-wise construction of an RNTupleDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDirectAccessView< T >;  A view variant that provides direct access to the I/O buffers. More...;  ; class  ROOT::Experimental::Internal::RNTupleFileWriter;  Write RNTuple data blocks in a TFile or a bare file container. More...;  ; class  ROOT::Experimental::RNTupleFillContext;  A context for filling entries (data) into clusters of an RNTuple. More...;  ; class  ROOT::Experimental::RNTupleFillStatus;  A status object after filling an entry. More...;  ; class  ROOT::Experimental::RNTupleFormatter;  Contains helper functions for RNTupleReader::PrintInfo() and RPrintSchemaVisitor::VisitField() More...;  ; class  ROOT::Experimental::RNTupleGlobalRange;  Used to loop over indexes (entries or collections) between start and end. More...;  ; class  ROOT::Experimental::RNTupleImporter;  Converts a TTree into an RNTuple. More...;  ; class  ROOT::Experimental::Internal::RNTupleIndex;  Builds an index on one or several fields of an RNTuple so it can be joined onto other RNTuples. More...;  ; class  ROOT::Experimental::RNT",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:10752,Security,access,access,10752,"ormance counter. More...;  ; class  ROOT::Experimental::RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  ROOT::Experimental::RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  ROOT::Experimental::RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  ROOT::Experimental::Internal::RNTupleSerializer;  A helper class for serializing and deserialization of the RNTuple binary format. More...;  ; class  ROOT::Experimental::Detail::RNTupleTickCounter< BaseCounterT >;  An either thread-safe or non thread safe counter for CPU ticks. More...;  ; class  ROOT::Experimental::Detail::RNTupleTimer< WallTimeT, CpuTimeT >;  Record wall time and CPU time between construction and destruction. More...;  ; class  ROOT::Experimental::RNTupleView< T >;  An RNTupleView for a known type. More...;  ; class  ROOT::Experimental::RNTupleViewBase< T >;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  ROOT::Experimental::RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  ROOT::Experimental::RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPage;  A page as being stored on disk, that is packed and compressed. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMap;  A memory region that contains packed and compressed pages. More...;  ; class  ROOT::Experimental::Internal::ROnDiskPageMapHeap;  An ROnDiskPageMap that is used for an fMemory allocated as an array of unsigned char. More...;  ; class  ROOT::Experimental::Internal::RPage;  A page is a slice of a column that is mapped into memory. More...;  ; class  ROOT::Experimental::Internal::",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NTuple.html:3777,Usability,simpl,simple,3777,"riptor;  Meta-data for a set of ntuple clusters. More...;  ; class  ROOT::Experimental::Internal::RClusterDescriptorBuilder;  A helper class for piece-wise construction of an RClusterDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RClusterDescriptorIterable;  Used to loop over all the clusters of an ntuple (in unspecified order) More...;  ; class  ROOT::Experimental::RClusterGroupDescriptor;  Clusters are bundled in cluster groups. More...;  ; class  ROOT::Experimental::Internal::RClusterGroupDescriptorBuilder;  A helper class for piece-wise construction of an RClusterGroupDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RClusterGroupDescriptorIterable;  Used to loop over all the cluster groups of an ntuple (in unspecified order) More...;  ; class  ROOT::Experimental::Internal::RClusterPool;  Managed a set of clusters containing compressed and packed pages. More...;  ; class  ROOT::Experimental::Internal::RColumn;  A column is a storage-backed array of a simple, fixed-size type, from which pages can be mapped into memory. More...;  ; class  ROOT::Experimental::RColumnDescriptor;  Meta-data stored for every column of an ntuple. More...;  ; class  ROOT::Experimental::Internal::RColumnDescriptorBuilder;  A helper class for piece-wise construction of an RColumnDescriptor. More...;  ; class  ROOT::Experimental::RNTupleDescriptor::RColumnDescriptorIterable;  Used to loop over a field's associated columns. More...;  ; class  ROOT::Experimental::Internal::RColumnElementBase;  A column element encapsulates the translation between basic C++ types and their column representation. More...;  ; class  ROOT::Experimental::Internal::RDaosNTupleAnchor;  Entry point for an RNTuple in a DAOS container. More...;  ; class  ROOT::Experimental::REntry;  The REntry is a collection of values in an ntuple corresponding to a complete row in the data set. More...;  ; class  ROOT::Experimental::RExtraTypeInfoDescriptor;  Field specific extra type infor",MatchSource.WIKI,doc/master/group__NTuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NTuple.html
https://root.cern/doc/master/group__NumAlgo.html:396,Deployability,integrat,integration,396,. ROOT: Numerical Algorithms. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Numerical AlgorithmsMath » MathCore | Math » MathMore. ; Numerical Algorithm classes from the MathCore and MathMore libraries. . Modules;  One-dimensional Minimization;  Classes for one-dimensional minimization. ;  ;  Numerical Integration;  Classes for numerical integration of functions. ;  ;  Multi-dimensional Minimization;  Classes implementing algorithms for multi-dimensional minimization. ;  ;  Numerical Differentiation;  Classes for numerical differentiation. ;  ;  One-dimensional Root-Finding;  Classes implementing algorithms for finding the roots of a one-dimensional function. ;  ;  Function Approximation (ChebyshevApprox);  Numerical algorithm from the MathMore library and implemented using the GSL library. ;  ;  Multidimensional ROOT finding;  Classes for finding the roots of a multi-dimensional system. ;  ;  Interpolation Classes;  Classes for interpolation of points. ;  . Classes; class  ROOT::Math::DistSamplerOptions;  DistSampler options class. More...;  ; class  ROOT::Math::GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; class  ROOT::Math::IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__NumAlgo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NumAlgo.html
https://root.cern/doc/master/group__NumAlgo.html:1341,Deployability,configurat,configuration,1341,. ROOT: Numerical Algorithms. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Numerical AlgorithmsMath » MathCore | Math » MathMore. ; Numerical Algorithm classes from the MathCore and MathMore libraries. . Modules;  One-dimensional Minimization;  Classes for one-dimensional minimization. ;  ;  Numerical Integration;  Classes for numerical integration of functions. ;  ;  Multi-dimensional Minimization;  Classes implementing algorithms for multi-dimensional minimization. ;  ;  Numerical Differentiation;  Classes for numerical differentiation. ;  ;  One-dimensional Root-Finding;  Classes implementing algorithms for finding the roots of a one-dimensional function. ;  ;  Function Approximation (ChebyshevApprox);  Numerical algorithm from the MathMore library and implemented using the GSL library. ;  ;  Multidimensional ROOT finding;  Classes for finding the roots of a multi-dimensional system. ;  ;  Interpolation Classes;  Classes for interpolation of points. ;  . Classes; class  ROOT::Math::DistSamplerOptions;  DistSampler options class. More...;  ; class  ROOT::Math::GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; class  ROOT::Math::IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__NumAlgo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NumAlgo.html
https://root.cern/doc/master/group__NumAlgo.html:396,Integrability,integrat,integration,396,. ROOT: Numerical Algorithms. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Numerical AlgorithmsMath » MathCore | Math » MathMore. ; Numerical Algorithm classes from the MathCore and MathMore libraries. . Modules;  One-dimensional Minimization;  Classes for one-dimensional minimization. ;  ;  Numerical Integration;  Classes for numerical integration of functions. ;  ;  Multi-dimensional Minimization;  Classes implementing algorithms for multi-dimensional minimization. ;  ;  Numerical Differentiation;  Classes for numerical differentiation. ;  ;  One-dimensional Root-Finding;  Classes implementing algorithms for finding the roots of a one-dimensional function. ;  ;  Function Approximation (ChebyshevApprox);  Numerical algorithm from the MathMore library and implemented using the GSL library. ;  ;  Multidimensional ROOT finding;  Classes for finding the roots of a multi-dimensional system. ;  ;  Interpolation Classes;  Classes for interpolation of points. ;  . Classes; class  ROOT::Math::DistSamplerOptions;  DistSampler options class. More...;  ; class  ROOT::Math::GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; class  ROOT::Math::IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__NumAlgo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NumAlgo.html
https://root.cern/doc/master/group__NumAlgo.html:1318,Integrability,interface,interface,1318,. ROOT: Numerical Algorithms. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Numerical AlgorithmsMath » MathCore | Math » MathMore. ; Numerical Algorithm classes from the MathCore and MathMore libraries. . Modules;  One-dimensional Minimization;  Classes for one-dimensional minimization. ;  ;  Numerical Integration;  Classes for numerical integration of functions. ;  ;  Multi-dimensional Minimization;  Classes implementing algorithms for multi-dimensional minimization. ;  ;  Numerical Differentiation;  Classes for numerical differentiation. ;  ;  One-dimensional Root-Finding;  Classes implementing algorithms for finding the roots of a one-dimensional function. ;  ;  Function Approximation (ChebyshevApprox);  Numerical algorithm from the MathMore library and implemented using the GSL library. ;  ;  Multidimensional ROOT finding;  Classes for finding the roots of a multi-dimensional system. ;  ;  Interpolation Classes;  Classes for interpolation of points. ;  . Classes; class  ROOT::Math::DistSamplerOptions;  DistSampler options class. More...;  ; class  ROOT::Math::GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; class  ROOT::Math::IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__NumAlgo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NumAlgo.html
https://root.cern/doc/master/group__NumAlgo.html:1341,Modifiability,config,configuration,1341,. ROOT: Numerical Algorithms. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Classes ; Numerical AlgorithmsMath » MathCore | Math » MathMore. ; Numerical Algorithm classes from the MathCore and MathMore libraries. . Modules;  One-dimensional Minimization;  Classes for one-dimensional minimization. ;  ;  Numerical Integration;  Classes for numerical integration of functions. ;  ;  Multi-dimensional Minimization;  Classes implementing algorithms for multi-dimensional minimization. ;  ;  Numerical Differentiation;  Classes for numerical differentiation. ;  ;  One-dimensional Root-Finding;  Classes implementing algorithms for finding the roots of a one-dimensional function. ;  ;  Function Approximation (ChebyshevApprox);  Numerical algorithm from the MathMore library and implemented using the GSL library. ;  ;  Multidimensional ROOT finding;  Classes for finding the roots of a multi-dimensional system. ;  ;  Interpolation Classes;  Classes for interpolation of points. ;  . Classes; class  ROOT::Math::DistSamplerOptions;  DistSampler options class. More...;  ; class  ROOT::Math::GenAlgoOptions;  class implementing generic options for a numerical algorithm Just store the options in a map of string-value pairs More...;  ; class  ROOT::Math::IOptions;  Generic interface for defining configuration options of a numerical algorithm. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,doc/master/group__NumAlgo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__NumAlgo.html
https://root.cern/doc/master/group__opengl.html:5075,Availability,avail,available,5075,"gram painter class using OpenGL. More...;  ; class  TGLIsoPainter;  ""gliso"" option for TH3. More...;  ; class  TGLLegoPainter;  Plot-painter implementing LEGO rendering of TH2 histograms in cartesian, polar, cylindrical and spherical coordinates. More...;  ; class  TGLLightSet;  Encapsulates a set of lights for OpenGL. More...;  ; class  TGLLightSetSubEditor;  Sub-editor for TGLLightSet. More...;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLLockable;  Simple locking interface used by viewer and scene. More...;  ; class  TGLLogicalShape;  Abstract logical shape - a GL 'drawable' - base for all shapes - faceset sphere etc. More...;  ; class  TGLManip;  Abstract base class for viewer manipulators, which allow direct in viewer manipulation of a (TGlPhysicalShape) object - currently translation, scaling and rotation along/round objects local axes. More...;  ; class  TGLManipSet;  Combine all available manipulators in a collection. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLObject;  Base-class for direct OpenGL renderers. More...;  ; class  TGLOrthoCamera;  Orthographic projection camera. More...;  ; class  TGLOutput;  Wrapper class for GL capture & output routines. More...;  ; class  TGLOverlayButton;  GL-overlay button. More...;  ; class  TGLOverlayElement;  An overlay element. More...;  ; class  TGLOverlayList;  Manage a collection of overlay elements. More...;  ; class  TGLOvlSelectRecord;  Selection record for overlay objects. More...;  ; class  TGLPadPainter;  ""Delegating"" part of TGLPadPainter. More...;  ; class  TGLParametricEquation;  A parametric surface is a surface defined by a parametric equation, involving two parameters (u, v): More...;  ; class  TGLParametricEquationGL;  GL-renderer wrapper for TGLParametricEquation. More...;  ; class  TGLParametricPlot;  ; class  TGLPerspectiveCamera;  P",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:9802,Availability,error,error,9802,"e...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out selected object (TGLPhysicalShape*, TObject* or simply a void* for foreign scenes). More...;  ; class  TGLSelectRecordBase;  Base class for select records. More...;  ; class  TGLSphere;  Implements a native ROOT-GL sphere that can be rendered at different levels of detail. More...;  ; class  TGLStopwatch;  Stopwatch object for timing GL work. More...;  ; class  TGLSurfacePainter;  Implements painting of TH2 with ""SURF"" option. More...;  ; class  TGLText;  GL Text. More...;  ; class  TGLTF3Painter;  Plot-painter for TF3 functions. More...;  ; class  TGLTH3Composition;  ; class  TGLTH3CompositionPainter;  ; class  TGLTH3Slice;  A slice of a TH3. More...;  ; class  TGLTransManip;  Translation manipulator - attaches to physical shape and draws local axes widgets with arrow heads. More...;  ; class  TGLUtil;  Wrapper class for various misc static functions - error checking, draw helpers etc. More...;  ; class  TGLVector3;  3 component (x/y/z) vector class. More...;  ; class  TGLVertex3;  3 component (x/y/z) vertex class. More...;  ; class  TGLViewer;  Base GL viewer object - used by both standalone and embedded (in pad) GL. More...;  ; class  TGLViewerBase;  Base class for GL viewers. More...;  ; class  TGLViewerEditor;  GUI editor for TGLViewer. More...;  ; class  TGLVoxelPainter;  Paint TH3 histograms as ""voxels"" - colored boxes, transparent if transfer function was specified. More...;  ; class  TGLWidget;  GL window with context. More...;  ; class  TH2GL;  Rendering of TH2 and derived classes. More...;  ; class  TH3GL;  OpenGL renderer class for TH3. More...;  ; class  TPointSet3DGL;  Direct OpenGL renderer for TPointSet3D. More...;  ; class  TX11GLManager;  The TX11GLManager is X11 implementation of TGLManager. More...;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:32 (GVA Time) using Doxygen 1.9",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:233,Integrability,interface,interface,233,". ROOT: OpenGL rendering. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; OpenGL renderingGraphics » 3D Graphics. ; OpenGL rendering and utility classes. ; The GL module incapsulates ROOT's interface to the OpenGL rendering engine and provides the following functionality:. management of system-resources;; frequently used utility classes;; base-classes for shapes, scenes and viewers;; concrete implementations of shapes needed by TGeo package;; concrete implementations of scenes and viewers including the GUI components;; specialized plot-painters for GL rendering of TH2, TH3, TF2 and TF3 object as well as parametric surfaces. Papers describing OpenGL in ROOT:; ROOT 3D graphics, presented at CHEP 2006.; 3D graphics with OpenGL: recent improvements and plans, presented at ROOT Workshop 2007; Next generation of OpenGL support in ROOT, presented at CHEP 2007. . Classes; class  TArcBall;  Implements the arc-ball rotation manipulator. More...;  ; class  TF2GL;  GL renderer for TF2. More...;  ; class  TGL5DDataSet;  ; class  TGL5DDataSetEditor;  GUI editor for OpenGL 5D Painter. More...;  ; class  TGL5DPainter;  TGL5DPainter implements ""gl5d"" option for TTree::Draw. More...;  ; class  TGLAdapter;  Allow plot-painters to be used for gl-inpad and gl-viewer. More...;  ; class  TGLAnnotation;  GL-overlay annotation. More...;  ; class  TGLAutoRotator;  Automatically rotates GL camera. More...;  ; class  TGLAxis;  GL Axis. More...;  ; class  TGLAxisPainter;  Utility class to paint axis in GL. More...;  ; class  TGLAxisPainterBox;  Painter class for axes encompassing a 3D box. More...;  ; class  TGLBoundingBox;  Concrete class describing an orientated (free) or axis aligned box of 8 vertices. More...;  ; class  TGLBoxCut;  Used by plot-painters to determine the area of the plot that is cut away. More...;  ; class  TGLBoxPainter;  Paints TH3 histograms by rendering variable-sized boxes matching the bin contents. More...;  ; class  TGLCamera;",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:3800,Integrability,wrap,wrapper,3800,"or for TGLClipSet. More...;  ; class  TGLColor;  Class encapsulating color information in preferred GL format - an array of four unsigned bytes. More...;  ; class  TGLColorSet;  Class encapsulating a set of colors used throughout standard rendering. More...;  ; class  TGLContext;  This class encapsulates window-system specific information about a GL-context and alows their proper management in ROOT. More...;  ; class  TGLContextIdentity;  Identifier of a shared GL-context. More...;  ; class  TGLCylinder;  Implements a native ROOT-GL cylinder that can be rendered at different levels of detail. More...;  ; class  TGLEmbeddedViewer;  Minimal GL-viewer that can be embedded in a standard ROOT frames. More...;  ; class  TGLEventHandler;  Base-class and default implementation of event-handler for TGLViewer. More...;  ; class  TGLFaceSet;  Implements a native ROOT-GL representation of an arbitrary set of polygons. More...;  ; class  TGLFBO;  Frame-buffer object. More...;  ; class  TGLFont;  A wrapper class for FTFont. More...;  ; class  TGLFontManager;  A FreeType GL font manager. More...;  ; class  TGLFormat;  Encapsulation of format / contents of an OpenGL buffer. More...;  ; class  TGLH2PolyPainter;  Paint TH2Poly. More...;  ; class  TGLHistPainter;  The histogram painter class using OpenGL. More...;  ; class  TGLIsoPainter;  ""gliso"" option for TH3. More...;  ; class  TGLLegoPainter;  Plot-painter implementing LEGO rendering of TH2 histograms in cartesian, polar, cylindrical and spherical coordinates. More...;  ; class  TGLLightSet;  Encapsulates a set of lights for OpenGL. More...;  ; class  TGLLightSetSubEditor;  Sub-editor for TGLLightSet. More...;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLLockable;  Simple locking interface used by viewer and scene. More...;  ; class  TGLLogicalShape;  Abstract logical shape - a GL 'drawable' - base for all shapes - faceset sphere et",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:4646,Integrability,interface,interface,4646," Implements a native ROOT-GL representation of an arbitrary set of polygons. More...;  ; class  TGLFBO;  Frame-buffer object. More...;  ; class  TGLFont;  A wrapper class for FTFont. More...;  ; class  TGLFontManager;  A FreeType GL font manager. More...;  ; class  TGLFormat;  Encapsulation of format / contents of an OpenGL buffer. More...;  ; class  TGLH2PolyPainter;  Paint TH2Poly. More...;  ; class  TGLHistPainter;  The histogram painter class using OpenGL. More...;  ; class  TGLIsoPainter;  ""gliso"" option for TH3. More...;  ; class  TGLLegoPainter;  Plot-painter implementing LEGO rendering of TH2 histograms in cartesian, polar, cylindrical and spherical coordinates. More...;  ; class  TGLLightSet;  Encapsulates a set of lights for OpenGL. More...;  ; class  TGLLightSetSubEditor;  Sub-editor for TGLLightSet. More...;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLLockable;  Simple locking interface used by viewer and scene. More...;  ; class  TGLLogicalShape;  Abstract logical shape - a GL 'drawable' - base for all shapes - faceset sphere etc. More...;  ; class  TGLManip;  Abstract base class for viewer manipulators, which allow direct in viewer manipulation of a (TGlPhysicalShape) object - currently translation, scaling and rotation along/round objects local axes. More...;  ; class  TGLManipSet;  Combine all available manipulators in a collection. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLObject;  Base-class for direct OpenGL renderers. More...;  ; class  TGLOrthoCamera;  Orthographic projection camera. More...;  ; class  TGLOutput;  Wrapper class for GL capture & output routines. More...;  ; class  TGLOverlayButton;  GL-overlay button. More...;  ; class  TGLOverlayElement;  An overlay element. More...;  ; class  TGLOverlayList;  Manage a collection of overlay elements. More...;  ; class  TGLOv",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:5416,Integrability,rout,routines,5416,"penGL. More...;  ; class  TGLLightSetSubEditor;  Sub-editor for TGLLightSet. More...;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLLockable;  Simple locking interface used by viewer and scene. More...;  ; class  TGLLogicalShape;  Abstract logical shape - a GL 'drawable' - base for all shapes - faceset sphere etc. More...;  ; class  TGLManip;  Abstract base class for viewer manipulators, which allow direct in viewer manipulation of a (TGlPhysicalShape) object - currently translation, scaling and rotation along/round objects local axes. More...;  ; class  TGLManipSet;  Combine all available manipulators in a collection. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLObject;  Base-class for direct OpenGL renderers. More...;  ; class  TGLOrthoCamera;  Orthographic projection camera. More...;  ; class  TGLOutput;  Wrapper class for GL capture & output routines. More...;  ; class  TGLOverlayButton;  GL-overlay button. More...;  ; class  TGLOverlayElement;  An overlay element. More...;  ; class  TGLOverlayList;  Manage a collection of overlay elements. More...;  ; class  TGLOvlSelectRecord;  Selection record for overlay objects. More...;  ; class  TGLPadPainter;  ""Delegating"" part of TGLPadPainter. More...;  ; class  TGLParametricEquation;  A parametric surface is a surface defined by a parametric equation, involving two parameters (u, v): More...;  ; class  TGLParametricEquationGL;  GL-renderer wrapper for TGLParametricEquation. More...;  ; class  TGLParametricPlot;  ; class  TGLPerspectiveCamera;  Perspective projection camera - with characteristic foreshortening. More...;  ; class  TGLPhysicalShape;  Concrete physical shape - a GL drawable. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLPlot3D;  Description of TGLPlot3D. More...;  ; class  TGLPlotBox;  I",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:5969,Integrability,wrap,wrapper,5969,"ly translation, scaling and rotation along/round objects local axes. More...;  ; class  TGLManipSet;  Combine all available manipulators in a collection. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLObject;  Base-class for direct OpenGL renderers. More...;  ; class  TGLOrthoCamera;  Orthographic projection camera. More...;  ; class  TGLOutput;  Wrapper class for GL capture & output routines. More...;  ; class  TGLOverlayButton;  GL-overlay button. More...;  ; class  TGLOverlayElement;  An overlay element. More...;  ; class  TGLOverlayList;  Manage a collection of overlay elements. More...;  ; class  TGLOvlSelectRecord;  Selection record for overlay objects. More...;  ; class  TGLPadPainter;  ""Delegating"" part of TGLPadPainter. More...;  ; class  TGLParametricEquation;  A parametric surface is a surface defined by a parametric equation, involving two parameters (u, v): More...;  ; class  TGLParametricEquationGL;  GL-renderer wrapper for TGLParametricEquation. More...;  ; class  TGLParametricPlot;  ; class  TGLPerspectiveCamera;  Perspective projection camera - with characteristic foreshortening. More...;  ; class  TGLPhysicalShape;  Concrete physical shape - a GL drawable. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLPlot3D;  Description of TGLPlot3D. More...;  ; class  TGLPlotBox;  Implementation of a box around a histogram/function for plot-painters. More...;  ; class  TGLPlotCamera;  Camera for TGLPlotPainter and sub-classes. More...;  ; class  TGLPlotCoordinates;  Helper class for plot-painters holding information about axis ranges, numbers of bins and flags if certain axis is logarithmic. More...;  ; class  TGLPlotPainter;  Base class for plot-painters that provide GL rendering of various 2D and 3D histograms, functions and parametric surfaces. More...;  ; class  TGLPolyLine;  To draw a 3D polyline in a GL window. More...;  ; class  TGLPol",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:8327,Integrability,interface,interface,8327,"; class  TGLQuadric;  Wrapper class for GLU quadric shape drawing object. More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLRnrCtx;  The TGLRnrCtx class aggregates data for a given redering context as needed by various parts of the ROOT's OpenGL infrastructure. More...;  ; class  TGLRotateManip;  Rotate manipulator - attaches to physical shape and draws local axes widgets - rings drawn from attached physical center, in plane defined by axis. More...;  ; class  TGLSAFrame;  Standalone GL Viewer GUI main frame. More...;  ; class  TGLSAViewer;  The top level standalone GL-viewer - created via plugin manager. More...;  ; class  TGLScaleManip;  Scale manipulator - attaches to physical shape and draws local axes widgets with box heads. More...;  ; class  TGLScene;  TGLScene provides management and rendering of ROOT's default 3D /object representation as logical and physical shapes. More...;  ; class  TGLSceneBase;  Scene base-class – provides basic interface expected by the TGLViewer or its sub-classes: More...;  ; class  TGLSceneInfo;  Base class for extended scene context. More...;  ; class  TGLScenePad;  Implements VirtualViewer3D interface and fills the base-class visualization structures from pad contents. More...;  ; class  TGLSdfFontMaker;  Helper class for generation of Signed Distance Field (SDF) fonts for REve. More...;  ; class  TGLSelectBuffer;  Encapsulates OpenGL select buffer. More...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out selected object (TGLPhysicalShape*, TObject* or simply a void* for foreign scenes). More...;  ; class  TGLSelectRecordBase;  Base class for select records. More...;  ; class  TGLSphere;  Implements a native ROOT-GL sphere that can be rendered at different levels of detail. More...;  ; class  TGLStopwatch;  Stopwatch object for timing GL work. More...;  ; class  TGLSurfacePainter;  Impleme",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:8516,Integrability,interface,interface,8516,"gates data for a given redering context as needed by various parts of the ROOT's OpenGL infrastructure. More...;  ; class  TGLRotateManip;  Rotate manipulator - attaches to physical shape and draws local axes widgets - rings drawn from attached physical center, in plane defined by axis. More...;  ; class  TGLSAFrame;  Standalone GL Viewer GUI main frame. More...;  ; class  TGLSAViewer;  The top level standalone GL-viewer - created via plugin manager. More...;  ; class  TGLScaleManip;  Scale manipulator - attaches to physical shape and draws local axes widgets with box heads. More...;  ; class  TGLScene;  TGLScene provides management and rendering of ROOT's default 3D /object representation as logical and physical shapes. More...;  ; class  TGLSceneBase;  Scene base-class – provides basic interface expected by the TGLViewer or its sub-classes: More...;  ; class  TGLSceneInfo;  Base class for extended scene context. More...;  ; class  TGLScenePad;  Implements VirtualViewer3D interface and fills the base-class visualization structures from pad contents. More...;  ; class  TGLSdfFontMaker;  Helper class for generation of Signed Distance Field (SDF) fonts for REve. More...;  ; class  TGLSelectBuffer;  Encapsulates OpenGL select buffer. More...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out selected object (TGLPhysicalShape*, TObject* or simply a void* for foreign scenes). More...;  ; class  TGLSelectRecordBase;  Base class for select records. More...;  ; class  TGLSphere;  Implements a native ROOT-GL sphere that can be rendered at different levels of detail. More...;  ; class  TGLStopwatch;  Stopwatch object for timing GL work. More...;  ; class  TGLSurfacePainter;  Implements painting of TH2 with ""SURF"" option. More...;  ; class  TGLText;  GL Text. More...;  ; class  TGLTF3Painter;  Plot-painter for TF3 functions. More...;  ; class  TGLTH3Composition;  ; class  TGLTH3Com",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:1924,Modifiability,variab,variable-sized,1924,"es; class  TArcBall;  Implements the arc-ball rotation manipulator. More...;  ; class  TF2GL;  GL renderer for TF2. More...;  ; class  TGL5DDataSet;  ; class  TGL5DDataSetEditor;  GUI editor for OpenGL 5D Painter. More...;  ; class  TGL5DPainter;  TGL5DPainter implements ""gl5d"" option for TTree::Draw. More...;  ; class  TGLAdapter;  Allow plot-painters to be used for gl-inpad and gl-viewer. More...;  ; class  TGLAnnotation;  GL-overlay annotation. More...;  ; class  TGLAutoRotator;  Automatically rotates GL camera. More...;  ; class  TGLAxis;  GL Axis. More...;  ; class  TGLAxisPainter;  Utility class to paint axis in GL. More...;  ; class  TGLAxisPainterBox;  Painter class for axes encompassing a 3D box. More...;  ; class  TGLBoundingBox;  Concrete class describing an orientated (free) or axis aligned box of 8 vertices. More...;  ; class  TGLBoxCut;  Used by plot-painters to determine the area of the plot that is cut away. More...;  ; class  TGLBoxPainter;  Paints TH3 histograms by rendering variable-sized boxes matching the bin contents. More...;  ; class  TGLCamera;  Abstract base camera class - concrete classes for orthographic and perspective cameras derive from it. More...;  ; class  TGLCameraGuide;  Draws arrows showing camera orientation in the overlay. More...;  ; class  TGLCameraOverlay;  A GL overlay element which displays camera furstum. More...;  ; class  TGLClip;  Abstract clipping shape - derives from TGLPhysicalShape Adds clip mode (inside/outside) and pure virtual method to approximate shape as set of planes. More...;  ; class  TGLClipBox;  Concrete clip box object. More...;  ; class  TGLClipPlane;  Concrete clip plane object. More...;  ; class  TGLClipSet;  A collection of concrete TGLClip objects to be selected from. More...;  ; class  TGLClipSetEditor;  GUI editor for TGLClipSet. More...;  ; class  TGLClipSetSubEditor;  GUI sub-editor for TGLClipSet. More...;  ; class  TGLColor;  Class encapsulating color information in preferred GL format - an a",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:7967,Modifiability,plugin,plugin,7967,"ore...;  ; class  TGLPolyMarker;  To draw a 3D polymarker in a GL window. More...;  ; class  TGLPShapeObj;  Wrap TGLPysicalShape into TObject so that it can be edited using GED. More...;  ; class  TGLPShapeObjEditor;  GUI editor for TGLPShapeObj. More...;  ; class  TGLPShapeRef;  Base class for references to TGLPysicalShape that need to be notified when the shape is destroyed. More...;  ; class  TGLQuadric;  Wrapper class for GLU quadric shape drawing object. More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLRnrCtx;  The TGLRnrCtx class aggregates data for a given redering context as needed by various parts of the ROOT's OpenGL infrastructure. More...;  ; class  TGLRotateManip;  Rotate manipulator - attaches to physical shape and draws local axes widgets - rings drawn from attached physical center, in plane defined by axis. More...;  ; class  TGLSAFrame;  Standalone GL Viewer GUI main frame. More...;  ; class  TGLSAViewer;  The top level standalone GL-viewer - created via plugin manager. More...;  ; class  TGLScaleManip;  Scale manipulator - attaches to physical shape and draws local axes widgets with box heads. More...;  ; class  TGLScene;  TGLScene provides management and rendering of ROOT's default 3D /object representation as logical and physical shapes. More...;  ; class  TGLSceneBase;  Scene base-class – provides basic interface expected by the TGLViewer or its sub-classes: More...;  ; class  TGLSceneInfo;  Base class for extended scene context. More...;  ; class  TGLScenePad;  Implements VirtualViewer3D interface and fills the base-class visualization structures from pad contents. More...;  ; class  TGLSdfFontMaker;  Helper class for generation of Signed Distance Field (SDF) fonts for REve. More...;  ; class  TGLSelectBuffer;  Encapsulates OpenGL select buffer. More...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out s",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:8432,Modifiability,extend,extended,8432,"LRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLRnrCtx;  The TGLRnrCtx class aggregates data for a given redering context as needed by various parts of the ROOT's OpenGL infrastructure. More...;  ; class  TGLRotateManip;  Rotate manipulator - attaches to physical shape and draws local axes widgets - rings drawn from attached physical center, in plane defined by axis. More...;  ; class  TGLSAFrame;  Standalone GL Viewer GUI main frame. More...;  ; class  TGLSAViewer;  The top level standalone GL-viewer - created via plugin manager. More...;  ; class  TGLScaleManip;  Scale manipulator - attaches to physical shape and draws local axes widgets with box heads. More...;  ; class  TGLScene;  TGLScene provides management and rendering of ROOT's default 3D /object representation as logical and physical shapes. More...;  ; class  TGLSceneBase;  Scene base-class – provides basic interface expected by the TGLViewer or its sub-classes: More...;  ; class  TGLSceneInfo;  Base class for extended scene context. More...;  ; class  TGLScenePad;  Implements VirtualViewer3D interface and fills the base-class visualization structures from pad contents. More...;  ; class  TGLSdfFontMaker;  Helper class for generation of Signed Distance Field (SDF) fonts for REve. More...;  ; class  TGLSelectBuffer;  Encapsulates OpenGL select buffer. More...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out selected object (TGLPhysicalShape*, TObject* or simply a void* for foreign scenes). More...;  ; class  TGLSelectRecordBase;  Base class for select records. More...;  ; class  TGLSphere;  Implements a native ROOT-GL sphere that can be rendered at different levels of detail. More...;  ; class  TGLStopwatch;  Stopwatch object for timing GL work. More...;  ; class  TGLSurfacePainter;  Implements painting of TH2 with ""SURF"" option. More...;  ; class  TGLText;  GL Text. More...;  ; class ",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:4728,Testability,log,logical,4728,"  Frame-buffer object. More...;  ; class  TGLFont;  A wrapper class for FTFont. More...;  ; class  TGLFontManager;  A FreeType GL font manager. More...;  ; class  TGLFormat;  Encapsulation of format / contents of an OpenGL buffer. More...;  ; class  TGLH2PolyPainter;  Paint TH2Poly. More...;  ; class  TGLHistPainter;  The histogram painter class using OpenGL. More...;  ; class  TGLIsoPainter;  ""gliso"" option for TH3. More...;  ; class  TGLLegoPainter;  Plot-painter implementing LEGO rendering of TH2 histograms in cartesian, polar, cylindrical and spherical coordinates. More...;  ; class  TGLLightSet;  Encapsulates a set of lights for OpenGL. More...;  ; class  TGLLightSetSubEditor;  Sub-editor for TGLLightSet. More...;  ; class  TGLLine3;  3D space, fixed length, line class, with direction / length 'vector', passing through point 'vertex'. More...;  ; class  TGLLockable;  Simple locking interface used by viewer and scene. More...;  ; class  TGLLogicalShape;  Abstract logical shape - a GL 'drawable' - base for all shapes - faceset sphere etc. More...;  ; class  TGLManip;  Abstract base class for viewer manipulators, which allow direct in viewer manipulation of a (TGlPhysicalShape) object - currently translation, scaling and rotation along/round objects local axes. More...;  ; class  TGLManipSet;  Combine all available manipulators in a collection. More...;  ; class  TGLMatrix;  16 component (4x4) transform matrix - column MAJOR as per GL. More...;  ; class  TGLObject;  Base-class for direct OpenGL renderers. More...;  ; class  TGLOrthoCamera;  Orthographic projection camera. More...;  ; class  TGLOutput;  Wrapper class for GL capture & output routines. More...;  ; class  TGLOverlayButton;  GL-overlay button. More...;  ; class  TGLOverlayElement;  An overlay element. More...;  ; class  TGLOverlayList;  Manage a collection of overlay elements. More...;  ; class  TGLOvlSelectRecord;  Selection record for overlay objects. More...;  ; class  TGLPadPainter;  ""Delegating"" p",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:6693,Testability,log,logarithmic,6693,".;  ; class  TGLOvlSelectRecord;  Selection record for overlay objects. More...;  ; class  TGLPadPainter;  ""Delegating"" part of TGLPadPainter. More...;  ; class  TGLParametricEquation;  A parametric surface is a surface defined by a parametric equation, involving two parameters (u, v): More...;  ; class  TGLParametricEquationGL;  GL-renderer wrapper for TGLParametricEquation. More...;  ; class  TGLParametricPlot;  ; class  TGLPerspectiveCamera;  Perspective projection camera - with characteristic foreshortening. More...;  ; class  TGLPhysicalShape;  Concrete physical shape - a GL drawable. More...;  ; class  TGLPlane;  3D plane class - of format Ax + By + Cz + D = 0 More...;  ; class  TGLPlot3D;  Description of TGLPlot3D. More...;  ; class  TGLPlotBox;  Implementation of a box around a histogram/function for plot-painters. More...;  ; class  TGLPlotCamera;  Camera for TGLPlotPainter and sub-classes. More...;  ; class  TGLPlotCoordinates;  Helper class for plot-painters holding information about axis ranges, numbers of bins and flags if certain axis is logarithmic. More...;  ; class  TGLPlotPainter;  Base class for plot-painters that provide GL rendering of various 2D and 3D histograms, functions and parametric surfaces. More...;  ; class  TGLPolyLine;  To draw a 3D polyline in a GL window. More...;  ; class  TGLPolyMarker;  To draw a 3D polymarker in a GL window. More...;  ; class  TGLPShapeObj;  Wrap TGLPysicalShape into TObject so that it can be edited using GED. More...;  ; class  TGLPShapeObjEditor;  GUI editor for TGLPShapeObj. More...;  ; class  TGLPShapeRef;  Base class for references to TGLPysicalShape that need to be notified when the shape is destroyed. More...;  ; class  TGLQuadric;  Wrapper class for GLU quadric shape drawing object. More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLRnrCtx;  The TGLRnrCtx class aggregates data for a given redering context as needed by various parts of the ROOT's OpenGL infrastru",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:8230,Testability,log,logical,8230,"e...;  ; class  TGLPShapeRef;  Base class for references to TGLPysicalShape that need to be notified when the shape is destroyed. More...;  ; class  TGLQuadric;  Wrapper class for GLU quadric shape drawing object. More...;  ; class  TGLRect;  Viewport (pixel base) 2D rectangle class. More...;  ; class  TGLRnrCtx;  The TGLRnrCtx class aggregates data for a given redering context as needed by various parts of the ROOT's OpenGL infrastructure. More...;  ; class  TGLRotateManip;  Rotate manipulator - attaches to physical shape and draws local axes widgets - rings drawn from attached physical center, in plane defined by axis. More...;  ; class  TGLSAFrame;  Standalone GL Viewer GUI main frame. More...;  ; class  TGLSAViewer;  The top level standalone GL-viewer - created via plugin manager. More...;  ; class  TGLScaleManip;  Scale manipulator - attaches to physical shape and draws local axes widgets with box heads. More...;  ; class  TGLScene;  TGLScene provides management and rendering of ROOT's default 3D /object representation as logical and physical shapes. More...;  ; class  TGLSceneBase;  Scene base-class – provides basic interface expected by the TGLViewer or its sub-classes: More...;  ; class  TGLSceneInfo;  Base class for extended scene context. More...;  ; class  TGLScenePad;  Implements VirtualViewer3D interface and fills the base-class visualization structures from pad contents. More...;  ; class  TGLSdfFontMaker;  Helper class for generation of Signed Distance Field (SDF) fonts for REve. More...;  ; class  TGLSelectBuffer;  Encapsulates OpenGL select buffer. More...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out selected object (TGLPhysicalShape*, TObject* or simply a void* for foreign scenes). More...;  ; class  TGLSelectRecordBase;  Base class for select records. More...;  ; class  TGLSphere;  Implements a native ROOT-GL sphere that can be rendered at differ",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__opengl.html:8984,Usability,simpl,simply,8984,"  TGLSAViewer;  The top level standalone GL-viewer - created via plugin manager. More...;  ; class  TGLScaleManip;  Scale manipulator - attaches to physical shape and draws local axes widgets with box heads. More...;  ; class  TGLScene;  TGLScene provides management and rendering of ROOT's default 3D /object representation as logical and physical shapes. More...;  ; class  TGLSceneBase;  Scene base-class – provides basic interface expected by the TGLViewer or its sub-classes: More...;  ; class  TGLSceneInfo;  Base class for extended scene context. More...;  ; class  TGLScenePad;  Implements VirtualViewer3D interface and fills the base-class visualization structures from pad contents. More...;  ; class  TGLSdfFontMaker;  Helper class for generation of Signed Distance Field (SDF) fonts for REve. More...;  ; class  TGLSelectBuffer;  Encapsulates OpenGL select buffer. More...;  ; class  TGLSelectionBuffer;  ; class  TGLSelectRecord;  Standard selection record including information about containing scene and details ob out selected object (TGLPhysicalShape*, TObject* or simply a void* for foreign scenes). More...;  ; class  TGLSelectRecordBase;  Base class for select records. More...;  ; class  TGLSphere;  Implements a native ROOT-GL sphere that can be rendered at different levels of detail. More...;  ; class  TGLStopwatch;  Stopwatch object for timing GL work. More...;  ; class  TGLSurfacePainter;  Implements painting of TH2 with ""SURF"" option. More...;  ; class  TGLText;  GL Text. More...;  ; class  TGLTF3Painter;  Plot-painter for TF3 functions. More...;  ; class  TGLTH3Composition;  ; class  TGLTH3CompositionPainter;  ; class  TGLTH3Slice;  A slice of a TH3. More...;  ; class  TGLTransManip;  Translation manipulator - attaches to physical shape and draws local axes widgets with arrow heads. More...;  ; class  TGLUtil;  Wrapper class for various misc static functions - error checking, draw helpers etc. More...;  ; class  TGLVector3;  3 component (x/y/z) vector class. M",MatchSource.WIKI,doc/master/group__opengl.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__opengl.html
https://root.cern/doc/master/group__PdfFunc.html:302,Deployability,continuous,continuous,302,". ROOT: Probability Density Functions (PDF). ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; Probability Density Functions (PDF)Math » MathCore | Math » MathMore » Statistical functions. ; Probability density functions of various statistical distributions (continuous and discrete). ; The probability density function returns the probability that the variate has the value x. In statistics the PDF is also called the frequency function. . Functions; double ROOT::Math::noncentral_chisquared_pdf (double x, double r, double lambda);  Probability density function of the non central \(\chi^2\) distribution with \(r\) degrees of freedom and the noon-central parameter \(\lambda\). ;  ; double ROOT::Math::vavilov_accurate_pdf (double x, double kappa, double beta2);  The Vavilov probability density function. ;  ; double ROOT::Math::vavilov_fast_pdf (double x, double kappa, double beta2);  The Vavilov probability density function. ;  . Probability Density Functions from MathCore; Additional PDF's are provided in the MathMore library (see PDF functions from MathMore) . double ROOT::Math::beta_pdf (double x, double a, double b);  Probability density function of the beta distribution. ;  ; double ROOT::Math::binomial_pdf (unsigned int k, double p, unsigned int n);  Probability density function of the binomial distribution. ;  ; double ROOT::Math::negative_binomial_pdf (unsigned int k, double p, double n);  Probability density function of the negative binomial distribution. ;  ; double ROOT::Math::breitwigner_pdf (double x, double gamma, double x0=0);  Probability density function of Breit-Wigner distribution, which is similar, just a different definition of the parameters, to the Cauchy distribution (see cauchy_pdf ) ;  ; double ROOT::Math::cauchy_pdf (double x, double b=1, double x0=0);  Probability density function of the Cauchy distribution which is also called Lorentzian distribution. ;  ; double ROOT::Math::chisquared_pdf (double x, d",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:5032,Modifiability,variab,variable,5032,"pdf(). double ROOT::Math::beta_pdf ; (; double ; x, . double ; a, . double ; b . ). inline . Probability density function of the beta distribution. . \[ p(x) = \frac{\Gamma (a + b) } {\Gamma(a)\Gamma(b) } x ^{a-1} (1 - x)^{b-1} \]. for \(0 \leq x \leq 1 \). For detailed description see Mathworld. ; Definition at line 82 of file PdfFuncMathCore.h. ◆ bigaussian_pdf(). double ROOT::Math::bigaussian_pdf ; (; double ; x, . double ; y, . double ; sigmax = 1, . double ; sigmay = 1, . double ; rho = 0, . double ; x0 = 0, . double ; y0 = 0 . ). inline . Probability density function of the bi-dimensional (Gaussian) distribution. . \[ p(x) = {1 \over 2 \pi \sigma_x \sigma_y \sqrt{1-\rho^2}} \exp (-((x-x0)^2/\sigma_x^2 + (y-y0)^2/\sigma_y^2 - 2 \rho x y/(\sigma_x\sigma_y))/2(1-\rho^2)) \]. For detailed description see Mathworld. It can also be evaluated using normal_pdf which will call the same implementation.; Parameters. xx variable ; yy variable ; sigmaxthe stdev in x ; sigmaythe stdev in y ; rhocorrelation, must be between -1,1 ; x0the offset in x ; y0the offset in y . Definition at line 431 of file PdfFuncMathCore.h. ◆ binomial_pdf(). double ROOT::Math::binomial_pdf ; (; unsigned int ; k, . double ; p, . unsigned int ; n . ). inline . Probability density function of the binomial distribution. . \[ p(k) = \frac{n!}{k! (n-k)!} p^k (1-p)^{n-k} \]. for \( 0 \leq k \leq n \). For detailed description see Mathworld. ; Definition at line 118 of file PdfFuncMathCore.h. ◆ breitwigner_pdf(). double ROOT::Math::breitwigner_pdf ; (; double ; x, . double ; gamma, . double ; x0 = 0 . ). inline . Probability density function of Breit-Wigner distribution, which is similar, just a different definition of the parameters, to the Cauchy distribution (see cauchy_pdf ) . \[ p(x) = \frac{1}{\pi} \frac{\frac{1}{2} \Gamma}{x^2 + (\frac{1}{2} \Gamma)^2} \]. Definition at line 175 of file PdfFuncMathCore.h. ◆ cauchy_pdf(). double ROOT::Math::cauchy_pdf ; (; double ; x, . double ; b = 1, . double ; x0",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:5046,Modifiability,variab,variable,5046,"pdf(). double ROOT::Math::beta_pdf ; (; double ; x, . double ; a, . double ; b . ). inline . Probability density function of the beta distribution. . \[ p(x) = \frac{\Gamma (a + b) } {\Gamma(a)\Gamma(b) } x ^{a-1} (1 - x)^{b-1} \]. for \(0 \leq x \leq 1 \). For detailed description see Mathworld. ; Definition at line 82 of file PdfFuncMathCore.h. ◆ bigaussian_pdf(). double ROOT::Math::bigaussian_pdf ; (; double ; x, . double ; y, . double ; sigmax = 1, . double ; sigmay = 1, . double ; rho = 0, . double ; x0 = 0, . double ; y0 = 0 . ). inline . Probability density function of the bi-dimensional (Gaussian) distribution. . \[ p(x) = {1 \over 2 \pi \sigma_x \sigma_y \sqrt{1-\rho^2}} \exp (-((x-x0)^2/\sigma_x^2 + (y-y0)^2/\sigma_y^2 - 2 \rho x y/(\sigma_x\sigma_y))/2(1-\rho^2)) \]. For detailed description see Mathworld. It can also be evaluated using normal_pdf which will call the same implementation.; Parameters. xx variable ; yy variable ; sigmaxthe stdev in x ; sigmaythe stdev in y ; rhocorrelation, must be between -1,1 ; x0the offset in x ; y0the offset in y . Definition at line 431 of file PdfFuncMathCore.h. ◆ binomial_pdf(). double ROOT::Math::binomial_pdf ; (; unsigned int ; k, . double ; p, . unsigned int ; n . ). inline . Probability density function of the binomial distribution. . \[ p(k) = \frac{n!}{k! (n-k)!} p^k (1-p)^{n-k} \]. for \( 0 \leq k \leq n \). For detailed description see Mathworld. ; Definition at line 118 of file PdfFuncMathCore.h. ◆ breitwigner_pdf(). double ROOT::Math::breitwigner_pdf ; (; double ; x, . double ; gamma, . double ; x0 = 0 . ). inline . Probability density function of Breit-Wigner distribution, which is similar, just a different definition of the parameters, to the Cauchy distribution (see cauchy_pdf ) . \[ p(x) = \frac{1}{\pi} \frac{\frac{1}{2} \Gamma}{x^2 + (\frac{1}{2} \Gamma)^2} \]. Definition at line 175 of file PdfFuncMathCore.h. ◆ cauchy_pdf(). double ROOT::Math::cauchy_pdf ; (; double ; x, . double ; b = 1, . double ; x0",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:10084,Modifiability,variab,variable,10084,"Landau distribution: . \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. where \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DENLAN) is used; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 21 of file PdfFuncMathCore.cxx. ◆ lognormal_pdf(). double ROOT::Math::lognormal_pdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). inline . Probability density function of the lognormal distribution. . \[ p(x) = {1 \over x \sqrt{2 \pi s^2} } e^{-(\ln{x} - m)^2/2 s^2} \]. for x>0. For detailed description see Mathworld. Parameters. xx variable ; mM = 0 for lognormal ; sscale parameter (not the sigma of the distribution which is not even defined) ; x0location parameter, corresponds approximately to the most probable value. For x0 = 0, sigma = 1, the x_mpv = -0.22278 . Definition at line 483 of file PdfFuncMathCore.h. ◆ negative_binomial_pdf(). double ROOT::Math::negative_binomial_pdf ; (; unsigned int ; k, . double ; p, . double ; n . ). inline . Probability density function of the negative binomial distribution. . \[ p(k) = \frac{(k+n-1)!}{k! (n-1)!} p^{n} (1-p)^{k} \]. For detailed description see Mathworld (where \(k \to x\) and \(n \to r\)). The distribution in Wikipedia is defined with a \(p\) corresponding to \(1-p\) in this case. ; Definition at line 146 of file PdfFuncMathCore.h. ◆ noncentral_chisquared_pdf(). double ROOT::Math::noncentral_chisquared_pdf ; (; double ; x, . double ; r, . double ; lambda . ). Probability density function of the non central \(\chi^2\) distribution with \(r\) degrees of freedom and the noon-central parameter \(\lambda\). . \[ p_r(x) = \frac{1}{\Gamma(r/2) 2^{r/2}} x^{r/2",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:3287,Testability,log,lognormal,3287,"double alpha, double n, double sigma, double mean=0);  Crystal ball function. ;  ; double ROOT::Math::exponential_pdf (double x, double lambda, double x0=0);  Probability density function of the exponential distribution. ;  ; double ROOT::Math::fdistribution_pdf (double x, double n, double m, double x0=0);  Probability density function of the F-distribution. ;  ; double ROOT::Math::gamma_pdf (double x, double alpha, double theta, double x0=0);  Probability density function of the gamma distribution. ;  ; double ROOT::Math::gaussian_pdf (double x, double sigma=1, double x0=0);  Probability density function of the normal (Gaussian) distribution. ;  ; double ROOT::Math::bigaussian_pdf (double x, double y, double sigmax=1, double sigmay=1, double rho=0, double x0=0, double y0=0);  Probability density function of the bi-dimensional (Gaussian) distribution. ;  ; double ROOT::Math::landau_pdf (double x, double xi=1, double x0=0);  Probability density function of the Landau distribution: ;  ; double ROOT::Math::lognormal_pdf (double x, double m, double s, double x0=0);  Probability density function of the lognormal distribution. ;  ; double ROOT::Math::normal_pdf (double x, double sigma=1, double x0=0);  Probability density function of the normal (Gaussian) distribution. ;  ; double ROOT::Math::poisson_pdf (unsigned int n, double mu);  Probability density function of the Poisson distribution. ;  ; double ROOT::Math::tdistribution_pdf (double x, double r, double x0=0);  Probability density function of Student's t-distribution. ;  ; double ROOT::Math::uniform_pdf (double x, double a, double b, double x0=0);  Probability density function of the uniform (flat) distribution. ;  ; double ROOT::Math::crystalball_pdf (double x, double alpha, double n, double sigma, double mean=0);  pdf definition of the crystal_ball which is defined only for n > 1 otherwise integral is diverging ;  . Function Documentation. ◆ beta_pdf(). double ROOT::Math::beta_pdf ; (; double ; x, . double ; a, . d",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:9333,Testability,log,log,9333,". double ; alpha, . double ; theta, . double ; x0 = 0 . ). inline . Probability density function of the gamma distribution. . \[ p(x) = {1 \over \Gamma(\alpha) \theta^{\alpha}} x^{\alpha-1} e^{-x/\theta} \]. for x>0. For detailed description see Mathworld. ; Definition at line 363 of file PdfFuncMathCore.h. ◆ gaussian_pdf(). double ROOT::Math::gaussian_pdf ; (; double ; x, . double ; sigma = 1, . double ; x0 = 0 . ). inline . Probability density function of the normal (Gaussian) distribution. . \[ p(x) = {1 \over \sqrt{2 \pi \sigma^2}} e^{-x^2 / 2\sigma^2} \]. For detailed description see Mathworld. It can also be evaluated using normal_pdf which will call the same implementation. ; Definition at line 402 of file PdfFuncMathCore.h. ◆ landau_pdf(). double ROOT::Math::landau_pdf ; (; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). Probability density function of the Landau distribution: . \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. where \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DENLAN) is used; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 21 of file PdfFuncMathCore.cxx. ◆ lognormal_pdf(). double ROOT::Math::lognormal_pdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). inline . Probability density function of the lognormal distribution. . \[ p(x) = {1 \over x \sqrt{2 \pi s^2} } e^{-(\ln{x} - m)^2/2 s^2} \]. for x>0. For detailed description see Mathworld. Parameters. xx variable ; mM = 0 for lognormal ; sscale parameter (not the sigma of the distribution which is not even defined) ; x0location parameter, corresponds approximately to the most probable value. For x0 = 0, sigma =",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:9924,Testability,log,lognormal,9924,"valuated using normal_pdf which will call the same implementation. ; Definition at line 402 of file PdfFuncMathCore.h. ◆ landau_pdf(). double ROOT::Math::landau_pdf ; (; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). Probability density function of the Landau distribution: . \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. where \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DENLAN) is used; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 21 of file PdfFuncMathCore.cxx. ◆ lognormal_pdf(). double ROOT::Math::lognormal_pdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). inline . Probability density function of the lognormal distribution. . \[ p(x) = {1 \over x \sqrt{2 \pi s^2} } e^{-(\ln{x} - m)^2/2 s^2} \]. for x>0. For detailed description see Mathworld. Parameters. xx variable ; mM = 0 for lognormal ; sscale parameter (not the sigma of the distribution which is not even defined) ; x0location parameter, corresponds approximately to the most probable value. For x0 = 0, sigma = 1, the x_mpv = -0.22278 . Definition at line 483 of file PdfFuncMathCore.h. ◆ negative_binomial_pdf(). double ROOT::Math::negative_binomial_pdf ; (; unsigned int ; k, . double ; p, . double ; n . ). inline . Probability density function of the negative binomial distribution. . \[ p(k) = \frac{(k+n-1)!}{k! (n-1)!} p^{n} (1-p)^{k} \]. For detailed description see Mathworld (where \(k \to x\) and \(n \to r\)). The distribution in Wikipedia is defined with a \(p\) corresponding to \(1-p\) in this case. ; Definition at line 146 of file PdfFuncMathCore.h. ◆ noncentral_chisquared_pdf(). double ROOT::Math::noncentral_chisq",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__PdfFunc.html:10106,Testability,log,lognormal,10106,"Landau distribution: . \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. where \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DENLAN) is used; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 21 of file PdfFuncMathCore.cxx. ◆ lognormal_pdf(). double ROOT::Math::lognormal_pdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). inline . Probability density function of the lognormal distribution. . \[ p(x) = {1 \over x \sqrt{2 \pi s^2} } e^{-(\ln{x} - m)^2/2 s^2} \]. for x>0. For detailed description see Mathworld. Parameters. xx variable ; mM = 0 for lognormal ; sscale parameter (not the sigma of the distribution which is not even defined) ; x0location parameter, corresponds approximately to the most probable value. For x0 = 0, sigma = 1, the x_mpv = -0.22278 . Definition at line 483 of file PdfFuncMathCore.h. ◆ negative_binomial_pdf(). double ROOT::Math::negative_binomial_pdf ; (; unsigned int ; k, . double ; p, . double ; n . ). inline . Probability density function of the negative binomial distribution. . \[ p(k) = \frac{(k+n-1)!}{k! (n-1)!} p^{n} (1-p)^{k} \]. For detailed description see Mathworld (where \(k \to x\) and \(n \to r\)). The distribution in Wikipedia is defined with a \(p\) corresponding to \(1-p\) in this case. ; Definition at line 146 of file PdfFuncMathCore.h. ◆ noncentral_chisquared_pdf(). double ROOT::Math::noncentral_chisquared_pdf ; (; double ; x, . double ; r, . double ; lambda . ). Probability density function of the non central \(\chi^2\) distribution with \(r\) degrees of freedom and the noon-central parameter \(\lambda\). . \[ p_r(x) = \frac{1}{\Gamma(r/2) 2^{r/2}} x^{r/2",MatchSource.WIKI,doc/master/group__PdfFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__PdfFunc.html
https://root.cern/doc/master/group__ProbFunc.html:739,Deployability,release,releases,739,". ROOT: Cumulative Distribution Functions (CDF). ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; Cumulative Distribution Functions (CDF)Math » MathCore | Math » MathMore » Statistical functions. ; Cumulative distribution functions of various distributions. ; The functions with the extension _cdf calculate the lower tail integral of the probability density function. \[ D(x) = \int_{-\infty}^{x} p(x') dx' \]. while those with the _cdf_c extension calculate the complement of cumulative distribution function, called in statistics the survival function. It corresponds to the upper tail integral of the probability density function. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. NOTE: In the old releases (< 5.14) the _cdf functions were called _quant and the _cdf_c functions were called _prob. These names are currently kept for backward compatibility, but their usage is deprecated.; These functions are defined in the header file Math/ProbFunc.h or in the global one including all statistical functions Math/DistFunc.h . Functions; double ROOT::Math::beta_cdf (double x, double a, double b);  Cumulative distribution function of the beta distribution Upper tail of the integral of the beta_pdf. ;  ; double ROOT::Math::beta_cdf_c (double x, double a, double b);  Complement of the cumulative distribution function of the beta distribution. ;  ; double ROOT::Math::binomial_cdf (unsigned int k, double p, unsigned int n);  Cumulative distribution function of the Binomial distribution Lower tail of the integral of the binomial_pdf. ;  ; double ROOT::Math::binomial_cdf_c (unsigned int k, double p, unsigned int n);  Complement of the cumulative distribution function of the Binomial distribution. ;  ; double ROOT::Math::breitwigner_cdf (double x, double gamma, double x0=0);  Cumulative distribution function (lower tail) of the Breit_Wigner distribution and it is similar (just a different parameter definition) to the Cauchy distribution (see cauchy_c",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__ProbFunc.html:5025,Testability,log,lognormal,5025,"n, double m, double x0=0);  Cumulative distribution function of the F-distribution (lower tail). ;  ; double ROOT::Math::fdistribution_cdf_c (double x, double n, double m, double x0=0);  Complement of the cumulative distribution function of the F-distribution (upper tail). ;  ; double ROOT::Math::gamma_cdf (double x, double alpha, double theta, double x0=0);  Cumulative distribution function of the gamma distribution (lower tail). ;  ; double ROOT::Math::gamma_cdf_c (double x, double alpha, double theta, double x0=0);  Complement of the cumulative distribution function of the gamma distribution (upper tail). ;  ; double ROOT::Math::landau_cdf (double x, double xi=1, double x0=0);  Cumulative distribution function of the Landau distribution (lower tail). ;  ; double ROOT::Math::landau_cdf_c (double x, double xi=1, double x0=0);  Complement of the distribution function of the Landau distribution (upper tail). ;  ; double ROOT::Math::lognormal_cdf (double x, double m, double s, double x0=0);  Cumulative distribution function of the lognormal distribution (lower tail). ;  ; double ROOT::Math::lognormal_cdf_c (double x, double m, double s, double x0=0);  Complement of the cumulative distribution function of the lognormal distribution (upper tail). ;  ; double ROOT::Math::negative_binomial_cdf (unsigned int k, double p, double n);  Cumulative distribution function of the Negative Binomial distribution Lower tail of the integral of the negative_binomial_pdf. ;  ; double ROOT::Math::negative_binomial_cdf_c (unsigned int k, double p, double n);  Complement of the cumulative distribution function of the Negative Binomial distribution. ;  ; double ROOT::Math::normal_cdf (double x, double sigma=1, double x0=0);  Cumulative distribution function of the normal (Gaussian) distribution (lower tail). ;  ; double ROOT::Math::normal_cdf_c (double x, double sigma=1, double x0=0);  Complement of the cumulative distribution function of the normal (Gaussian) distribution (upper tail). ;  ;",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__ProbFunc.html:5206,Testability,log,lognormal,5206," double x0=0);  Complement of the cumulative distribution function of the F-distribution (upper tail). ;  ; double ROOT::Math::gamma_cdf (double x, double alpha, double theta, double x0=0);  Cumulative distribution function of the gamma distribution (lower tail). ;  ; double ROOT::Math::gamma_cdf_c (double x, double alpha, double theta, double x0=0);  Complement of the cumulative distribution function of the gamma distribution (upper tail). ;  ; double ROOT::Math::landau_cdf (double x, double xi=1, double x0=0);  Cumulative distribution function of the Landau distribution (lower tail). ;  ; double ROOT::Math::landau_cdf_c (double x, double xi=1, double x0=0);  Complement of the distribution function of the Landau distribution (upper tail). ;  ; double ROOT::Math::lognormal_cdf (double x, double m, double s, double x0=0);  Cumulative distribution function of the lognormal distribution (lower tail). ;  ; double ROOT::Math::lognormal_cdf_c (double x, double m, double s, double x0=0);  Complement of the cumulative distribution function of the lognormal distribution (upper tail). ;  ; double ROOT::Math::negative_binomial_cdf (unsigned int k, double p, double n);  Cumulative distribution function of the Negative Binomial distribution Lower tail of the integral of the negative_binomial_pdf. ;  ; double ROOT::Math::negative_binomial_cdf_c (unsigned int k, double p, double n);  Complement of the cumulative distribution function of the Negative Binomial distribution. ;  ; double ROOT::Math::normal_cdf (double x, double sigma=1, double x0=0);  Cumulative distribution function of the normal (Gaussian) distribution (lower tail). ;  ; double ROOT::Math::normal_cdf_c (double x, double sigma=1, double x0=0);  Complement of the cumulative distribution function of the normal (Gaussian) distribution (upper tail). ;  ; double ROOT::Math::poisson_cdf (unsigned int n, double mu);  Cumulative distribution function of the Poisson distribution Lower tail of the integral of the poisson_pdf. ;",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__ProbFunc.html:16094,Testability,log,log,16094,"mplete gamma function, ROOT::Math::inc_gamma, from Cephes ; Definition at line 204 of file ProbFuncMathCore.cxx. ◆ gamma_cdf_c(). double ROOT::Math::gamma_cdf_c ; (; double ; x, . double ; alpha, . double ; theta, . double ; x0 = 0 . ). Complement of the cumulative distribution function of the gamma distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} {1 \over \Gamma(\alpha) \theta^{\alpha}} x'^{\alpha-1} e^{-x'/\theta} dx' \]. For detailed description see Mathworld. It is implemented using the incomplete gamma function, ROOT::Math::inc_gamma, from Cephes ; Definition at line 198 of file ProbFuncMathCore.cxx. ◆ landau_cdf(). double ROOT::Math::landau_cdf ; (; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). Cumulative distribution function of the Landau distribution (lower tail). . \[ D(x) = \int_{-\infty}^{x} p(x) dx \]. where \(p(x)\) is the Landau probability density function : ; \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. with \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DISLAN) is used.; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 336 of file ProbFuncMathCore.cxx. ◆ landau_cdf_c(). double ROOT::Math::landau_cdf_c ; (; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). inline . Complement of the distribution function of the Landau distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} p(x) dx \]. where p(x) is the Landau probability density function. It is implemented simply as 1. - landau_cdf; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 402 of file ProbFuncMathCore.h. ◆ lognormal_cdf(). double ROOT::Math::l",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__ProbFunc.html:17176,Testability,log,lognormal,17176,"S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DISLAN) is used.; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 336 of file ProbFuncMathCore.cxx. ◆ landau_cdf_c(). double ROOT::Math::landau_cdf_c ; (; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). inline . Complement of the distribution function of the Landau distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} p(x) dx \]. where p(x) is the Landau probability density function. It is implemented simply as 1. - landau_cdf; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 402 of file ProbFuncMathCore.h. ◆ lognormal_cdf(). double ROOT::Math::lognormal_cdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). Cumulative distribution function of the lognormal distribution (lower tail). . \[ D(x) = \int_{-\infty}^{x} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \]. For detailed description see Mathworld. ; Definition at line 218 of file ProbFuncMathCore.cxx. ◆ lognormal_cdf_c(). double ROOT::Math::lognormal_cdf_c ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). Complement of the cumulative distribution function of the lognormal distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \]. For detailed description see Mathworld. ; Definition at line 210 of file ProbFuncMathCore.cxx. ◆ negative_binomial_cdf(). double ROOT::Math::negative_binomial_cdf ; (; unsigned int ; k, . double ; p, . double ; n . ). Cumulative distribution function of the Negative Binomial distribution Lower tail of the integral of the negative_binomial_pdf. ; Definition at line 316 of file ProbFuncMathCore.cxx. ◆ negative_binomial_cdf_c(). double ROOT::Math::nega",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__ProbFunc.html:17587,Testability,log,lognormal,17587,"; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). inline . Complement of the distribution function of the Landau distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} p(x) dx \]. where p(x) is the Landau probability density function. It is implemented simply as 1. - landau_cdf; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 402 of file ProbFuncMathCore.h. ◆ lognormal_cdf(). double ROOT::Math::lognormal_cdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). Cumulative distribution function of the lognormal distribution (lower tail). . \[ D(x) = \int_{-\infty}^{x} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \]. For detailed description see Mathworld. ; Definition at line 218 of file ProbFuncMathCore.cxx. ◆ lognormal_cdf_c(). double ROOT::Math::lognormal_cdf_c ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). Complement of the cumulative distribution function of the lognormal distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \]. For detailed description see Mathworld. ; Definition at line 210 of file ProbFuncMathCore.cxx. ◆ negative_binomial_cdf(). double ROOT::Math::negative_binomial_cdf ; (; unsigned int ; k, . double ; p, . double ; n . ). Cumulative distribution function of the Negative Binomial distribution Lower tail of the integral of the negative_binomial_pdf. ; Definition at line 316 of file ProbFuncMathCore.cxx. ◆ negative_binomial_cdf_c(). double ROOT::Math::negative_binomial_cdf_c ; (; unsigned int ; k, . double ; p, . double ; n . ). Complement of the cumulative distribution function of the Negative Binomial distribution. ; Upper tail of the integral of the negative_binomial_pdf ; Definition at line 326 of file ProbFuncMathCore.cxx. ◆ normal_cdf(). double ROOT::Math::normal_cdf ; (; double ; x, . double ; sigma = 1, . double ; x0 = 0 . ). Cumulative distr",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__ProbFunc.html:16837,Usability,simpl,simply,16837,"ribution (lower tail). . \[ D(x) = \int_{-\infty}^{x} p(x) dx \]. where \(p(x)\) is the Landau probability density function : ; \[ p(x) = \frac{1}{\xi} \phi (\lambda) \]. with ; \[ \phi(\lambda) = \frac{1}{2 \pi i}\int_{c-i\infty}^{c+i\infty} e^{\lambda s + s \log{s}} ds\]. with \(\lambda = (x-x_0)/\xi\). For a detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (DISLAN) is used.; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 336 of file ProbFuncMathCore.cxx. ◆ landau_cdf_c(). double ROOT::Math::landau_cdf_c ; (; double ; x, . double ; xi = 1, . double ; x0 = 0 . ). inline . Complement of the distribution function of the Landau distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} p(x) dx \]. where p(x) is the Landau probability density function. It is implemented simply as 1. - landau_cdf; Parameters. xThe argument \(x\) ; xiThe width parameter \(\xi\) ; x0The location parameter \(x_0\) . Definition at line 402 of file ProbFuncMathCore.h. ◆ lognormal_cdf(). double ROOT::Math::lognormal_cdf ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). Cumulative distribution function of the lognormal distribution (lower tail). . \[ D(x) = \int_{-\infty}^{x} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \]. For detailed description see Mathworld. ; Definition at line 218 of file ProbFuncMathCore.cxx. ◆ lognormal_cdf_c(). double ROOT::Math::lognormal_cdf_c ; (; double ; x, . double ; m, . double ; s, . double ; x0 = 0 . ). Complement of the cumulative distribution function of the lognormal distribution (upper tail). . \[ D(x) = \int_{x}^{+\infty} {1 \over x' \sqrt{2 \pi s^2} } e^{-(\ln{x'} - m)^2/2 s^2} dx' \]. For detailed description see Mathworld. ; Definition at line 210 of file ProbFuncMathCore.cxx. ◆ negative_binomia",MatchSource.WIKI,doc/master/group__ProbFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__ProbFunc.html
https://root.cern/doc/master/group__proof.html:661,Testability,benchmark,benchmark,661,". ROOT: PROOF. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files ; PROOF. ; Classes defining the Parallel ROOT Facility, PROOF, a framework for parallel analysis of ROOT TTrees. ; Deprecated:We keep PROOF for those who still need it for legacy use cases. PROOF is not developed anymore and receiving only limited support. ROOT has since a few years moved to RDataFrame and related products as multi-core/multi-processing engines. Modules;  PROOF kernel Libraries;  The PROOF kernel libraries (libProof, libProofPlayer, libProofDraw) contain the classes defining the kernel of the PROOF facility, i.e. ;  ;  PROOF benchmark utilities;  Set of utilities to benchmark a PROOF facility. ;  . Files; file  runProof.C;  Macro to run examples of analysis on PROOF, corresponding to the TSelector implementations found under <ROOTSYS>/tutorials/proof. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__proof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__proof.html
https://root.cern/doc/master/group__proof.html:703,Testability,benchmark,benchmark,703,". ROOT: PROOF. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Modules |; Files ; PROOF. ; Classes defining the Parallel ROOT Facility, PROOF, a framework for parallel analysis of ROOT TTrees. ; Deprecated:We keep PROOF for those who still need it for legacy use cases. PROOF is not developed anymore and receiving only limited support. ROOT has since a few years moved to RDataFrame and related products as multi-core/multi-processing engines. Modules;  PROOF kernel Libraries;  The PROOF kernel libraries (libProof, libProofPlayer, libProofDraw) contain the classes defining the kernel of the PROOF facility, i.e. ;  ;  PROOF benchmark utilities;  Set of utilities to benchmark a PROOF facility. ;  . Files; file  runProof.C;  Macro to run examples of analysis on PROOF, corresponding to the TSelector implementations found under <ROOTSYS>/tutorials/proof. ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/group__proof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__proof.html
https://root.cern/doc/master/group__QuantFunc.html:943,Deployability,release,releases,943,". ROOT: Quantile Functions. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions ; Quantile FunctionsMath » MathCore | Math » MathMore » Statistical functions. ; Inverse functions of the cumulative distribution functions and the inverse of the complement of the cumulative distribution functions for various distributions. ; The functions with the extension _quantile calculate the inverse of the _cdf function, the lower tail integral of the probability density function \(D^{-1}(z)\) where. \[ D(x) = \int_{-\infty}^{x} p(x') dx' \]. while those with the _quantile_c extension calculate the inverse of the _cdf_c functions, the upper tail integral of the probability density function \(D^{-1}(z) \) where. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. These functions are defined in the header file Math/ProbFunc.h or in the global one including all statistical functions Math/DistFunc.h; NOTE: In the old releases (< 5.14) the _quantile functions were called _quant_inv and the _quantile_c functions were called _prob_inv. These names are currently kept for backward compatibility, but their usage is deprecated.; The functions with the extension _quantile calculate the inverse of the _cdf function, the lower tail integral of the probability density function \(D^{-1}(z)\) where. \[ D(x) = \int_{-\infty}^{x} p(x') dx' \]. while those with the _quantile_c extension calculate the inverse of the _cdf_c functions, the upper tail integral of the probability density function \(D^{-1}(z) \) where. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. The implementation used is that of GSL.; NOTE: In the old releases (< 5.14) the _quantile functions were called _quant_inv and the _quantile_c functions were called _prob_inv. These names are currently kept for backward compatibility, but their usage is deprecated. . Functions; double ROOT::MathMore::chisquared_quantile (double z, double r);  Re-implementation in MathMore of the Inverse ( \(D^{-1}(z)\)) of the cumulativ",MatchSource.WIKI,doc/master/group__QuantFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html
https://root.cern/doc/master/group__QuantFunc.html:1636,Deployability,release,releases,1636,"verse of the _cdf_c functions, the upper tail integral of the probability density function \(D^{-1}(z) \) where. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. These functions are defined in the header file Math/ProbFunc.h or in the global one including all statistical functions Math/DistFunc.h; NOTE: In the old releases (< 5.14) the _quantile functions were called _quant_inv and the _quantile_c functions were called _prob_inv. These names are currently kept for backward compatibility, but their usage is deprecated.; The functions with the extension _quantile calculate the inverse of the _cdf function, the lower tail integral of the probability density function \(D^{-1}(z)\) where. \[ D(x) = \int_{-\infty}^{x} p(x') dx' \]. while those with the _quantile_c extension calculate the inverse of the _cdf_c functions, the upper tail integral of the probability density function \(D^{-1}(z) \) where. \[ D(x) = \int_{x}^{+\infty} p(x') dx' \]. The implementation used is that of GSL.; NOTE: In the old releases (< 5.14) the _quantile functions were called _quant_inv and the _quantile_c functions were called _prob_inv. These names are currently kept for backward compatibility, but their usage is deprecated. . Functions; double ROOT::MathMore::chisquared_quantile (double z, double r);  Re-implementation in MathMore of the Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the \(\chi^2\) distribution with \(r\) degrees of freedom (ROOT::Math::chisquared_cdf). ;  ; double ROOT::MathMore::gamma_quantile (double z, double alpha, double theta);  Re-implementation in MathMore of the Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the gamma distribution (ROOT::Math::gamma_cdf). ;  ; double ROOT::Math::vavilov_accurate_quantile (double z, double kappa, double beta2);  The inverse of the Vavilov cumulative probability density function. ;  ; double ROOT::Math::vavilov_accurate_quantile_c (double z, double kappa, double be",MatchSource.WIKI,doc/master/group__QuantFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html
https://root.cern/doc/master/group__QuantFunc.html:6848,Testability,log,lognormal,6848,"function of the upper tail of the f distribution (fdistribution_cdf_c). ;  ; double ROOT::Math::gamma_quantile_c (double z, double alpha, double theta);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the gamma distribution (gamma_cdf_c). ;  ; double ROOT::Math::gamma_quantile (double z, double alpha, double theta);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the gamma distribution (gamma_cdf). ;  ; double ROOT::Math::gaussian_quantile_c (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (gaussian_cdf_c). ;  ; double ROOT::Math::gaussian_quantile (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (gaussian_cdf). ;  ; double ROOT::Math::lognormal_quantile_c (double x, double m, double s);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the lognormal distribution (lognormal_cdf_c). ;  ; double ROOT::Math::lognormal_quantile (double x, double m, double s);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the lognormal distribution (lognormal_cdf). ;  ; double ROOT::Math::normal_quantile_c (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (normal_cdf_c). ;  ; double ROOT::Math::normal_quantile (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (normal_cdf). ;  ; double ROOT::Math::uniform_quantile_c (double z, double a, double b);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the uniform (flat) distribution (uniform_cdf_c). ;  ; double ROOT::Math::uniform_quantile (double z, double a, double ",MatchSource.WIKI,doc/master/group__QuantFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html
https://root.cern/doc/master/group__QuantFunc.html:7056,Testability,log,lognormal,7056,"n function of the upper tail of the gamma distribution (gamma_cdf_c). ;  ; double ROOT::Math::gamma_quantile (double z, double alpha, double theta);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the gamma distribution (gamma_cdf). ;  ; double ROOT::Math::gaussian_quantile_c (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (gaussian_cdf_c). ;  ; double ROOT::Math::gaussian_quantile (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (gaussian_cdf). ;  ; double ROOT::Math::lognormal_quantile_c (double x, double m, double s);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the lognormal distribution (lognormal_cdf_c). ;  ; double ROOT::Math::lognormal_quantile (double x, double m, double s);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the lognormal distribution (lognormal_cdf). ;  ; double ROOT::Math::normal_quantile_c (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (normal_cdf_c). ;  ; double ROOT::Math::normal_quantile (double z, double sigma);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (normal_cdf). ;  ; double ROOT::Math::uniform_quantile_c (double z, double a, double b);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the uniform (flat) distribution (uniform_cdf_c). ;  ; double ROOT::Math::uniform_quantile (double z, double a, double b);  Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the uniform (flat) distribution (uniform_cdf). ;  ; double ROOT::Math::landau_quantile (double z, double xi=1);  Inve",MatchSource.WIKI,doc/master/group__QuantFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html
https://root.cern/doc/master/group__QuantFunc.html:17843,Testability,log,lognormal,17843,"e cumulative distribution function of the lower tail of the Landau distribution (landau_cdf). ; For detailed description see K.S. Kölbig and B. Schorr, A program package for the Landau distribution, Computer Phys. Comm. 31 (1984) 97-111 [Erratum-ibid. 178 (2008) 972]. The same algorithms as in CERNLIB (RANLAN) is used.; Parameters. zThe argument \(z\) ; xiThe width parameter \(\xi\) . Definition at line 189 of file QuantFuncMathCore.cxx. ◆ landau_quantile_c(). double ROOT::Math::landau_quantile_c ; (; double ; z, . double ; xi = 1 . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the landau distribution (landau_cdf_c). ; Implemented using landau_quantile; Parameters. zThe argument \(z\) ; xiThe width parameter \(\xi\) . Definition at line 396 of file QuantFuncMathCore.cxx. ◆ lognormal_quantile(). double ROOT::Math::lognormal_quantile ; (; double ; x, . double ; m, . double ; s . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the lognormal distribution (lognormal_cdf). ; For detailed description see Mathworld. The implementation used is that of GSL. ; Definition at line 151 of file QuantFuncMathCore.cxx. ◆ lognormal_quantile_c(). double ROOT::Math::lognormal_quantile_c ; (; double ; x, . double ; m, . double ; s . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the lognormal distribution (lognormal_cdf_c). ; For detailed description see Mathworld. The implementation used is that of GSL. ; Definition at line 143 of file QuantFuncMathCore.cxx. ◆ normal_quantile(). double ROOT::Math::normal_quantile ; (; double ; z, . double ; sigma . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (normal_cdf). ; For detailed description see Mathworld. It can also be evaluated using gaussian_quantile which will call the same implementation. It is implemented using the function ROOT::Math::",MatchSource.WIKI,doc/master/group__QuantFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html
https://root.cern/doc/master/group__QuantFunc.html:18226,Testability,log,lognormal,18226,") . Definition at line 189 of file QuantFuncMathCore.cxx. ◆ landau_quantile_c(). double ROOT::Math::landau_quantile_c ; (; double ; z, . double ; xi = 1 . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the landau distribution (landau_cdf_c). ; Implemented using landau_quantile; Parameters. zThe argument \(z\) ; xiThe width parameter \(\xi\) . Definition at line 396 of file QuantFuncMathCore.cxx. ◆ lognormal_quantile(). double ROOT::Math::lognormal_quantile ; (; double ; x, . double ; m, . double ; s . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the lognormal distribution (lognormal_cdf). ; For detailed description see Mathworld. The implementation used is that of GSL. ; Definition at line 151 of file QuantFuncMathCore.cxx. ◆ lognormal_quantile_c(). double ROOT::Math::lognormal_quantile_c ; (; double ; x, . double ; m, . double ; s . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the lognormal distribution (lognormal_cdf_c). ; For detailed description see Mathworld. The implementation used is that of GSL. ; Definition at line 143 of file QuantFuncMathCore.cxx. ◆ normal_quantile(). double ROOT::Math::normal_quantile ; (; double ; z, . double ; sigma . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the lower tail of the normal (Gaussian) distribution (normal_cdf). ; For detailed description see Mathworld. It can also be evaluated using gaussian_quantile which will call the same implementation. It is implemented using the function ROOT::Math::Cephes::ndtri taken from Cephes. ; Definition at line 134 of file QuantFuncMathCore.cxx. ◆ normal_quantile_c(). double ROOT::Math::normal_quantile_c ; (; double ; z, . double ; sigma . ). Inverse ( \(D^{-1}(z)\)) of the cumulative distribution function of the upper tail of the normal (Gaussian) distribution (normal_cdf_c). ; For detailed description see Mathworld. It can also be ev",MatchSource.WIKI,doc/master/group__QuantFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__QuantFunc.html
https://root.cern/doc/master/group__Random.html:3326,Integrability,wrap,wrapper,3326,"eration of Ranlux generator with luxury level of 1 (It throws away 202 value for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanLuxD2;  Double precision (48 bits) version of Second generation of Ranlux generator with luxury level of 2 (It throws away 397 value for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanLuxS1;  Second generation of Ranlux generator for single precision with luxury level of 1 (It throws away 202 values for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanLuxS2;  Second generation of Ranlux generator for Single precision with luxury level of 2 (It throws away 397 value for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanMar;  RANMAR generator see here More...;  ; class  ROOT::Math::GSLRngTaus;  Tausworthe generator by L'Ecuyer see here More...;  ; class  ROOT::Math::MersenneTwisterEngine;  Random number generator class based on M. More...;  ; class  ROOT::Math::MixMaxEngine< N, SkipNumber >;  MixMaxEngine is a wrapper class for the MIXMAX Random number generator. More...;  ; class  ROOT::Math::Random< Engine >;  Documentation for the Random class. More...;  ; class  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >;  Specialized implementation of the Random functions based on the GSL library. More...;  ; class  ROOT::Math::StdEngine< Generator >;  Class to wrap engines from the C++ standard random library in the ROOT Random interface. More...;  ; class  TKDTree< Index, Value >;  Class implementing a kd-tree. More...;  ; class  TRandom;  This is the base class for the ROOT Random number generators. More...;  ; class  TRandom1;  The Ranlux Random number generator class. More...;  ; class  TRandom2;  Random number generator class based on the maximally quidistributed combined Tausworthe generator by L'Ecuyer. More...;  ; class  TRandom3;  Random number generator class based on M. More...;  . Typedefs; typedef TRandomEngine ROOT::Math::DefaultEngineType;  Documenta",MatchSource.WIKI,doc/master/group__Random.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Random.html
https://root.cern/doc/master/group__Random.html:3700,Integrability,wrap,wrap,3700," single precision with luxury level of 1 (It throws away 202 values for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanLuxS2;  Second generation of Ranlux generator for Single precision with luxury level of 2 (It throws away 397 value for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanMar;  RANMAR generator see here More...;  ; class  ROOT::Math::GSLRngTaus;  Tausworthe generator by L'Ecuyer see here More...;  ; class  ROOT::Math::MersenneTwisterEngine;  Random number generator class based on M. More...;  ; class  ROOT::Math::MixMaxEngine< N, SkipNumber >;  MixMaxEngine is a wrapper class for the MIXMAX Random number generator. More...;  ; class  ROOT::Math::Random< Engine >;  Documentation for the Random class. More...;  ; class  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >;  Specialized implementation of the Random functions based on the GSL library. More...;  ; class  ROOT::Math::StdEngine< Generator >;  Class to wrap engines from the C++ standard random library in the ROOT Random interface. More...;  ; class  TKDTree< Index, Value >;  Class implementing a kd-tree. More...;  ; class  TRandom;  This is the base class for the ROOT Random number generators. More...;  ; class  TRandom1;  The Ranlux Random number generator class. More...;  ; class  TRandom2;  Random number generator class based on the maximally quidistributed combined Tausworthe generator by L'Ecuyer. More...;  ; class  TRandom3;  Random number generator class based on M. More...;  . Typedefs; typedef TRandomEngine ROOT::Math::DefaultEngineType;  Documentation for the RandomFunction class. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 240, 0 > > TRandomMixMax;  MIXMAX generator based on a state of N=240. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 17, 0 > > TRandomMixMax17;  MIXMAX generator based on a state of N=17. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 256, 2 > > TRandomMixMax256;  MIXMAX generator based on a state o",MatchSource.WIKI,doc/master/group__Random.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Random.html
https://root.cern/doc/master/group__Random.html:3769,Integrability,interface,interface,3769," single precision with luxury level of 1 (It throws away 202 values for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanLuxS2;  Second generation of Ranlux generator for Single precision with luxury level of 2 (It throws away 397 value for every 12 used) see here More...;  ; class  ROOT::Math::GSLRngRanMar;  RANMAR generator see here More...;  ; class  ROOT::Math::GSLRngTaus;  Tausworthe generator by L'Ecuyer see here More...;  ; class  ROOT::Math::MersenneTwisterEngine;  Random number generator class based on M. More...;  ; class  ROOT::Math::MixMaxEngine< N, SkipNumber >;  MixMaxEngine is a wrapper class for the MIXMAX Random number generator. More...;  ; class  ROOT::Math::Random< Engine >;  Documentation for the Random class. More...;  ; class  ROOT::Math::RandomFunctions< EngineType, ROOT::Math::GSLRandomEngine >;  Specialized implementation of the Random functions based on the GSL library. More...;  ; class  ROOT::Math::StdEngine< Generator >;  Class to wrap engines from the C++ standard random library in the ROOT Random interface. More...;  ; class  TKDTree< Index, Value >;  Class implementing a kd-tree. More...;  ; class  TRandom;  This is the base class for the ROOT Random number generators. More...;  ; class  TRandom1;  The Ranlux Random number generator class. More...;  ; class  TRandom2;  Random number generator class based on the maximally quidistributed combined Tausworthe generator by L'Ecuyer. More...;  ; class  TRandom3;  Random number generator class based on M. More...;  . Typedefs; typedef TRandomEngine ROOT::Math::DefaultEngineType;  Documentation for the RandomFunction class. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 240, 0 > > TRandomMixMax;  MIXMAX generator based on a state of N=240. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 17, 0 > > TRandomMixMax17;  MIXMAX generator based on a state of N=17. ;  ; typedef TRandomGen< ROOT::Math::MixMaxEngine< 256, 2 > > TRandomMixMax256;  MIXMAX generator based on a state o",MatchSource.WIKI,doc/master/group__Random.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Random.html
https://root.cern/doc/master/group__Roofitcore.html:9612,Availability,error,error,9612,". More...;  ; class  RooDerivative;  Represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class. More...;  ; class  RooDirItem;  Utility base class for RooFit objects that are to be attached to ROOT directories. More...;  ; class  RooDLLSignificanceMCSModule;  Add-on module to RooMCStudy that calculates the significance of a signal by comparing the likelihood of a fit fit with a given parameter floating with a fit with that given parameter fixed to a nominal value (usually zero). More...;  ; class  RooDouble;  Minimal implementation of a TObject holding a double value. More...;  ; class  RooEffGenContext;  Specialized generator context for p.d.fs represented by class RooEffProd, which are p.d.fs multiplied with an efficiency function. More...;  ; class  RooEfficiency;  A PDF helper class to fit efficiencies parameterized by a supplied function F. More...;  ; class  RooEllipse;  Two-dimensional ellipse that can be used to represent an error contour. More...;  ; class  RooErrorVar;  Auxiliary class that represents the error of a RooRealVar as a separate object. More...;  ; class  RooExpensiveObjectCache;  Singleton class that serves as repository for objects that are expensive to calculate. More...;  ; class  RooExtendedTerm;  A p.d.f with no observables that only introduces an extended ML term for a given number of expected events term when an extended ML is constructed. More...;  ; class  RooFactoryWSTool;  Implementation detail of the RooWorkspace. More...;  ; class  RooFFTConvPdf;  PDF for the numerical (FFT) convolution of two PDFs. More...;  ; class  RooFirstMoment;  ; class  RooFoamGenerator;  Generic Monte Carlo toy generator that implement the TFOAM sampling technique on any positively valued function. More...;  ; class  RooFormula;  Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. More...;  ; class  RooFracRemainder;  Calculates the remaind",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:9696,Availability,error,error,9696,"al as calculated (numerically) by the MathCore Richardson derivator class. More...;  ; class  RooDirItem;  Utility base class for RooFit objects that are to be attached to ROOT directories. More...;  ; class  RooDLLSignificanceMCSModule;  Add-on module to RooMCStudy that calculates the significance of a signal by comparing the likelihood of a fit fit with a given parameter floating with a fit with that given parameter fixed to a nominal value (usually zero). More...;  ; class  RooDouble;  Minimal implementation of a TObject holding a double value. More...;  ; class  RooEffGenContext;  Specialized generator context for p.d.fs represented by class RooEffProd, which are p.d.fs multiplied with an efficiency function. More...;  ; class  RooEfficiency;  A PDF helper class to fit efficiencies parameterized by a supplied function F. More...;  ; class  RooEllipse;  Two-dimensional ellipse that can be used to represent an error contour. More...;  ; class  RooErrorVar;  Auxiliary class that represents the error of a RooRealVar as a separate object. More...;  ; class  RooExpensiveObjectCache;  Singleton class that serves as repository for objects that are expensive to calculate. More...;  ; class  RooExtendedTerm;  A p.d.f with no observables that only introduces an extended ML term for a given number of expected events term when an extended ML is constructed. More...;  ; class  RooFactoryWSTool;  Implementation detail of the RooWorkspace. More...;  ; class  RooFFTConvPdf;  PDF for the numerical (FFT) convolution of two PDFs. More...;  ; class  RooFirstMoment;  ; class  RooFoamGenerator;  Generic Monte Carlo toy generator that implement the TFOAM sampling technique on any positively valued function. More...;  ; class  RooFormula;  Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. More...;  ; class  RooFracRemainder;  Calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i). More...;  ; class  RooFunctor;  Lightweight",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:11614,Availability,error,error,11614,"ooAbsReal fraction, i.e (1 - sum_i a_i). More...;  ; class  RooFunctor;  Lightweight interface adaptor that exports a RooAbsPdf as a functor. More...;  ; class  RooGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooGenContext;  Implements a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context. More...;  ; class  RooGenericPdf;  Implementation of a probability density function that takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers. More...;  ; class  RooGenFitStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooGenProdProj;  General form of projected integral of product of PDFs, utility class for RooProdPdf. More...;  ; class  RooHist;  Graphical representation of binned data based on the TGraphAsymmErrors class. More...;  ; class  RooHistError;  Singleton class used to calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real-valued function sampled from a multidimensional histogram. More...;  ; class  RooHistPdf;  A propability density function sampled from a multidimensional histogram. More...;  ; class  RooImproperIntegrator1D;  Special numeric integrator that can handle integrals over open domains. More...;  ; class  RooInvTransform;  Lightweight function binding that returns the inverse of an input function binding. More...;  ; class  RooLinkedList;  Collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list. More...;  ; class  RooLinkedListElem;  Link element for the RooLinkedList class. More...;  ; class  RooLinTransBinning;  Special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does. More...;  ; class  RooMCIntegrator;  Implements an adaptive multi-dimensional Monte Carlo nu",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:2289,Deployability,integrat,integrators,2289,"s for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to co",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4140,Deployability,integrat,integration,4140,"...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4243,Deployability,integrat,integration,4243,"ctionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from ",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4744,Deployability,integrat,integration,4744,"sStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using t",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4795,Deployability,integrat,integration,4795,"sStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using t",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:6232,Deployability,integrat,integrated,6232,"plements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using the Brent-Decker method. More...;  ; class  RooCachedPdf;  Implementation of RooAbsCachedPdf that can cache any external RooAbsPdf input function provided in the constructor. More...;  ; class  RooCachedReal;  Implementation of RooAbsCachedReal that can cache any external RooAbsReal input function provided in the constructor. More...;  ; class  RooCacheManager< T >;  Manages the storage of any type of data indexed on the choice of normalization and optionally the set of integrated observables. More...;  ; class  RooCategory;  Object to represent discrete states. More...;  ; class  RooChangeTracker;  Meta object that tracks value changes in a given set of RooAbsArgs by registering itself as value client of these objects. More...;  ; class  RooChi2Var;  Simple \( \chi^2 \) calculation from a binned dataset and a PDF. More...;  ; class  RooClassFactory;  Similar to TTree::MakeClass(), generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names. More...;  ; class  RooCmdArg;  Named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods. More...;  ; class  RooCmdConfig;  Configurable parser for RooCmdArg named arguments. More...;  ; class  RooCollectionProxy< RooCollection_t >;  Concrete proxy for RooArgSet or RooArgList objects. More...;  ; clas",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:7697,Deployability,integrat,integration,7697,"; class  RooClassFactory;  Similar to TTree::MakeClass(), generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names. More...;  ; class  RooCmdArg;  Named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods. More...;  ; class  RooCmdConfig;  Configurable parser for RooCmdArg named arguments. More...;  ; class  RooCollectionProxy< RooCollection_t >;  Concrete proxy for RooArgSet or RooArgList objects. More...;  ; class  RooCompositeDataStore;  Combines several disjunct datasets into one. More...;  ; class  RooConstraintSum;  Calculates the sum of the -(log) likelihoods of a set of RooAbsPfs that represent constraint functions. More...;  ; class  RooConstVar;  Represents a constant real-valued object. More...;  ; class  RooConvCoefVar;  Auxiliary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism. More...;  ; class  RooConvGenContext;  Efficient implementation of the generator context specific for RooAbsAnaConvPdf objects. More...;  ; class  RooConvIntegrandBinding;  Implementation of RooAbsFunc that represent the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator. More...;  ; class  RooCurve;  One-dimensional graphical representation of a real-valued function. More...;  ; class  RooDataHist;  Container class to hold N-dimensional binned data. More...;  ; class  RooDataHistSliceIter;  Iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet. More...;  ; class  RooDataProjBinding;  adaptor that projects a real function via summation of states provided in a dataset. More...;  ; class  RooDataSet;  Container class to hold unbinned data. More...;  ; cla",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:8032,Deployability,integrat,integrator,8032,"ser methods. More...;  ; class  RooCmdConfig;  Configurable parser for RooCmdArg named arguments. More...;  ; class  RooCollectionProxy< RooCollection_t >;  Concrete proxy for RooArgSet or RooArgList objects. More...;  ; class  RooCompositeDataStore;  Combines several disjunct datasets into one. More...;  ; class  RooConstraintSum;  Calculates the sum of the -(log) likelihoods of a set of RooAbsPfs that represent constraint functions. More...;  ; class  RooConstVar;  Represents a constant real-valued object. More...;  ; class  RooConvCoefVar;  Auxiliary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism. More...;  ; class  RooConvGenContext;  Efficient implementation of the generator context specific for RooAbsAnaConvPdf objects. More...;  ; class  RooConvIntegrandBinding;  Implementation of RooAbsFunc that represent the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator. More...;  ; class  RooCurve;  One-dimensional graphical representation of a real-valued function. More...;  ; class  RooDataHist;  Container class to hold N-dimensional binned data. More...;  ; class  RooDataHistSliceIter;  Iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet. More...;  ; class  RooDataProjBinding;  adaptor that projects a real function via summation of states provided in a dataset. More...;  ; class  RooDataSet;  Container class to hold unbinned data. More...;  ; class  RooDerivative;  Represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class. More...;  ; class  RooDirItem;  Utility base class for RooFit objects that are to be attached to ROOT directories. More...;  ; class  RooDLLSignificanceMCSModule;  Add-on module to RooMCSt",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:10823,Deployability,integrat,integration,10823,"ss that serves as repository for objects that are expensive to calculate. More...;  ; class  RooExtendedTerm;  A p.d.f with no observables that only introduces an extended ML term for a given number of expected events term when an extended ML is constructed. More...;  ; class  RooFactoryWSTool;  Implementation detail of the RooWorkspace. More...;  ; class  RooFFTConvPdf;  PDF for the numerical (FFT) convolution of two PDFs. More...;  ; class  RooFirstMoment;  ; class  RooFoamGenerator;  Generic Monte Carlo toy generator that implement the TFOAM sampling technique on any positively valued function. More...;  ; class  RooFormula;  Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. More...;  ; class  RooFracRemainder;  Calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i). More...;  ; class  RooFunctor;  Lightweight interface adaptor that exports a RooAbsPdf as a functor. More...;  ; class  RooGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooGenContext;  Implements a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context. More...;  ; class  RooGenericPdf;  Implementation of a probability density function that takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers. More...;  ; class  RooGenFitStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooGenProdProj;  General form of projected integral of product of PDFs, utility class for RooProdPdf. More...;  ; class  RooHist;  Graphical representation of binned data based on the TGraphAsymmErrors class. More...;  ; class  RooHistError;  Singleton class used to calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real-valued function sampled from a multidimensional histogram. More...;  ; class  RooHistPdf;  A propabi",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:11925,Deployability,integrat,integrator,11925," all RooAbsPdf classes that do not have or need a specialized generator context. More...;  ; class  RooGenericPdf;  Implementation of a probability density function that takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers. More...;  ; class  RooGenFitStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooGenProdProj;  General form of projected integral of product of PDFs, utility class for RooProdPdf. More...;  ; class  RooHist;  Graphical representation of binned data based on the TGraphAsymmErrors class. More...;  ; class  RooHistError;  Singleton class used to calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real-valued function sampled from a multidimensional histogram. More...;  ; class  RooHistPdf;  A propability density function sampled from a multidimensional histogram. More...;  ; class  RooImproperIntegrator1D;  Special numeric integrator that can handle integrals over open domains. More...;  ; class  RooInvTransform;  Lightweight function binding that returns the inverse of an input function binding. More...;  ; class  RooLinkedList;  Collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list. More...;  ; class  RooLinkedListElem;  Link element for the RooLinkedList class. More...;  ; class  RooLinTransBinning;  Special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does. More...;  ; class  RooMCIntegrator;  Implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Mi",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:12612,Deployability,integrat,integration,12612,"calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real-valued function sampled from a multidimensional histogram. More...;  ; class  RooHistPdf;  A propability density function sampled from a multidimensional histogram. More...;  ; class  RooImproperIntegrator1D;  Special numeric integrator that can handle integrals over open domains. More...;  ; class  RooInvTransform;  Lightweight function binding that returns the inverse of an input function binding. More...;  ; class  RooLinkedList;  Collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list. More...;  ; class  RooLinkedListElem;  Link element for the RooLinkedList class. More...;  ; class  RooLinTransBinning;  Special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does. More...;  ; class  RooMCIntegrator;  Implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. More...;  ; class  RooMoment;  ; class  RooMsgService;  Singleton class that organizes messages generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of se",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:13606,Deployability,integrat,integration,13606,"te Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. More...;  ; class  RooMoment;  ; class  RooMsgService;  Singleton class that organizes messages generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given conf",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14112,Deployability,configurat,configuration,14112,generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects w,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14160,Deployability,integrat,integrators,14160,generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects w,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14266,Deployability,integrat,integrators,14266,class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and ,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14320,Deployability,configurat,configuration,14320,class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and ,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14382,Deployability,configurat,configuration,14382,lass  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features. More...;  ; class  RooPolyVar;  A RooAbsReal implement,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14430,Deployability,integrat,integrators,14430,lass  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features. More...;  ; class  RooPolyVar;  A RooAbsReal implement,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14536,Deployability,integrat,integrators,14536,mSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features. More...;  ; class  RooPolyVar;  A RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients. More...;  ; class  RooPrintable;  A 'mix-in' base class that define the,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:14590,Deployability,configurat,configuration,14590,mSet cache manage the bookkeeping of multiple instances of sets of integration and normalization observables that effectively have the same definition. More...;  ; class  RooNumber;  Provides numeric constants used in RooFit. More...;  ; class  RooNumCdf;  Implementation of RooNumRunningInt that calculates cumulative distribution functions from p.d.f.s. More...;  ; class  RooNumConvolution;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumConvPdf;  Numeric 1-dimensional convolution operator PDF. More...;  ; class  RooNumGenConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumGenFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumIntConfig;  Holds the configuration parameters of the various numeric integrators used by RooRealIntegral. More...;  ; class  RooNumIntFactory;  Factory to instantiate numeric integrators from a given function binding and a given configuration. More...;  ; class  RooNumRunningInt;  Implementation of RooAbsCachedReal that represents a running integral. More...;  ; class  RooObjCacheManager;  Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. More...;  ; class  RooParamBinning;  Implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects. More...;  ; class  RooPlot;  Plot frame and a container for graphics objects within that frame. More...;  ; class  RooPlotable;  Class RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features. More...;  ; class  RooPolyVar;  A RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients. More...;  ; class  RooPrintable;  A 'mix-in' base class that define the,MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:18340,Deployability,integrat,integration,18340,"  ; class  RooRealIntegral;  Performs hybrid numerical/analytical integrals of RooAbsReal objects. More...;  ; class  RooFit::TestStatistics::RooRealL;  RooAbsReal that wraps RooAbsL likelihoods for use in RooFit outside of the RooMinimizer context. More...;  ; class  RooRealMPFE;  Multi-processor front-end for parallel calculation of RooAbsReal objects. More...;  ; class  RooRealSumPdf;  Implements a PDF constructed from a sum of functions: More...;  ; class  RooRealVar;  Variable that can be changed from the outside. More...;  ; class  RooRealVarSharedProperties;  Implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones. More...;  ; class  RooRecursiveFraction;  A RooAbsReal implementation that calculates the plain fraction of sum of RooAddPdf components from a set of recursive fractions: for a given set of input fractions \( {a_i} \), it returns \( a_n * \prod_{i=0}^{n-1} (1 - a_i) \). More...;  ; class  RooRombergIntegrator;  Adaptive numerical integration algorithm. More...;  ; class  RooSecondMoment;  ; class  RooSharedProperties;  Class RooSharedProperties is the base class for shared properties that can be stored in RooSharedPropertiesList. More...;  ; class  RooSimGenContext;  Efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs. More...;  ; class  RooSimSplitGenContext;  Efficient implementation of the generator context specific for RooSimultaneous PDFs when generating more than one of the component pdfs. More...;  ; class  RooSimultaneous;  Facilitates simultaneous fitting of multiple PDFs to subsets of a given dataset. More...;  ; class  RooStringVar;  A RooAbsArg implementing string values. More...;  ; class  RooStudyManager;  Utility class to manage studies that consist of repeated applications of generate-and-fit operations on a workspace. More...;  ; class  RooStudyPackage;  Utility class to manage studies that consi",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:8424,Energy Efficiency,adapt,adaptor,8424,"alued object. More...;  ; class  RooConvCoefVar;  Auxiliary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism. More...;  ; class  RooConvGenContext;  Efficient implementation of the generator context specific for RooAbsAnaConvPdf objects. More...;  ; class  RooConvIntegrandBinding;  Implementation of RooAbsFunc that represent the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator. More...;  ; class  RooCurve;  One-dimensional graphical representation of a real-valued function. More...;  ; class  RooDataHist;  Container class to hold N-dimensional binned data. More...;  ; class  RooDataHistSliceIter;  Iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet. More...;  ; class  RooDataProjBinding;  adaptor that projects a real function via summation of states provided in a dataset. More...;  ; class  RooDataSet;  Container class to hold unbinned data. More...;  ; class  RooDerivative;  Represents the first, second, or third order derivative of any RooAbsReal as calculated (numerically) by the MathCore Richardson derivator class. More...;  ; class  RooDirItem;  Utility base class for RooFit objects that are to be attached to ROOT directories. More...;  ; class  RooDLLSignificanceMCSModule;  Add-on module to RooMCStudy that calculates the significance of a signal by comparing the likelihood of a fit fit with a given parameter floating with a fit with that given parameter fixed to a nominal value (usually zero). More...;  ; class  RooDouble;  Minimal implementation of a TObject holding a double value. More...;  ; class  RooEffGenContext;  Specialized generator context for p.d.fs represented by class RooEffProd, which are p.d.fs multiplied with an efficiency function. More...;  ; class  RooEfficiency;  A PDF ",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:10698,Energy Efficiency,adapt,adaptor,10698,"rror of a RooRealVar as a separate object. More...;  ; class  RooExpensiveObjectCache;  Singleton class that serves as repository for objects that are expensive to calculate. More...;  ; class  RooExtendedTerm;  A p.d.f with no observables that only introduces an extended ML term for a given number of expected events term when an extended ML is constructed. More...;  ; class  RooFactoryWSTool;  Implementation detail of the RooWorkspace. More...;  ; class  RooFFTConvPdf;  PDF for the numerical (FFT) convolution of two PDFs. More...;  ; class  RooFirstMoment;  ; class  RooFoamGenerator;  Generic Monte Carlo toy generator that implement the TFOAM sampling technique on any positively valued function. More...;  ; class  RooFormula;  Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. More...;  ; class  RooFracRemainder;  Calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i). More...;  ; class  RooFunctor;  Lightweight interface adaptor that exports a RooAbsPdf as a functor. More...;  ; class  RooGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooGenContext;  Implements a universal generator context for all RooAbsPdf classes that do not have or need a specialized generator context. More...;  ; class  RooGenericPdf;  Implementation of a probability density function that takes a RooArgList of servers and a C++ expression string defining how its value should be calculated from the given list of servers. More...;  ; class  RooGenFitStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooGenProdProj;  General form of projected integral of product of PDFs, utility class for RooProdPdf. More...;  ; class  RooHist;  Graphical representation of binned data based on the TGraphAsymmErrors class. More...;  ; class  RooHistError;  Singleton class used to calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:12563,Energy Efficiency,adapt,adaptive,12563,"calculate the error bars for each bin of a RooHist object. More...;  ; class  RooHistFunc;  A real-valued function sampled from a multidimensional histogram. More...;  ; class  RooHistPdf;  A propability density function sampled from a multidimensional histogram. More...;  ; class  RooImproperIntegrator1D;  Special numeric integrator that can handle integrals over open domains. More...;  ; class  RooInvTransform;  Lightweight function binding that returns the inverse of an input function binding. More...;  ; class  RooLinkedList;  Collection class for internal use, storing a collection of RooAbsArg pointers in a doubly linked list. More...;  ; class  RooLinkedListElem;  Link element for the RooLinkedList class. More...;  ; class  RooLinTransBinning;  Special binning implementation for RooLinearVar that transforms the binning of the RooLinearVar input variable in the same way that RooLinearVar does. More...;  ; class  RooMCIntegrator;  Implements an adaptive multi-dimensional Monte Carlo numerical integration, following the VEGAS algorithm originally described in G. More...;  ; class  RooMCStudy;  Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. More...;  ; class  RooMinimizer;  Wrapper class around ROOT::Math::Minimizer that provides a seamless interface between the minimizer functionality and the native RooFit interface. More...;  ; class  RooMoment;  ; class  RooMsgService;  Singleton class that organizes messages generated in RooFit. More...;  ; class  RooMultiCategory;  Connects several RooAbsCategory objects into a single category. More...;  ; class  RooMultiVarGaussian;  Multivariate Gaussian p.d.f. More...;  ; class  RooNameReg;  Registry for const char* names. More...;  ; class  RooNLLVar;  Implements a -log(likelihood) calculation from a dataset and a PDF. More...;  ; class  RooNormSetCache;  Class RooNormSet cache manage the bookkeeping of multiple instances of se",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:17084,Energy Efficiency,adapt,adaptor,17084," of a given input p.d.f and the object returned by RooAbsPdf::createProjection. More...;  ; class  RooPullVar;  Represents the pull of a measurement w.r.t. More...;  ; class  RooQuasiRandomGenerator;  This class generates the quasi-random (aka ""low discrepancy"") sequence for dimensions up to 12 using the Niederreiter base 2 algorithm described in Bratley, Fox, Niederreiter, ACM Trans. More...;  ; class  RooRandom;  This class provides a static interface for generating random numbers. More...;  ; class  RooRandomizeParamMCSModule;  Add-on module to RooMCStudy that allows you to randomize input generation parameters. More...;  ; class  RooRangeBinning;  Binning/range definition that only defines a range but no binning. More...;  ; class  RooRangeBoolean;  Returns 1.0 if variable is within given a range and 0.0 otherwise. More...;  ; class  RooRatio;  Represents the ratio of two RooAbsReal objects. More...;  ; class  RooRealBinding;  Lightweight interface adaptor that binds a RooAbsReal object to a subset of its servers and present it as a simple array oriented interface. More...;  ; class  RooRealConstant;  Provides static functions to create and keep track of RooRealVar constants. More...;  ; class  RooRealIntegral;  Performs hybrid numerical/analytical integrals of RooAbsReal objects. More...;  ; class  RooFit::TestStatistics::RooRealL;  RooAbsReal that wraps RooAbsL likelihoods for use in RooFit outside of the RooMinimizer context. More...;  ; class  RooRealMPFE;  Multi-processor front-end for parallel calculation of RooAbsReal objects. More...;  ; class  RooRealSumPdf;  Implements a PDF constructed from a sum of functions: More...;  ; class  RooRealVar;  Variable that can be changed from the outside. More...;  ; class  RooRealVarSharedProperties;  Implementation of RooSharedProperties that stores the properties of a RooRealVar that are shared among clones. More...;  ; class  RooRecursiveFraction;  A RooAbsReal implementation that calculates the plain fraction of su",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:1888,Integrability,interface,interface,1888,"t base class for p.d.f.s that need or want to cache their evaluate() output in a RooHistPdf defined in terms of the used observables. More...;  ; class  RooAbsCachedReal;  Abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables. More...;  ; class  RooAbsCacheElement;  Abstract base class for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point ",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:2275,Integrability,interface,interface,2275,"s for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to co",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:2289,Integrability,integrat,integrators,2289,"s for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to co",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:2356,Integrability,interface,interface,2356,"s for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to co",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:2987,Integrability,interface,interface,2987,"n it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/re",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:3078,Integrability,interface,interface,3078,"ntexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of real-valued functions that implement the RooAbsFunc interface. More...;  ; class  RooAbsLValue;  Abstract base class for objects that are lvalues, i.e. More...;  ; class  RooAbsMCStudyModule;  Base class for add-on modules to RooMCStudy that can perform additional calculations on each generate+fit cycle managed by RooMCStudy. More...;  ; class  RooAbsMoment;  ; class  RooAbsNumGenerator;  Abstract base class for MC event generator implementations like RooAcceptReject and RooFoam. More...;  ; class  RooAbsOptTestStatistic;  Abstract base class for test statistics objects that evaluate a function or PDF at each point of a given dataset. More...;  ; class  RooAbsPdf;  Abstract interface for all probability density functions. More...;  ; class  RooAbsProxy;  Abstract interface for proxy classes. More...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  Ro",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4140,Integrability,integrat,integration,4140,"...;  ; class  RooAbsReal;  Abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4243,Integrability,integrat,integration,4243,"ctionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc. More...;  ; class  RooAbsRealLValue;  Abstract base class for objects that represent a real value that may appear on the left hand side of an equation ('lvalue'). More...;  ; class  RooAbsSelfCached< Base_t >;  Abstract base class for functions whose output is cached in terms of a histogram in all observables between getVal() and evaluate(). More...;  ; class  RooAbsStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from ",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4744,Integrability,integrat,integration,4744,"sStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using t",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4795,Integrability,integrat,integration,4795,"sStudy;  Abstract base class for RooStudyManager modules. More...;  ; class  RooAbsTestStatistic;  Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using t",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:4855,Integrability,interface,interface,4855,"Abstract base class for all test statistics. More...;  ; class  RooAcceptReject;  Generic Monte Carlo toy generator implement the accept/reject sampling technique on any positively valued function. More...;  ; class  RooAdaptiveGaussKronrodIntegrator1D;  Implements the Gauss-Kronrod integration algorithm. More...;  ; class  RooAdaptiveIntegratorND;  Adaptive one-dimensional numerical integration algorithm. More...;  ; class  RooAddGenContext;  Efficient implementation of the generator context specific for RooAddPdf PDFs. More...;  ; class  RooAddition;  Calculates the sum of a set of RooAbsReal terms, or when constructed with two sets, it sums the product of the terms in the two sets. More...;  ; class  RooAddPdf;  Efficient implementation of a sum of PDFs of the form. More...;  ; class  RooAICRegistry;  Utility class for operator p.d.f classes that keeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using the Brent-Decker method. More...;  ; class  RooCachedPdf;  Implementation of RooAbsCachedPdf that ca",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:5741,Integrability,interface,interface,5741,"eeps track of analytical integration codes and associated normalization and integration sets. More...;  ; class  RooArgProxy;  Abstract interface for RooAbsArg proxy classes. More...;  ; class  RooBinIntegrator;  Computes the integral over a binned distribution by summing the bin contents of all bins. More...;  ; class  RooBinnedGenContext;  Efficient implementation of the generator context specific for binned pdfs. More...;  ; class  RooBinnedL;  Implements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using the Brent-Decker method. More...;  ; class  RooCachedPdf;  Implementation of RooAbsCachedPdf that can cache any external RooAbsPdf input function provided in the constructor. More...;  ; class  RooCachedReal;  Implementation of RooAbsCachedReal that can cache any external RooAbsReal input function provided in the constructor. More...;  ; class  RooCacheManager< T >;  Manages the storage of any type of data indexed on the choice of normalization and optionally the set of integrated observables. More...;  ; class  RooCategory;  Object to represent discrete states. More...;  ; class  RooChangeTracker;  Meta object that tracks value changes in a given set of RooAbsArgs by registering itself as value client of these objects. More...;  ; class  RooChi2Var;  Simple \( \chi^2 \) calculation from a binned dataset and a PDF. More...;  ; class  RooClassFactory;  Similar to TTree::MakeClass(), generates skeleton code for RooAbsPdf and RooAbsReal functions given",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:6232,Integrability,integrat,integrated,6232,"plements a -log(likelihood) calculation from a dataset (assumed to be binned) and a PDF. More...;  ; class  RooBinning;  Implements a RooAbsBinning in terms of an array of boundary values, posing no constraints on the choice of binning, thus allowing variable bin sizes. More...;  ; class  RooBinningCategory;  Provides a real-to-category mapping defined by a series of thresholds. More...;  ; class  RooBinWidthFunction;  Returns the bin width (or volume) given a RooHistFunc. More...;  ; class  RooBrentRootFinder;  Implement the abstract 1-dimensional root finding interface using the Brent-Decker method. More...;  ; class  RooCachedPdf;  Implementation of RooAbsCachedPdf that can cache any external RooAbsPdf input function provided in the constructor. More...;  ; class  RooCachedReal;  Implementation of RooAbsCachedReal that can cache any external RooAbsReal input function provided in the constructor. More...;  ; class  RooCacheManager< T >;  Manages the storage of any type of data indexed on the choice of normalization and optionally the set of integrated observables. More...;  ; class  RooCategory;  Object to represent discrete states. More...;  ; class  RooChangeTracker;  Meta object that tracks value changes in a given set of RooAbsArgs by registering itself as value client of these objects. More...;  ; class  RooChi2Var;  Simple \( \chi^2 \) calculation from a binned dataset and a PDF. More...;  ; class  RooClassFactory;  Similar to TTree::MakeClass(), generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names. More...;  ; class  RooCmdArg;  Named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods. More...;  ; class  RooCmdConfig;  Configurable parser for RooCmdArg named arguments. More...;  ; class  RooCollectionProxy< RooCollection_t >;  Concrete proxy for RooArgSet or RooArgList objects. More...;  ; clas",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:7630,Integrability,interface,interface,7630,"; class  RooClassFactory;  Similar to TTree::MakeClass(), generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names. More...;  ; class  RooCmdArg;  Named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods. More...;  ; class  RooCmdConfig;  Configurable parser for RooCmdArg named arguments. More...;  ; class  RooCollectionProxy< RooCollection_t >;  Concrete proxy for RooArgSet or RooArgList objects. More...;  ; class  RooCompositeDataStore;  Combines several disjunct datasets into one. More...;  ; class  RooConstraintSum;  Calculates the sum of the -(log) likelihoods of a set of RooAbsPfs that represent constraint functions. More...;  ; class  RooConstVar;  Represents a constant real-valued object. More...;  ; class  RooConvCoefVar;  Auxiliary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism. More...;  ; class  RooConvGenContext;  Efficient implementation of the generator context specific for RooAbsAnaConvPdf objects. More...;  ; class  RooConvIntegrandBinding;  Implementation of RooAbsFunc that represent the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator. More...;  ; class  RooCurve;  One-dimensional graphical representation of a real-valued function. More...;  ; class  RooDataHist;  Container class to hold N-dimensional binned data. More...;  ; class  RooDataHistSliceIter;  Iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet. More...;  ; class  RooDataProjBinding;  adaptor that projects a real function via summation of states provided in a dataset. More...;  ; class  RooDataSet;  Container class to hold unbinned data. More...;  ; cla",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
https://root.cern/doc/master/group__Roofitcore.html:7697,Integrability,integrat,integration,7697,"; class  RooClassFactory;  Similar to TTree::MakeClass(), generates skeleton code for RooAbsPdf and RooAbsReal functions given a list of input parameter names. More...;  ; class  RooCmdArg;  Named container for two doubles, two integers two object points and three string pointers that can be passed as generic named arguments to a variety of RooFit end user methods. More...;  ; class  RooCmdConfig;  Configurable parser for RooCmdArg named arguments. More...;  ; class  RooCollectionProxy< RooCollection_t >;  Concrete proxy for RooArgSet or RooArgList objects. More...;  ; class  RooCompositeDataStore;  Combines several disjunct datasets into one. More...;  ; class  RooConstraintSum;  Calculates the sum of the -(log) likelihoods of a set of RooAbsPfs that represent constraint functions. More...;  ; class  RooConstVar;  Represents a constant real-valued object. More...;  ; class  RooConvCoefVar;  Auxiliary class that represents the coefficient of a RooAbsAnaConvPdf implementation as a separate RooAbsReal object to be able to interface these coefficient terms with the generic RooRealIntegral integration mechanism. More...;  ; class  RooConvGenContext;  Efficient implementation of the generator context specific for RooAbsAnaConvPdf objects. More...;  ; class  RooConvIntegrandBinding;  Implementation of RooAbsFunc that represent the integrand of a generic (numeric) convolution A (x) B so that it can be passed to a numeric integrator. More...;  ; class  RooCurve;  One-dimensional graphical representation of a real-valued function. More...;  ; class  RooDataHist;  Container class to hold N-dimensional binned data. More...;  ; class  RooDataHistSliceIter;  Iterates over all bins in a RooDataHist that occur in a slice defined by the bin coordinates of the input sliceSet. More...;  ; class  RooDataProjBinding;  adaptor that projects a real function via summation of states provided in a dataset. More...;  ; class  RooDataSet;  Container class to hold unbinned data. More...;  ; cla",MatchSource.WIKI,doc/master/group__Roofitcore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html
