id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html530/TH1.html:115117,Availability,error,errors,115117,"-*-*Return location of bin with maximum value in the range*-*. Double_t GetMinimum(Double_t minval = -FLT_MAX) const; Return minimum value smaller than maxval of bins in the range,; unless the value has been overridden by TH1::SetMinimum,; in which case it returns that value. (This happens, for example,; when the histogram is drawn and the y or z axis limits are changed. To get the minimum value of bins in the histogram regardless of; whether the value has been overridden, use; h->GetBinContent(h->GetMinimumBin()). Int_t GetMinimumBin() const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. Int_t GetMinimumBin(Int_t& locmix, Int_t& locmiy, Int_t& locmiz) const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:115439,Availability,error,errors,115439,"are changed. To get the minimum value of bins in the histogram regardless of; whether the value has been overridden, use; h->GetBinContent(h->GetMinimumBin()). Int_t GetMinimumBin() const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. Int_t GetMinimumBin(Int_t& locmix, Int_t& locmiy, Int_t& locmiz) const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xma",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:115458,Availability,error,errors,115458,"are changed. To get the minimum value of bins in the histogram regardless of; whether the value has been overridden, use; h->GetBinContent(h->GetMinimumBin()). Int_t GetMinimumBin() const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. Int_t GetMinimumBin(Int_t& locmix, Int_t& locmiy, Int_t& locmiz) const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xma",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:115858,Availability,error,errors,115858,"void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, c",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:115877,Availability,error,errors,115877,"void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, c",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:116242,Availability,error,errors,116242,"able bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be o",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:116261,Availability,error,errors,116261,"able bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be o",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:116747,Availability,error,errors,116747," parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetMaximum(Double_t maximum = -1111); Set the maximum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the maximum value used in drawing is the maximum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'maximum' is; used, with no extra margin. TH1::GetMaximum ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:116766,Availability,error,errors,116766," parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetMaximum(Double_t maximum = -1111); Set the maximum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the maximum value used in drawing is the maximum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'maximum' is; used, with no extra margin. TH1::GetMaximum ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:117170,Availability,error,errors,117170," resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetMaximum(Double_t maximum = -1111); Set the maximum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the maximum value used in drawing is the maximum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'maximum' is; used, with no extra margin. TH1::GetMaximum returns the maximum value of the bins in the histogram, unless the; maximum has been set manually by this function or by altering the y/z axis limits.; Use TH1::GetMaximumBin to find the bin with the maximum value of an histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the minimum value used in drawing is the minimum value of the histogram plus; a margin of 10",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:117189,Availability,error,errors,117189," resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetMaximum(Double_t maximum = -1111); Set the maximum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the maximum value used in drawing is the maximum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'maximum' is; used, with no extra margin. TH1::GetMaximum returns the maximum value of the bins in the histogram, unless the; maximum has been set manually by this function or by altering the y/z axis limits.; Use TH1::GetMaximumBin to find the bin with the maximum value of an histogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the minimum value used in drawing is the minimum value of the histogram plus; a margin of 10",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:118989,Availability,error,error,118989,"stogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the minimum value used in drawing is the minimum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'minimum' is; used, with no extra margin. TH1::GetMinimum returns the minimum value of the bins in the histogram, unless the; minimum has been set manually by this function or by altering the y/z axis limits.; Use TH1::GetMinimumBin to find the bin with the minimum value of an histogram. void SetDirectory(TDirectory* dir); By default when an histogram is created, it is added to the list; of histogram objects in the current directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. void SetError(const Double_t* error); -*-*-*-*-*-*-*Replace bin errors by values in array error*-*-*-*-*-*-*-*-*. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name and title of this histogram. void SetStats(Bool_t stats = kTRUE); -*-*-*-*-*-*-*Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Style option. void Sumw2(); Create structure to store sum of squares of weights*-*-*-*-*-*-*-*. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:119023,Availability,error,errors,119023,"stogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the minimum value used in drawing is the minimum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'minimum' is; used, with no extra margin. TH1::GetMinimum returns the minimum value of the bins in the histogram, unless the; minimum has been set manually by this function or by altering the y/z axis limits.; Use TH1::GetMinimumBin to find the bin with the minimum value of an histogram. void SetDirectory(TDirectory* dir); By default when an histogram is created, it is added to the list; of histogram objects in the current directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. void SetError(const Double_t* error); -*-*-*-*-*-*-*Replace bin errors by values in array error*-*-*-*-*-*-*-*-*. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name and title of this histogram. void SetStats(Bool_t stats = kTRUE); -*-*-*-*-*-*-*Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Style option. void Sumw2(); Create structure to store sum of squares of weights*-*-*-*-*-*-*-*. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:119049,Availability,error,error,119049,"stogram. void SetMinimum(Double_t minimum = -1111); Set the minimum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the minimum value used in drawing is the minimum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'minimum' is; used, with no extra margin. TH1::GetMinimum returns the minimum value of the bins in the histogram, unless the; minimum has been set manually by this function or by altering the y/z axis limits.; Use TH1::GetMinimumBin to find the bin with the minimum value of an histogram. void SetDirectory(TDirectory* dir); By default when an histogram is created, it is added to the list; of histogram objects in the current directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. void SetError(const Double_t* error); -*-*-*-*-*-*-*Replace bin errors by values in array error*-*-*-*-*-*-*-*-*. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name and title of this histogram. void SetStats(Bool_t stats = kTRUE); -*-*-*-*-*-*-*Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Style option. void Sumw2(); Create structure to store sum of squares of weights*-*-*-*-*-*-*-*. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:119723,Availability,error,error,119723,"t directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. void SetError(const Double_t* error); -*-*-*-*-*-*-*Replace bin errors by values in array error*-*-*-*-*-*-*-*-*. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name and title of this histogram. void SetStats(Bool_t stats = kTRUE); -*-*-*-*-*-*-*Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Style option. void Sumw2(); Create structure to store sum of squares of weights*-*-*-*-*-*-*-*. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function with name*-*-*-*-*-*-*-*-*-*-*-*-*. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,bin",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:120215,Availability,error,error,120215,"he name and title of this histogram. void SetStats(Bool_t stats = kTRUE); -*-*-*-*-*-*-*Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Style option. void Sumw2(); Create structure to store sum of squares of weights*-*-*-*-*-*-*-*. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function with name*-*-*-*-*-*-*-*-*-*-*-*-*. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins i",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:120563,Availability,error,error,120563,"); Create structure to store sum of squares of weights*-*-*-*-*-*-*-*. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function with name*-*-*-*-*-*-*-*-*-*-*-*-*. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); see convention for numbering bins in TH1::GetBin. void SetCellContent(Int_t binx, Int_t biny, Double_t content); Set cell content. void Set",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:120727,Availability,error,error,120727,"g bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before. TF1 * GetFunction(const char* name) const; -*-*-*Return pointer to function with name*-*-*-*-*-*-*-*-*-*-*-*-*. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); see convention for numbering bins in TH1::GetBin. void SetCellContent(Int_t binx, Int_t biny, Double_t content); Set cell content. void SetBinError(Int_t binx, Int_t biny, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:121041,Availability,error,error,121041,"name*-*-*-*-*-*-*-*-*-*-*-*-*. Functions such as TH1::Fit store the fitted function in the list of; functions of this histogram. Double_t GetBinError(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); see convention for numbering bins in TH1::GetBin. void SetCellContent(Int_t binx, Int_t biny, Double_t content); Set cell content. void SetBinError(Int_t binx, Int_t biny, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); see convention for numbering bins in TH1::GetBin. void SetCellError(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t bin, Double_t content); see convention for numbering bins in TH1::GetBin. TH1 * ShowBackground(Int_t niter = 20, Option_t",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:121161,Availability,error,error,121161,"(Int_t bin) const; -*-*-*-*-*Return value of error associated to bin number bin*-*-*-*-*. if the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Double_t GetBinError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); see convention for numbering bins in TH1::GetBin. void SetCellContent(Int_t binx, Int_t biny, Double_t content); Set cell content. void SetBinError(Int_t binx, Int_t biny, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); see convention for numbering bins in TH1::GetBin. void SetCellError(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t bin, Double_t content); see convention for numbering bins in TH1::GetBin. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram. Function parameter",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:121586,Availability,error,error,121586,"biny. NB: Function to be called for 2-D histograms only. Double_t GetBinError(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); see convention for numbering bins in TH1::GetBin. void SetCellContent(Int_t binx, Int_t biny, Double_t content); Set cell content. void SetBinError(Int_t binx, Int_t biny, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); see convention for numbering bins in TH1::GetBin. void SetCellError(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t bin, Double_t content); see convention for numbering bins in TH1::GetBin. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram. Function parameters:; -niter, number of iterations (default value = 2); Increasing niter make the result smoother and lower.; -option: may contain one of the following options; - to set the direction parameter; ""BackDecreasingWindow"". By default the direction is BackIncreasingWindow; - filterOrder-order of clipping filter, (default ""BackOrder2""; -possible values= ""BackOrder4""; ""BackOrder6""; ""BackOrder8""; - ""nosmoothing""- if selected",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:121706,Availability,error,error,121706,"const; -*-*-*-*-*Return error of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only. Double_t GetCellContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only. Double_t GetCellError(Int_t binx, Int_t biny) const; -*-*-*-*-*Return error of bin number binx, biny. NB: Function to be called for 2-D histograms only. void SetBinError(Int_t bin, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t binx, Int_t biny, Int_t binz, Double_t content); see convention for numbering bins in TH1::GetBin. void SetCellContent(Int_t binx, Int_t biny, Double_t content); Set cell content. void SetBinError(Int_t binx, Int_t biny, Double_t error); see convention for numbering bins in TH1::GetBin. void SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); see convention for numbering bins in TH1::GetBin. void SetCellError(Int_t binx, Int_t biny, Double_t content); see convention for numbering bins in TH1::GetBin. void SetBinContent(Int_t bin, Double_t content); see convention for numbering bins in TH1::GetBin. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram. Function parameters:; -niter, number of iterations (default value = 2); Increasing niter make the result smoother and lower.; -option: may contain one of the following options; - to set the direction parameter; ""BackDecreasingWindow"". By default the direction is BackIncreasingWindow; - filterOrder-order of clipping filter, (default ""BackOrder2""; -possible values= ""BackOrder4""; ""BackOrder6""; ""BackOrder8""; - ""nosmoothing""- if selected, the background is not smoothed; By default the background is smoothed.; - smoothWindow-width of smoothing window",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:13920,Deployability,update,updated,13920,"gram; Like for any other ROOT object derived from TObject, one can use; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:. TH1F *hnew = (TH1F*)h->Clone(""hnew"");. Normalizing histograms; One can scale an histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram.; Drawing histograms; Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use. h->DrawCopy();. This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle().; Setting Drawing histogram",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:61489,Deployability,update,updated,61489,"e making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See THistPainter::Paint for a description of all the drawing options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:64769,Deployability,release,released,64769,"-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void DrawPanel(); -*-*-*-*-*Display a panel with all histogram drawing options*-*-*-*-*-*. See class TDrawPanelHist for example. void Eval(TF1* f1, Option_t* option = """"); -*-*-*Evaluate function f1 at the center of bins of this histogram-*-*-*-*. If option ""R"" is specified, the function is evaluated only; for the bins included in the function range.; If option ""A"" is specified, the value of the function is added to the; existing bin contents; If option ""S"" is specified, the value of the function is used to; generate a value, distributed according to the Poisson; distribution, with f1 as the mean. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Execute action corresponding to one event*-*-*-*. This member function is called when a histogram is clicked with the locator. If Left button clicked on the bin top value, then the content of this bin; is modified according to the new position of the mouse when it is released. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1* FFT(TH1* h_output, Option_t* option); This function allows to do discrete Fourier transforms of TH1 and TH2.; Available transform types and flags are described below. To extract more information about the transform, use the function; TVirtualFFT::GetCurrentTransform() to get a pointer to the current; transform object. Parameters:; 1st - histogram for the output. If a null pointer is passed, a new histogram is created; and returned, otherwise, the provided histogram is used and should be big enough. Options: option parameters consists of 3 parts:; - option on what to return; ""RE"" - returns a histogram of the real part of the output; ""IM"" - returns a histogram of the imaginary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; """,MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:69272,Deployability,integrat,integrated,69272,"uares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the bin corresponding to x. void FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); -*-*-*-*-*-*Fill this histogram with an array x and weights w*-*-*-*-*. ntimes: number of entries in arrays x and w (array size must be ntimes*stride); x: array of values to be histogrammed; w: array of weighs; stride: step size through arrays x and w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w[i]^2 in the bin corresponding to x[i].; if w is NULL each entry is assumed a weight=1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in function fname*-*-*-*. The distribution contained in the function fname (TF1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the sa",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:69911,Deployability,integrat,integrated,69911,"w[i]^2 in the bin corresponding to x[i].; if w is NULL each entry is assumed a weight=1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in function fname*-*-*-*. The distribution contained in the function fname (TF1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the same binning as the source.; in this case we simply use a poisson distribution where; the mean value per bin = bincontent/integral. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. Int_t FindBin(Double_t x, Double_t y = 0, Double_t z = 0); Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function tries to rebin the axis if the given point; belongs to an under-/overflow bin.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions.; See also TH1::GetBin, TAxis::Fi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:47443,Energy Efficiency,power,power,47443,"ll as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator o",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:84334,Energy Efficiency,adapt,adapted,84334,"tions*-*-*-*-*-*. See class TFitPanel for example. TH1 * GetAsymmetry(TH1* h2, Double_t c2 = 1, Double_t dc2 = 0); return an histogram containing the asymmetry of this histogram with h2,; where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this. works for 1D, 2D, etc. histograms; c2 is an optional argument that gives a relative weight between the two; histograms, and dc2 is the error on this weight. This is useful, for example,; when forming an asymmetry between two histograms from 2 different data sets that; need to be normalized to each other in some way. The function calculates; the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)). example: assuming 'h1' and 'h2' are already filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:85081,Energy Efficiency,power,power,85081,"ready filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py. TVirtualHistPainter * GetPainter(Option_t* option = """"); return pointer to painter; if painter does not exist, it is created. Int_t GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum = 0); Compute Quantiles for this histogram; Quantile x_q of a probability distribution Function F is defined as. F(x_q) = q with 0 <= q <= 1. For instance the median x_0.5 of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. F(x_0.5) = Probability(x < x_0.5) = 0.5. code from Eddy Offermann, Renaissance. input parameters; - this 1-d histogram (TH1F,D,etc). Could also be a TProfile; - nprobSum maximum size of array q and size of array probSum (",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110194,Energy Efficiency,adapt,adapted,110194,"haracter string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:55714,Integrability,rout,routine,55714,"ory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method description,; see Chi2Test() function.; Returns p-value; parameters:; - h2-second histogram; - option:; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted). ""NORM"" = if one or both histograms is scaled. ""OF"" = overflows included; ""UF"" = underflows included; by default underflows and overlows are not included. - igood:; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'; For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histo",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:66691,Integrability,depend,depending,66691,"ary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; ""R2C"" - real to complex transforms - default; ""R2HC"" - real to halfcomplex (special format of storing output data,; results the same as for R2C); ""DHT"" - discrete Hartley transform; real to real transforms (sine and cosine):; ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; To specify the type of each dimension of a 2-dimensional real to real; transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd. - option of transform flag; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. Default is ""ES"".; Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX"". Int_t Fill(Double_t x); -*-*-*-*-*-*-*-*Increment bin with abscissa X by 1*-*-*-*-*-*-*-*-*-*-*. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t Fill(Double_t x, Double_t w); -*-*-*-*-*-*Increment bin with abscis",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:69272,Integrability,integrat,integrated,69272,"uares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the bin corresponding to x. void FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); -*-*-*-*-*-*Fill this histogram with an array x and weights w*-*-*-*-*. ntimes: number of entries in arrays x and w (array size must be ntimes*stride); x: array of values to be histogrammed; w: array of weighs; stride: step size through arrays x and w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w[i]^2 in the bin corresponding to x[i].; if w is NULL each entry is assumed a weight=1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in function fname*-*-*-*. The distribution contained in the function fname (TF1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the sa",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:69911,Integrability,integrat,integrated,69911,"w[i]^2 in the bin corresponding to x[i].; if w is NULL each entry is assumed a weight=1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in function fname*-*-*-*. The distribution contained in the function fname (TF1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the same binning as the source.; in this case we simply use a poisson distribution where; the mean value per bin = bincontent/integral. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. Int_t FindBin(Double_t x, Double_t y = 0, Double_t z = 0); Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function tries to rebin the axis if the given point; belongs to an under-/overflow bin.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions.; See also TH1::GetBin, TAxis::Fi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:76588,Integrability,rout,routines,76588,"parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0, 3.1, 1.e-6, -8, 0, 100);; func->SetParLimits(3, -10, -4);; func->FixParameter(4, 0);; func->SetParLimits(5, 1, 1);; With this setup, parameters 0->2 can vary freely; Parameter 3 has boundaries [-10,-4] with initial value -8; Parameter 4 is fixed to 0; Parameter 5 is fixed to 100.; When the lower limit and upper limit are equal, the parameter is fixed.; However to fix a parameter to 0, one must call the FixParameter function. Note that option ""I"" gives better results but is slower. Changing the fitting objective function. By default a chi square function is used for fitting. When option ""L"" (or ""LL"") is used; a Poisson likelihood function (see note below) is used.; The functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; the file math/mathcore/src/FitUtil.cxx.; To specify a User defined fitting function, specify option ""U"" and; call the following functions:; TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Likelihood Fits. When using option ""L"" a likelihood fit is used instead of the default chi2 square fit.; The likelihood is built assuming a Poisson probability density function for each bin.; This method can then be used only when the bin content represents counts (i.e. errors are sqrt(N) ).; The likelihood method has the advantage of treating correctly the empty bins and use them in the; fit procedure.; In the chi2 method the empty bins are skipped and not considered in the fit.; The likelihood method, although a bit slower, it is the recommended method in case of low; bin statistics, where the chi2 method ma",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:80622,Integrability,depend,depending,80622,"ter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is OK (i.e no error occurred).; The value of the fit status code is negative in case of an error not connected with the; minimization procedure, for example when a wrong function is used.; Otherwise the return value is the one returned from the minimization procedure.; When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :; fitStatus = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.; TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in; case of error (see the documentation of TMinuit::mnexcm). So for example, for an error; only in Minos but not in Migrad a fitStatus of 40 will be returned.; Minuit2 will return also 0 in case of success and different values in migrad minos or; hesse depending on the error. See in this case the documentation of; Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the; minosResult and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the case of Fumili, for the status returned see TFumili::Minimize. Excluding points. Use TF1::RejectPoint inside your fitting function to exclude points; within a certain range from the fit. Example:; Double_t fline(Double_t *x, Double_t *par); {; if (x[0] > 2.5 && x[0] < 3.5) {; TF1::RejectPoint();; return 0;; }; return par[0] + par[1]*x[0];; }. void exclude() {; TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:82324,Integrability,interface,interface,82324," TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ""l"");; }. Warning when using the option ""0"". When selecting the option ""0"", the fitted function is added to; the list of functions of the histogram, but it is not drawn.; You can undo what you disabled in the following way:; h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; h.Draw(); function is not drawn; const Int_t kNotDraw = 1<<9;; h.GetFunction(""myFunction"")->ResetBit(kNotDraw);; h.Draw(); // function is visible again. Access to the Minimizer information during fitting. This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx; which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction; (e.g. chi2 or likelihood) and uses an implementation of the Minimizer interface for minimizing; the function.; The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).; The default can be set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2; A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer; (or TVirtualFitter::SetDefaultFitter).; For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");; will set the usdage of the BFGS algorithm of the GSL multi-dimensional minimization; (implemented in libMathMore). ROOT::Math::MinimizerOptions can be used also to set other; default options, like maximum number of function calls, minimization tolerance or print; level. See the documentation of this class. For fitting linear functions (containing the ""++"" sign"" and polN functions,; the linear fitter is automatically initialized. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void FitPanel(); -*-*-*-*-*Display a panel ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:95744,Integrability,rout,routine,95744,"s*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histograms*-*-*-*-*-*-*. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list of options). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this histogram. -case 1 xbins=0; if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter ngroup indicates how many bins of this have to me merged; into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; h1->Rebin(5); //merges five bins in one in h1; TH1F *hnew = h1->Rebin(5,""hnew""); // creates a new histogram hnew; //merging 5 bins of h1 in one bin. NOTE: If ngroup is not an exact divider of the number of bins,; the top limit of the rebinned histog",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:100483,Integrability,rout,routine,100483,"ntents and errors are divided; by the bin width. void SetDefaultBufferSize(Int_t buffersize = 1000); static function to set the default buffer size for automatic histograms.; When an histogram is created with one of its axis lower limit greater; or equal to its upper limit, the function SetBuffer is automatically; called with the default buffer size. void SetDefaultSumw2(Bool_t sumw2 = kTRUE); static function.; When this static function is called with sumw2=kTRUE, all new; histograms will automatically activate the storage; of the sum of squares of errors, ie TH1::Sumw2 is automatically called. void SetTitle(const char* title); Change (i.e. set) the title. if title is in the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt, the x axis title to stringx,; the y axis title to stringy, and the z axis title to stringz.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". void SmoothArray(Int_t NN, Double_t* XX, Int_t ntimes = 1); smooth array xx, translation of Hbook routine hsmoof.F; based on algorithm 353QH twice presented by J. Friedman; in Proc.of the 1974 CERN School of Computing, Norway, 11-24 August, 1974. void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this histogram.; if option contains ""R"" smoothing is applied only to the bins; defined in the X axis range (default is to smooth all bins); Bin contents are replaced by their smooth values.; Errors (if any) are not modified.; the smoothing procedure is repeated ntimes (default=1). void StatOverflows(Bool_t flag = kTRUE); if flag=kTRUE, underflows and overflows are used by the Fill functions; in the computation of statistics (mean value, RMS).; By default, underflows or overflows are not used. void Streamer(TBuffer& b); -*-*-*-*-*-*-*Stream a class object*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Print(Option_t* option = """") const; -*-*-*-*-*Print some global quantities for this histogram*-*-*-*-*-*-*-*. If option ""base"" is give",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110235,Integrability,rout,routine,110235,"haracter string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:111206,Integrability,depend,depending,111206,"patible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform distributions of 500 events in 100 bins, the values of PROB,; instead of being exactly uniformly distributed between zero and one, have; a mean value of about 0.56. We can apply a useful; rule: As long as the bin width is small compared with any significant; physical effect (for example the experimental resolution) then the binning; cannot have an important effect. Therefore, we believe that for all; practical purposes, the probability value PROB is calculated correctly; provided the user is aware that:; 1. The value of PROB should not be expected to have exactly the correct; distribution for binned data.; 2. The user is responsible for seeing to it that the bin widths are; small compared with any physical phenomena of interest.; 3. The effect of binning (if any) is always to make the value of PROB; slightly too big. That is, setting an acceptance criterion of (PROB>0.05; will a",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:2577,Modifiability,inherit,inherit,2577,"bin content = 2147483647; TH3F : histograms with one float per channel. Maximum precision 7 digits; TH3D : histograms with one double per channel. Maximum precision 14 digits; ; Profile histograms: See classes TProfile, TProfile2D and TProfile3D.; Profile histograms are used to display the mean value of Y and its RMS; for each bin in X. Profile histograms are in many cases an elegant; replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. All histogram classes are derived from the base class TH1. TH1; ^; |; |; |; -----------------------------------------------------------; | | | | | | |; | | TH1C TH1S TH1I TH1F TH1D; | | |; | | |; | TH2 TProfile; | |; | |; | ----------------------------------; | | | | | |; | TH2C TH2S TH2I TH2F TH2D; | |; TH3 |; | TProfile2D; |; -------------------------------------; | | | | |; TH3C TH3S TH3I TH3F TH3D; |; |; TProfile3D; The TH*C classes also inherit from the array class TArrayC.; The TH*S classes also inherit from the array class TArrayS.; The TH*I classes also inherit from the array class TArrayI.; The TH*F classes also inherit from the array class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:2638,Modifiability,inherit,inherit,2638,"3D.; Profile histograms are used to display the mean value of Y and its RMS; for each bin in X. Profile histograms are in many cases an elegant; replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. All histogram classes are derived from the base class TH1. TH1; ^; |; |; |; -----------------------------------------------------------; | | | | | | |; | | TH1C TH1S TH1I TH1F TH1D; | | |; | | |; | TH2 TProfile; | |; | |; | ----------------------------------; | | | | | |; | TH2C TH2S TH2I TH2F TH2D; | |; TH3 |; | TProfile2D; |; -------------------------------------; | | | | |; TH3C TH3S TH3I TH3F TH3D; |; |; TProfile3D; The TH*C classes also inherit from the array class TArrayC.; The TH*S classes also inherit from the array class TArrayS.; The TH*I classes also inherit from the array class TArrayI.; The TH*F classes also inherit from the array class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:2699,Modifiability,inherit,inherit,2699," Y and its RMS; for each bin in X. Profile histograms are in many cases an elegant; replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. All histogram classes are derived from the base class TH1. TH1; ^; |; |; |; -----------------------------------------------------------; | | | | | | |; | | TH1C TH1S TH1I TH1F TH1D; | | |; | | |; | TH2 TProfile; | |; | |; | ----------------------------------; | | | | | |; | TH2C TH2S TH2I TH2F TH2D; | |; TH3 |; | TProfile2D; |; -------------------------------------; | | | | |; TH3C TH3S TH3I TH3F TH3D; |; |; TProfile3D; The TH*C classes also inherit from the array class TArrayC.; The TH*S classes also inherit from the array class TArrayS.; The TH*I classes also inherit from the array class TArrayI.; The TH*F classes also inherit from the array class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:2760,Modifiability,inherit,inherit,2760,"many cases an elegant; replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. All histogram classes are derived from the base class TH1. TH1; ^; |; |; |; -----------------------------------------------------------; | | | | | | |; | | TH1C TH1S TH1I TH1F TH1D; | | |; | | |; | TH2 TProfile; | |; | |; | ----------------------------------; | | | | | |; | TH2C TH2S TH2I TH2F TH2D; | |; TH3 |; | TProfile2D; |; -------------------------------------; | | | | |; TH3C TH3S TH3I TH3F TH3D; |; |; TProfile3D; The TH*C classes also inherit from the array class TArrayC.; The TH*S classes also inherit from the array class TArrayS.; The TH*I classes also inherit from the array class TArrayI.; The TH*F classes also inherit from the array class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:2821,Modifiability,inherit,inherit,2821,"ams : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. All histogram classes are derived from the base class TH1. TH1; ^; |; |; |; -----------------------------------------------------------; | | | | | | |; | | TH1C TH1S TH1I TH1F TH1D; | | |; | | |; | TH2 TProfile; | |; | |; | ----------------------------------; | | | | | |; | TH2C TH2S TH2I TH2F TH2D; | |; TH3 |; | TProfile2D; |; -------------------------------------; | | | | |; TH3C TH3S TH3I TH3F TH3D; |; |; TProfile3D; The TH*C classes also inherit from the array class TArrayC.; The TH*S classes also inherit from the array class TArrayS.; The TH*I classes also inherit from the array class TArrayI.; The TH*F classes also inherit from the array class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:3748,Modifiability,variab,variable,3748,"class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/lineariz",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:3809,Modifiability,variab,variable,3809,"class TArrayF.; The TH*D classes also inherit from the array class TArrayD. Creating histograms. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/lineariz",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:3880,Modifiability,variab,variable,3880,"ams. Histograms are created by invoking one of the constructors, e.g. TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information ind",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:8719,Modifiability,extend,extend,8719,"pically filled with statements like:. h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w). or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent.; To access the bin content of a given bin, do:. Double_t binContent = h->GetBinContent(bin);. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via. h->SetBit(TH1::kCanRebin);. then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision.; In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents.; Rebinning; At any time, an histogram can be rebinned via TH1::Rebin. This function; returns a new histogram with the rebinned contents.; If bin errors were stored, they are recomputed during the rebinning.; Associated errors; By default,",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:9014,Modifiability,variab,variables,9014,"functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent.; To access the bin content of a given bin, do:. Double_t binContent = h->GetBinContent(bin);. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via. h->SetBit(TH1::kCanRebin);. then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision.; In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents.; Rebinning; At any time, an histogram can be rebinned via TH1::Rebin. This function; returns a new histogram with the rebinned contents.; If bin errors were stored, they are recomputed during the rebinning.; Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sq",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:14734,Modifiability,inherit,inherit,14734,"om the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use. h->DrawCopy();. This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle().; Setting Drawing histogram contour levels (2-D hists only); By default contours are automatically generated at equidistant; intervals. A default value of 20 levels is used. This can be modified; via TH1::SetContour() or TH1::SetContourLevel().; the contours level info is used by the drawing options ""cont"", ""surf"",; and ""lego"".; Setting histogram graphics attributes; The histogram classes inherit from the attribute classes:; TAttLine, TAttFill, TAttMarker and TAttText.; See the member functions of these classes for the list of options.; Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; It is also possible to specify the histogram title and the axis; titles at creation time. These titles can be given in the ""titl",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:15214,Modifiability,inherit,inherit,15214," clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle().; Setting Drawing histogram contour levels (2-D hists only); By default contours are automatically generated at equidistant; intervals. A default value of 20 levels is used. This can be modified; via TH1::SetContour() or TH1::SetContourLevel().; the contours level info is used by the drawing options ""cont"", ""surf"",; and ""lego"".; Setting histogram graphics attributes; The histogram classes inherit from the attribute classes:; TAttLine, TAttFill, TAttMarker and TAttText.; See the member functions of these classes for the list of options.; Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; It is also possible to specify the histogram title and the axis; titles at creation time. These titles can be given in the ""title""; parameter. They must be separated by "";"":. TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis;Z Axis"", 100, 0, 1);. Any title can be omitted:. TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);. The method SetTitle has the same syntax:. h->SetTitle(""Histogram title;Another X title Axis"");; Saving/Reading histograms to/from a ROOT file; The following statements create a ROOT file and store an histogram; on the file. Because T",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:38454,Modifiability,variab,variable,38454,"-*-*-*-*Histogram default destructor*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup); -*-*-*-*-*-*-*Normal constructor for fix bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for eac",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:39050,Modifiability,variab,variable,39050,"st bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also re",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:44674,Modifiability,variab,variable,44674,"n drawing the histogram. action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when filling the histogram and the entries is; larger than the buffer size. Int_t BufferFill(Double_t x, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry. bool CheckBinLimits(const TAxis* a1, const TAxis* a2). bool CheckAxisLimits(const TAxis* a1, const TAxis* a2); Check that the axis limits of the histograms are the same; if a first and last bin is passed the axis is compared between the given range. bool CheckEqualAxes(const TAxis* a1, const TAxis* a2); Check that the axis are the same. bool CheckConsistentSubAxes(const TAxis* a1, Int_t firstBin1, Int_t lastBin1, const TAxis* a2, Int_t firstBin2 = 0, Int_t lastBin2 = 0); Check that two sub axis are the same; the limits are defined by first bin and last bin; N.B. no check is done in this case for variable bins. bool CheckConsistency(const TH1* h1, const TH1* h2); Check histogram compatibility; returns kTRUE if number of bins and bin limits are identical. Double_t Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; test for comparing weighted and unweighted histograms. Function: Returns p-value. Other return values are specified by the 3rd parameter <br>. Parameters:. - h2: the second histogram; - option:; o ""UU"" = experiment experiment comparison (unweighted-unweighted); o ""UW"" = experiment MC comparison (unweighted-weighted). Note that; the first histogram should be unweighted; o ""WW"" = MC MC comparison (weighted-weighted); o ""NORM"" = to be used when one or both of the histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:47262,Modifiability,variab,variables,47262,"d widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approxi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:48180,Modifiability,variab,variable,48180," are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator of pi, i=1,...,r, is. and then. has approximately a distribution [3].; The comparison procedure can include an analysis of the residuals which; is often helpful in identifying the bins of histograms responsible for; a significant overall value. Most convenient for; analysis are the adjusted (normalized) residuals [4]. If hypotheses of homogeneity are valid then residuals ri are; approximately independent and identically distributed random variables; having N(0,1) distribution. The application of the test has; restrictions related to the value of the expected frequencies Npi,; Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; expectations must be 1 or greater for both histograms. In practical; cases when expected frequencies are not known the estima",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:48860,Modifiability,variab,variables,48860,"togram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator of pi, i=1,...,r, is. and then. has approximately a distribution [3].; The comparison procedure can include an analysis of the residuals which; is often helpful in identifying the bins of histograms responsible for; a significant overall value. Most convenient for; analysis are the adjusted (normalized) residuals [4]. If hypotheses of homogeneity are valid then residuals ri are; approximately independent and identically distributed random variables; having N(0,1) distribution. The application of the test has; restrictions related to the value of the expected frequencies Npi,; Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; expectations must be 1 or greater for both histograms. In practical; cases when expected frequencies are not known the estimated expected; frequencies can be used. Unweighted and weighted histograms comparison:. A simple modification of the ideas described above can be used for the; comparison of the usual (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogra",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:49930,Modifiability,variab,variable,49930,"cted frequencies Npi,; Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; expectations must be 1 or greater for both histograms. In practical; cases when expected frequencies are not known the estimated expected; frequencies can be used. Unweighted and weighted histograms comparison:. A simple modification of the ideas described above can be used for the; comparison of the usual (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as well; as the original one [3], has a restriction on the expected frequencies. The; expected frequencies recommended for the weighted histogram is more than 25.; The value of the minimal expected frequency can be decreased down to 10 for; the case when the weights of the events are close to constant. In the case; of a weighted histogram if the number of events is unknown, then we can; apply this recommendation for the equivalent number of events as. The minimal expected frequency for an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that ha",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:51777,Modifiability,variab,variables,51777,"or an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that have constant weights equal to 1.; The variance of the difference between the weight wi; and the estimated expectation value of the weight is approximately equal to:. The residuals. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted histograms comparison:. Let us denote the common weight of events of the ith bin in the first; histogram as w1i and as w2i in the second one. The total weight of events; in the first histogram is equal to. and. in the second histogram. Let us formulate the hypothesis of identity of; weighted histograms so that there exist r constants p1,...,pr, such that. and also expectation value of weight w1i equal to W1pi and expectation value; of weight w2i equal to W2pi. Weights in both the histograms are random; variables with distributions which can be approximated by a normal; probability distribution for the first histogram; and by a distribution for the second.; Here and are the variances; of w1i and w2i with estimators and respectively.; If the hypothesis of identity is valid, then the maximum likelihood and; Least Square Method estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2].; The normalized or studentised residuals [6]. have approximately a normal distribution with mean equal to 0 and standard; deviation 1. A recommended minimal expected frequency is equal to 10 for; the proposed test. Numerical examples:. The method described herein is now illustrated with an example.; We take a distribution. defined on the interval [4,16]. Events distributed according to the formula; (1) are simulated to create the unweighted histogram. Uniformly distributed; events are simulated for the weighted histogram with weights calculated by; formula (1). Each histogram has the same number of bins: 20. ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:62220,Modifiability,inherit,inherit,62220," an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See THistPainter::Paint for a description of all the drawing options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawCopy(Option_t* option = """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawNormalized(Option_t* option = """", Double_t norm = 1) const; Draw a normalized copy of this histogram. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned.; The contents of the histogram copy are scaled such that the new; sum of weights (excluding under and overflow) is equal to norm.; Note th",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:84334,Modifiability,adapt,adapted,84334,"tions*-*-*-*-*-*. See class TFitPanel for example. TH1 * GetAsymmetry(TH1* h2, Double_t c2 = 1, Double_t dc2 = 0); return an histogram containing the asymmetry of this histogram with h2,; where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this. works for 1D, 2D, etc. histograms; c2 is an optional argument that gives a relative weight between the two; histograms, and dc2 is the error on this weight. This is useful, for example,; when forming an asymmetry between two histograms from 2 different data sets that; need to be normalized to each other in some way. The function calculates; the errors asumming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)). example: assuming 'h1' and 'h2' are already filled. h3 = h1->GetAsymmetry(h2). then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; h1 and h2 are left intact. Note that it is the user's responsibility to manage the created histogram. code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun. clone the histograms so top and bottom will have the; correct dimensions:; Sumw2 just makes sure the errors will be computed properly; when we form sums and ratios below. Int_t GetDefaultBufferSize(); static function; return the default buffer size for automatic histograms; the parameter fgBufferSize may be changed via SetDefaultBufferSize. Bool_t GetDefaultSumw2(); static function; return kTRUE if TH1::Sumw2 must be called when creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:85788,Modifiability,variab,variable,85788," creating new histograms.; see TH1::SetDefaultSumw2. Double_t GetEntries() const; return the current number of entries. Double_t GetEffectiveEntries() const; number of effective entries of the histogram,; i.e. the number of unweighted entries a histogram would need to; have the same statistical power as this histogram with possibly; weighted entries (i.e. <= TH1::GetEntries()). char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py. TVirtualHistPainter * GetPainter(Option_t* option = """"); return pointer to painter; if painter does not exist, it is created. Int_t GetQuantiles(Int_t nprobSum, Double_t* q, const Double_t* probSum = 0); Compute Quantiles for this histogram; Quantile x_q of a probability distribution Function F is defined as. F(x_q) = q with 0 <= q <= 1. For instance the median x_0.5 of a distribution is defined as that value; of the random variable for which the distribution function equals 0.5:. F(x_0.5) = Probability(x < x_0.5) = 0.5. code from Eddy Offermann, Renaissance. input parameters; - this 1-d histogram (TH1F,D,etc). Could also be a TProfile; - nprobSum maximum size of array q and size of array probSum (if given); - probSum array of positions where quantiles will be computed.; if probSum is null, probSum will be computed internally and will; have a size = number of bins + 1 in h. it will correspond to the; quantiles calculated at the lowest edge of the histogram (quantile=0) and; all the upper edges of the bins.; if probSum is not null, it is assumed to contain at least nprobSum values.; output; - return value nq (<=nprobSum) with the number of quantiles computed; - array q filled with nq quantiles. Note that the Integral of the histogram is automatically recomputed; if the number of entries is different of the number of entries when; the integral was computed last time. In case you do not use the Fill; func",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:97026,Modifiability,variab,variable,97026," is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter ngroup indicates how many bins of this have to me merged; into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; h1->Rebin(5); //merges five bins in one in h1; TH1F *hnew = h1->Rebin(5,""hnew""); // creates a new histogram hnew; //merging 5 bins of h1 in one bin. NOTE: If ngroup is not an exact divider of the number of bins,; the top limit of the rebinned histogram is changed; to the upper edge of the bin=newbins*ngroup and the corresponding; bins are added to the overflow bin.; Statistics will be recomputed from the new bin contents. -case 2 xbins!=0; a new histogram is created (you should specify newname).; The parameter is the number of variable size bins in the created histogram.; The array xbins must contain ngroup+1 elements that represent the low-edge; of the bins.; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew. Bool_t FindNewAxisLimits(const TAxis* axis, const Double_t point, Double_t& newMin, Double_t& newMax); finds new limits for the axis so that *point* is within the range and; the limits are compatible with the previous ones (see TH1::Merge).; new limits are put into *newMin* and *newMax* variables.; axis - axis whose limits are to be recomputed; point - point that should fit within the new axis limits; newMin - new minimum will be stored here; newMax - new maximum will be stored here.; false if failed (e.g. if the init",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:97475,Modifiability,variab,variable,97475,"o bins in one in h1: previous contents of h1 are lost; h1->Rebin(5); //merges five bins in one in h1; TH1F *hnew = h1->Rebin(5,""hnew""); // creates a new histogram hnew; //merging 5 bins of h1 in one bin. NOTE: If ngroup is not an exact divider of the number of bins,; the top limit of the rebinned histogram is changed; to the upper edge of the bin=newbins*ngroup and the corresponding; bins are added to the overflow bin.; Statistics will be recomputed from the new bin contents. -case 2 xbins!=0; a new histogram is created (you should specify newname).; The parameter is the number of variable size bins in the created histogram.; The array xbins must contain ngroup+1 elements that represent the low-edge; of the bins.; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew. Bool_t FindNewAxisLimits(const TAxis* axis, const Double_t point, Double_t& newMin, Double_t& newMax); finds new limits for the axis so that *point* is within the range and; the limits are compatible with the previous ones (see TH1::Merge).; new limits are put into *newMin* and *newMax* variables.; axis - axis whose limits are to be recomputed; point - point that should fit within the new axis limits; newMin - new minimum will be stored here; newMax - new maximum will be stored here.; false if failed (e.g. if the initial axis limits are wrong; or the new range is more than 2^64 times the old one). void RebinAxis(Double_t x, TAxis* axis); Histogram is resized along axis such that x is in the axis range.; The new axis limits are recomputed by doubling iteratively; the current axis range until the specified value x is within the limits.; The algorithm makes a copy of the histogram, then loops on all bins; of the old hi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:97797,Modifiability,variab,variables,97797," the bin=newbins*ngroup and the corresponding; bins are added to the overflow bin.; Statistics will be recomputed from the new bin contents. -case 2 xbins!=0; a new histogram is created (you should specify newname).; The parameter is the number of variable size bins in the created histogram.; The array xbins must contain ngroup+1 elements that represent the low-edge; of the bins.; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if h1 is an existing TH1F histogram with 100 bins; Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew. Bool_t FindNewAxisLimits(const TAxis* axis, const Double_t point, Double_t& newMin, Double_t& newMax); finds new limits for the axis so that *point* is within the range and; the limits are compatible with the previous ones (see TH1::Merge).; new limits are put into *newMin* and *newMax* variables.; axis - axis whose limits are to be recomputed; point - point that should fit within the new axis limits; newMin - new minimum will be stored here; newMax - new maximum will be stored here.; false if failed (e.g. if the initial axis limits are wrong; or the new range is more than 2^64 times the old one). void RebinAxis(Double_t x, TAxis* axis); Histogram is resized along axis such that x is in the axis range.; The new axis limits are recomputed by doubling iteratively; the current axis range until the specified value x is within the limits.; The algorithm makes a copy of the histogram, then loops on all bins; of the old histogram to fill the rebinned histogram.; Takes into account errors (Sumw2) if any.; The algorithm works for 1-d, 2-D and 3-D histograms.; The bit kCanRebin must be set before invoking this function.; Ex: h->SetBit(TH1::kCanRebin);. void RecursiveRemove(TObject* obj); Recursively remove object from the list of functions. void Scale(Double_",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110194,Modifiability,adapt,adapted,110194,"haracter string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:115324,Modifiability,variab,variable,115324,"maxval of bins in the range,; unless the value has been overridden by TH1::SetMinimum,; in which case it returns that value. (This happens, for example,; when the histogram is drawn and the y or z axis limits are changed. To get the minimum value of bins in the histogram regardless of; whether the value has been overridden, use; h->GetBinContent(h->GetMinimumBin()). Int_t GetMinimumBin() const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. Int_t GetMinimumBin(Int_t& locmix, Int_t& locmiy, Int_t& locmiz) const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previou",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:116123,Modifiability,variab,variable,116123,"t array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:117048,Modifiability,variab,variable,117048,"etRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetMaximum(Double_t maximum = -1111); Set the maximum value for the Y axis, in case of 1-D histograms,; or the Z axis in case of 2-D histograms. By default the maximum value used in drawing is the maximum value of the histogram plus; a margin of 10 per cent. If this function has been called, the value of 'maximum' is; used, with no extra margin. TH1::GetMaximum returns the maximum value of the bins in the histogram, unless the; maximum has been set manually by this function or by altering the y/z axis limits.; Use TH1::GetMaximumBin to find the bi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:66417,Performance,perform,performance,66417,"ary part of the output; ""MAG""- returns a histogram of the magnitude of the output; ""PH"" - returns a histogram of the phase of the output. - option of transform type; ""R2C"" - real to complex transforms - default; ""R2HC"" - real to halfcomplex (special format of storing output data,; results the same as for R2C); ""DHT"" - discrete Hartley transform; real to real transforms (sine and cosine):; ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; To specify the type of each dimension of a 2-dimensional real to real; transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd. - option of transform flag; ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; performance; ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; ""EX"" (from ""exhaustive"") - the most optimal way is found; This option should be chosen depending on how many transforms of the same size and; type are going to be done. Planning is only done once, for the first transform of this; size and type. Default is ""ES"".; Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX"". Int_t Fill(Double_t x); -*-*-*-*-*-*-*-*Increment bin with abscissa X by 1*-*-*-*-*-*-*-*-*-*-*. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t Fill(Double_t x, Double_t w); -*-*-*-*-*-*Increment bin with abscis",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:37709,Safety,avoid,avoid,37709,"um of weight*X; Double_tfTsumwx2Total Sum of weight*X*X; TAxisfXaxisX axis descriptor; TAxisfYaxisY axis descriptor; TAxisfZaxisZ axis descriptor; static Bool_tfgAddDirectory!flag to add histograms to the directory; static Int_tfgBufferSize!default buffer size for automatic histograms; static Bool_tfgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tfgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1(); -*-*-*-*-*-*-*-*-*Histogram default constructor*-*-*-*-*-*-*-*-*-*-*-*-*. ~TH1(); -*-*-*-*-*-*-*-*-*Histogram default destructor*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup); -*-*-*-*-*-*-*Normal constructor for fix bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : numb",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:38562,Safety,avoid,avoid,38562,"*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringy, the y axis title to stringy, etc.; nbins : number of bins; xlow : low edge of first bin; xup : upper edge of last bin (not included in last bin). When an histogram is created, it is automatically added to the list; of special objects in the current directory.; To find the pointer to this histogram in the current directory; by its name, do:; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed).",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:39158,Safety,avoid,avoid,39158,"*h1 = (TH1F*)gDirectory->FindObject(name);. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:3966,Security,access,access,3966,"1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);. Histograms may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:4093,Security,access,access,4093," may also be created by:; ; calling the Clone function, see below; making a projection from a 2-D or 3-D histogram, see below; reading an histogram from a file; ; When an histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:4259,Security,access,access,4259,"ogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; This default behaviour can be changed by:. h->SetDirectory(0); for the current histogram h; TH1::AddDirectory(kFALSE); sets a global switch disabling the reference. When the histogram is deleted, the reference to it is removed from; the list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted.; Fix or variable bin size; All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);. returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3.; Alphanumeric Bin Labels; By default, an histogram axis is drawn with i",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:4831,Security,access,access,4831,"ve fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);. returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3.; Alphanumeric Bin Labels; By default, an histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See example in $ROOTSYS/tutorials/graphs/labels1.C, labels2.C; call to a Fill function with one of the arguments being a string, e.g. hist1->Fill(somename, weigth);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);. See example in $ROOTSYS/tutorials/hist/hlabels1.C, hlabels2.C; via TTree::Draw.; see for exam",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:4918,Security,access,access,4918,"or access; histograms are identical in both cases.; Each histogram always contains 3 objects TAxis: fXaxis, fYaxis and fZaxis; To access the axis parameters, do:. TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc. See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision.; Convention for numbering bins; For all histogram types: nbins, xlow, xup. bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function. Int_t gbin = h->GetBin(binx, biny, binz);. returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:. Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);. returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3.; Alphanumeric Bin Labels; By default, an histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See example in $ROOTSYS/tutorials/graphs/labels1.C, labels2.C; call to a Fill function with one of the arguments being a string, e.g. hist1->Fill(somename, weigth);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);. See example in $ROOTSYS/tutorials/hist/hlabels1.C, hlabels2.C; via TTree::Draw.; see for example $ROOTSYS/tutorials/tree/cernstaff.C. tree.Draw(""Nation::Division"");. where ""Nation"" and ""Division"" are two br",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:8437,Security,access,access,8437,"qual to fgBufferSize (default value=1000).; fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.; The axis limits will be automatically computed when the buffer will; be full or when the function BufferEmpty is called.; Filling histograms; An histogram is typically filled with statements like:. h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w). or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent.; To access the bin content of a given bin, do:. Double_t binContent = h->GetBinContent(bin);. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via. h->SetBit(TH1::kCanRebin);. then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms.; During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision.; In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may h",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:78724,Security,access,access,78724," Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given an histogram h, one can retrieve an associated function; with: TF1 *myfunc = h->GetFunction(""myfunc"");. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit which is return by an; automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves as a smart; pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:88834,Security,access,access,88834,"-*-*-*-*-*Decode string choptin and fill fitOption structure*-*-*-*-*-*. Int_t GetBin(Int_t binx, Int_t biny = 0, Int_t binz = 0) const; -*-*-*-*Return Global bin number corresponding to binx,y,z*-*-*-*-*-*-*. 2-D and 3-D histograms are represented with a one dimensional; structure.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions. In case of a TH1x, returns binx directly.; see TH1::GetBinXYZ for the inverse transformation. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful; to access the bin information independently of the dimension.; -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void GetBinXYZ(Int_t binglobal, Int_t& binx, Int_t& biny, Int_t& binz) const; return binx, biny, binz corresponding to the global bin number globalbin; see TH1::GetBin function above. Double_t GetRandom() const; return a random number distributed according the histogram bin contents.; This function checks if the bins integral exists. If not, the integral; is evaluated, normalized to one.; The integral is automatically recomputed if the number of entries; is not the same then when the integral was computed.; NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise. Double_t GetBinContent(Int_t bin) const; -*-*-*-*-*Return content of bin number bin. Implemented in TH1C,S,F,D. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCL",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:90135,Security,access,access,90135,". Double_t GetRandom() const; return a random number distributed according the histogram bin contents.; This function checks if the bins integral exists. If not, the integral; is evaluated, normalized to one.; The integral is automatically recomputed if the number of entries; is not the same then when the integral was computed.; NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise. Double_t GetBinContent(Int_t bin) const; -*-*-*-*-*Return content of bin number bin. Implemented in TH1C,S,F,D. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful; to access the bin information independently of the dimension. Double_t GetBinContent(Int_t binx, Int_t biny) const; -*-*-*-*-*Return content of bin number binx, biny. NB: Function to be called for 2-D histograms only; see convention for numbering bins in TH1::GetBin. Double_t GetBinContent(Int_t binx, Int_t biny, Int_t binz) const; -*-*-*-*-*Return content of bin number binx,biny,binz. NB: Function to be called for 3-D histograms only; see convention for numbering bins in TH1::GetBin. Double_t GetBinWithContent(Double_t c, Int_t& binx, Int_t firstx = 0, Int_t lastx = 0, Double_t maxdiff = 0) const; compute first binx in the range [firstx,lastx] for which; diff = abs(bin_content-c) <= maxdiff; In case several bins in the specified range with diff=0 are found; the first bin found is returned in binx.; In case several bins in the specified range satisfy diff <=maxdiff; the bin with the smallest difference is returned in binx.; In all cases the function returns the smallest difference. NOTE1: if firstx <= ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110832,Security,access,access,110832," pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform distributions of 500 events in 100 bins, the values of PROB,; instead of being exactly uniformly distributed between zero and one, have; a mean value of about 0.56. We can apply a useful; rule: As long as the bin width is small compared with any significant; physical effect (for example the experimental resolution) then the binning; cannot have an important effect. Therefore, we believe that for all; practical purposes, the probability value PROB is calculated correctly; provided the user is aware that:; 1. The value of PROB should not be expected to have exactly the correct; distribution for binned data.; 2.",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:16679,Testability,test,test,16679,"tted:. TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);. The method SetTitle has the same syntax:. h->SetTitle(""Histogram title;Another X title Axis"");; Saving/Reading histograms to/from a ROOT file; The following statements create a ROOT file and store an histogram; on the file. Because TH1 derives from TNamed, the key identifier on; the file is the histogram name:. TFile f(""histos.root"", ""new"");; TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);; h1->Write();. To read this histogram in another Root session, do:. TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");. One can save all histograms in memory to the file by:. file->Write();. Miscelaneous operations. TH1::KolmogorovTest(): statistical test of compatibility in shape; between two histograms; TH1::Smooth() smooths the bin contents of a 1-d histogram; TH1::Integral() returns the integral of bin contents in a given bin range; TH1::GetMean(int axis) returns the mean value along axis; TH1::GetRMS(int axis) returns the sigma distribution along axis; TH1::GetEntries() returns the number of entries; TH1::Reset() resets the bin contents and errors of an histogram. . Function Members (Methods); public:. TH1(const TH1&); virtual~TH1(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TH1* h1, Double_t c1 = 1); virtual voidAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidAdd(const TH1* h, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1)MENU ; virtual voidAddBinContent(Int_t bin); virtual voidAddBinContent(Int_t bin, Double_t w); static voidAddDirectory(Bool_t add = kTRUE); static Bool_tAddDirectoryStatus(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Int_tBufferEmpty(Int_t action = 0); virtual Double_tChi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; virtual Double_tChi2TestX(const TH1* h2, Double_t& ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:44919,Testability,test,test,44919,"ate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry. bool CheckBinLimits(const TAxis* a1, const TAxis* a2). bool CheckAxisLimits(const TAxis* a1, const TAxis* a2); Check that the axis limits of the histograms are the same; if a first and last bin is passed the axis is compared between the given range. bool CheckEqualAxes(const TAxis* a1, const TAxis* a2); Check that the axis are the same. bool CheckConsistentSubAxes(const TAxis* a1, Int_t firstBin1, Int_t lastBin1, const TAxis* a2, Int_t firstBin2 = 0, Int_t lastBin2 = 0); Check that two sub axis are the same; the limits are defined by first bin and last bin; N.B. no check is done in this case for variable bins. bool CheckConsistency(const TH1* h1, const TH1* h2); Check histogram compatibility; returns kTRUE if number of bins and bin limits are identical. Double_t Chi2Test(const TH1* h2, Option_t* option = ""UU"", Double_t* res = 0) const; test for comparing weighted and unweighted histograms. Function: Returns p-value. Other return values are specified by the 3rd parameter <br>. Parameters:. - h2: the second histogram; - option:; o ""UU"" = experiment experiment comparison (unweighted-unweighted); o ""UW"" = experiment MC comparison (unweighted-weighted). Note that; the first histogram should be unweighted; o ""WW"" = MC MC comparison (weighted-weighted); o ""NORM"" = to be used when one or both of the histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Co",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:45808,Testability,test,test,45808," Option_t* option = ""UU"", Double_t* res = 0) const; test for comparing weighted and unweighted histograms. Function: Returns p-value. Other return values are specified by the 3rd parameter <br>. Parameters:. - h2: the second histogram; - option:; o ""UU"" = experiment experiment comparison (unweighted-unweighted); o ""UW"" = experiment MC comparison (unweighted-weighted). Note that; the first histogram should be unweighted; o ""WW"" = MC MC comparison (weighted-weighted); o ""NORM"" = to be used when one or both of the histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006. Introduction:. A frequently used technique in data analysis is the comparison of; histograms. First suggested by Pearson [1] the test of; homogeneity is used widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analys",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:46189,Testability,test,test,46189,"son (unweighted-weighted). Note that; the first histogram should be unweighted; o ""WW"" = MC MC comparison (weighted-weighted); o ""NORM"" = to be used when one or both of the histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006. Introduction:. A frequently used technique in data analysis is the comparison of; histograms. First suggested by Pearson [1] the test of; homogeneity is used widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximat",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:46320,Testability,test,tests,46320,"e histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006. Introduction:. A frequently used technique in data analysis is the comparison of; histograms. First suggested by Pearson [1] the test of; homogeneity is used widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. No",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:46440,Testability,test,test,46440,"e histograms is scaled; but the histogram originally was unweighted; o by default underflows and overlows are not included:; * ""OF"" = overflows included; * ""UF"" = underflows included; o ""P"" = print chi2, ndf, p_value, igood; o ""CHI2"" = returns chi2 instead of p-value; o ""CHI2/NDF"" = returns ; - res: not empty - computes normalized residuals and returns them in; this array. The current implementation is based on the papers test for comparison; of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006. Introduction:. A frequently used technique in data analysis is the comparison of; histograms. First suggested by Pearson [1] the test of; homogeneity is used widely for comparing usual (unweighted) histograms.; This paper describes the implementation modified tests; for comparison of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. No",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:47330,Testability,test,test,47330,"on of weighted and unweighted histograms and two weighted; histograms [2] as well as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If th",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:47452,Testability,test,test,47452,"ll as usual Pearson's test for; comparison two usual (unweighted) histograms. Overview:. Comparison of two histograms expect hypotheses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator o",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:47482,Testability,test,test,47482,"ses that two histograms; represent identical distributions. To make a decision p-value should; be calculated. The hypotheses of identity is rejected if the p-value is; lower then some significance level. Traditionally significance levels; 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; analysis of the residuals which is often helpful in identifying the; bins of histograms responsible for a significant overall value.; Residuals are the difference between bin contents and expected bin; contents. Most convenient for analysis are the normalized residuals. If; hypotheses of identity are valid then normalized residuals are; approximately independent and identically distributed random variables; having N(0,1) distribution. Analysis of residuals expect test of above; mentioned properties of residuals. Notice that indirectly the analysis; of residuals increase the power of test. Methods of comparison:. test for comparison two (unweighted) histograms:; Let us consider two histograms with the same binning and the number; of bins equal to r. Let us denote the number of events in the ith bin; in the first histogram as ni and as mi in the second one. The total; number of events in the first histogram is equal to:. and. in the second histogram. The hypothesis of identity (homogeneity) [3]; is that the two histograms represent random values with identical; distributions. It is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator of pi, i=1,...,r, is. and then. has approximately a distribution [3].; The comparison procedure can include an analysis of the residua",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:48922,Testability,test,test,48922,"t is equivalent that there exist r constants p1,...,pr,; such that. and the probability of belonging to the ith bin for some measured value; in both experiments is equal to pi. The number of events in the ith; bin is a random variable with a distribution approximated by a Poisson; probability distribution. for the first histogram and with distribution. for the second histogram. If the hypothesis of homogeneity is valid,; then the maximum likelihood estimator of pi, i=1,...,r, is. and then. has approximately a distribution [3].; The comparison procedure can include an analysis of the residuals which; is often helpful in identifying the bins of histograms responsible for; a significant overall value. Most convenient for; analysis are the adjusted (normalized) residuals [4]. If hypotheses of homogeneity are valid then residuals ri are; approximately independent and identically distributed random variables; having N(0,1) distribution. The application of the test has; restrictions related to the value of the expected frequencies Npi,; Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; expectations must be 1 or greater for both histograms. In practical; cases when expected frequencies are not known the estimated expected; frequencies can be used. Unweighted and weighted histograms comparison:. A simple modification of the ideas described above can be used for the; comparison of the usual (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distrib",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:50272,Testability,test,test,50272," comparison:. A simple modification of the ideas described above can be used for the; comparison of the usual (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as well; as the original one [3], has a restriction on the expected frequencies. The; expected frequencies recommended for the weighted histogram is more than 25.; The value of the minimal expected frequency can be decreased down to 10 for; the case when the weights of the events are close to constant. In the case; of a weighted histogram if the number of events is unknown, then we can; apply this recommendation for the equivalent number of events as. The minimal expected frequency for an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that have constant weights equal to 1.; The variance of the difference between the weight wi; and the estimated expectation value of the weight is approximately equal to:. The residuals. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:50338,Testability,test,test,50338," (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as well; as the original one [3], has a restriction on the expected frequencies. The; expected frequencies recommended for the weighted histogram is more than 25.; The value of the minimal expected frequency can be decreased down to 10 for; the case when the weights of the events are close to constant. In the case; of a weighted histogram if the number of events is unknown, then we can; apply this recommendation for the equivalent number of events as. The minimal expected frequency for an unweighted histogram must be 1. Notice; that any usual (unweighted) histogram can be considered as a weighted; histogram with events that have constant weights equal to 1.; The variance of the difference between the weight wi; and the estimated expectation value of the weight is approximately equal to:. The residuals. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted histograms comparison:. Let us denote the common weight of events of the ith bin in the first; histogram as w",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:52156,Testability,test,test,52156,"als. have approximately a normal distribution with mean equal to 0 and standard; deviation equal to 1. Two weighted histograms comparison:. Let us denote the common weight of events of the ith bin in the first; histogram as w1i and as w2i in the second one. The total weight of events; in the first histogram is equal to. and. in the second histogram. Let us formulate the hypothesis of identity of; weighted histograms so that there exist r constants p1,...,pr, such that. and also expectation value of weight w1i equal to W1pi and expectation value; of weight w2i equal to W2pi. Weights in both the histograms are random; variables with distributions which can be approximated by a normal; probability distribution for the first histogram; and by a distribution for the second.; Here and are the variances; of w1i and w2i with estimators and respectively.; If the hypothesis of identity is valid, then the maximum likelihood and; Least Square Method estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2].; The normalized or studentised residuals [6]. have approximately a normal distribution with mean equal to 0 and standard; deviation 1. A recommended minimal expected frequency is equal to 10 for; the proposed test. Numerical examples:. The method described herein is now illustrated with an example.; We take a distribution. defined on the interval [4,16]. Events distributed according to the formula; (1) are simulated to create the unweighted histogram. Uniformly distributed; events are simulated for the weighted histogram with weights calculated by; formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; the result of comparison of the unweighted histogram with 200 events; (minimal expected frequency equal to one) and the weighted histogram with; 500 events (minimal expected frequency equal to 25). Fig 1. An example of comparison of the unweighted histogram with 200 events; and the weighted histogram with ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:52426,Testability,test,test,52426," in the second one. The total weight of events; in the first histogram is equal to. and. in the second histogram. Let us formulate the hypothesis of identity of; weighted histograms so that there exist r constants p1,...,pr, such that. and also expectation value of weight w1i equal to W1pi and expectation value; of weight w2i equal to W2pi. Weights in both the histograms are random; variables with distributions which can be approximated by a normal; probability distribution for the first histogram; and by a distribution for the second.; Here and are the variances; of w1i and w2i with estimators and respectively.; If the hypothesis of identity is valid, then the maximum likelihood and; Least Square Method estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2].; The normalized or studentised residuals [6]. have approximately a normal distribution with mean equal to 0 and standard; deviation 1. A recommended minimal expected frequency is equal to 10 for; the proposed test. Numerical examples:. The method described herein is now illustrated with an example.; We take a distribution. defined on the interval [4,16]. Events distributed according to the formula; (1) are simulated to create the unweighted histogram. Uniformly distributed; events are simulated for the weighted histogram with weights calculated by; formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; the result of comparison of the unweighted histogram with 200 events; (minimal expected frequency equal to one) and the weighted histogram with; 500 events (minimal expected frequency equal to 25). Fig 1. An example of comparison of the unweighted histogram with 200 events; and the weighted histogram with 500 events:; a) unweighted histogram;; b) weighted histogram;; c) normalized residuals plot;; d) normal Q-Q plot of residuals. The value of the test statistic is equal to; 21.09 with p-value equal to 0.33, therefore the hypothesis of iden",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:53297,Testability,test,test,53297," with mean equal to 0 and standard; deviation 1. A recommended minimal expected frequency is equal to 10 for; the proposed test. Numerical examples:. The method described herein is now illustrated with an example.; We take a distribution. defined on the interval [4,16]. Events distributed according to the formula; (1) are simulated to create the unweighted histogram. Uniformly distributed; events are simulated for the weighted histogram with weights calculated by; formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; the result of comparison of the unweighted histogram with 200 events; (minimal expected frequency equal to one) and the weighted histogram with; 500 events (minimal expected frequency equal to 25). Fig 1. An example of comparison of the unweighted histogram with 200 events; and the weighted histogram with 500 events:; a) unweighted histogram;; b) weighted histogram;; c) normalized residuals plot;; d) normal Q-Q plot of residuals. The value of the test statistic is equal to; 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of; the two histograms can be accepted for 0.05 significant level. The behavior; of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot; (see Fig. 1d) of residuals are regular and we cannot identify the outliers; or bins with a big influence on . The second example presents the same two histograms but 17 events was added; to content of bin number 15 in unweighted histogram. Fig.2 shows the result; of comparison of the unweighted histogram with 217 events (minimal expected; frequency equal to one) and the weighted histogram with 500 events (minimal; expected frequency equal to 25). Fig 2. An example of comparison of the unweighted histogram with 217 events; and the weighted histogram with 500 events:; a) unweighted histogram;; b) weighted histogram;; c) normalized residuals plot;; d) normal Q-Q plot of residuals. The value of the test statistic is equal to; 32.33 with p-value equa",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:54253,Testability,test,test,54253,"Q plot of residuals. The value of the test statistic is equal to; 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of; the two histograms can be accepted for 0.05 significant level. The behavior; of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot; (see Fig. 1d) of residuals are regular and we cannot identify the outliers; or bins with a big influence on . The second example presents the same two histograms but 17 events was added; to content of bin number 15 in unweighted histogram. Fig.2 shows the result; of comparison of the unweighted histogram with 217 events (minimal expected; frequency equal to one) and the weighted histogram with 500 events (minimal; expected frequency equal to 25). Fig 2. An example of comparison of the unweighted histogram with 217 events; and the weighted histogram with 500 events:; a) unweighted histogram;; b) weighted histogram;; c) normalized residuals plot;; d) normal Q-Q plot of residuals. The value of the test statistic is equal to; 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; the two histograms is rejected for 0.05 significant level. The behavior of; the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; Fig. 2d) of residuals are not regular and we can identify the outlier or; bin with a big influence on . References:. [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:54817,Testability,test,test,54817,"istogram with 217 events (minimal expected; frequency equal to one) and the weighted histogram with 500 events (minimal; expected frequency equal to 25). Fig 2. An example of comparison of the unweighted histogram with 217 events; and the weighted histogram with 500 events:; a) unweighted histogram;; b) weighted histogram;; c) normalized residuals plot;; d) normal Q-Q plot of residuals. The value of the test statistic is equal to; 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; the two histograms is rejected for 0.05 significant level. The behavior of; the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; Fig. 2d) of residuals are not regular and we can identify the outlier or; bin with a big influence on . References:. [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method description,; see Chi2Test() function.; Returns p-value; parameters:; - h2-second hist",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:55429,Testability,test,test,55429,"havior of; the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; Fig. 2d) of residuals are not regular and we can identify the outlier or; bin with a big influence on . References:. [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method description,; see Chi2Test() function.; Returns p-value; parameters:; - h2-second histogram; - option:; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted). ""NORM"" = if one or both histograms is scaled. ""OF"" = overflows included; ""UF"" = underflows included; by default underflows and overlows are not included. - igood:; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram wit",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:55739,Testability,test,test,55739,"ory of Contingency and Its Relation to; Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; Series No. 1, London.; [2] Gagunashvili, N., 2006. test for comparison; of weighted and unweighted histograms. Statistical Problems in Particle; Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; Gagunashvili,N., Comparison of weighted and unweighted histograms,; arXiv:physics/0605123, 2006.; [3] Cramer, H., 1946. Mathematical methods of statistics.; Princeton University Press, Princeton.; [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; Biometrics 29, 205-220.; [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; test in 2xN tables. Biometrics 21, 19-33.; [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; John Wiley & Sons Inc., New York. Double_t Chi2TestX(const TH1* h2, Double_t& chi2, Int_t& ndf, Int_t& igood, Option_t* option = ""UU"", Double_t* res = 0) const; The computation routine of the Chisquare test. For the method description,; see Chi2Test() function.; Returns p-value; parameters:; - h2-second histogram; - option:; ""UU"" = experiment experiment comparison (unweighted-unweighted); ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; histogram should be unweighted; ""WW"" = MC MC comparison (weighted-weighted). ""NORM"" = if one or both histograms is scaled. ""OF"" = overflows included; ""UF"" = underflows included; by default underflows and overlows are not included. - igood:; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'; For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histo",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:57089,Testability,test,test,57089,"d; ""UF"" = underflows included; by default underflows and overlows are not included. - igood:; igood=0 - no problems; For unweighted unweighted comparison; igood=1'There is a bin in the 1st histogram with less than 1 event'; igood=2'There is a bin in the 2nd histogram with less than 1 event'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'; For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'; For weighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 10 effective; number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective; number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. - chi2 - chisquare of the test; - ndf - number of degrees of freedom (important, when both histograms have the same; empty bins); - res - normalized residuals for further analysis. Double_t ComputeIntegral(); Compute integral (cumulative sum of bins); The result stored in fIntegral is used by the GetRandom functions.; This function is automatically called by GetRandom when the fIntegral; array does not exist or when the number of entries in the histogram; has changed since the previous call to GetRandom.; The resulting integral is normalized to 1. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called. void Copy(TObject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObJect::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the sema",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:109063,Testability,test,test,109063," of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2] and its error; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x.; the error is computed using error propagation from the bin errors assumming that; all the bins are uncorrelated. Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t& err, Option_t* opt, Bool_t doerr = kFALSE) const; internal function compute integral and optionally the error between the limits; specified by the bin number values working for all histograms (1D, 2D and 3D). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test. Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this op",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:109143,Testability,test,test,109143," of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2] and its error; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x.; the error is computed using error propagation from the bin errors assumming that; all the bins are uncorrelated. Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t& err, Option_t* opt, Bool_t doerr = kFALSE) const; internal function compute integral and optionally the error between the limits; specified by the bin number values working for all histograms (1D, 2D and 3D). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test. Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this op",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:109280,Testability,test,test,109280,"idth"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x.; the error is computed using error propagation from the bin errors assumming that; all the bins are uncorrelated. Double_t DoIntegral(Int_t ix1, Int_t ix2, Int_t iy1, Int_t iy2, Int_t iz1, Int_t iz2, Double_t& err, Option_t* opt, Bool_t doerr = kFALSE) const; internal function compute integral and optionally the error between the limits; specified by the bin number values working for all histograms (1D, 2D and 3D). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test. Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110140,Testability,test,test,110140,"orov test. Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test (also for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PR",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110294,Testability,test,test,110294,"so for 2-dim); ""O"" include Overflows (also valid for 2-dim); ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:110448,Testability,test,test,110448,"ov distance instead of prob; ""X"" Run the pseudo experiments post-processor with the following procedure:; make pseudoexperiments based on random values from the parent; distribution and compare the KS distance of the pseudoexperiment; to the parent distribution. Bin the KS distances in a histogram,; and then take the integral of all the KS values above the value; obtained from the original data to Monte Carlo distribution.; The number of pseudo-experiments nEXPT is currently fixed at 1000.; The function returns the integral.; (thanks to Ben Kilminster to submit this procedure). Note that; this option ""X"" is much slower. The returned function value is the probability of test; (much less than one means NOT compatible). Code adapted by Rene Brun from original HBOOK routine HDIFF. NOTE1; A good description of the Kolmogorov test can be seen at:; http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm. NOTE2; see also alternative function TH1::Chi2Test; The Kolmogorov test is assumed to give better results than Chi2Test; in case of histograms with low statistics. NOTE3 (Jan Conrad, Fred James); ""The returned value PROB is calculated such that it will be; uniformly distributed between zero and one for compatible histograms,; provided the data are not binned (or the number of bins is very large; compared with the number of events). Users who have access to unbinned; data and wish exact confidence levels should therefore not put their data; into histograms, but should call directly TMath::KolmogorovTest. On; the other hand, since TH1 is a convenient way of collecting data and; saving space, this function has been provided. However, the values of; PROB for binned data will be shifted slightly higher than expected,; depending on the effects of the binning. For example, when comparing two; uniform distributions of 500 events in 100 bins, the values of PROB,; instead of being exactly uniformly distributed between zero and one, have; a mean value of about 0.56. We can ap",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:112876,Testability,log,log,112876," to have exactly the correct; distribution for binned data.; 2. The user is responsible for seeing to it that the bin widths are; small compared with any physical phenomena of interest.; 3. The effect of binning (if any) is always to make the value of PROB; slightly too big. That is, setting an acceptance criterion of (PROB>0.05; will assure that at most 5% of truly compatible histograms are rejected,; and usually somewhat less."". void SetContent(const Double_t* content); -*-*-*-*-*-*Replace bin contents by the contents of array content*-*-*-*. Int_t GetContour(Double_t* levels = 0); Return contour values into array levels if pointer levels is non zero. The function returns the number of contour levels.; see GetContourLevel to return one contour only. Double_t GetContourLevel(Int_t level) const; Return value of contour number level; see GetContour to return the array of all contour levels. Double_t GetContourLevelPad(Int_t level) const; Return the value of contour number ""level"" in Pad coordinates ie: if the Pad; is in log scale along Z it returns le log of the contour level value.; see GetContour to return the array of all contour levels. void SetBuffer(Int_t buffersize, Option_t* option = """"); set the maximum number of entries to be kept in the buffer. void SetContour(Int_t nlevels, const Double_t* levels = 0); Set the number and values of contour levels. By default the number of contour levels is set to 20. The contours values; in the array ""levels"" should be specify un increasing order. if argument levels = 0 or missing, equidistant contours are computed. void SetContourLevel(Int_t level, Double_t value); Set value for one contour level. Double_t GetMaximum(Double_t maxval = FLT_MAX) const; Return maximum value smaller than maxval of bins in the range,; unless the value has been overridden by TH1::SetMaximum,; in which case it returns that value. (This happens, for example,; when the histogram is drawn and the y or z axis limits are changed. To get the maximum v",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:112908,Testability,log,log,112908," to have exactly the correct; distribution for binned data.; 2. The user is responsible for seeing to it that the bin widths are; small compared with any physical phenomena of interest.; 3. The effect of binning (if any) is always to make the value of PROB; slightly too big. That is, setting an acceptance criterion of (PROB>0.05; will assure that at most 5% of truly compatible histograms are rejected,; and usually somewhat less."". void SetContent(const Double_t* content); -*-*-*-*-*-*Replace bin contents by the contents of array content*-*-*-*. Int_t GetContour(Double_t* levels = 0); Return contour values into array levels if pointer levels is non zero. The function returns the number of contour levels.; see GetContourLevel to return one contour only. Double_t GetContourLevel(Int_t level) const; Return value of contour number level; see GetContour to return the array of all contour levels. Double_t GetContourLevelPad(Int_t level) const; Return the value of contour number ""level"" in Pad coordinates ie: if the Pad; is in log scale along Z it returns le log of the contour level value.; see GetContour to return the array of all contour levels. void SetBuffer(Int_t buffersize, Option_t* option = """"); set the maximum number of entries to be kept in the buffer. void SetContour(Int_t nlevels, const Double_t* levels = 0); Set the number and values of contour levels. By default the number of contour levels is set to 20. The contours values; in the array ""levels"" should be specify un increasing order. if argument levels = 0 or missing, equidistant contours are computed. void SetContourLevel(Int_t level, Double_t value); Set value for one contour level. Double_t GetMaximum(Double_t maxval = FLT_MAX) const; Return maximum value smaller than maxval of bins in the range,; unless the value has been overridden by TH1::SetMaximum,; in which case it returns that value. (This happens, for example,; when the histogram is drawn and the y or z axis limits are changed. To get the maximum v",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:13452,Usability,usab,usable,13452,"r another; TH1 histogram (for all dimensions).; For example the following two statements create and fill an histogram; 10000 times with a default gaussian distribution of mean 0 and sigma 1:. TH1F h1(""h1"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);. TH1::GetRandom can be used to return a random number distributed; according the contents of an histogram.; Making a copy of an histogram; Like for any other ROOT object derived from TObject, one can use; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:. TH1F *hnew = (TH1F*)h->Clone(""hnew"");. Normalizing histograms; One can scale an histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram.; Drawing histograms; Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use. h->DrawCopy();. This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; fun",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:49285,Usability,simpl,simple,49285,"sis of homogeneity is valid,; then the maximum likelihood estimator of pi, i=1,...,r, is. and then. has approximately a distribution [3].; The comparison procedure can include an analysis of the residuals which; is often helpful in identifying the bins of histograms responsible for; a significant overall value. Most convenient for; analysis are the adjusted (normalized) residuals [4]. If hypotheses of homogeneity are valid then residuals ri are; approximately independent and identically distributed random variables; having N(0,1) distribution. The application of the test has; restrictions related to the value of the expected frequencies Npi,; Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; expectations must be 1 or greater for both histograms. In practical; cases when expected frequencies are not known the estimated expected; frequencies can be used. Unweighted and weighted histograms comparison:. A simple modification of the ideas described above can be used for the; comparison of the usual (unweighted) and weighted histograms. Let us; denote the number of events in the ith bin in the unweighted; histogram as ni and the common weight of events in the ith bin of the; weighted histogram as wi. The total number of events in the; unweighted histogram is equal to. and the total weight of events in the weighted histogram is equal to. Let us formulate the hypothesis of identity of an unweighted histogram; to a weighted histogram so that there exist r constants p1,...,pr, such; that. for the unweighted histogram. The weight wi is a random variable with a; distribution approximated by the normal probability distribution; where is the variance of the weight wi.; If we replace the variance ; with estimate (sum of squares of weights of; events in the ith bin) and the hypothesis of identity is valid, then the; maximum likelihood estimator of pi,i=1,...,r, is. We may then use the test statistic. and it has approximately a distribution [2]. This test, as we",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:58540,Usability,simpl,simple,58540,"andom.; The resulting integral is normalized to 1. Double_t * GetIntegral(); Return a pointer to the array of bins integral.; if the pointer fIntegral is null, TH1::ComputeIntegral is called. void Copy(TObject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObJect::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:61102,Usability,usab,usable,61102," not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This functi",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:61805,Usability,clear,clears,61805,"vide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See THistPainter::Paint for a description of all the drawing options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawCopy(Option_t* option = """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:63477,Usability,clear,cleared,63477,"= """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawNormalized(Option_t* option = """", Double_t norm = 1) const; Draw a normalized copy of this histogram. A clone of this histogram is normalized to norm and drawn with option.; A pointer to the normalized histogram is returned.; The contents of the histogram copy are scaled such that the new; sum of weights (excluding under and overflow) is equal to norm.; Note that the returned normalized histogram is not added to the list; of histograms in the current directory in memory.; It is the user's responsability to delete this histogram.; The kCanDelete bit is set for the returned object. If a pad containing; this copy is cleared, the histogram will be automatically deleted.; See also remark about calling Sumw2 before scaling a histogram to get; a correct computation of the error bars. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void DrawPanel(); -*-*-*-*-*Display a panel with all histogram drawing options*-*-*-*-*-*. See class TDrawPanelHist for example. void Eval(TF1* f1, Option_t* option = """"); -*-*-*Evaluate function f1 at the center of bins of this histogram-*-*-*-*. If option ""R"" is specified, the function is evaluated only; for the bins included in the function range.; If option ""A"" is specified, the value of the function is added to the; existing bin contents; If option ""S"" is specified, the value of the function is used to; generate a value, distributed according to the Poisson; distribution, with f1 as the mean. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void ExecuteEvent(Int_t event, Int_t px, Int_t py); -*-",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:70323,Usability,simpl,simply,70323,"malized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. One can also call TF1::GetRandom to get a random variate from a function. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*-*-*Fill histogram following distribution in histogram h*-*-*-*. The distribution contained in the histogram h (TH1) is integrated; over the channel contents for the bin range of this histogram.; It is normalized to 1.; Getting one random number implies:; - Generating a random number between 0 and 1 (say r1); - Look in which bin in the normalized integral r1 corresponds to; - Fill histogram channel; ntimes random numbers are generated. SPECIAL CASE when the target histogram has the same binning as the source.; in this case we simply use a poisson distribution where; the mean value per bin = bincontent/integral. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-**-*-*-*-*-*-*-*. Int_t FindBin(Double_t x, Double_t y = 0, Double_t z = 0); Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function tries to rebin the axis if the given point; belongs to an under-/overflow bin.; This has the advantage that all existing functions, such as; GetBinContent, GetBinError, GetBinFunction work for all dimensions.; See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin; -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Int_t FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; Return Global bin number corresponding to x,y,z. 2-D and 3-D histograms are represented with a one dimensional; structure. This function DOES not try to rebin the axis if the given; point belongs to an under-/overflow bin.; This has the advantage that all existing fun",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:81765,Usability,undo,undo,81765,"lt and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the case of Fumili, for the status returned see TFumili::Minimize. Excluding points. Use TF1::RejectPoint inside your fitting function to exclude points; within a certain range from the fit. Example:; Double_t fline(Double_t *x, Double_t *par); {; if (x[0] > 2.5 && x[0] < 3.5) {; TF1::RejectPoint();; return 0;; }; return par[0] + par[1]*x[0];; }. void exclude() {; TF1 *f1 = new TF1(""f1"", ""[0] +[1]*x +gaus(2)"", 0, 5);; f1->SetParameters(6, -1,5, 3, 0.2);; TH1F *h = new TH1F(""h"", ""background + signal"", 100, 0, 5);; h->FillRandom(""f1"", 2000);; TF1 *fline = new TF1(""fline"", fline, 0, 5, 2);; fline->SetParameters(2, -1);; h->Fit(""fline"", ""l"");; }. Warning when using the option ""0"". When selecting the option ""0"", the fitted function is added to; the list of functions of the histogram, but it is not drawn.; You can undo what you disabled in the following way:; h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; h.Draw(); function is not drawn; const Int_t kNotDraw = 1<<9;; h.GetFunction(""myFunction"")->ResetBit(kNotDraw);; h.Draw(); // function is visible again. Access to the Minimizer information during fitting. This function calls, the ROOT::Fit::FitObject function implemented in HFitImpl.cxx; which uses the ROOT::Fit::Fitter class. The Fitter class creates the objective fuction; (e.g. chi2 or likelihood) and uses an implementation of the Minimizer interface for minimizing; the function.; The default minimizer is Minuit (class TMinuitMinimizer which calls TMinuit).; The default can be set in the resource file in etc/system.rootrc. For example; Root.Fitter: Minuit2; A different fitter can also be set via ROOT::Math::MinimizerOptions::SetDefaultMinimizer; (or TVirtualFitter::SetDefaultFitter).; For example ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");; will set the usdage of ",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1.html:106572,Usability,simpl,simply,106572,"he histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void ResetStats(); Reset the statistics including the number of entries; and replace with values calculates from bin content; The number of entries is set to the total bin content or (in case of weighted histogram); to number of effective entries. Double_t GetSumOfWeights() const; -*-*-*-*-*-*Return the sum of weights excluding under/overflows*-*-*-",MatchSource.WIKI,root/html530/TH1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1.html
https://root.cern/root/html530/TH1C.html:3012,Availability,error,error,3012,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t",MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:3096,Availability,error,error,3096,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis",MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:13999,Availability,error,error,13999,,MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:14069,Availability,error,error,14069,,MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:14151,Availability,error,error,14151,,MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:15631,Availability,error,error,15631,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:22844,Modifiability,variab,variable,22844,"::fTsumw2Total Sum of squares of weights; Double_tTH1::fTsumwxTotal Sum of weight*X; Double_tTH1::fTsumwx2Total Sum of weight*X*X; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1C(); Constructor. TH1C(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type char (one byte per channel). (see TH1::TH1 for explanation of parameters). TH1C(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type char (one byte per channel). (see TH1::TH1 for explanation of parameters). TH1C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type char (one byte per channel). (see TH1::TH1 for explanation of parameters). ~TH1C(); Destructor. TH1C(const TH1C& h1c); Copy constructor. void AddBinContent(Int_t bin); -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*. void AddBinContent(Int_t bin, Double_t w); -*-*-*-*-*-*-*-*Increment bin content by w*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the tim",MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1C.html:23051,Modifiability,variab,variable,23051,"H1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1C(); Constructor. TH1C(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type char (one byte per channel). (see TH1::TH1 for explanation of parameters). TH1C(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type char (one byte per channel). (see TH1::TH1 for explanation of parameters). TH1C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type char (one byte per channel). (see TH1::TH1 for explanation of parameters). ~TH1C(); Destructor. TH1C(const TH1C& h1c); Copy constructor. void AddBinContent(Int_t bin); -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*. void AddBinContent(Int_t bin, Double_t w); -*-*-*-*-*-*-*-*Increment bin content by w*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow",MatchSource.WIKI,root/html530/TH1C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1C.html
https://root.cern/root/html530/TH1D.html:3047,Availability,error,error,3047,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t",MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:3131,Availability,error,error,3131,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis",MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:14044,Availability,error,error,14044,,MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:14114,Availability,error,error,14114,,MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:14196,Availability,error,error,14196,,MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:15676,Availability,error,error,15676,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:22872,Modifiability,variab,variable,22872,"tal Sum of weights; Double_tTH1::fTsumw2Total Sum of squares of weights; Double_tTH1::fTsumwxTotal Sum of weight*X; Double_tTH1::fTsumwx2Total Sum of weight*X*X; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1D(); Constructor. TH1D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type double. (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type double. (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type double. (see TH1::TH1 for explanation of parameters). TH1D(const TVectorD& v); Create a histogram from a TVectorD; by default the histogram name is ""TVectorD"" and title = """". ~TH1D(); Destructor. TH1D(const TH1D& h1d); Constructor. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void Se",MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1D.html:23058,Modifiability,variab,variable,23058,"escriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1D(); Constructor. TH1D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type double. (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type double. (see TH1::TH1 for explanation of parameters). TH1D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type double. (see TH1::TH1 for explanation of parameters). TH1D(const TVectorD& v); Create a histogram from a TVectorD; by default the histogram name is ""TVectorD"" and title = """". ~TH1D(); Destructor. TH1D(const TH1D& h1d); Constructor. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH1D& operator=(const TH1D& h1); Operator =. void AddBinContent(Int_t bin). v",MatchSource.WIKI,root/html530/TH1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1D.html
https://root.cern/root/html530/TH1Editor.html:1072,Availability,error,error,1072,". TH1Editor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter:",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:1105,Availability,error,errors,1105,". TH1Editor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter:",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:1320,Availability,error,errors,1320,"ED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizont",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:2489,Availability,avail,available,2489," drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizontal Bar': draw a horizontal bar chart. 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made vi",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:8997,Availability,error,error,8997,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:9081,Availability,error,error,9081,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:24422,Availability,mask,mask,24422," which shows the rebinned bin number for ntuple histogram; TGHSlider*fBinOffsetSldAdd an offset to the origin of the histogram; TGHSlider*fBinSliderSlider to set rebinning integer value; TGHSlider*fBinSlider1Slider to set rebinning integer value for ntuple histogram; Int_tTGFrame::fBorderWidthframe border width; TGTextButton*fCancelCancel-Button to reprobate the rebinned histogram; TGClient*TGObject::fClientConnection to display server; TGComboBox*fCoordsComboCoordinate System combo box; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDelaydrawDelayed drawing of the new axis range; TGRadioButton*fDim2D-Plot RadioButton; TGRadioButton*fDim03D-Plot RadioButton; TGLayoutHints*fDim0lhlayout hints for 3D-Plot RadioButton; TGHButtonGroup*fDimGroupRadiobuttongroup to change 2D <-> 3D-Plot; TGLayoutHints*fDimlhlayout hints for 2D-Plot RadioButton; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGComboBox*fErrorComboError combo box; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; TH1*fHisthistogram object; TGCheckButton*fHistOnOffDraw a simple histogram with default options; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fMakeHBarDraw Horizontal Bar Chart; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:28828,Availability,error,errors,28828,"old; Int_tfPx2old; Int_tfPy1old; Int_tfPy2old. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of histogram attribute GUI. void CreateBinTab(); Create binning tab. ~TH1Editor(); Destructor of TH1 editor. void ConnectSignals2Slots(); Connect signals to slots. Bool_t AcceptModel(TObject* model); Check if object is able to configure with this editor. void SetModel(TObject* obj); Pick up current values of histogram attributes. void DoTitle(const char* text); Slot connected to the histogram title setting. void DoAddMarker(Bool_t on); Slot connected to the show markers check box. void DoAddB(Bool_t ); Slot connected to the bar Add check box. void DoAddBar(Bool_t ); Slot connected to the bar Add check box. void DoAddSimple(Bool_t on); Slot connected to fAddSimple check box for drawing a simple histogram; without errors (== HIST draw option) in combination with some other; draw options. It draws an additional line on the top of the bins. void DoHistView(); Slot connected to the 'Plot' button group. void DoHistSimple(); Slot connected to the 2D radio button. void DoHistComplex(); Slot connected to the 3D radio button. void DoHistChanges(); Slot connected to the histogram type, the coordinate type, the error type; and the Add combo box. void DoBarWidth(); Slot connected to the Bar Width of the Bar Charts. void DoBarOffset(); Slot connected to the Bar Offset of the Bar Charts. void DoPercent(); Slot connected to the bar percentage settings. void DoHBar(Bool_t on); Slot connected to the Horizontal Bar check button. void DoSliderMoved(); Slot connected to the x-Slider for redrawing of the histogram; according to the new Slider range. void DoSliderPressed(); Slot connected to the x-axis Range slider for initialising the; values of the slider movement. void DoSliderReleased(); Slot co",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:29223,Availability,error,error,29223,"or of TH1 editor. void ConnectSignals2Slots(); Connect signals to slots. Bool_t AcceptModel(TObject* model); Check if object is able to configure with this editor. void SetModel(TObject* obj); Pick up current values of histogram attributes. void DoTitle(const char* text); Slot connected to the histogram title setting. void DoAddMarker(Bool_t on); Slot connected to the show markers check box. void DoAddB(Bool_t ); Slot connected to the bar Add check box. void DoAddBar(Bool_t ); Slot connected to the bar Add check box. void DoAddSimple(Bool_t on); Slot connected to fAddSimple check box for drawing a simple histogram; without errors (== HIST draw option) in combination with some other; draw options. It draws an additional line on the top of the bins. void DoHistView(); Slot connected to the 'Plot' button group. void DoHistSimple(); Slot connected to the 2D radio button. void DoHistComplex(); Slot connected to the 3D radio button. void DoHistChanges(); Slot connected to the histogram type, the coordinate type, the error type; and the Add combo box. void DoBarWidth(); Slot connected to the Bar Width of the Bar Charts. void DoBarOffset(); Slot connected to the Bar Offset of the Bar Charts. void DoPercent(); Slot connected to the bar percentage settings. void DoHBar(Bool_t on); Slot connected to the Horizontal Bar check button. void DoSliderMoved(); Slot connected to the x-Slider for redrawing of the histogram; according to the new Slider range. void DoSliderPressed(); Slot connected to the x-axis Range slider for initialising the; values of the slider movement. void DoSliderReleased(); Slot connected to the x-axis Range slider for finalizing the; values of the slider movement. void DoAxisRange(); Slot connected to the number entry fields containing the Max/Min; value of the x-axis. void DoBinReleased(); Slot connected to the rebin slider in case of a not ntuple histogram; Updates some other widgets which are related to the rebin slider. void DoBinMoved(Int_t number); Slot",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:31886,Availability,error,error,31886,"nnected to the OffSetSlider that saves the OldBinOffset; (nessesary for delay draw mode). void DoOffsetReleased(); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new Offset given by the Slider. void DoOffsetMoved(Int_t num); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new offset given by the Slider. void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry.  Author: Carsten Hof 16/08/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last c",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:32260,Availability,error,error,32260,"iven by the Slider. void DoOffsetMoved(Int_t num); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new offset given by the Slider. void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry.  Author: Carsten Hof 16/08/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/ged:$Id: TH1Editor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:32518,Availability,error,error,32518,"iven by the Slider. void DoOffsetMoved(Int_t num); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new offset given by the Slider. void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry.  Author: Carsten Hof 16/08/04  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/ged:$Id: TH1Editor.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:3833,Deployability,update,updated,3833," the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. /*. */. /*. */. Function Members (Methods); public:. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH1Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); vir",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:3861,Deployability,release,released,3861," the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. /*. */. /*. */. Function Members (Methods); public:. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH1Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); vir",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:30616,Deployability,update,updates,30616,w Slider range. void DoSliderPressed(); Slot connected to the x-axis Range slider for initialising the; values of the slider movement. void DoSliderReleased(); Slot connected to the x-axis Range slider for finalizing the; values of the slider movement. void DoAxisRange(); Slot connected to the number entry fields containing the Max/Min; value of the x-axis. void DoBinReleased(); Slot connected to the rebin slider in case of a not ntuple histogram; Updates some other widgets which are related to the rebin slider. void DoBinMoved(Int_t number); Slot connected to the rebin slider in case of a not ntuple histogram; (does the Rebinning of the histogram). void DoBinPressed(); Slot connected to the rebin slider in case of a not ntuple histogram. void DoBinReleased1(); Slot connected to the BinNumber Slider in case of a ntuple histogram; (does the Rebinning of the histogram). void DoBinMoved1(); Slot connected to the rebin slider in case of an ntuple histogram.; It updates the BinNumberEntryField during the BinSlider movement. void DoBinLabel(); Slot connected to the Bin number entry of the Rebinning tab. void DoBinLabel1(); Slot connected to the Bin number entry of the Rebinning tab. void DoOffsetPressed(); Slot connected to the OffSetSlider that saves the OldBinOffset; (nessesary for delay draw mode). void DoOffsetReleased(); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new Offset given by the Slider. void DoOffsetMoved(Int_t num); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth and; rebin the histogram with the new offset given by the Slider. void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TS,MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:3287,Energy Efficiency,reduce,reduced,3287,"tes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the slider the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. /*. */. /*. */. Function Members (Methods); public:. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH1Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t);",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:463,Integrability,interface,interface,463,". TH1Editor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter:",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:28333,Modifiability,config,configure,28333,"serColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TH1*fBinHistCloned histogram for rebin; Bool_tfMakeVeto Variable; Bool_tfMakeBavoid execution of Bar Slots; Double_tfOldOffsetsave the old offset of the histogram; Float_tfP1NDCold[3]; Float_tfP1old[3]; Float_tfP2NDCold[3]; Float_tfP2old[3]; Float_tfP3NDCold[3]; Float_tfP3old[3]; Float_tfP4NDCold[3]; Float_tfP4old[3]; Float_tfP5old[3]; Float_tfP6old[3]; Float_tfP7old[3]; Float_tfP8old[3]; Int_tfPx1old; Int_tfPx2old; Int_tfPy1old; Int_tfPy2old. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of histogram attribute GUI. void CreateBinTab(); Create binning tab. ~TH1Editor(); Destructor of TH1 editor. void ConnectSignals2Slots(); Connect signals to slots. Bool_t AcceptModel(TObject* model); Check if object is able to configure with this editor. void SetModel(TObject* obj); Pick up current values of histogram attributes. void DoTitle(const char* text); Slot connected to the histogram title setting. void DoAddMarker(Bool_t on); Slot connected to the show markers check box. void DoAddB(Bool_t ); Slot connected to the bar Add check box. void DoAddBar(Bool_t ); Slot connected to the bar Add check box. void DoAddSimple(Bool_t on); Slot connected to fAddSimple check box for drawing a simple histogram; without errors (== HIST draw option) in combination with some other; draw options. It draws an additional line on the top of the bins. void DoHistView(); Slot connected to the 'Plot' button group. void DoHistSimple(); Slot connected to the 2D radio button. void DoHistComplex(); Slot connected to the 3D radio button. void DoHistChanges(); Slot connected to the histogram type, the coordinate type, the error type; and the Add combo box. void DoBarWidth(); Slot connected to the Bar Width of the",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:1113,Usability,simpl,simple,1113,". TH1Editor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter:",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:1228,Usability,simpl,simple,1228,"ED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizont",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:1294,Usability,simpl,simple,1294,"ED;  TH1Editor. class TH1Editor: public TGedFrame. TH1Editor; Editor for changing TH1 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH1Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Error' : ComboBox: add different error bars to the histogram; (no errors, simple, ..., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizont",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:22824,Usability,simpl,simple,22824,,MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:24687,Usability,simpl,simple,24687,"; Int_tTGFrame::fBorderWidthframe border width; TGTextButton*fCancelCancel-Button to reprobate the rebinned histogram; TGClient*TGObject::fClientConnection to display server; TGComboBox*fCoordsComboCoordinate System combo box; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDelaydrawDelayed drawing of the new axis range; TGRadioButton*fDim2D-Plot RadioButton; TGRadioButton*fDim03D-Plot RadioButton; TGLayoutHints*fDim0lhlayout hints for 3D-Plot RadioButton; TGHButtonGroup*fDimGroupRadiobuttongroup to change 2D <-> 3D-Plot; TGLayoutHints*fDimlhlayout hints for 2D-Plot RadioButton; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGComboBox*fErrorComboError combo box; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; TH1*fHisthistogram object; TGCheckButton*fHistOnOffDraw a simple histogram with default options; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fMakeHBarDraw Horizontal Bar Chart; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedra",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1Editor.html:28802,Usability,simpl,simple,28802,"old; Int_tfPx2old; Int_tfPy1old; Int_tfPy2old. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of histogram attribute GUI. void CreateBinTab(); Create binning tab. ~TH1Editor(); Destructor of TH1 editor. void ConnectSignals2Slots(); Connect signals to slots. Bool_t AcceptModel(TObject* model); Check if object is able to configure with this editor. void SetModel(TObject* obj); Pick up current values of histogram attributes. void DoTitle(const char* text); Slot connected to the histogram title setting. void DoAddMarker(Bool_t on); Slot connected to the show markers check box. void DoAddB(Bool_t ); Slot connected to the bar Add check box. void DoAddBar(Bool_t ); Slot connected to the bar Add check box. void DoAddSimple(Bool_t on); Slot connected to fAddSimple check box for drawing a simple histogram; without errors (== HIST draw option) in combination with some other; draw options. It draws an additional line on the top of the bins. void DoHistView(); Slot connected to the 'Plot' button group. void DoHistSimple(); Slot connected to the 2D radio button. void DoHistComplex(); Slot connected to the 3D radio button. void DoHistChanges(); Slot connected to the histogram type, the coordinate type, the error type; and the Add combo box. void DoBarWidth(); Slot connected to the Bar Width of the Bar Charts. void DoBarOffset(); Slot connected to the Bar Offset of the Bar Charts. void DoPercent(); Slot connected to the bar percentage settings. void DoHBar(Bool_t on); Slot connected to the Horizontal Bar check button. void DoSliderMoved(); Slot connected to the x-Slider for redrawing of the histogram; according to the new Slider range. void DoSliderPressed(); Slot connected to the x-axis Range slider for initialising the; values of the slider movement. void DoSliderReleased(); Slot co",MatchSource.WIKI,root/html530/TH1Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1Editor.html
https://root.cern/root/html530/TH1F.html:3042,Availability,error,error,3042,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t",MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:3126,Availability,error,error,3126,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis",MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:14034,Availability,error,error,14034,,MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:14104,Availability,error,error,14104,,MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:14186,Availability,error,error,14186,,MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:15666,Availability,error,error,15666,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:22859,Modifiability,variab,variable,22859,"Total Sum of weights; Double_tTH1::fTsumw2Total Sum of squares of weights; Double_tTH1::fTsumwxTotal Sum of weight*X; Double_tTH1::fTsumwx2Total Sum of weight*X*X; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1F(); Constructor. TH1F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type float. (see TH1::TH1 for explanation of parameters). TH1F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type float. (see TH1::TH1 for explanation of parameters). TH1F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type float. (see TH1::TH1 for explanation of parameters). TH1F(const TVectorF& v); Create a histogram from a TVectorF; by default the histogram name is ""TVectorF"" and title = """". TH1F(const TH1F& h1f); Copy Constructor. ~TH1F(); Destructor. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void",MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1F.html:23044,Modifiability,variab,variable,23044,"s descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1F(); Constructor. TH1F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type float. (see TH1::TH1 for explanation of parameters). TH1F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type float. (see TH1::TH1 for explanation of parameters). TH1F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type float. (see TH1::TH1 for explanation of parameters). TH1F(const TVectorF& v); Create a histogram from a TVectorF; by default the histogram name is ""TVectorF"" and title = """". TH1F(const TH1F& h1f); Copy Constructor. ~TH1F(); Destructor. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH1F& operator=(const TH1F& h1); Operator =. void AddBinContent(Int_t bin",MatchSource.WIKI,root/html530/TH1F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1F.html
https://root.cern/root/html530/TH1I.html:3015,Availability,error,error,3015,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t",MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:3099,Availability,error,error,3099,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis",MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:13997,Availability,error,error,13997,,MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:14067,Availability,error,error,14067,,MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:14149,Availability,error,error,14149,,MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:15629,Availability,error,error,15629,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:22831,Modifiability,variab,variable,22831,"al Sum of weights; Double_tTH1::fTsumw2Total Sum of squares of weights; Double_tTH1::fTsumwxTotal Sum of weight*X; Double_tTH1::fTsumwx2Total Sum of weight*X*X; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1I(); Constructor. TH1I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type integer. (see TH1::TH1 for explanation of parameters). TH1I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type integer. (see TH1::TH1 for explanation of parameters). TH1I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type integer. (see TH1::TH1 for explanation of parameters). ~TH1I(); Destructor. TH1I(const TH1I& h1i); Copy constructor. void AddBinContent(Int_t bin); -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins i",MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1I.html:23018,Modifiability,variab,variable,23018,"criptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1I(); Constructor. TH1I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type integer. (see TH1::TH1 for explanation of parameters). TH1I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type integer. (see TH1::TH1 for explanation of parameters). TH1I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type integer. (see TH1::TH1 for explanation of parameters). ~TH1I(); Destructor. TH1I(const TH1I& h1i); Copy constructor. void AddBinContent(Int_t bin); -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH1I& operator=(cons",MatchSource.WIKI,root/html530/TH1I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1I.html
https://root.cern/root/html530/TH1K.html:3316,Availability,error,error,3316,"tual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t x); virtual Int_tFill(Double_t x, Double_t w); virtual Int_tFill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; ",MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:3400,Availability,error,error,3400," Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t x); virtual Int_tFill(Double_t x, Double_t w); virtual Int_tFill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis = 1) const; vi",MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:14301,Availability,error,error,14301,,MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:14371,Availability,error,error,14371,,MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:14453,Availability,error,error,14453,,MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:15936,Availability,error,error,15936,"ual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidTH1::SetBinsLength(Int_t = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetKOrd(Int_t k); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:23753,Availability,error,error,23753,"g to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1K(); Constructor. TH1K(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t k = 0); Create a 1-Dim histogram with fix bins of type float; (see TH1K::TH1 for explanation of parameters). ~TH1K(); Destructor. Int_t Fill(Double_t x); Increment bin with abscissa X by 1. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. Double_t GetBinContent(Int_t bin) const; Return content of global bin number bin. Double_t GetBinError(Int_t bin) const; Return content of global bin error. void Reset(Option_t* option = """"); Reset. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out; Note the following restrictions in the code generated:; - variable bin size not implemented; - Objects in list of functions not saved (fits); - Contours not saved. void Sort(); Sort. TH1K(). Int_t Fill(Double_t x). Int_t Fill(Double_t x, Double_t w); {return TH1::Fill(x,w);}. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. Double_t GetBinError(Int_t bin) const. Double_t GetBinError(Int_t bin, Int_t ) const; {return GetBinError(bin);}. void SetKOrd(Int_t k); {fKOrd=k;}.  Author: Victor Perevoztchikov 21/02/2001  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH1K.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:32; This page has been automatically generated. For",MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1K.html:23976,Modifiability,variab,variable,23976,"under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1K(); Constructor. TH1K(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t k = 0); Create a 1-Dim histogram with fix bins of type float; (see TH1K::TH1 for explanation of parameters). ~TH1K(); Destructor. Int_t Fill(Double_t x); Increment bin with abscissa X by 1. if x is less than the low-edge of the first bin, the Underflow bin is incremented; if x is greater than the upper edge of last bin, the Overflow bin is incremented. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by 1 in the bin corresponding to x. Double_t GetBinContent(Int_t bin) const; Return content of global bin number bin. Double_t GetBinError(Int_t bin) const; Return content of global bin error. void Reset(Option_t* option = """"); Reset. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out; Note the following restrictions in the code generated:; - variable bin size not implemented; - Objects in list of functions not saved (fits); - Contours not saved. void Sort(); Sort. TH1K(). Int_t Fill(Double_t x). Int_t Fill(Double_t x, Double_t w); {return TH1::Fill(x,w);}. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. Double_t GetBinError(Int_t bin) const. Double_t GetBinError(Int_t bin, Int_t ) const; {return GetBinError(bin);}. void SetKOrd(Int_t k); {fKOrd=k;}.  Author: Victor Perevoztchikov 21/02/2001  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH1K.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH1K.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1K.html
https://root.cern/root/html530/TH1S.html:3018,Availability,error,error,3018,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t",MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:3102,Availability,error,error,3102,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH1::Fill(Double_t x); virtual Int_tTH1::Fill(Double_t x, Double_t w); virtual Int_tTH1::Fill(const char* name, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillN(Int_t, const Double_t*, const Double_t*, const Double_t*, Int_t); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis",MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:14010,Availability,error,error,14010,,MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:14080,Availability,error,error,14080,,MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:14162,Availability,error,error,14162,,MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:15642,Availability,error,error,15642,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:22835,Modifiability,variab,variable,22835,"Total Sum of weights; Double_tTH1::fTsumw2Total Sum of squares of weights; Double_tTH1::fTsumwxTotal Sum of weight*X; Double_tTH1::fTsumwx2Total Sum of weight*X*X; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1S(); Constructor. TH1S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type short. (see TH1::TH1 for explanation of parameters). TH1S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type short. (see TH1::TH1 for explanation of parameters). TH1S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type short. (see TH1::TH1 for explanation of parameters). ~TH1S(); Destructor. TH1S(const TH1S& h1s); Copy constructor. void AddBinContent(Int_t bin); -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is a",MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH1S.html:23020,Modifiability,variab,variable,23020,"s descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH1S(); Constructor. TH1S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup). Create a 1-Dim histogram with fix bins of type short. (see TH1::TH1 for explanation of parameters). TH1S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins). Create a 1-Dim histogram with variable bins of type short. (see TH1::TH1 for explanation of parameters). TH1S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins). Create a 1-Dim histogram with variable bins of type short. (see TH1::TH1 for explanation of parameters). ~TH1S(); Destructor. TH1S(const TH1S& h1s); Copy constructor. void AddBinContent(Int_t bin); -*-*-*-*-*-*-*-*Increment bin content by 1*-*-*-*-*-*-*-*-*-*-*-*-*-*. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w. void Copy(TObject& hnew) const; Copy this to newth1. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; see convention for numbering bins in TH1::GetBin. void Reset(Option_t* option = """"); Reset. void SetBinContent(Int_t bin, Double_t content); Set bin content; see convention for numbering bins in TH1::GetBin; In case the bin number is greater than the number of bins and; the timedisplay option is set or the kCanRebin bit is set,; the number of bins is automatically doubled to accomodate the new bin. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH1S& operator=(const",MatchSource.WIKI,root/html530/TH1S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH1S.html
https://root.cern/root/html530/TH2.html:2874,Availability,error,error,2874,"tual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(Double_t x, const char* namey, Double_t w); virtual Int_tFill(const char* namex, Double_t y, Double_t w); virtual Int_tFill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidFillRandom(const char* fname, Int_t ntimes = 5000); virtual voidFillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_t",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:2958,Availability,error,error,2958," Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(Double_t x, const char* namey, Double_t w); virtual Int_tFill(const char* namex, Double_t y, Double_t w); virtual Int_tFill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidFillRandom(const char* fname, Int_t ntimes = 5000); virtual voidFillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tFindFirstBinA",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:15145,Availability,error,error,15145,,MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:15215,Availability,error,error,15215,,MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:15297,Availability,error,error,15297,,MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:16780,Availability,error,error,16780," Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidTH1::SetBinsLength(Int_t = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:39925,Availability,error,error,39925,"(Option_t* option = """") const; Return integral of bin contents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" inclu",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:39937,Availability,error,error,39937,"(Option_t* option = """") const; Return integral of bin contents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" inclu",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:39969,Availability,error,errors,39969,"(Option_t* option = """") const; Return integral of bin contents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" inclu",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:41778,Availability,error,errors,41778,"e between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together*-*-*-*-. if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygro",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:42859,Availability,error,errors,42859,"; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together*-*-*-*-. if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to me merged into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins; hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; // Carefull: previous contents of hpxpy are lost; hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned histogram; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the corresponding bins are added to; the overflow bin.; Statistics will be recomputed from the new bin contents. TProfile * DoProfile(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const. TProfile * Pro",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:42920,Availability,error,errors,42920,"; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together*-*-*-*-. if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to me merged into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins; hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; // Carefull: previous contents of hpxpy are lost; hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned histogram; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the corresponding bins are added to; the overflow bin.; Statistics will be recomputed from the new bin contents. TProfile * DoProfile(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const. TProfile * Pro",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:44644,Availability,error,error,44644," bin.; Statistics will be recomputed from the new bin contents. TProfile * DoProfile(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const. TProfile * ProfileX(const char* name = ""_pfx"", Int_t firstybin = 1, Int_t lastybin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along X*-*-*-*-*-*; *-* ========================================================. The projection is made from the channels along the Y axis; ranging from firstybin to lastybin included.; By default, bins 1 to ny are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:45498,Availability,error,error,45498,"aget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TProfile * ProfileY(const char* name = ""_pfy"", Int_t firstxbin = 1, Int_t lastxbin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along Y*-*-*-*-*-*; *-* ========================================================. The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, bins 1 to nx are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if opt",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:46680,Availability,error,error,46680,"under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TProfile * ProfileY(const char* name = ""_pfy"", Int_t firstxbin = 1, Int_t lastxbin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along Y*-*-*-*-*-*; *-* ========================================================. The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, bins 1 to nx are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; Using a TCutG object, it is possible to select a sub-range of a 2-D histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProfileY("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that he Y axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:47509,Availability,error,error,47509,"ginal axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; Using a TCutG object, it is possible to select a sub-range of a 2-D histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProfileY("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that he Y axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TH1D * DoProjection(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const; internal (protected) method for performing projection on the X or Y axis; called by ProjectionX or ProjectionY. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the Y axis; ranging from firstybin to lastybin included.; By default, all bins including under- and overflow are included.; The number of en",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:48773,Availability,error,errors,48773,"unt, so here the under- and overflow; bins are ignored by default. TH1D * DoProjection(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const; internal (protected) method for performing projection on the X or Y axis; called by ProjectionX or ProjectionY. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the Y axis; ranging from firstybin to lastybin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in Y, use firstybin=1;; to exclude the underflow bins in Y, use lastybin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL po",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:49736,Availability,error,error,49736,". if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the projection. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in X, use firstxbin=1;; to exclude the underflow bins in X, use lastxbin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget a",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:50597,Availability,error,errors,50597,"ving; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the projection. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in X, use firstxbin=1;; to exclude the underflow bins in X, use lastxbin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL po",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:51560,Availability,error,error,51560,". if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetShowProjectionX(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""sa",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:51855,Availability,error,errors,51855," to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetShowProjectionX(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram.; to be implemented (may be). Int_t ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05); Interface to TSpectrum2::Search; the function finds pe",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:30097,Deployability,integrat,integrated,30097," is incremented; by w^2 in the cell corresponding to x,y. void FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); -*-*-*Fill a 2-D histogram with an array of values and weights; *-* ========================================================; -; *-* ntimes: number of entries in arrays x and w (array size must be ntimes*stride); *-* x: array of x values to be histogrammed; *-* y: array of y values to be histogrammed; *-* w: array of weights; *-* stride: step size through arrays x, y and w; -; *-* If the storage of the sum of squares of weights has been triggered,; *-* via the function Sumw2, then the sum of the squares of weights is incremented; *-* by w[i]^2 in the cell corresponding to x[i],y[i].; *-* if w is NULL each entry is assumed a weight=1; -; *-* NB: function only valid for a TH2x object; -; -. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF2::GetRandom2 to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:30724,Deployability,integrat,integrated,30724,"2, then the sum of the squares of weights is incremented; *-* by w[i]^2 in the cell corresponding to x[i],y[i].; *-* if w is NULL each entry is assumed a weight=1; -; *-* NB: function only valid for a TH2x object; -; -. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF2::GetRandom2 to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *. Int_t FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find first bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. Int_t FindLastBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find last bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. void DoFitSlices(bool onX, TF1* f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t* option, TObjArray* arr). void FitSlicesX(TF1* f1 = 0, Int_t firstybin = 0, Int_t lastybin ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:41517,Energy Efficiency,adapt,adapted,41517,"8. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:30097,Integrability,integrat,integrated,30097," is incremented; by w^2 in the cell corresponding to x,y. void FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); -*-*-*Fill a 2-D histogram with an array of values and weights; *-* ========================================================; -; *-* ntimes: number of entries in arrays x and w (array size must be ntimes*stride); *-* x: array of x values to be histogrammed; *-* y: array of y values to be histogrammed; *-* w: array of weights; *-* stride: step size through arrays x, y and w; -; *-* If the storage of the sum of squares of weights has been triggered,; *-* via the function Sumw2, then the sum of the squares of weights is incremented; *-* by w[i]^2 in the cell corresponding to x[i],y[i].; *-* if w is NULL each entry is assumed a weight=1; -; *-* NB: function only valid for a TH2x object; -; -. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF2::GetRandom2 to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:30724,Integrability,integrat,integrated,30724,"2, then the sum of the squares of weights is incremented; *-* by w[i]^2 in the cell corresponding to x[i],y[i].; *-* if w is NULL each entry is assumed a weight=1; -; *-* NB: function only valid for a TH2x object; -; -. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF2::GetRandom2 to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH2) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *. Int_t FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find first bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. Int_t FindLastBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find last bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. void DoFitSlices(bool onX, TF1* f1, Int_t firstbin, Int_t lastbin, Int_t cut, Option_t* option, TObjArray* arr). void FitSlicesX(TF1* f1 = 0, Int_t firstybin = 0, Int_t lastybin ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:41558,Integrability,rout,routine,41558,"8. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:41517,Modifiability,adapt,adapted,41517,"8. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * RebinX(Int_t ngroup = 2, const char* newname = """"); Rebin only the X axis; see Rebin2D. TH2 * RebinY(Int_t ngroup = 2, const char* newname = """"); Rebin only the Y axis; see Rebin2D. TH2 * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:47969,Performance,perform,performing,47969,"etween [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProfileY("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that he Y axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TH1D * DoProjection(bool onX, const char* name, Int_t firstbin, Int_t lastbin, Option_t* option) const; internal (protected) method for performing projection on the X or Y axis; called by ProjectionX or ProjectionY. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the Y axis; ranging from firstybin to lastybin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in Y, use firstybin=1;; to exclude the underflow bins in Y, use lastybin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but o",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:33786,Security,access,access,33786,"e aSlice goes out of scope. aSlices will; contain the histogram for the i-th parameter of the fit function at aSlices[i];; aSlices[n] (n being the number of parameters) contains the chi2 distribution of; the fits. If arr is NULL, the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 2-d histogram h2; Root > h2->FitSlicesX(); produces 4 TH1D histograms; with h2_0 containing parameter 0(Constant) for a Gaus fit; of each bin in Y projected along X; with h2_1 containing parameter 1(Mean) for a gaus fit; with h2_2 containing parameter 2(RMS) for a gaus fit; with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h2->FitSlicesX(0,15,22,10);; same as above, but only for bins 15 to 22 along Y; and only for bins in Y for which the corresponding projection; along X has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");. void FitSlicesY(TF1* f1 = 0, Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t cut = 0, Option_t* option = ""QNR"", TObjArray* arr = 0); Project slices along Y in case of a 2-D histogram, then fit each slice; with function f1 and make a histogram for each fit parameter; Only bins along X between firstxbin and lastxbin are considered.; By default (firstxbin == 0, lastxbin == -1), all bins in x including; over- and underflows are taken into account.; If f1=0, a gaussian is assumed; Before invoking this function, one can set a subrange to be fitted along Y; via f1->SetRange(ymin,ymax); The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range; ""G2"" merge 2 consecutive bins along Y; ""G3"" merge 3 consecutive bins along Y; ""G4"" merge 4 consecutive bins along Y; ""G5"" merge 5 consecutive bins alo",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:36117,Security,access,access,36117,"e aSlice goes out of scope. aSlices will; contain the histogram for the i-th parameter of the fit function at aSlices[i];; aSlices[n] (n being the number of parameters) contains the chi2 distribution of; the fits. If arr is NULL, the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 2-d histogram h2; Root > h2->FitSlicesY(); produces 4 TH1D histograms; with h2_0 containing parameter 0(Constant) for a Gaus fit; of each bin in X projected along Y; with h2_1 containing parameter 1(Mean) for a gaus fit; with h2_2 containing parameter 2(RMS) for a gaus fit; with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h2->FitSlicesY(0,15,22,10);; same as above, but only for bins 15 to 22 along X; and only for bins in X for which the corresponding projection; along Y has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");. A complete example of this function is given in tutorial:fitslicesy.C. with the following output:. /*; ; */. Double_t GetBinWithContent2(Double_t c, Int_t& binx, Int_t& biny, Int_t firstxbin = 1, Int_t lastxbin = -1, Int_t firstybin = 1, Int_t lastybin = -1, Double_t maxdiff = 0) const; compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny.; In all cases the function returns the smallest difference. NOTE1: if firstxbin < 0, firstxbin is set to 1; if (lastxbin < firstxbin then lastxbin is set to the number of bins in X; ie if firstxbin=1 and lastxbin=0 (default) the search is on all bins in X except; for",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:40702,Testability,test,test,40702,"x1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:40782,Testability,test,test,40782,"x1, Int_t binx2, Int_t biny1, Int_t biny2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; for a 2-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:40920,Testability,test,test,40920,"n errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is ",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:41141,Testability,test,test,41141,"tegral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Interpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:41197,Testability,test,test,41197,"nterpolate(Double_t x); illegal for a TH2. Double_t Interpolate(Double_t x, Double_t y); Given a point P(x,y), Interpolate approximates the value via bilinear; interpolation based on the four nearest bin centers; see Wikipedia, Bilinear Interpolation; Andy Mastbaum 10/8/2008; vaguely based on R.Raja 6-Sep-2008. Double_t Interpolate(Double_t x, Double_t y, Double_t z); illegal for a TH2. Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in 2D the order for generating the pseudo-CDF is; arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; other from the y axis and the maximum distance is the average of the two maximum; distances obtained. Code adapted by Rene Brun from original HBOOK routine HDIFF. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH2 * Reb",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:45207,Testability,log,logical,45207," ranging from firstybin to lastybin included.; By default, bins 1 to ny are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TProfile * ProfileY(const char* name = ""_pfy"", Int_t firstxbin = 1, Int_t lastxbin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along Y*-*-*-*-*-*; *-* ========================================================. The projection is made",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2.html:38385,Usability,simpl,simply,38385,"bins in Y except; for Y's under- and overflow bins.; NOTE2: if maxdiff=0 (default), the first cell with content=c is returned. Double_t GetCorrelationFactor(Int_t axis1 = 1, Int_t axis2 = 2) const; -*-*-*Return correlation factor between axis1 and axis2; *-* ====================================================. Double_t GetCovariance(Int_t axis1 = 1, Int_t axis2 = 2) const; -*-*-*Return covariance between axis1 and axis2; *-* ====================================================. void GetRandom2(Double_t& x, Double_t& y); return 2 random numbers along axis x and y distributed according; the cellcontents of a 2-dim histogram. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy. If no axis-subranges are specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If sub-ranges are specified, the function recomputes these quantities; from the bin contents in the current axis ranges. Note that the mean value/RMS is computed using the bins in the currently; defined ranges (see TAxis::SetRange). By default the ranges include; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. Double_t Integral(Option_t* option = """") const; Return integral of bin contents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x and in y. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Option_t* option = """") const; Return integral",MatchSource.WIKI,root/html530/TH2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2.html
https://root.cern/root/html530/TH2C.html:3354,Availability,error,error,3354,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2:",MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2C.html:3438,Availability,error,error,3438,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Doub",MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2C.html:16210,Availability,error,error,16210,,MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2C.html:16280,Availability,error,error,16280,,MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2C.html:16362,Availability,error,error,16362,,MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2C.html:17842,Availability,error,error,17842,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2C.html:26598,Availability,error,errors,26598,"or. TH2C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2C(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins); Constructor. TH2C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins); Constructor. TH2C(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins); Constructor. TH2C(const TH2C& h2c); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH2C. TH2C& operator=(const TH2C& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t binx, Int_t biny) const; {return GetBinContent(GetBin(binx,biny));}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t binx, Int_t biny, Double_t content); {SetBinContent(GetBin(binx,biny),content);}.  Author: Rene Brun 26/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH2.h 29775 2009-08-13 15:07:28Z moneta $  Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH2C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2C.html
https://root.cern/root/html530/TH2D.html:3394,Availability,error,error,3394,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2:",MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2D.html:3478,Availability,error,error,3478,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Doub",MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2D.html:16260,Availability,error,error,16260,,MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2D.html:16330,Availability,error,error,16330,,MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2D.html:16412,Availability,error,error,16412,,MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2D.html:17892,Availability,error,error,17892,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2D.html:26484,Availability,error,errors,26484,"tructor. ~TH2D(); Destructor. TH2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins); Constructor. TH2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins); Constructor. TH2D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins); Constructor. TH2D(const TMatrixDBase& m); Constructor. TH2D(const TH2D& h2d); Copy constructor. void Copy(TObject& hnew) const; Copy. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH2D. TH2D& operator=(const TH2D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t binx, Int_t biny) const; {return GetBinContent(GetBin(binx,biny));}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t binx, Int_t biny, Double_t content); {SetBinContent(GetBin(binx,biny),content);}.  Author: Rene Brun 26/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH2.h 29775 2009-08-13 15:07:28Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html530/TH2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2D.html
https://root.cern/root/html530/TH2Editor.html:1857,Availability,error,errors,1857,"d Plot:; 'Contour' : ComboBox: draw a contour plot (None, Cont0..4); 'Cont #' : TGNumberEntry: set the number of Contours; 2d Plot checkboxes:; 'Arrow' : arrow mode. Shows gradient between adjacent cells; 'Col' : a box is drawn for each cell with a color scale; varying with contents; 'Text' : Draw bin contents as text; 'Box' : a box is drawn for each cell with surface; proportional to contents; 'Scat' : Draw a scatter-plot (default); 'Palette' : the color palette is drawn. 3d Plot:; 'Type' : ComboBox: set histogram type Lego or Surface-Plot; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Cont #' : TGNumberEntry: set the number of Contours (for e.g.; Lego2 drawoption; 3d Plot checkboxes:; 'Errors' : draw errors in a cartesian lego plot; 'Palette' : the color palette is drawn; 'Front' : draw the front box of a cartesian lego plot; 'Back' : draw the back box of a cartesian lego plot; Available for a 3D lego plot:; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; Further Editor:; 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. /*. */. Rebinning Tab:; This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do for example:; TFile f(""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Sliders (one for the x, one for the y axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; re",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:2408,Availability,avail,available,2408,"; 'Scat' : Draw a scatter-plot (default); 'Palette' : the color palette is drawn. 3d Plot:; 'Type' : ComboBox: set histogram type Lego or Surface-Plot; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Cont #' : TGNumberEntry: set the number of Contours (for e.g.; Lego2 drawoption; 3d Plot checkboxes:; 'Errors' : draw errors in a cartesian lego plot; 'Palette' : the color palette is drawn; 'Front' : draw the front box of a cartesian lego plot; 'Back' : draw the back box of a cartesian lego plot; Available for a 3D lego plot:; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; Further Editor:; 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. /*. */. Rebinning Tab:; This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do for example:; TFile f(""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Sliders (one for the x, one for the y axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:9291,Availability,error,error,9291,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:9375,Availability,error,error,9375,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:22840,Availability,error,error,22840,,MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:25226,Availability,mask,mask,25226,,MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:3824,Deployability,update,updated,3824,"axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can be set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. Function Members (Methods); public:. TH2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH2Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBac",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:3852,Deployability,release,released,3852,"axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can be set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. Function Members (Methods); public:. TH2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH2Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBac",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:31139,Deployability,update,updates,31139," option"" check button. void DoAddCol(Bool_t on); Slot connected to the ""Col draw option"" check button. void DoAddScat(Bool_t on); Slot connected to the ""Scat draw option"" check button. void DoAddText(Bool_t on); Slot connected to the ""Text draw option"" check button. void DoAddError(Bool_t on); Slot connected to the ""Error"" check button. void DoAddPalette(Bool_t on); Slot connected to the color palette check button. void DoAddFB(); Slot connected to the ""FB front-box draw option"" check button. void DoAddBB(); Slot connected to the ""BB back-box draw option"" check button. void DoContLevel(); Slot connected to the contour level number entry fContLevels. void DoContLevel1(); Slot connected to the contour level number entry fContLevels1. void DoBarWidth(); Slot connected to the bar width of the bar chart. void DoBarOffset(); Slot connected to the bar offset of the bar chart. void DoBinReleased(); Slot connected to the rebin slider in case of no ntuple histogram.; It updates some other widgets related to the rebin slider. void DoBinPressed(); Slot connected to the rebin slider in case of no ntuple histogram. void DoBinMoved(); Slot connected to the rebin sliders in case of no ntuple histogram; does the rebinning of the selected histogram. void DoBinLabel(); Slot connected to the Bin Number Entry for the Rebin. void DoApply(); Slot connected to the Apply Button in the Rebinned histogram Window. void DoCancel(); Slot connected to the Cancel Button in the Rebinned histogram Window. void DoBinReleased1(); Slot connected to the BinNumber Slider in case of a 'ntuple histogram'.; It does the rebin. void DoBinMoved1(); Slot connected to the rebin slider in case of an ntuple histogram.; Updates the BinNumberEntryField during the BinSlider movement. void DoBinLabel1(); Slot connected to the Bin Number Entry for the Rebin. void DoOffsetPressed(); Slot connected to the OffSetSlider. It saves the OldBinOffset; (nessesary for delay draw mode). void DoOffsetReleased(); Slot connected to ",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:3275,Energy Efficiency,reduce,reduced,3275,"togram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do for example:; TFile f(""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Sliders (one for the x, one for the y axis); the number of bins (shown in the field below the; Slider) can be changed to any number which divides; the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen.; Pushing 'Ignore' the origin histogram will be restored; Histogram drawn from an ntuple:; 'Rebin' with the sliders the number of bins can be enlarged by; a factor of 2,3,4,5 (moving to the right) or reduced; by a factor of 1/2, 1/3, 1/4, 1/5; 'BinOffset': with the BinOffset slider the origin of the; histogram can be changed within one binwidth; Using this slider the effect of binning the data into; bins can be made visible => statistical fluctuations; 'Axis Range': with the DoubleSlider it is possible to zoom into; the specified axis range. It is also possible to set; the upper and lower limit in fields below the slider; 'Delayed drawing': all the Binning sliders can be set to delay; draw mode. Then the changes on the histogram are only; updated, when the Slider is released. This should be; activated if the redrawing of the histogram is too; time consuming. Function Members (Methods); public:. TH2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TH2Editor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAcceptModel(TObject* model); virtual voidTGFrame::Activate(Bool_t); virtual voidActivateBaseClassEditors(TClass* cl); virtual void",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:465,Integrability,interface,interface,465,". TH2Editor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GUI;  GED;  TH2Editor. class TH2Editor: public TGedFrame. TH2Editor; Editor for changing TH2 histogram attributes, rebinning & fitting.; For all possible draw options (there are a few which are not imple-; mentable in a graphical user interface) see THistPainter::Paint in; root/histpainter/THistPainter.cxx. /*. */. /*. */. These changes can be made via the TH2Editor:; Style Tab:; 'Line' : change Line attributes (color, thickness); see TAttLineEditor; 'Fill' : change Fill attributes (color, pattern); see TAttFillEditor; 'Title' : TextEntry: set the title of the histogram; 'Histogram': change the draw options of the histogram; 'Plot' : Radiobutton: draw a 2D or 3D plot of the histogram; according to the Plot dimension there will be; different drawing possibilities (ComboBoxes/; CheckBoxes); 2d Plot:; 'Contour' : ComboBox: draw a contour plot (None, Cont0..4); 'Cont #' : TGNumberEntry: set the number of Contours; 2d Plot checkboxes:; 'Arrow' : arrow mode. Shows gradient between adjacent cells; 'Col' : a box is drawn for each cell with a color scale; varying with contents; 'Text' : Draw bin contents as text; 'Box' : a box is drawn for each cell with surface; proportional to contents; 'Scat' : Draw a scatter-plot (default); 'Palette' : the color palette is drawn. 3d Plot:; 'Type' : ComboBox: set histogram type Lego or Surface-Plot; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Cont #' : TGNumberEntry: set the number of Contours (for e.g.; Lego2 drawoption; 3d Plot checkboxes:; 'Errors' : draw errors in a cartesian lego plot; 'Palette' : the color palette is drawn; 'Front' : draw the front box of a cartesian lego plot; 'Back' : draw th",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:29550,Modifiability,config,configure,29550,"TGFrame::fgWhitePixel. private:. TH2*fBinHistCloned histogram for rebin; Double_tfOldXOffsetsaves the old x offset of the histogram; Double_tfOldYOffsetsaves the old y offset of the histogram; Float_tfP1oldx[3]; Float_tfP1oldy[3]; Float_tfP2oldx[3]; Float_tfP2oldy[3]; Float_tfP3oldx[3]; Float_tfP3oldy[3]; Float_tfP4oldx[3]; Float_tfP4oldy[3]; Float_tfP5oldx[3]; Float_tfP5oldy[3]; Float_tfP6oldx[3]; Float_tfP6oldy[3]; Float_tfP7oldx[3]; Float_tfP7oldy[3]; Float_tfP8oldx[3]; Float_tfP8oldy[3]; Int_tfPx1old; Int_tfPx2old; Int_tfPy1old; Int_tfPy2old. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH2Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of histogram attribute GUI. void CreateBinTab(); Create the Binning tab. ~TH2Editor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. Bool_t AcceptModel(TObject* model); Check if object is able to configure with this editor. void SetModel(TObject* obj); Pick up the values of current histogram attributes. void DoTitle(const char* text); Slot connected to the histogram title setting. void DoHistView(); Slot connected to the 'Plot' button group. void DoHistSimple(); Slot connected to the 2D-Plot radio button. void DoHistComplex(); Slot connected to the 3D-Plot radio button. void DoHistChanges(); Slot connected to histogram type, coordinate system, contour combo box. void DoAddArr(Bool_t on); Slot connected to the ""Arrow draw option"" check button. void DoAddBox(Bool_t on); Slot connected to the ""Box draw option"" check button. void DoAddCol(Bool_t on); Slot connected to the ""Col draw option"" check button. void DoAddScat(Bool_t on); Slot connected to the ""Scat draw option"" check button. void DoAddText(Bool_t on); Slot connected to the ""Text draw option"" check button. void DoAddError(Bool_t on); Slot connected to the ""Error"" check button. void DoAddPalette(Bool_t on);",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:32332,Modifiability,variab,variable,32332," sliders in case of no ntuple histogram; does the rebinning of the selected histogram. void DoBinLabel(); Slot connected to the Bin Number Entry for the Rebin. void DoApply(); Slot connected to the Apply Button in the Rebinned histogram Window. void DoCancel(); Slot connected to the Cancel Button in the Rebinned histogram Window. void DoBinReleased1(); Slot connected to the BinNumber Slider in case of a 'ntuple histogram'.; It does the rebin. void DoBinMoved1(); Slot connected to the rebin slider in case of an ntuple histogram.; Updates the BinNumberEntryField during the BinSlider movement. void DoBinLabel1(); Slot connected to the Bin Number Entry for the Rebin. void DoOffsetPressed(); Slot connected to the OffSetSlider. It saves the OldBinOffset; (nessesary for delay draw mode). void DoOffsetReleased(); Slot connected to the OffSetSlider that; changes the origin of the histogram inbetween a binwidth;; rebin the histogram with the new Offset given by the slider.; problem: histogram with variable binwidth??. void DoOffsetMoved(); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth;; rebin the histogram with the new offset given by the slider.; problem: histogram with variable binwidth??. void DoBinOffset(); Slot connected to the OffSetNumberEntry, related to the OffSetSlider; changes the origin of the histogram inbetween a binwidth. void DoSliderXMoved(); Slot connected to the x-Slider that redraws the histogram; with the new slider range. void DoSliderXPressed(); Slot connected to the x axis range slider that initialises; the ""virtual"" box which is drawn in delay draw mode. void DoSliderXReleased(); Slot connected to the x-axis slider finalizing values after; the slider movement. void DoXAxisRange(); Slot connected to the Max/Min number entry fields showing x-axis range. void DoSliderYMoved(); Slot connected to the x-slider for redrawing the; histogram with the new slider Range (immediately). void DoSliderYPressed(); Slo",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2Editor.html:32560,Modifiability,variab,variable,32560,"istogram Window. void DoCancel(); Slot connected to the Cancel Button in the Rebinned histogram Window. void DoBinReleased1(); Slot connected to the BinNumber Slider in case of a 'ntuple histogram'.; It does the rebin. void DoBinMoved1(); Slot connected to the rebin slider in case of an ntuple histogram.; Updates the BinNumberEntryField during the BinSlider movement. void DoBinLabel1(); Slot connected to the Bin Number Entry for the Rebin. void DoOffsetPressed(); Slot connected to the OffSetSlider. It saves the OldBinOffset; (nessesary for delay draw mode). void DoOffsetReleased(); Slot connected to the OffSetSlider that; changes the origin of the histogram inbetween a binwidth;; rebin the histogram with the new Offset given by the slider.; problem: histogram with variable binwidth??. void DoOffsetMoved(); Slot connected to the OffSetSlider.; It changes the origin of the histogram inbetween a binwidth;; rebin the histogram with the new offset given by the slider.; problem: histogram with variable binwidth??. void DoBinOffset(); Slot connected to the OffSetNumberEntry, related to the OffSetSlider; changes the origin of the histogram inbetween a binwidth. void DoSliderXMoved(); Slot connected to the x-Slider that redraws the histogram; with the new slider range. void DoSliderXPressed(); Slot connected to the x axis range slider that initialises; the ""virtual"" box which is drawn in delay draw mode. void DoSliderXReleased(); Slot connected to the x-axis slider finalizing values after; the slider movement. void DoXAxisRange(); Slot connected to the Max/Min number entry fields showing x-axis range. void DoSliderYMoved(); Slot connected to the x-slider for redrawing the; histogram with the new slider Range (immediately). void DoSliderYPressed(); Slot connected to y-axis slider which initialises; the ""virtual"" box which is drawn in delay draw mode. void DoSliderYReleased(); Slot connected to the y-axis slider finalizing values after; the slider movement. void DoYAxisRange()",MatchSource.WIKI,root/html530/TH2Editor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Editor.html
https://root.cern/root/html530/TH2F.html:3389,Availability,error,error,3389,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2:",MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2F.html:3473,Availability,error,error,3473,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Doub",MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2F.html:16250,Availability,error,error,16250,,MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2F.html:16320,Availability,error,error,16320,,MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2F.html:16402,Availability,error,error,16402,,MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2F.html:17882,Availability,error,error,17882,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2F.html:26472,Availability,error,errors,26472,"tructor. ~TH2F(); Destructor. TH2F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins); Constructor. TH2F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins); Constructor. TH2F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins); Constructor. TH2F(const TMatrixFBase& m); Constructor. TH2F(const TH2F& h2f); Copy constructor. void Copy(TObject& hnew) const; Copy. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH2F. TH2F& operator=(const TH2F& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t binx, Int_t biny) const; {return GetBinContent(GetBin(binx,biny));}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t binx, Int_t biny, Double_t content); {SetBinContent(GetBin(binx,biny),content);}.  Author: Rene Brun 26/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH2.h 29775 2009-08-13 15:07:28Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding",MatchSource.WIKI,root/html530/TH2F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2F.html
https://root.cern/root/html530/TH2GL.html:2113,Performance,cache,cached,2113,"_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TH2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2GL.html
https://root.cern/root/html530/TH2GL.html:864,Testability,log,logx,864," TH2GL(); virtual~TH2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combi",MatchSource.WIKI,root/html530/TH2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2GL.html
https://root.cern/root/html530/TH2GL.html:877,Testability,log,logy,877," TH2GL(); virtual~TH2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combi",MatchSource.WIKI,root/html530/TH2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2GL.html
https://root.cern/root/html530/TH2GL.html:890,Testability,log,logz,890," TH2GL(); virtual~TH2GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combi",MatchSource.WIKI,root/html530/TH2GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2GL.html
https://root.cern/root/html530/TH2I.html:3364,Availability,error,error,3364,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2:",MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2I.html:3448,Availability,error,error,3448,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Doub",MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2I.html:16215,Availability,error,error,16215,,MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2I.html:16285,Availability,error,error,16285,,MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2I.html:16367,Availability,error,error,16367,,MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2I.html:17847,Availability,error,error,17847,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2I.html:26612,Availability,error,errors,26612,"xup, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins); Constructor. TH2I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins); Constructor. TH2I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins); Constructor. TH2I(const TH2I& h2i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH2I& operator=(const TH2I& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t binx, Int_t biny) const; {return GetBinContent(GetBin(binx,biny));}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t binx, Int_t biny, Double_t content); {SetBinContent(GetBin(binx,biny),content);}.  Author: Rene Brun 26/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH2.h 29775 2009-08-13 15:07:28Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH2I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2I.html
https://root.cern/root/html530/TH2Poly.html:4505,Availability,down,down,4505,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xl",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:7993,Availability,error,error,7993,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(const char* name, Double_t w); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(Double_t, const char*, Double_t); virtual Int_tFill(const char*, Double_t, Double_t); virtual Int_tFill(const char*, const char*, Double_t); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tFindBin(Double_t ",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:8077,Availability,error,error,8077,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(const char* name, Double_t w); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(Double_t, const char*, Double_t); virtual Int_tFill(const char*, Double_t, Double_t); virtual Int_tFill(const char*, const char*, Double_t); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tFindBin(Double_t x, Double_t y, Double_t z = 0); virtual Int_tTH2::FindFirstBinAbove(Double_t thresho",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:20578,Availability,error,error,20578,,MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:20648,Availability,error,error,20648,,MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:20730,Availability,error,error,20730,,MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:22213,Availability,error,error,22213,":SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidTH1::SetBinsLength(Int_t = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetFloat(Bool_t flag = true); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:32706,Availability,error,errors,32706,"coordinates are required as input. It returns the bin number in the; histogram. Int_t AddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new bin to the histogram. The bin shape is a rectangle.; It returns the bin number of the bin in the histogram. void Add(const TH1* h1, Double_t c1); Performs the operation: this = this + c1*h1. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. void Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Replace contents of this histogram by the addition of h1 and h2. void AddBinToPartition(TH2PolyBin* bin); Adds the input bin into the partition cell matrix. This method is called; in AddBin() and ChangePartition(). void ChangePartition(Int_t n, Int_t m); Changes the number of partition cells in the histogram.; Deletes the old partition and constructs a new one. void ClearBinContents(); Clears the contents of all bins in the histogram. void Reset(Option_t* option); Reset this histogram: contents, errors, etc. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Int_t FindBin(Double_t x, Double_t y, Double_t z = 0); Returns the bin number of the bin at the given coordinate. -1 to -9 are; the overflow and underflow bins. overflow bin -5 is the unbinned areas in; the histogram (also called ""the sea""). The third parameter can be left; blank.; The overflow/underflow bins are:. -1 | -2 | -3. -4 | -5 | -6. -7 | -8 | -9. where -5 means is the ""sea"" bin (i.e. unbinned areas). Int_t Fill(Double_t x, Double_t y); Increment the bin containing (x,y) by 1.; Uses the partitioning algorithm. Int_t Fill(Double_t x, Double_t y, Double_t w); Increment the bin containing (x,y) by w.; Uses the partitioning algorithm. Int_t Fill(const char* name, Double_t w); Increment the bin named ""name"" by w. void FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); Fills a 2-D histogram with an array of values and weights. ntimes: number of e",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:34463,Availability,error,error,34463,", Double_t w); Increment the bin named ""name"" by w. void FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); Fills a 2-D histogram with an array of values and weights. ntimes: number of entries in arrays x and w; (array size must be ntimes*stride); x: array of x values to be histogrammed; y: array of y values to be histogrammed; w: array of weights; stride: step size through arrays x, y and w. Double_t Integral(Option_t* option = """") const; Returns the integral of bin contents.; By default the integral is computed as the sum of bin contents.; If option ""width"" or ""area"" is specified, the integral is the sum of; the bin contents multiplied by the area of the bin. Double_t GetBinContent(Int_t bin) const; Returns the content of the input bin; For the overflow/underflow/sea bins:. -1 | -2 | -3; ---+----+----; -4 | -5 | -6; ---+----+----; -7 | -8 | -9. where -5 is the ""sea"" bin (i.e. unbinned areas). Double_t GetBinError(Int_t bin) const; Returns the value of error associated to bin number bin.; If the sum of squares of weights has been defined (via Sumw2),; this function returns the sqrt(sum of w2).; otherwise it returns the sqrt(contents) for this bin. const char * GetBinName(Int_t bin) const; Returns the bin name. const char * GetBinTitle(Int_t bin) const; Returns the bin title. Double_t GetMaximum() const; Returns the maximum value of the histogram. Double_t GetMaximum(Double_t maxval) const; Returns the maximum value of the histogram that is less than maxval. Double_t GetMinimum() const; Returns the minimum value of the histogram. Double_t GetMinimum(Double_t minval) const; Returns the minimum value of the histogram that is greater than minval. void Honeycomb(Double_t xstart, Double_t ystart, Double_t a, Int_t k, Int_t s); Bins the histogram using a honeycomb structure. void Initialize(Double_t xlow, Double_t xup, Double_t ylow, Double_t yup, Int_t n, Int_t m); Initializes the TH2Poly object. This method is called by the c",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:2187,Deployability,update,updated,2187,"as previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by Fill(). The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of TLists.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; ChangePartition(Int_t, Int_t) method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can bin found in $ROOTSYS/",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:2195,Deployability,continuous,continuously,2195,"as previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by Fill(). The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of TLists.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; ChangePartition(Int_t, Int_t) method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can bin found in $ROOTSYS/",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:5091,Energy Efficiency,efficient,efficient,5091,"opriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xlow, Double_t xup, Int_t nY, Double_t ylow, Double_t yup); virtual~TH2Poly(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TH1* h1, Double_t c1); virtual voidAdd(TF1* h1, Double_t c1 = 1, Option_t* option = """"); virtual voidAdd(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); Int_tAddBin(TObject* poly); Int_tAddBin(Int_t n, const Double_t* x, const Double_t* y); Int_tAddBin(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTH1::AddBinContent(Int_t bin); virtual voidTH1::AddBinContent(Int_t bin, Double_t w); static ",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:1444,Modifiability,extend,extends,1444," TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices (stored; as TGraphs or TMultiGraphs ) and contents of the polygonal; bin as well as several related functions. Essentially, a TH2Poly is a TList of TH2PolyBin objects; with methods to manipulate them. Bins are defined using one of the AddBin() methods. The bin definition; should be done before filling. The histogram can be filled with Fill(Double_t x, Double_t y, Double_t w); . w is the weight.; If no weight is specified, it is assumed to be 1. Not all histogram's area need to be binned. Filling an area without bins,; will falls into the overflows. Adding a bin is not retroactive; it doesn't; affect previous fillings. A Fill() call, that; was previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by Fill(). The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of TLists.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; ChangePartition(Int_t, Int_t) method. The partitioning algorithm is; considerably fast",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:1672,Modifiability,extend,extend,1672,"s a TList of TH2PolyBin objects; with methods to manipulate them. Bins are defined using one of the AddBin() methods. The bin definition; should be done before filling. The histogram can be filled with Fill(Double_t x, Double_t y, Double_t w); . w is the weight.; If no weight is specified, it is assumed to be 1. Not all histogram's area need to be binned. Filling an area without bins,; will falls into the overflows. Adding a bin is not retroactive; it doesn't; affect previous fillings. A Fill() call, that; was previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by Fill(). The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of TLists.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; ChangePartition(Int_t, Int_t) method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a ",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:4548,Modifiability,enhance,enhance,4548,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xl",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:4490,Safety,avoid,avoid,4490,"nside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, AddBin() calls the; AddBinToPartition() method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the ChangePartition() method.; ChangePartition() deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times Fill() will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When Fill(); is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; . Function Members (Methods); public:. TH2Poly(); TH2Poly(const TH2Poly&); TH2Poly(const char* name, const char* title, Double_t xlow, Double_t xup, Double_t ylow, Double_t yup); TH2Poly(const char* name, const char* title, Int_t nX, Double_t xl",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:503,Usability,simpl,simple,503,". TH2Poly. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TH2Poly. class TH2Poly: public TH2. TH2Poly: 2D Histogram with Polygonal Bins; Overview; TH2Poly is a 2D Histogram class (TH2) allowing to define polygonal; bins of arbitary shape. Each bin in the TH2Poly histogram is a TH2PolyBin object.; TH2PolyBin is a very simple class containing the vertices (stored; as TGraphs or TMultiGraphs ) and contents of the polygonal; bin as well as several related functions. Essentially, a TH2Poly is a TList of TH2PolyBin objects; with methods to manipulate them. Bins are defined using one of the AddBin() methods. The bin definition; should be done before filling. The histogram can be filled with Fill(Double_t x, Double_t y, Double_t w); . w is the weight.; If no weight is specified, it is assumed to be 1. Not all histogram's area need to be binned. Filling an area without bins,; will falls into the overflows. Adding a bin is not retroactive; it doesn't; affect previous fillings. A Fill() call, that; was previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by Fill(). The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of TLists.; When a coordinate in the histogram is to be filled; the method (quickly) find",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2Poly.html:2632,Usability,simpl,simple,2632," Adding bins to it will extend it up to a proper size. TH2Poly implements a partitioning algorithm to speed up bins' filling.; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of TLists.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; ChangePartition(Int_t, Int_t) method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a TH2Poly:. {; TH2Poly *h2p = new TH2Poly();; Double_t x1[] = {0, 5, 5};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, -1};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(3, x2, y2);; h2p->AddBin(3, x3, y3);; h2p->Fill( 3, 1, 3); // fill bin 1; h2p->Fill(-0.5, -0.5, 7); // fill bin 2; h2p->Fill(-0.7, -0.5, 1); // fill bin 2; h2p->Fill( 1, 3, 5); // fill bin 3; }. More examples can bin found in $ROOTSYS/tutorials/hist/th2poly*.C; Partitioning Algorithm; The partitioning algorithm forms an essential part of the TH2Poly; class. It is implemented to speed up the filling of bins. With the brute force approach, the filling is done in the following way: An; iterator loops over all bins in the TH2Poly and invokes the; method IsInside() for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is fi",MatchSource.WIKI,root/html530/TH2Poly.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2Poly.html
https://root.cern/root/html530/TH2PolyBin.html:1392,Availability,error,error,1392,"2PolyBin(TObject* poly, Int_t bin_number); virtual~TH2PolyBin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearContent(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t w); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetArea(); Int_tGetBinNumber() const; Bool_tGetChanged() const; Double_tGetContent() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetPolygon() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXMax(); Double_tGetXMin(); Double_tGetYMax(); Double_tGetYMin()",MatchSource.WIKI,root/html530/TH2PolyBin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2PolyBin.html
https://root.cern/root/html530/TH2PolyBin.html:1476,Availability,error,error,1476,"ctMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearContent(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t w); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetArea(); Int_tGetBinNumber() const; Bool_tGetChanged() const; Double_tGetContent() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetPolygon() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXMax(); Double_tGetXMin(); Double_tGetYMax(); Double_tGetYMin(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() ",MatchSource.WIKI,root/html530/TH2PolyBin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2PolyBin.html
https://root.cern/root/html530/TH2S.html:3367,Availability,error,error,3367,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2:",MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH2S.html:3451,Availability,error,error,3451,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH2::Fill(Double_t); virtual Int_tTH2::Fill(const char*, Double_t); virtual Int_tTH2::Fill(Double_t x, Double_t y); virtual Int_tTH2::Fill(Double_t x, Double_t y, Double_t w); virtual Int_tTH2::Fill(Double_t x, const char* namey, Double_t w); virtual Int_tTH2::Fill(const char* namex, Double_t y, Double_t w); virtual Int_tTH2::Fill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Doub",MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH2S.html:16228,Availability,error,error,16228,,MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH2S.html:16298,Availability,error,error,16298,,MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH2S.html:16380,Availability,error,error,16380,,MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH2S.html:17860,Availability,error,error,17860,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH2S.html:26618,Availability,error,errors,26618,"or. TH2S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup); Constructor. TH2S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins); Constructor. TH2S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins); Constructor. TH2S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins); Constructor. TH2S(const TH2S& h2s); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH2S. TH2S& operator=(const TH2S& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t binx, Int_t biny) const; {return GetBinContent(GetBin(binx,biny));}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t binx, Int_t biny, Double_t content); {SetBinContent(GetBin(binx,biny),content);}.  Author: Rene Brun 26/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH2.h 29775 2009-08-13 15:07:28Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH2S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH2S.html
https://root.cern/root/html530/TH3.html:3127,Availability,error,error,3127,"tual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(const char*, Double_t); Int_tFill(Double_t, const char*, Double_t); Int_tFill(const char*, Double_t, Double_t); Int_tFill(const char*, const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tFill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tFill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tFill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tFill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tFil",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:3211,Availability,error,error,3211," Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(const char*, Double_t); Int_tFill(Double_t, const char*, Double_t); Int_tFill(const char*, Double_t, Double_t); Int_tFill(const char*, const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tFill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tFill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tFill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tFill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tFill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tFill(Double_t",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:15924,Availability,error,error,15924,,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:15994,Availability,error,error,15994,,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:16076,Availability,error,error,16076,,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:17559,Availability,error,error,17559," Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidTH1::SetBinsLength(Int_t = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:36317,Availability,error,error,36317,"ents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; for a 3-D histogram; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; for a 3-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Interpolate(Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:36329,Availability,error,error,36329,"ents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; for a 3-D histogram; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; for a 3-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Interpolate(Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:36361,Availability,error,errors,36361,"ents. Only bins in the bins range are considered.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Integral(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; for a 3-D histogram; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t IntegralAndError(Int_t binx1, Int_t binx2, Int_t biny1, Int_t biny2, Int_t binz1, Int_t binz2, Double_t& err, Option_t* option = """") const; Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; for a 3-D histogram. Calculates also the integral error using error propagation; from the bin errors assumming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Interpolate(Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:38384,Availability,error,errors,38384,"t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from iymin to iymax and izmin to izmax included.; By default, underflow and overflows are included; By Setting iymin=1 and iym",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:39428,Availability,error,errors,39428,"are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from iymin to iymax and izmin to izmax included.; By default, underflow and overflows are included; By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Y axis; ranging from ixmin to ixmax and izmin to izmax included.; By default, underflow and overflow are ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:39871,Availability,error,error,39871,"Int_t firstybin = 0, Int_t lastybin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from iymin to iymax and izmin to izmax included.; By default, underflow and overflows are included; By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Y axis; ranging from ixmin to ixmax and izmin to izmax included.; By default, underflow and overflow are included.; By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:40549,Availability,error,errors,40549,"nal axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Y axis; ranging from ixmin to ixmax and izmin to izmax included.; By default, underflow and overflow are included.; By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionZ(const char* name = ""_pz"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Z*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny ar",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:40992,Availability,error,error,40992,"Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Y axis; ranging from ixmin to ixmax and izmin to izmax included.; By default, underflow and overflow are included.; By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionZ(const char* name = ""_pz"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Z*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE t",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:41771,Availability,error,errors,41771,"ed. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionZ(const char* name = ""_pz"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstybin = 0, Int_t lastybin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Z*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D.",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:42214,Availability,error,error,42214,"= """") const; Project a 3-D histogram into a 1-D histogram along Z*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = """,MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:43781,Availability,error,errors,43781,"roject3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D histogram; option = ""yz"" return the y versus z projection into a TH2D histogram; option = ""zy"" return the z versus y projection into a TH2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. If option contains the string ""e"", errors are computed. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + option; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; if a histogram of the same type already exists, it is overwritten.; The following sequence; h->Project3D(""xy"");; h->Project3D(""xy2"");; will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; A different name can be generated by attaching a string to the option; For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy. NOTE 2: If an histogram of the same type already exists with compatible axes,; the histogram is reset and filled again with the projected contents of the TH3.; In the case of axes incompatibility, an error is reported and a NULL pointer is returned. NOTE 3: The number of entri",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:44696,Availability,error,error,44696,"bins inside the selected range will be filled. If option contains the string ""e"", errors are computed. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + option; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; if a histogram of the same type already exists, it is overwritten.; The following sequence; h->Project3D(""xy"");; h->Project3D(""xy2"");; will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; A different name can be generated by attaching a string to the option; For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy. NOTE 2: If an histogram of the same type already exists with compatible axes,; the histogram is reset and filled again with the projected contents of the TH3.; In the case of axes incompatibility, an error is reported and a NULL pointer is returned. NOTE 3: The number of entries in the projected histogram is estimated from the number of; effective entries for all the cells included in the projection. NOTE 4: underflow/overflow are included by default in the projection; To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option ""NUF"" and/or ""NOF""; With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as; following after having called SetRange:; axis->SetRange(1, axis->GetNbins());; axis->SetBit(TAxis::kAxisRange);. void DoFillProfileProjection(TProfile2D* p2, const TAxis& a1, const TAxis& a2, const TAxis& a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) const; internal function to fill the bins of the projected profile 2D histogram; called from DoProjectProfile2D. TProfile2D * DoProjectProfile2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool originalR",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:47357,Availability,error,error,47357,"sus z projection into a TProfile2D histogram; option = ""zy"" return the z versus y projection into a TProfile2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + _poption; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; The following sequence; h->Project3DProfile(""xy"");; h->Project3DProfile(""xy2"");; will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2"". NOTE 2: If a profile of the same type already exists with compatible axes,; the profile is reset and filled again with the projected contents of the TH3.; In the case of axes incompatibility, an error is reported and a NULL pointer is returned. NOTE 3: The number of entries in the projected profile is estimated from the number of; effective entries for all the cells included in the projection. NOTE 4: underflow/overflow are by default excluded from the projection; (Note that this is a different default behavior compared to the projection to an histogram); To include the underflow and/or overflow use option ""UF"" and/or ""OF"". void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH3 * RebinX(Int_t ngroup, const char* newname); Rebin only the X axis; see Rebin3D. TH3 * RebinY(Int_t ngroup, const char* newname); Rebin only the Y axis; see Rebin3D. TH3 * RebinZ(Int_t ngroup, const char* newname); Rebin only the Z axis; see Rebin3D. TH3 * Rebin3D(Int_t nxgroup, Int_t nygroup, Int_t nzgroup, const char* newname); -*-*-*Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together*-*-*-*-. if newname is not blank a new",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:48604,Availability,error,errors,48604,"e projection. NOTE 4: underflow/overflow are by default excluded from the projection; (Note that this is a different default behavior compared to the projection to an histogram); To include the underflow and/or overflow use option ""UF"" and/or ""OF"". void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH3 * RebinX(Int_t ngroup, const char* newname); Rebin only the X axis; see Rebin3D. TH3 * RebinY(Int_t ngroup, const char* newname); Rebin only the Y axis; see Rebin3D. TH3 * RebinZ(Int_t ngroup, const char* newname); Rebin only the Z axis; see Rebin3D. TH3 * Rebin3D(Int_t nxgroup, Int_t nygroup, Int_t nzgroup, const char* newname); -*-*-*Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together*-*-*-*-. if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to me merged into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; // Carefull: previous contents of hpxpy are lost; hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned histogram; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the corresponding bins are added to; the overflow bin.; Statistics will be recomputed from the new bin contents. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ====================",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:48665,Availability,error,errors,48665,"e projection. NOTE 4: underflow/overflow are by default excluded from the projection; (Note that this is a different default behavior compared to the projection to an histogram); To include the underflow and/or overflow use option ""UF"" and/or ""OF"". void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH3 * RebinX(Int_t ngroup, const char* newname); Rebin only the X axis; see Rebin3D. TH3 * RebinY(Int_t ngroup, const char* newname); Rebin only the Y axis; see Rebin3D. TH3 * RebinZ(Int_t ngroup, const char* newname); Rebin only the Z axis; see Rebin3D. TH3 * Rebin3D(Int_t nxgroup, Int_t nygroup, Int_t nzgroup, const char* newname); -*-*-*Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together*-*-*-*-. if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to me merged into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; // Carefull: previous contents of hpxpy are lost; hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned histogram; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the corresponding bins are added to; the overflow bin.; Statistics will be recomputed from the new bin contents. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ====================",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:49509,Availability,error,errors,49509,"ong the xaxis/yaxis of this; have to me merged into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculated. examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; // Carefull: previous contents of hpxpy are lost; hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned histogram; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the corresponding bins are added to; the overflow bin.; Statistics will be recomputed from the new bin contents. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void Streamer(TBuffer& b); Stream an object of class TH3. void SetShowProjection(const char* option = ""xy"", Int_t nbins = 1); When the mouse is moved in a pad containing a 3-d view of this histogram; a second canvas shows a projection type given as option.; To stop the generation of the projections, delete the canvas; containing the projection.; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D histogram; option = ""yz"" return the y versus z projection into a TH2D histogra",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:30188,Deployability,integrat,integrated,30188,"t cell defined by x,namey,namezz by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. Int_t Fill(Double_t x, const char* namey, Double_t z, Double_t w); Increment cell defined by x,namey,z by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. Int_t Fill(Double_t x, Double_t y, const char* namez, Double_t w); Increment cell defined by x,y,namez by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF1) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF1::GetRandom to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH3) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:30814,Deployability,integrat,integrated,30814,"d by x,y,namez by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF1) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF1::GetRandom to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH3) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *. Int_t FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find first bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. Int_t FindLastBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find last bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. void FitSlicesZ(TF1* f1 = 0, Int_t binminx = 1, Int_t binmaxx = 0, Int_t binminy = 1, Int_t binmaxy = 0, Int_t cut = 0, Option_t* option = ""QNR""); Project slices along Z in case ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:30188,Integrability,integrat,integrated,30188,"t cell defined by x,namey,namezz by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. Int_t Fill(Double_t x, const char* namey, Double_t z, Double_t w); Increment cell defined by x,namey,z by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. Int_t Fill(Double_t x, Double_t y, const char* namez, Double_t w); Increment cell defined by x,y,namez by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF1) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF1::GetRandom to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH3) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:30814,Integrability,integrat,integrated,30814,"d by x,y,namez by a weight w. If the storage of the sum of squares of weights has been triggered,; via the function Sumw2, then the sum of the squares of weights is incremented; by w^2 in the cell corresponding to x,y,z. void FillRandom(const char* fname, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in function fname; *-* =======================================================; -; *-* The distribution contained in the function fname (TF1) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *-* One can also call TF1::GetRandom to get a random variate from a function.; -; *. void FillRandom(TH1* h, Int_t ntimes = 5000); -*-*-*Fill histogram following distribution in histogram h; *-* ====================================================; -; *-* The distribution contained in the histogram h (TH3) is integrated; *-* over the channel contents.; *-* It is normalized to 1.; *-* Getting one random number implies:; *-* - Generating a random number between 0 and 1 (say r1); *-* - Look in which bin in the normalized integral r1 corresponds to; *-* - Fill histogram channel; *-* ntimes random numbers are generated; -; *. Int_t FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find first bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. Int_t FindLastBinAbove(Double_t threshold = 0, Int_t axis = 1) const; find last bin with content > threshold for axis (1=x, 2=y, 3=z); if no bins with content > threshold is found the function returns -1. void FitSlicesZ(TF1* f1 = 0, Int_t binminx = 1, Int_t binmaxx = 0, Int_t binminy = 1, Int_t binmaxy = 0, Int_t cut = 0, Option_t* option = ""QNR""); Project slices along Z in case ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:42862,Integrability,depend,depending,42862," incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D histogram; option = ""yz"" return the y versus z projection into a TH2D histogram; option = ""zy"" return the z versus y projection into a TH2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. If option contains the string ""e"", errors are computed. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + option; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; if a histogram of the same type already exists, it is overwritten.; T",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:45932,Integrability,depend,depending,45932,"axis bit range as; following after having called SetRange:; axis->SetRange(1, axis->GetNbins());; axis->SetBit(TAxis::kAxisRange);. void DoFillProfileProjection(TProfile2D* p2, const TAxis& a1, const TAxis& a2, const TAxis& a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) const; internal function to fill the bins of the projected profile 2D histogram; called from DoProjectProfile2D. TProfile2D * DoProjectProfile2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool originalRange, bool useUF, bool useOF) const; internal method to project to a 2D Profile; called from TH3::Project3DProfile. TProfile2D * Project3DProfile(Option_t* option = ""xy"") const; Project a 3-d histogram into a 2-d profile histograms depending; on the option parameter; option may contain a combination of the characters x,y,z; option = ""xy"" return the x versus y projection into a TProfile2D histogram; option = ""yx"" return the y versus x projection into a TProfile2D histogram; option = ""xz"" return the x versus z projection into a TProfile2D histogram; option = ""zx"" return the z versus x projection into a TProfile2D histogram; option = ""yz"" return the y versus z projection into a TProfile2D histogram; option = ""zy"" return the z versus y projection into a TProfile2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. The projection is made for the selected bins only.; To select a bin range along an axis, use TAxis::SetRange, eg; h3.GetYaxis()->SetRange(23,56);. NOTE 1: The generated histogram is named th3name + _poption; eg if the TH3* h histogram is named ""myhist"", then; h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; The following sequence; h->Project3DProfile(""xy"");; h->Project3DProfile(""xy2"");; will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2"". NOTE 2: If a profil",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:26256,Modifiability,variab,variable,26256,"2Total Sum of weight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3(); Default constructor. TH3(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3(const TH3& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). ~TH3(); Destructor. void Copy(TObject& hnew) const; Copy. Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferF",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:26535,Modifiability,variab,variable,26535,"ms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3(); Default constructor. TH3(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3(const TH3& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). ~TH3(); Destructor. void Copy(TObject& hnew) const; Copy. Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of f",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:42451,Performance,perform,performing,42451,"s made from the cells along the X axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:42693,Performance,perform,performing,42693,"ed; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D histogram; option = ""yz"" return the y versus z projection into a TH2D histogram; option = ""zy"" return the z versus y projection into a TH2D histogram; NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal. option = ""o"" origina",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:32987,Security,access,access,32987,"e(zmin,zmax); The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range. Note that the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 3-d histogram h3; Root > h3->FitSlicesZ(); produces 4 TH2D histograms; with h3_0 containing parameter 0(Constant) for a Gaus fit; of each cell in X,Y projected along Z; with h3_1 containing parameter 1(Mean) for a gaus fit; with h3_2 containing parameter 2(RMS) for a gaus fit; with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h3->Fit(0,15,22,0,0,10);; same as above, but only for bins 15 to 22 along X; and only for cells in X,Y for which the corresponding projection; along Z has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");. Double_t GetBinWithContent3(Double_t c, Int_t& binx, Int_t& biny, Int_t& binz, Int_t firstx = 0, Int_t lastx = 0, Int_t firsty = 0, Int_t lasty = 0, Int_t firstz = 0, Int_t lastz = 0, Double_t maxdiff = 0) const; compute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,lastz] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny,binz.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny,binz.; In all cases the function returns the smallest difference. NOTE1: if firstx <= 0, firstx is set to bin 1; if (lastx < firstx then firstx is set to the number of bins in X; ie if firstx=0 and lastx=0 (default) the search is on all bins in X.; if firsty <= 0, firsty is set to bin 1; if (lasty < firsty then firsty is set to t",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:37372,Testability,test,test,37372,"ming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Interpolate(Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:37452,Testability,test,test,37452,"ming that all the bins are uncorrelated.; By default the integral is computed as the sum of bin contents in the range.; if option ""width"" is specified, the integral is the sum of; the bin contents multiplied by the bin width in x, y and in z. Double_t Interpolate(Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:37590,Testability,test,test,37590,"Double_t x). Double_t Interpolate(Double_t x, Double_t y). Double_t Interpolate(Double_t x, Double_t y, Double_t z); Given a point P(x,y,z), Interpolate approximates the value via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y ",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:37811,Testability,test,test,37811,"lue via trilinear interpolation; based on the 8 nearest bin center points ( corner of the cube surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:37867,Testability,test,test,37867,"be surronding the points); The Algorithm is described in http://en.wikipedia.org/wiki/Trilinear_interpolation; The given values (x,y,z) must be between first bin center and last bin center for each coordinate:. fXAxis.GetBinCenter(1) < x < fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t l",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3.html:38172,Testability,test,tests,38172,"fXaxis.GetBinCenter(nbinX) AND; fYAxis.GetBinCenter(1) < y < fYaxis.GetBinCenter(nbinY) AND; fZAxis.GetBinCenter(1) < z < fZaxis.GetBinCenter(nbinZ). Double_t KolmogorovTest(const TH1* h2, Option_t* option = """") const; Statistical test of compatibility in shape between; THIS histogram and h2, using Kolmogorov test.; Default: Ignore under- and overflow bins in comparison. option is a character string to specify options; ""U"" include Underflows in test; ""O"" include Overflows; ""N"" include comparison of normalizations; ""D"" Put out a line of ""Debug"" printout; ""M"" Return the Maximum Kolmogorov distance instead of prob. The returned function value is the probability of test; (much less than one means NOT compatible). The KS test uses the distance between the pseudo-CDF's obtained; from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinatons of the 3 axis.; The average of all the maximum distances obtained is used in the tests. Long64_t Merge(TCollection* list); Add all histograms in the collection to this histogram.; This function computes the min/max for the axes,; compute a new number of bins, if necessary,; add bin contents, errors and statistics.; If overflows are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type T",MatchSource.WIKI,root/html530/TH3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3.html
https://root.cern/root/html530/TH3C.html:3224,Availability,error,error,3224,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const c",MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:3308,Availability,error,error,3308,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const",MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:16629,Availability,error,error,16629,,MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:16699,Availability,error,error,16699,,MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:16781,Availability,error,error,16781,,MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:18261,Availability,error,error,18261,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:27788,Availability,error,errors,27788,"t_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const TH3C& h3c); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void SetBinContent(Int_t bin, Double_t content); Set bin content. void Streamer(TBuffer& b); Stream an object of class TH3C. TH3C& operator=(const TH3C& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}.  Author: Rene Brun 27/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH3.h 37961 2011-02-03 10:44:09Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:26849,Modifiability,variab,variable,26849,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3C(); Constructor. ~TH3C(); Destructor. TH3C(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const TH3C& h3c); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ",MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3C.html:27129,Modifiability,variab,variable,27129,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3C(); Constructor. ~TH3C(); Destructor. TH3C(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3C(const TH3C& h3c); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void SetBinContent(Int_t bin, Double_t content); Set bin content. void Streamer(TBuffer& b); Stream an object of clas",MatchSource.WIKI,root/html530/TH3C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3C.html
https://root.cern/root/html530/TH3D.html:3235,Availability,error,error,3235,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const c",MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:3319,Availability,error,error,3319,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const",MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:16650,Availability,error,error,16650,,MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:16720,Availability,error,error,16720,,MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:16802,Availability,error,error,16802,,MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:18282,Availability,error,error,18282,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:27603,Availability,error,errors,27603,"tor for fix bin size 3-D histograms; *-* ==================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const TH3D& h3d); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH3D. TH3D& operator=(const TH3D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}.  Author: Rene Brun 27/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH3.h 37961 2011-02-03 10:44:09Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:26874,Modifiability,variab,variable,26874,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3D(); Constructor. ~TH3D(); Destructor. TH3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const TH3D& h3d); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin",MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3D.html:27154,Modifiability,variab,variable,27154,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3D(); Constructor. ~TH3D(); Destructor. TH3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3D(const TH3D& h3d); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH3D. TH3D& operator=(const TH3D& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) ",MatchSource.WIKI,root/html530/TH3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3D.html
https://root.cern/root/html530/TH3F.html:3230,Availability,error,error,3230,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const c",MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:3314,Availability,error,error,3314,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const",MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:16640,Availability,error,error,16640,,MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:16710,Availability,error,error,16710,,MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:16792,Availability,error,error,16792,,MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:18272,Availability,error,error,18272,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:27591,Availability,error,errors,27591,"tor for fix bin size 3-D histograms; *-* ==================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const TH3F& h3f); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH3F. TH3F& operator=(const TH3F& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}.  Author: Rene Brun 27/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH3.h 37961 2011-02-03 10:44:09Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general ",MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:26862,Modifiability,variab,variable,26862,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3F(); Constructor. ~TH3F(); Destructor. TH3F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const TH3F& h3f); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin",MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3F.html:27142,Modifiability,variab,variable,27142,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3F(); Constructor. ~TH3F(); Destructor. TH3F(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3F(const TH3F& h3f); Copy constructor. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH3F. TH3F& operator=(const TH3F& h1); Operator =. void AddBinContent(Int_t bin). void AddBinContent(Int_t bin, Double_t w). Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) ",MatchSource.WIKI,root/html530/TH3F.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3F.html
https://root.cern/root/html530/TH3GL.html:2087,Performance,cache,cached,2087,"_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html530/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3GL.html
https://root.cern/root/html530/TH3GL.html:838,Testability,log,logx,838," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogic",MatchSource.WIKI,root/html530/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3GL.html
https://root.cern/root/html530/TH3GL.html:851,Testability,log,logy,851," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogic",MatchSource.WIKI,root/html530/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3GL.html
https://root.cern/root/html530/TH3GL.html:864,Testability,log,logz,864," TH3GL(); TH3GL(TH3* h, TPolyMarker3D* pm); virtual~TH3GL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); static TGLPlot3D*TGLPlot3D::CreatePlot(TH3* h, TPolyMarker3D* pm); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, TVirtualPad* pad); static TGLPlot3D*TGLPlot3D::CreatePlot(TObject* obj, Option_t* opt, Bool_t logx, Bool_t logy, Bool_t logz); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLPlot3D::KeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogic",MatchSource.WIKI,root/html530/TH3GL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3GL.html
https://root.cern/root/html530/TH3I.html:3234,Availability,error,error,3234,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const c",MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:3318,Availability,error,error,3318,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const",MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:16634,Availability,error,error,16634,,MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:16704,Availability,error,error,16704,,MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:16786,Availability,error,error,16786,,MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:18266,Availability,error,error,18266,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:27802,Availability,error,errors,27802,", const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const TH3I& h3i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH3I& operator=(const TH3I& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}.  Author: Rene Brun 27/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH3.h 37961 2011-02-03 10:44:09Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:26863,Modifiability,variab,variable,26863,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3I(); Constructor. ~TH3I(); Destructor. TH3I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const TH3I& h3i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ",MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3I.html:27143,Modifiability,variab,variable,27143,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3I(); Constructor. ~TH3I(); Destructor. TH3I(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3I(const TH3I& h3i); Copy constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. TH3I& operator=(const TH3I& h1); Operator =. Double",MatchSource.WIKI,root/html530/TH3I.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3I.html
https://root.cern/root/html530/TH3S.html:3237,Availability,error,error,3237,"; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const c",MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:3321,Availability,error,error,3321,"t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t); virtual Int_tTH3::Fill(Double_t, Double_t); virtual Int_tTH3::Fill(const char*, Double_t); Int_tTH3::Fill(Double_t, const char*, Double_t); Int_tTH3::Fill(const char*, Double_t, Double_t); Int_tTH3::Fill(const char*, const char*, Double_t); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const",MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:16647,Availability,error,error,16647,,MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:16717,Availability,error,error,16717,,MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:16799,Availability,error,error,16799,,MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:18279,Availability,error,error,18279,"in, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Double_t error); virtual voidTH1::SetBinError(Int_t binx, Int_t biny, Int_t binz, Double_t error); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); virtual voidTH1::SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); virtual voidTH1::SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); virtual voidSetBinsLength(Int_t n = -1); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTH1::SetBuffer(Int_t buffersize, Option_t* option = """"); virtual voidTH1::SetCellContent(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetCellError(Int_t binx, Int_t biny, Double_t content); virtual voidTH1::SetContent(const Double_t* content); virtual voidTH1::SetContour(Int_t nlevels, const Double_t* levels = 0); virtual voidTH1::SetContourLevel(Int_t level, Double_t value); static voidTH1::SetDefaultBufferSize(Int_t buffersize = 1000); static voidTH1::SetDefaultSumw2(Bool_t sumw2 = kTRUE); virtual voidTH1::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTH1::SetEntries(Double_t n); virtual voidTH1::SetError(const Double_t* error); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTH1::SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); virtual voidTH1::SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); virtual voidTH1::SetLabelOffset(Float_t offset = 0.",MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:27808,Availability,error,errors,27808,"t_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const TH3S& h3s); Copy Constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of class TH3S. TH3S& operator=(const TH3S& h1); Operator =. Double_t GetBinContent(Int_t bin) const. Double_t GetBinContent(Int_t bin, Int_t ) const; {return GetBinContent(bin);}. void SetBinContent(Int_t bin, Double_t content). void SetBinContent(Int_t bin, Int_t , Double_t content); {SetBinContent(bin,content);}.  Author: Rene Brun 27/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: TH3.h 37961 2011-02-03 10:44:09Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:26869,Modifiability,variab,variable,26869,"eight*Z*Z; TAxisTH1::fXaxisX axis descriptor; TAxisTH1::fYaxisY axis descriptor; TAxisTH1::fZaxisZ axis descriptor; static Bool_tTH1::fgAddDirectory!flag to add histograms to the directory; static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3S(); Constructor. ~TH3S(); Destructor. TH3S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const TH3S& h3s); Copy Constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ",MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/TH3S.html:27149,Modifiability,variab,variable,27149,"TH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TH3S(); Constructor. ~TH3S(); Destructor. TH3S(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup); -*-*-*-*Normal constructor for fix bin size 3-D histograms; *-* ==================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Int_t nbinsy, const Float_t* ybins, Int_t nbinsz, const Float_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins); -*-*-*-*Normal constructor for variable bin size 3-D histograms; *-* =======================================================. TH3S(const TH3S& h3s); Copy Constructor. void AddBinContent(Int_t bin); Increment bin content by 1*-*-*-*-; *-* ==========================. void AddBinContent(Int_t bin, Double_t w); Increment bin content by w*-*-*-*-; *-* ==========================. void Copy(TObject& hnew) const; Copy this 3-D histogram structure to newth3*-*-*-; *-* ===========================================. TH1 * DrawCopy(Option_t* option = """") const; Draw copy. Double_t GetBinContent(Int_t bin) const; Get bin content. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void Streamer(TBuffer& b); Stream an object of clas",MatchSource.WIKI,root/html530/TH3S.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TH3S.html
https://root.cern/root/html530/THaarMatrixT_double_.html:1648,Availability,error,error,1648,"); THaarMatrixT<double>(Int_t n, Int_t no_cols = 0); virtual~THaarMatrixT<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html530/THaarMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THaarMatrixT_double_.html
https://root.cern/root/html530/THaarMatrixT_double_.html:1732,Availability,error,error,1732," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html530/THaarMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THaarMatrixT_double_.html
https://root.cern/root/html530/THaarMatrixT_float_.html:1638,Availability,error,error,1638,">&); THaarMatrixT<float>(Int_t n, Int_t no_cols = 0); virtual~THaarMatrixT<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html530/THaarMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THaarMatrixT_float_.html
https://root.cern/root/html530/THaarMatrixT_float_.html:1722,Availability,error,error,1722," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html530/THaarMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THaarMatrixT_float_.html
https://root.cern/root/html530/THashList.html:2905,Availability,error,error,2905,"; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObje",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:2989,Availability,error,error,2989,"static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Opti",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14657,Availability,avail,available,14657,"objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:11025,Energy Efficiency,reduce,reduce,11025,"ected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:616,Modifiability,inherit,inheriting,616,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TC",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:10090,Performance,cache,cache,10090,"TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. THashList(const THashList&); THashList&operator=(const THashList&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashin",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14995,Performance,perform,performance,14995,") const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:361,Security,hash,hash,361,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TC",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:407,Security,hash,hash,407,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TC",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:437,Security,access,access,437,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TC",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:520,Security,hash,hash,520,". THashList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashList. class THashList: public TList. THashList. THashList implements a hybrid collection class consisting of a; hash table and a list to store TObject's. The hash table is used for; quick access and lookup of objects while the list allows the objects; to be ordered. The hash value is calculated using the value returned; by the TObject's Hash() function. Each class inheriting from TObject; can override Hash() as it sees fit. /*. */. Function Members (Methods); public:. THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashList(); voidTObject::AbstractMethod(const char* method) const; virtual voidTList::Add(TObject* obj); virtual voidTList::Add(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddBefore(TObjLink* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddFirst(TObject* obj, Option_t* opt); virtual voidAddLast(TObject* obj); virtual voidAddLast(TObject* obj, Option_t* opt); voidTCollection::AddVector(TObject* obj1); virtual TObject*TList::After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*TList::At(Int_t idx) const; Float_tAverageCollisions() const; virtual TObject*TList::Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TC",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:10742,Security,hash,hashtable,10742,"Bits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:10983,Security,hash,hashtable,10983,"ected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:11325,Security,hash,hashlist,11325,"n::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an obje",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:11525,Security,hash,hashlist,11525,"Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddBefore(const TObject",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:13084,Security,hash,hashtable,13084,"t(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:13630,Security,access,access,13630," obj); Insert object before object before in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table.",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:13776,Security,hash,hash,13776,"ter, TObject* obj); Insert object after object after in the list. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:13926,Security,hash,hash,13926," Insert object at location idx in the list. Float_t AverageCollisions() const; Return the average collision rate. The higher the number the longer; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14098,Security,hash,hash,14098,"nger; the linked lists in the hashtable, the slower the lookup. If the number; is high, or lookup noticeably too slow, perfrom a Rehash(). void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table t",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14270,Security,hash,hash,14270,"); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14603,Security,hash,hash,14603," of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14621,Security,hash,hash,14621," of an object in this list one can still access the list to search for; other not yet deleted objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14638,Security,hash,hash,14638,"objects). TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT i",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:14779,Security,hash,hashlist,14779,") const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashList.html:15018,Security,hash,hashtable,15018,") const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). TList * GetListForObject(const TObject* obj) const; Return the THashTable's list (bucket) in which obj can be found based on; its hash; see THashTable::GetListForObject(). void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. void Rehash(Int_t newCapacity); Rehash the hashlist. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. THashList(const THashList& ). THashList& operator=(const THashList& ).  Author: Fons Rademakers 10/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashList.html
https://root.cern/root/html530/THashTable.html:2216,Availability,error,error,2216,"onst; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRehashLev",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:2300,Availability,error,error,2300,"voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; TList*GetListForObject(const char* name) const; TList*GetListForObject(const TObject* obj) const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetRehashLevel() const; virtual Int_tGetSize() const; virtual const char*TObject::GetTitle() con",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:8782,Energy Efficiency,reduce,reduce,8782,"elete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash ta",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:9394,Energy Efficiency,efficient,efficient,9394,"::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corres",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:463,Modifiability,inherit,inheriting,463,". THashTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashTable. class THashTable: public TCollection. THashTable. THashTable implements a hash table to store TObject's. The hash; value is calculated using the value returned by the TObject's; Hash() function. Each class inheriting from TObject can override; Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects.; If the insertion order is important AND fast retrieval is needed; use THashList instead. /*. */. Function Members (Methods); public:. THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection:",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:11164,Performance,perform,performance,11164,"r converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  L",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:331,Security,hash,hash,331,". THashTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashTable. class THashTable: public TCollection. THashTable. THashTable implements a hash table to store TObject's. The hash; value is calculated using the value returned by the TObject's; Hash() function. Each class inheriting from TObject can override; Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects.; If the insertion order is important AND fast retrieval is needed; use THashList instead. /*. */. Function Members (Methods); public:. THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection:",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:366,Security,hash,hash,366,". THashTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashTable. class THashTable: public TCollection. THashTable. THashTable implements a hash table to store TObject's. The hash; value is calculated using the value returned by the TObject's; Hash() function. Each class inheriting from TObject can override; Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects.; If the insertion order is important AND fast retrieval is needed; use THashList instead. /*. */. Function Members (Methods); public:. THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~THashTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* name) const; Int_tCollisions(TObject* obj) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection:",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:8489,Security,hash,hashtable,8489,"ue(TString& s) const; Int_tGetHashValue(const char* str) const; THashTable&operator=(const THashTable&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Doe",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:8740,Security,hash,hashtable,8740,"elete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash ta",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:9040,Security,hash,hashtable,9040,"Sizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:9175,Security,hash,hash,9175,"e; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TStri",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:9725,Security,hash,hash,9725," than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObj",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:9897,Security,hash,hash,9897,"s, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(I",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:10126,Security,hash,hash,10126," object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To impro",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:10276,Security,hash,hash,10276,"Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the tab",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:10424,Security,hash,hash,10424,"emented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all o",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:10612,Security,hash,hash,10612,". Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObjec",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:10850,Security,hash,hash,10850,"f collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() ",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:10947,Security,hash,hashtable,10947," length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). In",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:11187,Security,hash,hashtable,11187,"r converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  L",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:11532,Security,hash,hashtable,11532," can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:11602,Security,hash,hashtable,11602," can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTable.html:11630,Security,hash,hash,11630," can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all objects in the table are still valid; (i.e. have not been deleted from the system in the meanwhile). TObject * Remove(TObject* obj); Remove object from the hashtable. TObject * RemoveSlow(TObject* obj); Remove object from the hashtable without using the hash value. Float_t AverageCollisions() const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(const TObject* obj) const. Int_t GetHashValue(TString& s) const; { return s.Hash() % fSize; }. THashTable(const THashTable& ). THashTable& operator=(const THashTable& ). Int_t GetRehashLevel() const; { return fRehashLevel; }. Int_t GetSize() const; { return fEntries; }. void SetRehashLevel(Int_t rehash); { fRehashLevel = rehash; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTable.html
https://root.cern/root/html530/THashTableIter.html:2142,Integrability,depend,depending,2142,"); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTableIter.html
https://root.cern/root/html530/THashTableIter.html:333,Security,hash,hash,333,". THashTableIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  THashTableIter. class THashTableIter: public TIterator. THashTableIter. Iterator of hash table. Function Members (Methods); public:. THashTableIter(const THashTableIter& iter); THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); virtual~THashTableIter(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator& aIter) const; booloperator!=(const THashTableIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot();",MatchSource.WIKI,root/html530/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTableIter.html
https://root.cern/root/html530/THashTableIter.html:1520,Security,hash,hashtable,1520,"rForward); virtual~THashTableIter(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*TIterator::GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator& aIter) const; booloperator!=(const THashTableIter& aIter) const; TObject*TIterator::operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }",MatchSource.WIKI,root/html530/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTableIter.html
https://root.cern/root/html530/THashTableIter.html:1872,Security,hash,hashtable,1872," TIterator&operator=(const TIterator& rhs); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in gen",MatchSource.WIKI,root/html530/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTableIter.html
https://root.cern/root/html530/THashTableIter.html:1932,Security,hash,hashtable,1932,"); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTableIter.html
https://root.cern/root/html530/THashTableIter.html:2094,Security,hash,hashtable,2094,"); THashTableIter&operator=(const THashTableIter& rhs); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. bool operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. bool operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }.  Author: Fons Rademakers 27/09/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: THashTable.h 23198 2008-04-14 09:23:08Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THashTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THashTableIter.html
https://root.cern/root/html530/THbookBranch.html:1795,Availability,error,error,1795,"stBasket(Long64_t startEntry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTBranch::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTBranch::FillLeaves(TBuffer& b); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; const char*GetBlockName() const; v",MatchSource.WIKI,root/html530/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookBranch.html
https://root.cern/root/html530/THbookBranch.html:1879,Availability,error,error,1879,"; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTBranch::DeleteBaskets(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTBranch::DropBaskets(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBranch::ExpandBasketArrays(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTBranch::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTBranch::FillLeaves(TBuffer& b); virtual TBranch*TBranch::FindBranch(const char* name); virtual TLeaf*TBranch::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTBranch::FlushBaskets(); Int_tTBranch::FlushOneBasket(UInt_t which); virtual char*TBranch::GetAddress() const; TBasket*TBranch::GetBasket(Int_t basket); Int_t*TBranch::GetBasketBytes() const; Long64_t*TBranch::GetBasketEntry() const; virtual Long64_tTBranch::GetBasketSeek(Int_t basket) const; virtual Int_tTBranch::GetBasketSize() const; const char*GetBlockName() const; virtual TList*TBranch::GetBrowsables(); virtual const char*TBranch::GetClassName() co",MatchSource.WIKI,root/html530/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookBranch.html
https://root.cern/root/html530/THbookBranch.html:7937,Deployability,update,updateSubBranches,7937,"Branch::ResetReadEntry(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTAttFill::SaveFillAttributes(ostream& out, const char* name, Int_t coldef = 1, Int_t stydef = 1001); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAddress(void* addobj); virtual voidTBranch::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTBranch::SetBasketSize(Int_t buffsize); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBlockName(const char* name); virtual voidTBranch::SetBufferAddress(TBuffer* entryBuffer); voidTBranch::SetCompressionAlgorithm(Int_t algorithm = 0); voidTBranch::SetCompressionLevel(Int_t level = 1); voidTBranch::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEntries(Long64_t n); virtual voidTBranch::SetEntryOffsetLen(Int_t len, Bool_t updateSubBranches = kFALSE); virtual voidTBranch::SetFile(TFile* file = 0); virtual voidTBranch::SetFile(const char* filename); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTBranch::SetFirstEntry(Long64_t entry); virtual Bool_tTBranch::SetMakeClass(Bool_t decomposeObj = kTRUE); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTBranch::SetObject(void* objadd); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTBranch::SetOffset(Int_t offset = 0); virtual voidTBranch::SetStatus(Bool_t status = 1); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTBranch::SetTree(TTree* tree); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTBranch::SetupAddresses(); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer",MatchSource.WIKI,root/html530/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookBranch.html
https://root.cern/root/html530/THbookBranch.html:13466,Integrability,interface,interface,13466," go to the next basket; Int_tTBranch::fNleaves! Number of leaves; Int_tTBranch::fOffsetOffset of this branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; G__p2memfuncTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use. ; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THbookBranch(TTree* tree, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1). THbookBranch(TBranch* branch, const char* name, void* address, const char* leaflist, Int_t basketsize = 32000, Int_t compress = -1). ~THbookBranch(). void Browse(TBrowser* b); Browser interface. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); get one entry from hbook ntuple. void SetAddress(void* addobj); Set address of this branch; See important remark in the header of THbookTree. THbookBranch(); {;}. const char * GetBlockName() const; {return fBlockName.Data();}. void SetBlockName(const char* name); {fBlockName=name;}. void SetEntries(Long64_t n); {fEntries=n;}.  Author: Rene Brun 18/02/2002  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/hbook:$Id: THbookBranch.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookBranch.html
https://root.cern/root/html530/THbookBranch.html:10478,Modifiability,variab,variable,10478,"voidTObject::MakeZombie(); voidTBranch::ReadLeaves0Impl(TBuffer& b); voidTBranch::ReadLeaves1Impl(TBuffer& b); voidTBranch::ReadLeaves2Impl(TBuffer& b); voidTBranch::ReadLeavesImpl(TBuffer& b); voidTBranch::SetSkipZip(Bool_t skip = kTRUE); Int_tTBranch::WriteBasket(TBasket* basket, Int_t where). Data Members; public:. enum TBranch::EStatusBits { kAutoDelete; kDoNotUseBufferMap; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBranch::fAddress! Address of 1st leaf (variable or object); Int_t*TBranch::fBasketBytes[fMaxBaskets] Lenght of baskets on file; Long64_t*TBranch::fBasketEntry[fMaxBaskets] Table of first entry in eack basket; Long64_t*TBranch::fBasketSeek[fMaxBaskets] Addresses of baskets on file; Int_tTBranch::fBasketSizeInitial Size of Basket Buffer; TObjArrayTBranch::fBaskets-> List of baskets of this branch; TStringfBlockNameHbook block name; TObjArrayTBranch::fBranches-> List of Branches of this branch; TList*TBranch::fBrowsables! List of TVirtualBranchBrowsables used for Browse(); Int_tTBranch::fCompressCompression level and algorithm; TBasket*TBranch::fCurrentBasket! Pointer to the current basket.; TDirectory*TBranch::fDirectory! Pointer to directory where this branch buffers are stored; Long64_tTBranch::fEntriesNumber of entries; TBuffer*TBranch::fEntryBuffer! Buffer used to directly pass the content without streaming; Long64_tTBranch::fEntryNumberCurrent entry number (last one filled in this branch); Int_tTBranch::fEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TStringTBranch::fFileNameName of file where buffers are stored ("""" if in same file as Tree header); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTBranch::fFirstBasketEntry! First entry in the curre",MatchSource.WIKI,root/html530/THbookBranch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookBranch.html
https://root.cern/root/html530/THbookFile.html:2354,Availability,error,error,2354,"tual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; TObject*Get(Int_t id); const char*GetCurDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Int_tGetEntryBranch(Int_t entry, Int_t id); virtual const char*TObject::GetIconName() const; TList*GetList() const; TList*GetListOfKeys() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virt",MatchSource.WIKI,root/html530/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookFile.html
https://root.cern/root/html530/THbookFile.html:2438,Availability,error,error,2438,"_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; TObject*Get(Int_t id); const char*GetCurDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Int_tGetEntryBranch(Int_t entry, Int_t id); virtual const char*TObject::GetIconName() const; TList*GetList() const; TList*GetListOfKeys() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html530/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookFile.html
https://root.cern/root/html530/THbookFile.html:308,Integrability,interface,interface,308,". THbookFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HBOOK;  THbookFile. class THbookFile: public TNamed. This class is an interface to the Hbook objects in Hbook files; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:; gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser. Function Members (Methods); public:. THbookFile(); THbookFile(const THbookFile&); THbookFile(const char* fname, Int_t lrecl = 1024); virtual~THbookFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Bool_tcd(const char* dirname = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); vi",MatchSource.WIKI,root/html530/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookFile.html
https://root.cern/root/html530/THbookFile.html:792,Modifiability,variab,variables,792,". THbookFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HBOOK;  THbookFile. class THbookFile: public TNamed. This class is an interface to the Hbook objects in Hbook files; Any Hbook object (1-D, 2-D, Profile, RWN or CWN can be read; NB: a THbookFile can only be used in READ mode; Use the utility in $ROOTSYS/bin/h2root to convert Hbook to Root. Example of use:; gSystem->Load(""libHbook"");; THbookFile f(""myfile.hbook"");; f.ls();; TH1F *h1 = (TH1F*)f.Get(1); //import histogram ID=1 in h1; h1->Fit(""gaus"");; THbookTree *T = (THbookTree*)f.Get(111); //import ntuple header; T->Print(); //show the Hbook ntuple variables; T->Draw(""x"",""y<0""); // as in normal TTree::Draw. THbookFile can be browsed via TBrowser. Function Members (Methods); public:. THbookFile(); THbookFile(const THbookFile&); THbookFile(const char* fname, Int_t lrecl = 1024); virtual~THbookFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual Bool_tcd(const char* dirname = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); vi",MatchSource.WIKI,root/html530/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookFile.html
https://root.cern/root/html530/THbookFile.html:8179,Modifiability,variab,variables,8179,"bookFile(); the constructor. THbookFile(const char* fname, Int_t lrecl = 1024); Constructor for an HBook file object. ~THbookFile(); destructor. void Browse(TBrowser* b); to be implemented. Bool_t cd(const char* dirname = """"); change directory to dirname. void Close(Option_t* option = """"); Close the Hbook file. void DeleteID(Int_t id); remove id from file and memory. TObject * FindObject(const char* name) const; return object with name in fList in memory. TObject * FindObject(const TObject* obj) const; return object with pointer obj in fList in memory. TObject * Get(Int_t id); import Hbook object with identifier idd in memory. Int_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Read in memory all columns of entry number of ntuple id from the Hbook file. Int_t GetEntryBranch(Int_t entry, Int_t id); Read in memory only the branch bname. void InitLeaves(Int_t id, Int_t var, TTreeFormula* formula); This function is called from the first entry in TTreePlayer::InitLoop; It analyzes the list of variables involved in the current query; and pre-process the internal Hbook tables to speed-up the search; at the next entries. Bool_t IsOpen() const; Returns kTRUE in case file is open and kFALSE if file is not open. void SetBranchAddress(Int_t id, const char* bname, void* add); Set branch address. TFile * Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """"); Convert this Hbook file to a Root file with name rootname.; if rootname=""', rootname = hbook file name with .root instead of .hbook; By default, the Root file is connected and returned; option:; - ""NO"" do not connect the Root file; - ""C"" do not compress file (default is to compress); - ""L"" do not convert names to lower case (default is to convert). TObject * ConvertCWN(Int_t id); Convert the Column-Wise-Ntuple id to a Root Tree. TObject * ConvertRWN(Int_t id); Convert the Row-Wise-Ntuple id to a Root Tree. TObject * ConvertProfile(Int_t id); Convert an Hbook profile histogram into a Root ",MatchSource.WIKI,root/html530/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookFile.html
https://root.cern/root/html530/THbookFile.html:6924,Testability,log,logical,6924,"d, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfCurDirname of current directory; TList*fKeyslist of Hbook keys (Ids) on disk; TList*fListlist of objects in memory; Int_tfLreclRecord length in Hbook machine words; Int_tfLunFortran logical unit for this file; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Int_t*fgLuns; static Bool_tfgPawInit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THbookFile(); the constructor. THbookFile(const char* fname, Int_t lrecl = 1024); Constructor for an HBook file object. ~THbookFile(); destructor. void Browse(TBrowser* b); to be implemented. Bool_t cd(const char* dirname = """"); change directory to dirname. void Close(Option_t* option = """"); Close the Hbook file. void DeleteID(Int_t id); remove id from file and memory. TObject * FindObject(const char* name) const; return object with name in fList in memory. TObject * FindObject(const TObject* obj) const; return object with pointer obj in fList in memory. TObject * Get(Int_t id); import Hbook object with identifier idd in memory. Int_t GetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Read in memory all columns of entry num",MatchSource.WIKI,root/html530/THbookFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookFile.html
https://root.cern/root/html530/THbookKey.html:1332,Availability,error,error,1332,"); THbookKey(const THbookKey&); THbookKey(Int_t id, THbookFile* file); virtual~THbookKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html530/THbookKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookKey.html
https://root.cern/root/html530/THbookKey.html:1416,Availability,error,error,1416,"kKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html530/THbookKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookKey.html
https://root.cern/root/html530/THbookTree.html:5244,Availability,error,error,5244,"TTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTTree::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBra",MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:5328,Availability,error,error,5328,"ctory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTTree::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TTree::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*TTree::GetBranch(const char* name); virtual TBranchRef*TTree::GetBranchRef() const; virtual Bool_tTTree::GetBranchStatus(const char*",MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:16583,Deployability,update,updateExisting,16583,"Bit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THbookFile* file); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tc",MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:23885,Energy Efficiency,allocate,allocated,23885,hich share our addresses; Long64_t*TTree::fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*TTree::fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tTTree::fDebug! Debug level; Long64_tTTree::fDebugMax! Last entry number to debug; Long64_tTTree::fDebugMin! First entry number to debug; Int_tTTree::fDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*TTree::fDirectory! Pointer to directory holding this tree; Long64_tTTree::fEntriesNumber of entries; TEntryList*TTree::fEntryList! Pointer to event selection list (if one); Long64_tTTree::fEstimateNumber of entries to estimate histogram limits; TEventList*TTree::fEventList! Pointer to event selection list (if one); THbookFile*fFilepointer to Hbook file; Int_tTTree::fFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tTTree::fFlushedBytesNumber of autoflushed bytes; UInt_tTTree::fFriendLockStatus! Record which method is locking the friend recursion; TList*TTree::fFriendspointer to list of friend elements; Int_tfIDHbook identifier; TArrayITTree::fIndexIndex of sorted values; TArrayDTTree::fIndexValuesSorted index values; Bool_tfInitflag to know if branches computed; TObjArrayTTree::fLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buf,MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:304,Integrability,wrap,wrapper,304,". THbookTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HBOOK;  THbookTree. class THbookTree: public TTree. THbookTree. A wrapper class supporting Hbook ntuples (CWN and RWN).; The normal TTree calls can be used, including TTree::Draw().; Data read directly from the Hbook file via THbookFile. IMPORTANT NOTE; When setting the branch address (via THbookTree::SetBranchAddress); for a branch in an Hbook block containing several names, eg; Hbook block SELEVN with the following variables:. * 1 * R*4 * * * SELEVN * WGGS; * 2 * R*4 * * * SELEVN * AM12; * 3 * R*4 * * * SELEVN * AM34; * 4 * R*4 * * * SELEVN * AM14; * 5 * R*4 * * * SELEVN * AM32; * 6 * R*4 * * * SELEVN * PtPI(4); * 7 * R*4 * * * SELEVN * PHIPI(4); * 8 * R*4 * * * SELEVN * THTPI(4); one must define a C struct like:; struct {; Float_t Wggs;; Float_t Am12;; Float_t Am34;; Float_t Am14;; Float_t Am32;; Float_t Ptpi[4];; Float_t Phipi[4];; Float_t Thtpi[4];; } event;. and set ONLY the first variable address with:; h96->SetBranchAddress(""Wggs"",&event.Wggs);. Function Members (Methods); public:. THbookTree(); THbookTree(const char* name, Int_t id); virtual~THbookTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """,MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:659,Modifiability,variab,variables,659,". THbookTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HBOOK;  THbookTree. class THbookTree: public TTree. THbookTree. A wrapper class supporting Hbook ntuples (CWN and RWN).; The normal TTree calls can be used, including TTree::Draw().; Data read directly from the Hbook file via THbookFile. IMPORTANT NOTE; When setting the branch address (via THbookTree::SetBranchAddress); for a branch in an Hbook block containing several names, eg; Hbook block SELEVN with the following variables:. * 1 * R*4 * * * SELEVN * WGGS; * 2 * R*4 * * * SELEVN * AM12; * 3 * R*4 * * * SELEVN * AM34; * 4 * R*4 * * * SELEVN * AM14; * 5 * R*4 * * * SELEVN * AM32; * 6 * R*4 * * * SELEVN * PtPI(4); * 7 * R*4 * * * SELEVN * PHIPI(4); * 8 * R*4 * * * SELEVN * THTPI(4); one must define a C struct like:; struct {; Float_t Wggs;; Float_t Am12;; Float_t Am34;; Float_t Am14;; Float_t Am32;; Float_t Ptpi[4];; Float_t Phipi[4];; Float_t Thtpi[4];; } event;. and set ONLY the first variable address with:; h96->SetBranchAddress(""Wggs"",&event.Wggs);. Function Members (Methods); public:. THbookTree(); THbookTree(const char* name, Int_t id); virtual~THbookTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """,MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:1138,Modifiability,variab,variable,1138,"class description; function members; data members; class charts. ROOT;  HIST;  HBOOK;  THbookTree. class THbookTree: public TTree. THbookTree. A wrapper class supporting Hbook ntuples (CWN and RWN).; The normal TTree calls can be used, including TTree::Draw().; Data read directly from the Hbook file via THbookFile. IMPORTANT NOTE; When setting the branch address (via THbookTree::SetBranchAddress); for a branch in an Hbook block containing several names, eg; Hbook block SELEVN with the following variables:. * 1 * R*4 * * * SELEVN * WGGS; * 2 * R*4 * * * SELEVN * AM12; * 3 * R*4 * * * SELEVN * AM34; * 4 * R*4 * * * SELEVN * AM14; * 5 * R*4 * * * SELEVN * AM32; * 6 * R*4 * * * SELEVN * PtPI(4); * 7 * R*4 * * * SELEVN * PHIPI(4); * 8 * R*4 * * * SELEVN * THTPI(4); one must define a C struct like:; struct {; Float_t Wggs;; Float_t Am12;; Float_t Am34;; Float_t Am14;; Float_t Am32;; Float_t Ptpi[4];; Float_t Phipi[4];; Float_t Thtpi[4];; } event;. and set ONLY the first variable address with:; h96->SetBranchAddress(""Wggs"",&event.Wggs);. Function Members (Methods); public:. THbookTree(); THbookTree(const char* name, Int_t id); virtual~THbookTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 3",MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:16295,Performance,cache,cachesize,16295,"tual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THbookFile* file); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voi",MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:24370,Performance,load,loading,24370,rect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTypeRWN (0) or CWN (1); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); char*fXstorage area for RWN; Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch,MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THbookTree.html:3915,Usability,undo,undo,3915,"itlevel = 99); virtual TBranch*TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidTTree::Browse(TBrowser*); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); Int_tTTree::Debug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObjec",MatchSource.WIKI,root/html530/THbookTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THbookTree.html
https://root.cern/root/html530/THelix.html:2976,Availability,error,error,2976,"ual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& helix) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPolyLine3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidTPolyLine3D::DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTPolyLine3D::DrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyLine3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tTPolyLine3D::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine3D::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*TPolyLine3D::GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html530/THelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THelix.html
https://root.cern/root/html530/THelix.html:3060,Availability,error,error,3060,"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& helix) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPolyLine3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidTPolyLine3D::DrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidTPolyLine3D::DrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyLine3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tTPolyLine3D::GetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tTPolyLine3D::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*TPolyLine3D::GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_",MatchSource.WIKI,root/html530/THelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THelix.html
https://root.cern/root/html530/THelix.html:342,Energy Efficiency,charge,charge,342,". THelix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF3D;  G3D;  THelix. class THelix: public TPolyLine3D. THelix has two different constructors. If a particle with charge q passes through a point (x,y,z); with momentum (px,py,pz) with magnetic field B along an axis (nx,ny,nz),; this helix can be constrcuted like. THelix p(x,y,z, px,py,pz, q*B, nx,ny,nz);. (nx,ny,nz) defaults to (0,0,1). A helix in its own frame can be defined with a pivotal point; (x0,y0,z0), the velocity at that point (vx0,vy0,vz0), and; an angular frequency w. Combining vx0 and vy0 to a transverse; velocity vt0 one can parametrize the helix as. x(t) = x0 - vt0 / w * sin(-w * t + phi0); y(t) = y0 + vt0 / w * cos(-w * t + phi0); z(t) = z0 + vz0 * t. The second constructor has 6 parameters,. Example:; THelix pl1(xyz, v, w, range, rtype, axis);. where:; xyz : array of initial position; v : array of initial velocity; w : angular frequency; range: helix range; rtype: kHelixZ specifies allowed drawing range in helix Z direction, i.e., along B field.; kLabZ specifies drawing range in lab frame.; kHelixX, kHelixY, kLabX, kLabY, kUnchanged ... etc can also be specified; axis : helix axis. Example constructing a helix with several default values and drawing it:. This initializes a helix with its axis in Z direction (rtype=kHelixZ). Function Members (Methods); public:. THelix(); THelix(const THelix& helix); THelix(Double_t* xyz, Double_t* v, Double_t w, Double_t* range = 0, EHelixRangeType rtype = kHelixZ, Double_t* axis = 0); THelix(Double_t x, Double_t y, Double_t z, Double_t vx, Double_t vy, Double_t vz, Double_t w); virtual~THelix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject",MatchSource.WIKI,root/html530/THelix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THelix.html
https://root.cern/root/html530/THilbertMatrixTSym_double_.html:1756,Availability,error,error,1756,"rixTSym<double>(Int_t row_lwb, Int_t row_upb); virtual~THilbertMatrixTSym<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<double>::GetRowLwb() const; Int_tTMatrixTSymLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char*",MatchSource.WIKI,root/html530/THilbertMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixTSym_double_.html
https://root.cern/root/html530/THilbertMatrixTSym_double_.html:1840,Availability,error,error,1840," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<double>::GetRowLwb() const; Int_tTMatrixTSymLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* ",MatchSource.WIKI,root/html530/THilbertMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixTSym_double_.html
https://root.cern/root/html530/THilbertMatrixTSym_float_.html:1745,Availability,error,error,1745,"atrixTSym<float>(Int_t row_lwb, Int_t row_upb); virtual~THilbertMatrixTSym<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<float>::GetRowLwb() const; Int_tTMatrixTSymLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html530/THilbertMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixTSym_float_.html
https://root.cern/root/html530/THilbertMatrixTSym_float_.html:1829,Availability,error,error,1829," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTSymLazy<float>::GetRowLwb() const; Int_tTMatrixTSymLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html530/THilbertMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixTSym_float_.html
https://root.cern/root/html530/THilbertMatrixT_double_.html:1765,Availability,error,error,1765,"wb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~THilbertMatrixT<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTime",MatchSource.WIKI,root/html530/THilbertMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixT_double_.html
https://root.cern/root/html530/THilbertMatrixT_double_.html:1849,Availability,error,error,1849," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<double>::GetColLwb() const; Int_tTMatrixTLazy<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<double>::GetRowLwb() const; Int_tTMatrixTLazy<double>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html530/THilbertMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixT_double_.html
https://root.cern/root/html530/THilbertMatrixT_float_.html:1754,Availability,error,error,1754,"lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~THilbertMatrixT<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root/html530/THilbertMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixT_float_.html
https://root.cern/root/html530/THilbertMatrixT_float_.html:1838,Availability,error,error,1838," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTMatrixTLazy<float>::GetColLwb() const; Int_tTMatrixTLazy<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTMatrixTLazy<float>::GetRowLwb() const; Int_tTMatrixTLazy<float>::GetRowUpb() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html530/THilbertMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THilbertMatrixT_float_.html
https://root.cern/root/html530/THistPainter.html:884,Availability,error,error,884,". THistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HISTPAINTER;  THistPainter. class THistPainter: public TVirtualHistPainter. The histogram painter class. Introduction; Histograms' plotting options. Options supported for 1D and 2D histograms; Options supported for 1D histograms; Options supported for 2D histograms; Options supported for 3D histograms; Options supported for histograms' stacks (THStack). Setting the Style; Setting line, fill, marker, and text attributes; Setting Tick marks on the histogram axis; Giving titles to the X, Y and Z axis; The option ""SAME"". Limitations. Superimposing two histograms with different scales in the same pad; Statistics Display; Fit Statistics; The error bars options; The bar chart option; The ""BAR"" and ""HBAR"" options; The SCATter plot option (default for 2D histograms); The ARRow option; The BOX option; The COLor option; The TEXT and TEXTnn Option; The CONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box; Iso; Parametric plot. Introduction; Histograms are drawn ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:4513,Availability,error,error,4513,"new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:4637,Availability,error,error,4637,"new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:4903,Availability,error,errors,4903,"ad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A""",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:4943,Availability,error,error,4943,"ad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A""",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:4980,Availability,error,errors,4980,"l clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Cu",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6339,Availability,error,error,6339,"lot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6362,Availability,error,error,6362,"emoval. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resoluti",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6429,Availability,error,error,6429,"ot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resolution mode. By default, the histogram; is drawn in low resolution in case the number of b",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6490,Availability,error,error,6490," option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resolution mode. By default, the histogram; is drawn in low resolution in case the number of bins is greater than the number; of pixels in the c",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6580,Availability,error,error,6580," are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resolution mode. By default, the histogram; is drawn in low resolution in case the number of bins is greater than the number; of pixels in the current pad. This option should be combined with a ""drawi",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6656,Availability,error,error,6656,"etPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resolution mode. By default, the histogram; is drawn in low resolution in case the number of bins is greater than the number; of pixels in the current pad. This option should be combined with a ""drawing; option"" like ""H"" or ""L"". Options supported for 2D histograms. "" ""; Defa",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:6830,Availability,error,error,6830,"ptions supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A"" can be combined with any drawing option. For; instance, ""AC"" draws the histogram as a smooth Curve without axis. ""][""; When this option is selected the first and last vertical lines of the histogram; are not drawn. ""B""; Bar chart option. ""BAR""; Like option ""B"", but bars can be drawn with a 3D effect. ""HBAR""; Like option ""BAR"", but bars are drawn horizontally. ""C""; Draw a smooth Curve through the histogram bins. ""E""; Draw error bars. ""E0""; Draw error bars. Markers are drawn for bins with 0 contents. ""E1""; Draw error bars with perpendicular lines at the edges. ""E2""; Draw error bars with rectangles. ""E3""; Draw a fill area through the end points of the vertical error bars. ""E4""; Draw a smoothed filled area through the end points of the error bars. ""E5""; Like E3 but ignore the bins with 0 contents. ""E6""; Like E4 but ignore the bins with 0 contents. ""X0""; When used with one of the ""E"" option, it suppress the error bar along; X as gStyle->SetErrorX(0) would do. ""L""; Draw a line through the bin contents. ""P""; Draw current marker at each bin except empty bins. ""P0""; Draw current marker at each bin including empty bins. ""PIE""; Draw histogram as a Pie Chart. ""*H""; Draw histogram with a * at each bin. ""LF2""; Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws; also a fill area if the hist fill color is set but the fill area corresponds to; the histogram contour. ""9""; Force histogram to be drawn in high resolution mode. By default, the histogram; is drawn in low resolution in case the number of bins is greater than the number; of pixels in the current pad. This option should be combined with a ""drawing; option"" like ""H"" or ""L"". Options supported for 2D histograms. "" ""; Default (scatter plot). ""ARR""; Arrow mode. Shows gradient between adjacent cells. ""BOX""; A box is drawn for each cell with surface proportional to the content's; absolute value. A negative content is m",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:12732,Availability,avail,available,12732," drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutorial transpad.C for a variant; of this example. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; // create/fill draw h1; gStyle->SetOptStat(kFALSE);; TH1F *h1 = new TH1F(""h1"",""Supe",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:14817,Availability,error,error,14817,""",100,-3,3);; Float_t sum = 0;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:14886,Availability,error,error,14886,""",100,-3,3);; Float_t sum = 0;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:15046,Availability,error,error,15046,""",100,-3,3);; Float_t sum = 0;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:15109,Availability,error,error,15109,""",100,-3,3);; Float_t sum = 0;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; Float_t rightmax = 1.1*hint1->GetMaximum();; Float_t scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; TGaxis *axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; return c1;; }; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:16062,Availability,error,error,16062,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:16125,Availability,error,error,16125,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:16270,Availability,error,error,16270,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:16329,Availability,error,error,16329,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:18590,Availability,error,errors,18590,"stics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErro",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:18746,Availability,error,errors,18746,"change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through t",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:18965,Availability,error,error,18965,"> st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following examp",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19014,Availability,error,error,19014," with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new T",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19086,Availability,error,error,19086,"SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19200,Availability,error,error,19200,"bove).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19289,Availability,error,error,19289,"). and activate it again with:. h->SetStats(1). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRan",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19460,Availability,error,error,19460,"ault = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar c",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19704,Availability,error,error,19704,"(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as sh",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19755,Availability,error,error,19755,"(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as sh",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:19781,Availability,error,error,19781," the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Picture; Source. {; int i;; const Int_t nx = 8;; char *os_X[nx] = ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:30431,Availability,error,errors,30431," = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol2->Fill(px,5*py);; }; hcol2->Fill(0,0,-200);; gStyle->SetPalette(1);; hcol2->Draw(""COLZ"");; return c1;; }; The TEXT and TEXTnn Option; For each bin the content is printed. The text attributes are:. text font = current TStyle font (gStyle->SetTextFont()).; text size = 0.02*padheight*markersize (if h is the histogram drawn; with the option ""TEXT"" the marker size can be changed with; h->SetMarkerSize(markersize)).; text color = marker color. By default the format ""g"" is used. This format can be redefined; by calling gStyle->SetPaintTextFormat().; It is also possible to use ""TEXTnn"" in order to draw the text with; the angle nn (0 < nn < 90).; For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling gStyle->SetHistMinimumZero().; For 1D histogram the text is plotted at a y position equal to the bin content.; For 2D histograms when the option ""E"" (errors) is combined with the option; text (""TEXTE""), the error for each bin is also printed. Picture; Source. {; TCanvas *c01 = new TCanvas(""c01"",""c01"",700,400);; c01->Divide(2,1);; TH1F *htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; TH2F *htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; htext1->Fill(px,0.1);; htext2->Fill(px,5*py,0.1);; }; gStyle->SetPaintTextFormat(""4.1f m"");; htext2->SetMarkerSize(1.8);; c01->cd(1);; htext2->Draw(""TEXT45"");; c01->cd(2);; htext1->Draw();; htext1->Draw(""TEXT0 SAME"");; return c01;; }; In the case of profile histograms it is possible to print the number; of entries instead of the bin content. It is enough to combine the; option ""E"" (for entries) with the option ""TEXT"". Picture; Source. {; TCanvas *c02 = new TCanvas(""c02"",""c02"",700,400);; c02->Divide(2,1);; gStyle->SetPaintTextFormat(""g"");. TProfile *profile = new TProfile(""profile"",""profile"",10,0,",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:30488,Availability,error,error,30488," = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol2->Fill(px,5*py);; }; hcol2->Fill(0,0,-200);; gStyle->SetPalette(1);; hcol2->Draw(""COLZ"");; return c1;; }; The TEXT and TEXTnn Option; For each bin the content is printed. The text attributes are:. text font = current TStyle font (gStyle->SetTextFont()).; text size = 0.02*padheight*markersize (if h is the histogram drawn; with the option ""TEXT"" the marker size can be changed with; h->SetMarkerSize(markersize)).; text color = marker color. By default the format ""g"" is used. This format can be redefined; by calling gStyle->SetPaintTextFormat().; It is also possible to use ""TEXTnn"" in order to draw the text with; the angle nn (0 < nn < 90).; For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling gStyle->SetHistMinimumZero().; For 1D histogram the text is plotted at a y position equal to the bin content.; For 2D histograms when the option ""E"" (errors) is combined with the option; text (""TEXTE""), the error for each bin is also printed. Picture; Source. {; TCanvas *c01 = new TCanvas(""c01"",""c01"",700,400);; c01->Divide(2,1);; TH1F *htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; TH2F *htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; htext1->Fill(px,0.1);; htext2->Fill(px,5*py,0.1);; }; gStyle->SetPaintTextFormat(""4.1f m"");; htext2->SetMarkerSize(1.8);; c01->cd(1);; htext2->Draw(""TEXT45"");; c01->cd(2);; htext1->Draw();; htext1->Draw(""TEXT0 SAME"");; return c01;; }; In the case of profile histograms it is possible to print the number; of entries instead of the bin content. It is enough to combine the; option ""E"" (for entries) with the option ""TEXT"". Picture; Source. {; TCanvas *c02 = new TCanvas(""c02"",""c02"",700,400);; c02->Divide(2,1);; gStyle->SetPaintTextFormat(""g"");. TProfile *profile = new TProfile(""profile"",""profile"",10,0,",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:67113,Availability,error,errors,67113," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:68176,Availability,error,errors,68176," stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params);; TH2F *h2stb = new TH2F(""h2stb"",""h2stb"",20,-4,4,20,-4,4);; h2stb->SetFillColor(46);; h2stb->FillRandom(""f2"",3000);; a->Add(h2sta);; a->Add(h2stb);; a->Draw();; return cst;; }; If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option ""HIST"" should be used. Picture; Source. {; TCanvas *cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. TH1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the ; ""Fr",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:68231,Availability,error,error,68231," stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params);; TH2F *h2stb = new TH2F(""h2stb"",""h2stb"",20,-4,4,20,-4,4);; h2stb->SetFillColor(46);; h2stb->FillRandom(""f2"",3000);; a->Add(h2sta);; a->Add(h2stb);; a->Draw();; return cst;; }; If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option ""HIST"" should be used. Picture; Source. {; TCanvas *cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. TH1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the ; ""Fr",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:68267,Availability,error,errors,68267,"olor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = new TH2F(""h2sta"",""h2sta"",20,-4,4,20,-4,4);; h2sta->SetFillColor(38);; h2sta->FillRandom(""f1"",4000);; TF2 *f2 = new TF2(""f2"",""xygaus + xygaus(5)"",-4,4,-4,4);; Double_t params[] = {100,-1.4,1.9,1.1,2, 80,2,0.7,-2,0.5};; f2->SetParameters(params);; TH2F *h2stb = new TH2F(""h2stb"",""h2stb"",20,-4,4,20,-4,4);; h2stb->SetFillColor(46);; h2stb->FillRandom(""f2"",3000);; a->Add(h2sta);; a->Add(h2stb);; a->Draw();; return cst;; }; If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option ""HIST"" should be used. Picture; Source. {; TCanvas *cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. TH1F * hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. TH1F * hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:76068,Availability,error,error,76068," virtual~THistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDefineColorLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static const char*GetBestFormat(Double_t v, Double_t e, const char* f); virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:76152,Availability,error,error,76152,"ual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDefineColorLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static const char*GetBestFormat(Double_t v, Double_t e, const char* f); virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetStack() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; static TVirtualHistPainter*TVirtualHistPainter::HistPainter(TH1* obj); virtual ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:86175,Availability,error,error,86175,"d is painted (if needed). This allows; to draw the grid and the axis separately. In THistPainter::Paint this; feature is used to make sure that the grid is drawn in the background and; the axis tick marks in the foreground of the pad.; ; . void PaintBar(Option_t* option). Draw a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:86247,Availability,error,errors,86247,"eparately. In THistPainter::Paint this; feature is used to make sure that the grid is drawn in the background and; the axis tick marks in the foreground of the pad.; ; . void PaintBar(Option_t* option). Draw a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:91238,Availability,error,error,91238,"ather large, thus incorrectly giving the impression that, for example,; Greenland is larger than South America. In reality, the latter is about eight times the size of; Greenland. Also, the Former Soviet Union looks much bigger than Africa or South America. One may wonder; whether this illusion has had any influence on U.S. foreign policy.' (Source: GMT); code from Ernst-Jan Buis; ; . Int_t ProjectSinusoidal2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function code from Ernst-Jan Buis; ; . Int_t ProjectParabolic2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function code from Ernst-Jan Buis; ; . void RecalculateRange(). Recompute the histogram range following graphics operations.; ; . void SetHistogram(TH1* h). Set current histogram to ""h"".; ; . Int_t TableInit(). Initialize various options to draw 2D histograms.; ; . const char * GetBestFormat(Double_t v, Double_t e, const char* f). This function returns the best format to print the error value (e); knowing the parameter value (v) and the format (f) used to print it.; ; . void SetShowProjection(const char* option, Int_t nbins). Set projection.; ; . void ShowProjectionX(Int_t px, Int_t py). Show projection onto X.; ; . void ShowProjectionY(Int_t px, Int_t py). Show projection onto Y.; ; . void ShowProjection3(Int_t px, Int_t py). Show projection (specified by fShowProjection) of a TH3.; The drawing option for the projection is in fShowOption.; ; First implementation; R.Brun ; Full implementation: Tim Tran (timtran@jlab.org) April 2006; ; . THistPainter(). TList * GetStack() const; {return fStack;}. void RecursiveRemove(TObject* ); {;}. void SetStack(TList* stack); {fStack = stack;}.  Author: Rene Brun 26/08/99  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/histpainter:$Id: THistPainter.h 36953 2010-11-25 17:27:16Z couet $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the docu",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:3371,Deployability,update,updated,3371," a histogram ""h"" is enough to do:. h->Draw();. ""h"" can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a central singleton painter painting all histograms, allows; two histograms to be drawn in two threads without overwriting the painter's; values.; When a displayed histogram is filled again, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects; before drawing the new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:3390,Deployability,update,updated,3390,"ram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a central singleton painter painting all histograms, allows; two histograms to be drawn in two threads without overwriting the painter's; values.; When a displayed histogram is filled again, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects; before drawing the new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:16856,Deployability,update,updated,16856,"w (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:36913,Energy Efficiency,meter,meters,36913,"ours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavelength);; }. for(Int_t i=0; i < nPhiSamples; i++){; phi[i] = (i)*dPhi;; FofPhi[i] = sin(phi[i]);; }. // Create Histogram; TH2D *HistStreamFn = new TH2D(""HstreamFn"",; ""#splitline{Histogram with negative and positive contents. Six contours are defined.}{It is plotted with options CONT LIST to retrieve the contours points in TGraphs}"",; nZsamples, z[0], z[nZsamples-1], nPhiSamples, phi[0], phi[nPhiSamples-1]);. // Load Histogram Data; for (Int_t i = 0; i < nZsamples; i++) {; for(Int_t j = 0; j < nPhiSamples; j++){; HistStreamFn->SetBinContent(i,j, HofZ[i]*FofPhi[j]);; }; }. gStyle->SetPalette(1);; gStyle->SetOptStat(0);; gStyle->SetTitleW(0.99);; gStyle->SetTitleH(0.08);. Double_t contou",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:61191,Energy Efficiency,green,green,61191,"color number; in colors[N], etc. If the maximum cell content is greater than; ncolors, all cell contents are scaled to ncolors.; If ncolors <= 0, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ...; If ncolors == 1 && colors == 0, a pretty palette with a violet to; red spectrum is created. It is recommended you use this palette when drawing; legos, surfaces or contours.; If ncolors > 50 and colors=0, the DeepSea palette is used.; (see TColor::CreateGradientColorTable for more details); If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the Draw() option.; For example, with a TCutG named ""cutg"", one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a ""-"" in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts ("","" means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Picture; Source. #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h"". //+ Fitting a 2-D histogram (a variant); // This tutorial illustrates :; // - how to create a 2-d function; // - fill a 2-d histogram randomly from this function; // - fit the histogram; // - display the fitted function on top of the histogram (lego-plot); // using a surface plot in a sub-range of the histogram.; //; // T",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:72610,Energy Efficiency,green,green,72610," set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:74011,Energy Efficiency,green,green,74011,"atus bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal part of plot. This box; can be moved inside the plot's area (the full size of the box is; equal to the plot's surrounding box) by selecting one of the box; cut axes and pressing the left mouse button to move it.; Plot specific interactions (dynamic slicing etc.); Currently, all gl-plots support some form of slicing. When back plane; is selected (and if it's highlighted in green) you can press and hold; left mouse button and shift key and move this back plane inside; plot's area, creating the slice. During this ""slicing"" plot becomes; semi-transparent. To remove all slices (and projected curves for; surfaces) double click with left mouse button in a plot's area.; Surface with option ""GLSURF""; The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing 'p' or 'P' key.; TF3; The contour plot is drawn on the slicing plane. For TF3 the color; scheme can be changed by pressing 's' or 'S'.; Box; The contour plot corresponding to slice plane position is drawn in real time.; Iso; Slicing is similar to ""GLBOX"" option.; Parametric plot; No slicing. Additional keys: 's' or 'S' to change color scheme -; about 20 color schemes supported ('s' for ""scheme""); 'l' or 'L' to; increase number of polygons ('l' for ""level"" of details), 'w' or 'W'; to show outlines ('w' for ""wireframe"").; . Function Members (Methods); public:. THistPainter(); THistPain",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:59120,Integrability,interface,interface,59120,"61664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };. Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Poly *p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);. TFile *f;; f = TFile::Open(""http://root.cern.ch/files/usa.root"");. TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while (key = (TKey*)nextkey()) {; obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }. for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);. gStyle->SetOptStat(11);; gStyle->SetPalette(1);; p->Draw(""COLZ L"");; return ch2p2;; }; TH2Poly histograms can also be plotted using the GL interface using; the option ""GLLEGO"".; The SPEC option; This option allows to use the TSpectrum2Painter tools. See the full; documentation in TSpectrum2Painter::PaintSpectrum.; Option ""Z"" : Adding the color palette on the right side of the pad; When this option is specified, a color palette with an axis indicating the value; of the corresponding color is drawn on the right side of the picture. In case,; not enough space is left, one can increase the size of the right margin by; calling TPad::SetRightMargin(). The attributes used to display the; palette axis values are taken from the Z axis of the object. For example, to; set the labels size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). WARNING: The palette axis is always drawn vertically.; Setting the color palette; To change the color palette TStyle::SetPalette should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option ""COL"" draws a 2D histogram with",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:84913,Integrability,rout,routine,84913,"with all histogram drawing options.; ; . void ExecuteEvent(Int_t event, Int_t px, Int_t py). Execute the actions corresponding to ""event"".; ; This function is called when a histogram is clicked with the locator at; the pixel position px,py.; ; . TList * GetContourList(Double_t contour) const. Get a contour (as a list of TGraphs) using the Delaunay triangulation.; ; . char * GetObjectInfo(Int_t px, Int_t py) const. Display the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py.; ; . Bool_t IsInside(Int_t x, Int_t y). Return kTRUE if the cell ix, iy is inside one of the graphical cuts.; ; . Bool_t IsInside(Double_t x, Double_t y). Return kTRUE if the point x,y is inside one of the graphical cuts.; ; . Int_t MakeChopt(Option_t* option). Decode string ""choptin"" and fill Hoption structure.; ; . Int_t MakeCuts(char* cutsopt). Decode string ""choptin"" and fill Graphical cuts structure.; ; . void Paint(Option_t* option = """"). Control routine to paint any kind of histograms.; . void PaintArrows(Option_t* option). Control function to draw a table as an arrow plot.; . void PaintAxis(Bool_t drawGridOnly = kFALSE). Draw axis (2D case) of an histogram.; ; If drawGridOnly is TRUE, only the grid is painted (if needed). This allows; to draw the grid and the axis separately. In THistPainter::Paint this; feature is used to make sure that the grid is drawn in the background and; the axis tick marks in the foreground of the pad.; ; . void PaintBar(Option_t* option). Draw a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Doubl",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:86451,Integrability,rout,routine,86451,"n a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or h",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:86635,Integrability,rout,routines,86635,"ontrol function to draw a 2D histogram as a box plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or histogramming; system.; ; . void PaintStat(Int_t dostat, TF1* fit). Draw the statistics box for 1D and profile histograms.; . void PaintStat2(Int_t dostat",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:86719,Integrability,rout,routines,86719,"on). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or histogramming; system.; ; . void PaintStat(Int_t dostat, TF1* fit). Draw the statistics box for 1D and profile histograms.; . void PaintStat2(Int_t dostat, TF1* fit). Draw the statistics box for 2D histograms.; . void PaintStat3(Int_t dostat, TF1*",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:87431,Integrability,depend,dependency,87431," void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint special objects like vectors and matrices.; This function is called via gROOT->ProcessLine to paint these objects; without having a direct dependency of the graphics or histogramming; system.; ; . void PaintStat(Int_t dostat, TF1* fit). Draw the statistics box for 1D and profile histograms.; . void PaintStat2(Int_t dostat, TF1* fit). Draw the statistics box for 2D histograms.; . void PaintStat3(Int_t dostat, TF1* fit). Draw the statistics box for 3D histograms.; . void PaintSurface(Option_t* option). Control function to draw a 2D histogram as a surface plot.; . void PaintTriangles(Option_t* option). Control function to draw a table using Delaunay triangles.; ; . void DefineColorLevels(Int_t ndivz). Define the color levels used to paint legos, surfaces etc..; ; . void PaintTable(Option_t* option). Control function to draw 2D/3D histograms (tables).; . void PaintTH2PolyBins(Option_t* option). Control function to draw a TH2Poly bins' contours.; option = ""F"" draw the bins as filled areas.; option = ""L"" draw the bins as line.; option = ""P"" draw the bins as markers.; ; . void PaintTH2PolyColorLevels(Option",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:89330,Integrability,message,message,89330,"ion = ""P"" draw the bins as markers.; ; . void PaintTH2PolyColorLevels(Option_t* option). Control function to draw a TH2Poly as a color plot.; . void PaintTH2PolyScatterPlot(Option_t* option). Control function to draw a TH2Poly as a scatter plot.; . void PaintTH2PolyText(Option_t* option). Control function to draw a TH2Poly as a text plot.; . void PaintText(Option_t* option). Control function to draw a 1D/2D histograms with the bin values.; . void PaintTF3(). Control function to draw a 3D implicit functions.; . void PaintTitle(). Draw the histogram title; ; The title is drawn according to the title alignment returned by; GetTitleAlign(). It is a 2 digits integer): hv; ; where ""h"" is the horizontal alignment and ""v"" is the; vertical alignment.; ; ""h"" can get the values 1 2 3 for left, center, and right; ""v"" can get the values 1 2 3 for bottom, middle and top; ; for instance the default alignment is: 13 (left top); ; . void ProcessMessage(const char* mess, const TObject* obj). Process message ""mess"".; ; . Int_t ProjectAitoff2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function.; Convert Right Ascension, Declination to X,Y using an AITOFF projection.; This procedure can be used to create an all-sky map in Galactic; coordinates with an equal-area Aitoff projection. Output map; coordinates are zero longitude centered.; Also called Hammer-Aitoff projection (first presented by Ernst von Hammer in 1892); ; source: GMT; code from Ernst-Jan Buis; ; . Int_t ProjectMercator2xy(Double_t l, Double_t b, Double_t& Al, Double_t& Ab). Static function ; Probably the most famous of the various map projections, the Mercator projection; takes its name from Mercator who presented it in 1569. It is a cylindrical, conformal projection; with no distortion along the equator.; The Mercator projection has been used extensively for world maps in which the distortion towards; the polar regions grows rather large, thus incorrectly giving the impression that, for example,; Greenla",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:11295,Modifiability,inherit,inherit,11295,"""BOX""; Draw a for each cell with volume proportional to the content's absolute value. ""LEGO""; Same as BOX. Options supported for histograms' stacks (THStack). "" ""; Default, the histograms are drawn on top of each other (as lego plots for 2D; histograms). ""NOSTACK""; Histograms in the stack are all paint in the same pad as if the option; ""SAME"" had been specified. ""PADS""; The current pad/canvas is subdivided into a number of pads equal to the number; of histograms in the stack and each histogram is paint into a separate pad. Setting the Style; Histograms use the current style (gStyle). When one changes the current; style and would like to propagate the changes to the histogram,; TH1::UseCurrentStyle should be called. Call UseCurrentStyle on; each histogram is needed. To force all the histogram to use the current style use:. gROOT->ForceStyle();. All the histograms read after this call will use the current style.; Setting line, fill, marker, and text attributes; The histogram classes inherit from the attribute classes:; TAttLine, TAttFill, TAttMarker and TAttText.; See the description of these classes for the list of options.; Setting Tick marks on the histogram axis; The TPad::SetTicks method specifies the type of tick marks on the axis.; If tx = gPad->GetTickx() and ty = gPad->GetTicky() then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:24516,Performance,scalab,scalable,24516,"rawCopy(""bar2,same"");; ; TLegend *legend = new TLegend(0.55,0.65,0.76,0.82);; legend->AddEntry(h1,""All nations"",""f"");; legend->AddEntry(h2,""French only"",""f"");; legend->Draw();; ; c1->cd();; delete f;; return c1;; }; To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:24592,Performance,scalab,scalable,24592,"try(h1,""All nations"",""f"");; legend->AddEntry(h2,""French only"",""f"");; legend->Draw();; ; c1->cd();; delete f;; return c1;; }; To control the bar width (default is the bin width) TH1::SetBarWidth(); should be used. To control the bar offset (default is 0) TH1::SetBarOffset() should; be used. These two parameters are useful when several histograms are plotted using; the option SAME. They allow to plot the histograms next to each other.; The SCATter plot option (default for 2D histograms); For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above; kNMAX contents are normalized to kNMAX (kNMAX=2000).; If option is of the form ""scat=ff"", (eg scat=1.8,; scat=1e-3), then ff is used as a scale factor to compute the; number of dots. ""scat=1"" is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the TAttMarker; documentation). To change the marker size, a scalable marker type should be; used. For instance a circle (marker style 20). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5"");; return c1;; }; The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; return c1;; }; The BOX option; For each cell (i,j) a box is drawn. The size (surface) of the box is; proportional to the ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:35766,Performance,perform,performed,35766,"ace; colors to distinguish contours (""SURF"" option at theta = 0). Combined; with the option ""CONT"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(1);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:72458,Performance,perform,performed,72458,"lt, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes:; When such a plane selected, it's highlighted in green if the; dynamic slicing by this plane is supported, and it's; highlighted in red, if the dynamic slicing is not supported.; The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. Rotation and zooming. Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametr",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:39834,Safety,avoid,avoid,39834,"+= contLevel->GetSize();; }. nGraphs = 0;. TCanvas* c1 = new TCanvas(""c1"",""Contour List"",610,0,600,600);; c1->SetTopMargin(0.15);; TH2F *hr = new TH2F(""hr"",; ""#splitline{Negative contours are returned first (highest to lowest). Positive contours are returned from}{lowest to highest. On this plot Negative contours are drawn in red and positive contours in blue.}"",; 2, -2, 2, 2, 0, 6.5);. hr->Draw();; Double_t x0, y0, z0;; TLatex l;; l.SetTextSize(0.03);; char val[20];. for(i = 0; i < TotalConts; i++){; contLevel = (TList*)conts->At(i);; if (i<3) z0 = contours[2-i];; else z0 = contours[i];; printf(""Z-Level Passed in as: Z = %f\n"", z0);. // Get first graph from list on curves on this level; curv = (TGraph*)contLevel->First();; for(j = 0; j < contLevel->GetSize(); j++){; curv->GetPoint(0, x0, y0);; if (z0<0) curv->SetLineColor(kRed);; if (z0>0) curv->SetLineColor(kBlue);; nGraphs ++;; printf(""\tGraph: %d -- %d Elements\n"", nGraphs,curv->GetN());. 	 // Draw clones of the graphs to avoid deletions in case the 1st; 	 // pad is redrawn.; gc = (TGraph*)curv->Clone();; gc->Draw(""C"");. sprintf(val,""%g"",z0);; l.DrawLatex(x0,y0,val);; curv = (TGraph*)contLevel->After(curv); // Get Next graph; }; }; c1->Update();; printf(""\n\n\tExtracted %d Contours and %d Graphs \n"", TotalConts, nGraphs );; gStyle->SetTitleW(0.);; gStyle->SetTitleH(0.);; return c1;; }. Double_t SawTooth(Double_t x, Double_t WaveLen){. // This function is specific to a sawtooth function with period; // WaveLen, symmetric about x = 0, and with amplitude = 1. Each segment; // is 1/4 of the wavelength.; //; // |; // /\ |; // / \ |; // / \ |; // / \; // /--------\--------/------------; // |\ /; // | \ /; // | \ /; // | \/; //. Double_t y;; if ( (x < -WaveLen/2) || (x > WaveLen/2)) y = -99999999; // Error X out of bounds; if (x <= -WaveLen/4) {; y = x + 2.0;; } else if ((x > -WaveLen/4) && (x <= WaveLen/4)) {; y = -x ;; } else if (( x > WaveLen/4) && (x <= WaveLen/2)) {; y = x - 2.0;; }; return y;; }; The following op",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:69960,Safety,avoid,avoid,69960,"ng example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:16959,Security,access,accessed,16959,"eter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:35847,Security,access,accessible,35847,"T"" (or ""CONT0""), the option ""Z""; allows to display the color palette defined by gStyle->SetPalette(). Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH2F *hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; gStyle->SetPalette(1);; hcont4->Draw(""CONT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsampl",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:36253,Security,access,access,36253,"NT4Z"");; return c1;; }; The default number of contour levels is 20 equidistant levels and can be changed; with TH1::SetContour() or TStyle::SetNumberContours().; The LIST option; When option ""LIST"" is specified together with option; ""CONT"", the points used to draw the contours are saved in; TGraph objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in TGraph objects once the pad is painted.; Therefore to use this functionnality in a macro, gPad->Update(); should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = gROOT->GetListOfSpecials()->FindObject(""contours""); Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where i is a contour number, and list contains a list of; TGraph objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example shows how to use this functionality. Picture; Source. // Getting Contours From TH2D; // Author: Josh de Bever; // CSI Medical Physics Group; // The University of Western Ontario; // London, Ontario, Canada; // Date: Oct. 22, 2004; // Modified by O.Couet (Nov. 26, 2004). TCanvas *ContourList(){. const Double_t PI = TMath::Pi();. TCanvas* c = new TCanvas(""c"",""Contour List"",0,0,600,600);; c->SetRightMargin(0.15);; c->SetTopMargin(0.15);. Int_t i, j, TotalConts;. Int_t nZsamples = 80;; Int_t nPhiSamples = 80;. Double_t HofZwavelength = 4.0; // 4 meters; Double_t dZ = HofZwavelength/(Double_t)(nZsamples - 1);; Double_t dPhi = 2*PI/(Double_t)(nPhiSamples - 1);. TArrayD z(nZsamples);; TArrayD HofZ(nZsamples);; TArrayD phi(nPhiSamples);; TArrayD FofPhi(nPhiSamples);. // Discretized Z and Phi Values; for ( i = 0; i < nZsamples; i++) {; z[i] = (i)*dZ - HofZwavelength/2.0;; HofZ[i] = SawTooth(z[i], HofZwavele",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:61757,Testability,log,logical,61757,"tColorTable for more details); If ncolors > 0 && colors == 0, the default palette is used; with a maximum of ncolors.; The default palette defines:. index 0 to 9 : shades of grey; index 10 to 19 : shades of brown; index 20 to 29 : shades of blue; index 30 to 39 : shades of red; index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item ""colors"" in the ""VIEW"" menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; TColor::SetRGB().; Drawing a sub-range of a 2D histogram; the [cutg] option; Using a TCutG object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the Draw() option.; For example, with a TCutG named ""cutg"", one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a ""-"" in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts ("","" means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Picture; Source. #include ""TF2.h""; #include ""TH2.h""; #include ""TCutG.h""; #include ""TMath.h"". //+ Fitting a 2-D histogram (a variant); // This tutorial illustrates :; // - how to create a 2-d function; // - fill a 2-d histogram randomly from this function; // - fit the histogram; // - display the fitted function on top of the histogram (lego-plot); // using a surface plot in a sub-range of the histogram.; //; // This example can be executed via the interpreter or/and the compiler; // root > .x fit2a.C; // root > .x fit2a.C++; //Author: Rene Brun; ; Double_t g2(Double_t *x, Double_t *par) {; Double_t r1 = Double_t((x[0]-par[1])/par[2]);; Double_t r2 = Double_t((x[1]-par[3])/par[4]);; return par[0]*TMath::Exp(-0.5*(r1*r1+r2*r2));; } ; Double_t fun2(Double_t *x, Double_t *par) {; Double_t *p1 = &par[0];; Double_t *p2 = &par[5];; Double_t *p3 = &par[10];; Double_t result = g2(x,p1) + g2(x,p2) + g2(x,p3);; return result;; ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:66326,Testability,test,test,66326," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:66513,Testability,test,test,66513," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:66702,Testability,test,test,66702," pad as if the option ""SAME"" had been specified. This allows to; compute X and Y scales common to all the histograms, like; TMultiGraph does for graphs.; If the option ""PADS"" is specified, the current pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad.; The following example shows various types of stacks. Picture; Source. TCanvas *hstack() {; // Example of stacked histograms: class THStack; //; // Author: Rene Brun; ; THStack *hs = new THStack(""hs"",""Stacked 1D histograms"");; //create three 1-d histograms; TH1F *h1st = new TH1F(""h1st"",""test hstack"",100,-4,4);; h1st->FillRandom(""gaus"",20000);; h1st->SetFillColor(kRed);; h1st->SetMarkerStyle(21);; h1st->SetMarkerColor(kRed);; hs->Add(h1st);; TH1F *h2st = new TH1F(""h2st"",""test hstack"",100,-4,4);; h2st->FillRandom(""gaus"",15000);; h2st->SetFillColor(kBlue);; h2st->SetMarkerStyle(21);; h2st->SetMarkerColor(kBlue);; hs->Add(h2st);; TH1F *h3st = new TH1F(""h3st"",""test hstack"",100,-4,4);; h3st->FillRandom(""gaus"",10000);; h3st->SetFillColor(kGreen);; h3st->SetMarkerStyle(21);; h3st->SetMarkerColor(kGreen);; hs->Add(h3st);; ; TCanvas *cst = new TCanvas(""cst"",""stacked hists"",10,10,700,700);; cst->SetFillColor(41);; cst->Divide(2,2);; // in top left pad, draw the stack with defaults; cst->cd(1);; hs->Draw();; // in top right pad, draw the stack in non-stack mode ; // and errors option; cst->cd(2);; gPad->SetGrid();; hs->Draw(""nostack,e1p"");; //in bottom left, draw in stack mode with ""lego1"" option; cst->cd(3);; gPad->SetFrameFillColor(17);; gPad->SetTheta(3.77);; gPad->SetPhi(2.9);; hs->Draw(""lego1"");. cst->cd(4);; //create two 2-D histograms and draw them in stack mode; gPad->SetFrameFillColor(17);; THStack *a = new THStack(""a"",""Stacked 2D histograms"");; TF2 *f1 = new TF2(""f1"",; ""xygaus + xygaus(5) + xylandau(10)"",-4,4,-4,4);; Double_t params[] = {130,-1.4,1.8,1.5,1, 150,2,0.5,-2,0.5, ; 3600,-2,0.7,-3,0.3};; f1->SetParameters(params);; TH2F *h2sta = ne",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:70717,Testability,log,logarithmic,70717,"(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:70778,Testability,log,logarithmic,70778,"o:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surfac",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:71211,Testability,log,logarithmic,71211,"rary. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:71295,Testability,log,logarithmic,71295,"enGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a lego plot. It works also for TH2Poly. ""GLLEGO2; Bins with color levels. ""GLLEGO3; Cylindrical bars. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y.; For surface plots (TF2 and TH2) the supported options are:. ""GLSURF"" ; Draw a surface. ""GLSURF1""; Surface with color levels. ""GLSURF2""; The same as ""GLSURF1"" but without polygon outlines. ""GLSURF3""; Color level projection on top of plot (works only in cartesian coordinate; system). ""GLSURF4""; Same as ""GLSURF"" but without polygon outlines. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis.; Additional options to SURF and LEGO - Coordinate systems:. "" ""; Default, cartesian coordinates system. ""POL""; Polar coordinates system. ""CYL""; Cylindrical coordinates system. ""SPH""; Spherical coordinates system. TH3 as boxes (spheres); The supported options are:. GLBOX"" ; TH3 as a set of boxes, size of box is proportional to bin content. GLBOX1""; The same as ""glbox"", but spheres are drawn instead of boxes. TH3 as iso-surface(s); The supported option is:. ""GLISO"" ; TH3 is drawn using iso-surfaces. TF3 (implicit function); The supported option is:. GLTF3"" ; Draw a TF3. Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric; equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods; DistancetoPrimitive() and ExecuteEvent(). That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's are",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:2085,Usability,usab,usable,2085,"TEXTnn Option; The CONTour options. The LIST option. The LEGO options; The ""SURFace"" options; Cylindrical, Polar, Spherical and PseudoRapidity/Phi options; Base line for bar-charts and lego plots; TH2Poly Drawing; The SPEC option; Option ""Z"" : Adding the color palette on the right side of the pad; Setting the color palette; Drawing a sub-range of a 2-D histogram; the [cutg] option; Drawing options for 3D histograms; Drawing option for histograms' stacks; Drawing of 3D implicit functions; Associated functions drawing; Drawing using OpenGL. General information: plot types and supported options; TH3 as boxes (spheres); TH3 as iso-surface(s); TF3 (implicit function); Parametric surfaces; Interaction with the plots; Selectable parts; Rotation and zooming; Panning; Box cut; Plot specific interactions (dynamic slicing etc.); Surface with option ""GLSURF""; TF3; Box; Iso; Parametric plot. Introduction; Histograms are drawn via the THistPainter class. Each histogram has a; pointer to its own painter (to be usable in a multithreaded program). When the; canvas has to be redrawn, the Paint function of each objects in the; pad is called. In case of histograms, TH1::Paint invokes directly; THistPainter::Paint.; To draw a histogram ""h"" is enough to do:. h->Draw();. ""h"" can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the Draw() method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. THistPainter offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a cen",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:3561,Usability,clear,clears,3561,"rs many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time; (TH1::Draw), it creates a THistPainter object and saves a; pointer to this ""painter"" as a data member of the histogram. The; THistPainter class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram have its own; painter rather than a central singleton painter painting all histograms, allows; two histograms to be drawn in two threads without overwriting the painter's; values.; When a displayed histogram is filled again, there is not need to call the; Draw() method again; the image will be refreshed the next time the; pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects; before drawing the new image of the histogram. One can use the ""SAME""; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads.; When a displayed histogram is deleted, its image is automatically removed; from the pad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing ",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:12541,Usability,clear,cleared,12541,"ifies the type of tick marks on the axis.; If tx = gPad->GetTickx() and ty = gPad->GetTicky() then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutor",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:20463,Usability,simpl,simple,20463,"s drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Picture; Source. {; TCanvas *ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; TH1F *he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; TH1F *he3 = he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; return ce4;; }; The bar chart option; The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with TH1::SetBarWidth(),; and the bar offset wihtin the bin, with TH1::SetBarOffset().; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Picture; Source. {; int i;; const Int_t nx = 8;; char *os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. TCanvas *cb = new TCanvas(""cb"",""cb"",600,400);; cb->SetGrid();. gStyle->SetHistMinimumZero();. TH1F *h1b = new TH1F(""h1b"",""Option B example"",nx,0,nx);; h1b->SetFillColor(4);; h1b->SetBarWidth(0.4);; h1b->SetBarOffset(0.1);; h1b->SetStats(0);; h1b->SetMi",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:55437,Usability,simpl,simple,55437,"BarOffset(0.5);; h2bh->SetStats(0);; for (i=1;i<=nx;i++) h2bh->Fill(os_X[i-1], d_35_1[i-1]);. h2bh->Draw(""hbar same"");. return cbh;; }; TH2Poly Drawing; The following options are supported:. ""SCAT""; Draw a scatter plot (default). ""COL""; Draw a color plot. All the none empty bins are painted. Empty bins are not; painted. ""COLZ""; Same as ""COL"". In addition the color palette is also drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTN""; Draw bin names as text. ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""L""; Draw the bins boundaries as lines.; The lines attibutes are the TGraphs ones. ""P""; Draw the bins boundaries as markers.; The markers attibutes are the TGraphs ones. ""F""; Draw the bins boundaries as filled polygons.; The filled polygons attibutes are the TGraphs ones. TH2Poly can; be drawn as a color plot (option COL). TH2Poly bins can have any; shapes. The bins are defined as graphs. The following macro is a very simple; example showing how to book a TH2Poly and draw it. Picture; Source. {; TCanvas *ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; TH2Poly *h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 4.7, 3.5};; h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(4, x3, y3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; Double_t fx[] = {0.1, -0.5, -0.7, 1};; Double_t fy[] = {0.01, -0.5, -0.5, 3};; Double_t fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; gStyle->SetPalette(1);; h2p->Draw(""col"");; return ch2p1;; }; Rectangular bins are a frequent case. The special version of; the AddBin method allows to define them more easily like; shown in the following example. Picture; Source. //This tutorial illustrates how to create",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:69632,Usability,simpl,simply,69632,"ew TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:83807,Usability,simpl,simple,83807,"raph2DPainter object; TH1*fHpointer to histogram to paint; TPainter3dAlgorithms*fLegopointer to a TPainter3dAlgorithms object; Int_tfNcutsNumber of graphical cuts; TPie*fPiepointer to a TPie in case of option PIE; TStringfShowOptionOption to draw the projection; Int_tfShowProjectionTrue if a projection must be drawn; TList*fStackPointer to stack of histograms (if any); TAxis*fXaxispointer to X axis; Double_t*fXbufX buffer coordinates; TAxis*fYaxispointer to Y axis; Double_t*fYbufY buffer coordinates; TAxis*fZaxispointer to Z axis. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THistPainter(). Default constructor.; ; . ~THistPainter(). Default destructor.; ; . Int_t DistancetoPrimitive(Int_t px, Int_t py). Compute the distance from the point px,py to a line.; ; Compute the closest distance of approach from point px,py to elements of; an histogram. The distance is computed in pixels units.; ; Algorithm:; Currently, this simple model computes the distance from the mouse to the; histogram contour only.; ; . void DrawPanel(). Display a panel with all histogram drawing options.; ; . void ExecuteEvent(Int_t event, Int_t px, Int_t py). Execute the actions corresponding to ""event"".; ; This function is called when a histogram is clicked with the locator at; the pixel position px,py.; ; . TList * GetContourList(Double_t contour) const. Get a contour (as a list of TGraphs) using the Delaunay triangulation.; ; . char * GetObjectInfo(Int_t px, Int_t py) const. Display the histogram info (bin number, contents, integral up to bin; corresponding to cursor position px,py.; ; . Bool_t IsInside(Int_t x, Int_t y). Return kTRUE if the cell ix, iy is inside one of the graphical cuts.; ; . Bool_t IsInside(Double_t x, Double_t y). Return kTRUE if the point x,y is inside one of the graphical cuts.; ; . Int_t MakeChopt(Option_t* option). Decode string ""choptin"" and fill Hoption structure.; ; . Int_t MakeCuts(char* cutsopt). Decode string ""choptin"" an",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THistPainter.html:86299,Usability,clear,clear,86299," make sure that the grid is drawn in the background and; the axis tick marks in the foreground of the pad.; ; . void PaintBar(Option_t* option). Draw a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject* obj, Option_t* option). Static function to paint specia",MatchSource.WIKI,root/html530/THistPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THistPainter.html
https://root.cern/root/html530/THLimitsFinder.html:1563,Availability,error,error,1563," THLimitsFinder(); THLimitsFinder(const THLimitsFinder&); virtual~THLimitsFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); virtual Int_tFindGoodLimits(TH1* h, ",MatchSource.WIKI,root/html530/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THLimitsFinder.html
https://root.cern/root/html530/THLimitsFinder.html:1647,Availability,error,error,1647," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); virtual Int_tFindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static THLimitsFinder*GetLimitsFinder(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObjec",MatchSource.WIKI,root/html530/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THLimitsFinder.html
https://root.cern/root/html530/THLimitsFinder.html:6384,Performance,optimiz,optimized,6384,"har* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder deri",MatchSource.WIKI,root/html530/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THLimitsFinder.html
https://root.cern/root/html530/THLimitsFinder.html:6808,Performance,optimiz,optimized,6808,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. static THLimitsFinder*fgLimitsFinder!Pointer to hist limits finder. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Old WMIN,WMAX .; BinLow,B",MatchSource.WIKI,root/html530/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THLimitsFinder.html
https://root.cern/root/html530/THLimitsFinder.html:7119,Performance,optimiz,optimized,7119,"ion documentation; THLimitsFinder(). ~THLimitsFinder(). Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax); compute the best axis limits for the X axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters; example:; With the input parameters xmin=-1.467 and xmax=2.344, the function; will compute better limits -1.8 and 2.7 and store them in the axis. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax); compute the best axis limits for the X and Y axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. Int_t FindGoodLimits(TH1* h, Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax); compute the best axis limits for the X, Y and Z axis.; If the bit kIsInteger is set, the number of channels is also recomputed.; The axis parameters are replaced by the optimized parameters. THLimitsFinder * GetLimitsFinder(); Return pointer to the current finder.; Create one if none exists; Use SetLimitsFinder to set a user defined finder. void SetLimitsFinder(THLimitsFinder* finder); This static function can be used to specify a finder derived from THLimitsFinder.; The finder may redefine the functions FindGoodLimits.; Note that the redefined functions may call THLimitsFinder::FindGoodLimits. void Optimize(Double_t A1, Double_t A2, Int_t nold, Double_t& BinLow, Double_t& BinHigh, Int_t& nbins, Double_t& BWID, Option_t* option = """"); static function to compute reasonable axis limits. Input parameters:. A1,A2 : Old WMIN,WMAX .; BinLow,BinHigh : New WMIN,WMAX .; nold : Old NDIV .; nbins : New NDIV . void OptimizeLimits(Int_t nbins, Int_t& newbins, Double_t& xmin, Double_t& xmax, Bool_t isInteger); Optimize axis limits.; When isInter=kTRUE, the function makes an integer binwidth; and recompute the number of bins accordingly. THLimitsFinder(). ",MatchSource.WIKI,root/html530/THLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THLimitsFinder.html
https://root.cern/root/html530/THnSparse.html:1765,Availability,error,errors,1765,"asses:; THnSparseD (typedef for THnSparse<ArrayD>): bin content held by a Double_t,; THnSparseF (typedef for THnSparse<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparse<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparse<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparse<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparse<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:4967,Availability,avail,available,4967,"THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnSparse* h); voidDivide(const THn",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:6408,Availability,error,error,6408,"E); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnSparse* h); voidDivide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tFill(const Double_t* x, Double_t w = 1.); Long64_tFill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """"); TAxis*GetAxis(Int_t dim) const; Long64_tGetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tGetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tGetBin(const char** name, Bool_t allocate = kTRUE); Double_tGetBinContent(const Int_t* idx) const; Double_tGetBinContent(Long64_t bin, Int_t* idx = 0) const; Double_tGetBinError(const Int_t* idx) const; Double_",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:6492,Availability,error,error,6492,"E); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidDivide(const THnSparse* h); voidDivide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tFill(const Double_t* x, Double_t w = 1.); Long64_tFill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """"); TAxis*GetAxis(Int_t dim) const; Long64_tGetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tGetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tGetBin(const char** name, Bool_t allocate = kTRUE); Double_tGetBinContent(const Int_t* idx) const; Double_tGetBinContent(Long64_t bin, Int_t* idx = 0) const; Double_tGetBinError(const Int_t* idx) const; Double_",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:14191,Availability,error,errors,14191,"Int_t* coord, Option_t* options) const; TObject*ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TObjArrayfAxesaxes of the histogram; TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Double_tfEntriesnumber of entries, spread over chunks; Long64_tfFilledBinsnumber of filled bins; Double_t*fIntegral! array with bin weight sums; enum THnSparse::fIntegralStatus! status of integral; Int_tfNdimensionsnumber of dimensions; Double_tfTsumwtotal sum of weights; Double_tfTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDfTsumwxtotal sum of weight*X for each dimension; TArrayDfTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(const Int_t* x, Double_t v = 1.); Add ""v"" to the content of bin with coordinates ""coord"". void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. THnSparse* CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; Create a new THnSparse object that is of the same type as *this,; but w",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17402,Availability,error,error,17402,"""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory o",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17447,Availability,error,errors,17447,"n range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is appr",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17578,Availability,error,error,17578,"x for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, a",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17618,Availability,error,errors,17618," is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:19109,Availability,error,errors,19109,"BinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select all but over- and; underflow bins (it instead resets the axis to ""no range selected"").; Instead, simply call; TAxis* axis12 = hsparse.GetAxis(12);; axis12->SetRange(1, axis12->GetNbins());; axis12->SetBit(TAxis::kAxisRange);; to deselect the under- and overflow bins in the 12th dimension. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. T",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:19640,Availability,error,errors,19640,"t allow to select all but over- and; underflow bins (it instead resets the axis to ""no range selected"").; Instead, simply call; TAxis* axis12 = hsparse.GetAxis(12);; axis12->SetRange(1, axis12->GetNbins());; axis12->SetBit(TAxis::kAxisRange);; to deselect the under- and overflow bins in the 12th dimension. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. THnSparse* Projection(Int_t ndim, const Int_t* dim, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const; Project all bins",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:19919,Availability,error,errors,19919,"w bins in the 12th dimension. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. THnSparse* Projection(Int_t ndim, const Int_t* dim, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:20333,Availability,error,errors,20333,"; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. THnSparse* Projection(Int_t ndim, const Int_t* dim, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. void Scale(Double_t c); Scale contents and errors of this histogram by c:; this = this * c; It does not modify the histogram's number of entries. void AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Add() implementation for both rebinned histograms and those with",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:20767,Availability,error,errors,20767,"lculated.; ""A"" ranges of the taget axes will be ignored. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, Option_t* option = """") const; Project all bins into a 3-dimensional histogram,; keeping only axes ""xDim"", ""yDim"", and ""zDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. THnSparse* Projection(Int_t ndim, const Int_t* dim, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. void Scale(Double_t c); Scale contents and errors of this histogram by c:; this = this * c; It does not modify the histogram's number of entries. void AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Add() implementation for both rebinned histograms and those with identical; binning. See THnSparse::Add(). void Add(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automati",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:20999,Availability,error,errors,20999,"et axes will be; kept, but only bins inside the selected range; will be filled. THnSparse* Projection(Int_t ndim, const Int_t* dim, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TObject* ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const; Project all bins into a ndim-dimensional THnSparse histogram,; keeping only axes in dim (specifying ndim dimensions); If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. void Scale(Double_t c); Scale contents and errors of this histogram by c:; this = this * c; It does not modify the histogram's number of entries. void AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Add() implementation for both rebinned histograms and those with identical; binning. See THnSparse::Add(). void Add(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consist binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnSparses. All THnSparses provided; in the list must have the same bin layout!. void Multiply(const THnSparse* h); M",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:22259,Availability,error,errors,22259,"HnSparse::Add(). void Add(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consist binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnSparses. All THnSparses provided; in the list must have the same bin layout!. void Multiply(const THnSparse* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:22279,Availability,error,errors,22279,"HnSparse::Add(). void Add(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consist binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnSparses. All THnSparses provided; in the list must have the same bin layout!. void Multiply(const THnSparse* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:22403,Availability,error,errors,22403," Sumw2 is automatically called for this; if not already set. void RebinnedAdd(const THnSparse* h, Double_t c = 1.); Add contents of h scaled by c to this histogram:; this = this + c * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set.; In contrast to Add(), RebinnedAdd() does not require consist binning of; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnSparses. All THnSparses provided; in the list must have the same bin layout!. void Multiply(const THnSparse* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the param",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:22754,Availability,error,errors,22754,"; this and h; instead, each bin's center is used to determine the target bin. Long64_t Merge(TCollection* list); Merge this with a list of THnSparses. All THnSparses provided; in the list must have the same bin layout!. void Multiply(const THnSparse* h); Multiply this histogram by histogram h; this = this * h; Note that if h has Sumw2 set, Sumw2 is automatically called for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void Set",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:23124,Availability,error,errors,23124,"d for this; if not already set. void Multiply(TF1* f, Double_t c = 1.); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin a",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:23225,Availability,error,errors,23225,".); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional h",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:23814,Availability,error,error,23814,"t THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:23867,Availability,error,errors,23867,"t THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:23933,Availability,error,error,23933,"f this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void Reset(Option_t* option = """"); Clear the his",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:23978,Availability,error,errors,23978,"f this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void Reset(Option_t* option = """"); Clear the his",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:24032,Availability,error,errors,24032,"hat if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional histogram, all ""blocks""; of 2*2*2 bins will be put into a bin. void SetTitle(const char* title); Change (i.e. set) the title. If title is in the form ""stringt;string0;string1;string2 ...""; the histogram title is set to stringt, the title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void Reset(Option_t* option = """"); Clear the histogram. Double_t ComputeIntegral(); Calculate the integral of the histogram. ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:25428,Availability,error,error,25428,"e title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void Reset(Option_t* option = """"); Clear the histogram. Double_t ComputeIntegral(); Calculate the integral of the histogram. void PrintBin(Long64_t idx, Option_t* options) const; Print bin with linex index ""idx"".; For valid options see PrintBin(Long64_t idx, Int_t* bin, Option_t* options). Bool_t PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; Print one bin. If ""idx"" is != -1 use that to determine the bin,; otherwise (if ""idx"" == -1) use the coordinate in ""bin"".; If ""options"" contains:; '0': only print bins with an error or content != 0; Return whether the bin was printed (depends on options). void PrintEntries(Long64_t from = 0, Long64_t howmany = -1, Option_t* options = 0) const; Print ""howmany"" entries starting at ""from"". If ""howmany"" is -1, print all.; If ""options"" contains:; 'x': print in the order of axis bins, i.e. (0,0,...,0), (0,0,...,1),...; '0': only print bins with content != 0. void Print(Option_t* option = """") const; Print a THnSparse. If ""option"" contains:; 'a': print axis details; 'm': print memory usage; 's': print statistics; 'c': print its content, too (this can generate a LOT of output!); Other options are forwarded to PrintEntries(). THnSparseArrayChunk& operator=(const THnSparse& ). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Int_t GetChunkSize() const; { return fChunkSize; }. THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. Long64_t Fill(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bi",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:27118,Availability,error,errors,27118,"nt != 0. void Print(Option_t* option = """") const; Print a THnSparse. If ""option"" contains:; 'a': print axis details; 'm': print memory usage; 's': print statistics; 'c': print its content, too (this can generate a LOT of output!); Other options are forwarded to PrintEntries(). THnSparseArrayChunk& operator=(const THnSparse& ). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Int_t GetChunkSize() const; { return fChunkSize; }. THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. Long64_t Fill(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bin index. Bool_t PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const. Int_t GetNChunks() const; { return fBinContent.GetEntriesFast(); }. TObjArray* GetListOfAxes(); { return &fAxes; }. TAxis* GetAxis(Int_t dim) const; { return (TAxis*)fAxes[dim]; }. Long64_t Fill(const Double_t* x, Double_t w = 1.). return Fill(const char** name, Double_t w = 1.). TList* GetListOfFunctions(); { return 0; }. Double_t GetWeightSum() const; { return fTsumw; }. Long64_t GetNbins() const; { return fFilledBins; }. Int_t GetNdimensions() const; { return fNdimensions; }. Bool_t GetCalculateErrors() const; { return fTsumw2 >= 0.; }. void CalculateErrors(Bool_t calc = kTRUE); Calculate errors (or not if ""calc"" == kFALSE). void SetEntries(Double_t entries); { fEntries = entries; }. Double_t GetSumw() const; { return fTsumw; }. Double_t GetSumw2() const; { return fTsumw2; }. Double_t GetSumwx(Int_t dim) const; { return fTsumwx[dim]; }. Double_t GetSumwx2(Int_t dim) const; { return fTsumwx2[dim]; }.  Author: Axel Naumann (2007-09-11)  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:583,Energy Efficiency,allocate,allocates,583,". THnSparse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparse. class THnSparse: public TNamed. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; THnSparseD (typedef for THnSparse<ArrayD>): bin content held by a Double_t,; THnSparseF (typedef for THnSparse<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparse<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparse<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparse<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparse<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:1850,Energy Efficiency,allocate,allocated,1850,"or THnSparse<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparse<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparse<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparse<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparse<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSp",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:3050,Energy Efficiency,reduce,reduced,3050,"sing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be; cout << hs.GetBinContent(0, coord);; cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << endl;. * Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial hist/sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; See the important remark in THnSparse::IsInRange() when excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by G",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:3812,Energy Efficiency,allocate,allocated,3812,"""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. * Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; See the important remark in THnSparse::IsInRange() when excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Functio",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:7063,Energy Efficiency,allocate,allocate,7063,,MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:7123,Energy Efficiency,allocate,allocate,7123,,MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:7183,Energy Efficiency,allocate,allocate,7183,,MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:12704,Energy Efficiency,allocate,allocate,12704,"Virtual(TBuffer& b); voidSumw2(); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*AddChunk(); voidAddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tCheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tFill(Long64_t bin, Double_t w); voidFillExMap(); virtual TArray*GenerateArray() const; Long64_tGetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*GetChunk(Int_t idx) const; Int_tGetChunkSize() const; THnSparseCompactBinCoord*GetCompactCoord() const; Bool_tIsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tPrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TObjArrayfAxesaxes of the histogram",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16536,Energy Efficiency,allocate,allocate,16536,"Bins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get e",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16605,Energy Efficiency,allocate,allocate,16605,"Bins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get e",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16647,Energy Efficiency,allocate,allocate,16647,"Bins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get e",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16709,Energy Efficiency,allocate,allocate,16709,"ging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the i",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16802,Energy Efficiency,allocate,allocate,16802,"ging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the i",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16844,Energy Efficiency,allocate,allocate,16844,"ging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the i",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16904,Energy Efficiency,allocate,allocate,16904,"gral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16983,Energy Efficiency,allocate,allocate,16983,"gral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17025,Energy Efficiency,allocate,allocate,17025,"gral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17741,Energy Efficiency,allocate,allocate,17741,"n index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select all but over- and; underflow bins (it instead resets the axis to ""no range selected"").;",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17831,Energy Efficiency,allocate,allocate,17831,"exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select all but over- and; underflow bins (it instead resets the axis to ""no range selected"").; Instead, simply call; TAxis* axis12 = hsparse.GetAxis(12);; axis12->SetRange(1, axis",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:17853,Energy Efficiency,allocate,allocate,17853,"exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin, Int_t* idx = 0) const; Return the content of the filled bin number ""idx"".; If coord is non-null, it will contain the bin's coordinates for each axis; that correspond to the bin. Double_t GetBinError(const Int_t* idx) const; Get error of bin with coordinates ""coord"" as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Double_t GetBinError(Long64_t linidx) const; Get error of bin addressed by linidx as. If errors are not enabled (via Sumw2() or CalculateErrors()); return sqrt(contents). Long64_t GetBinIndexForCurrentBin(Bool_t allocate); Return the index for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select all but over- and; underflow bins (it instead resets the axis to ""no range selected"").; Instead, simply call; TAxis* axis12 = hsparse.GetAxis(12);; axis12->SetRange(1, axis",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:15318,Integrability,depend,depending,15318,". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(const Int_t* x, Double_t v = 1.); Add ""v"" to the content of bin with coordinates ""coord"". void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. THnSparse* CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; Create a new THnSparse object that is of the same type as *this,; but with dimensions and bins given by axes.; If keepTargetAxis is true, the axes will keep their original xmin / xmax,; else they will be restricted to the range selected (first / last). TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); Create a THnSparse object from a histogram deriving from TH1. void FillExMap(); We have been streamed; set up fBins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:25487,Integrability,depend,depends,25487,"e title of axis0 to string0,; of axis1 to string1, of axis2 to string2, etc, just like it is done; for TH1/TH2/TH3.; To insert the character "";"" in one of the titles, one should use ""#;""; or ""#semicolon"". THnSparse* Rebin(const Int_t* group) const; Combine the content of ""group"" neighboring bins for each dimension; into a new bin and return the resulting THnSparse.; For group={2,1,1} and a 3 dimensional histogram, pairs of x-bins; will be grouped. void Reset(Option_t* option = """"); Clear the histogram. Double_t ComputeIntegral(); Calculate the integral of the histogram. void PrintBin(Long64_t idx, Option_t* options) const; Print bin with linex index ""idx"".; For valid options see PrintBin(Long64_t idx, Int_t* bin, Option_t* options). Bool_t PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; Print one bin. If ""idx"" is != -1 use that to determine the bin,; otherwise (if ""idx"" == -1) use the coordinate in ""bin"".; If ""options"" contains:; '0': only print bins with an error or content != 0; Return whether the bin was printed (depends on options). void PrintEntries(Long64_t from = 0, Long64_t howmany = -1, Option_t* options = 0) const; Print ""howmany"" entries starting at ""from"". If ""howmany"" is -1, print all.; If ""options"" contains:; 'x': print in the order of axis bins, i.e. (0,0,...,0), (0,0,...,1),...; '0': only print bins with content != 0. void Print(Option_t* option = """") const; Print a THnSparse. If ""option"" contains:; 'a': print axis details; 'm': print memory usage; 's': print statistics; 'c': print its content, too (this can generate a LOT of output!); Other options are forwarded to PrintEntries(). THnSparseArrayChunk& operator=(const THnSparse& ). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Int_t GetChunkSize() const; { return fChunkSize; }. THnSparseArrayChunk* GetChunk(Int_t idx) const. TArray* GenerateArray() const. Long64_t Fill(Long64_t bin, Double_t w); Increment the bin content of ""bin"" by ""w"",; return the bi",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:15749,Performance,perform,performed,15749,"r* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; Create a new THnSparse object that is of the same type as *this,; but with dimensions and bins given by axes.; If keepTargetAxis is true, the axes will keep their original xmin / xmax,; else they will be restricted to the range selected (first / last). TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); Create a THnSparse object from a histogram deriving from TH1. void FillExMap(); We have been streamed; set up fBins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n d",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:15811,Performance,perform,performance,15811,"r* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; Create a new THnSparse object that is of the same type as *this,; but with dimensions and bins given by axes.; If keepTargetAxis is true, the axes will keep their original xmin / xmax,; else they will be restricted to the range selected (first / last). TH1* CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); Create a THnSparse object from a histogram deriving from TH1. void FillExMap(); We have been streamed; set up fBins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n d",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:706,Security,access,access,706,". THnSparse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparse. class THnSparse: public TNamed. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; THnSparseD (typedef for THnSparse<ArrayD>): bin content held by a Double_t,; THnSparseF (typedef for THnSparse<ArrayF>): bin content held by a Float_t,; THnSparseL (typedef for THnSparse<ArrayL>): bin content held by a Long_t,; THnSparseI (typedef for THnSparse<ArrayI>): bin content held by an Int_t,; THnSparseS (typedef for THnSparse<ArrayS>): bin content held by a Short_t,; THnSparseC (typedef for THnSparse<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to; Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparse hs(""hs"", ""hs"", 2, bins, min, max);. * Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). * Fast Bin Content Access; When ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:4102,Security,hash,hash,4102,"Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; See the important remark in THnSparse::IsInRange() when excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); v",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:4148,Security,hash,hash,4148,"Projection() members. To only project parts of the; histogram, call; THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);; See the important remark in THnSparse::IsInRange() when excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); v",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:4270,Security,hash,hash,4270,"hen excluding under-; and overflow bins!. * Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:4495,Security,hash,hash,4495,"e compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* ",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:4697,Security,hash,hash,4697,"esentation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tComputeIntegral(); virtual voidTNamed::Copy(TObje",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:13699,Security,hash,hashes,13699,"Int_t* coord, Option_t* options) const; TObject*ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. private:. THnSparse&operator=(const THnSparse&). Data Members; public:. enum { kNoInt; kValidInt; kInvalidInt; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TObjArrayfAxesaxes of the histogram; TObjArrayfBinContentarray of THnSparseArrayChunk; TExMapfBins! filled bins; TExMapfBinsContinued! filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1); Int_tfChunkSizenumber of entries for each chunk; THnSparseCompactBinCoord*fCompactCoord! compact coordinate; Double_tfEntriesnumber of entries, spread over chunks; Long64_tfFilledBinsnumber of filled bins; Double_t*fIntegral! array with bin weight sums; enum THnSparse::fIntegralStatus! status of integral; Int_tfNdimensionsnumber of dimensions; Double_tfTsumwtotal sum of weights; Double_tfTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDfTsumwxtotal sum of weight*X for each dimension; TArrayDfTsumwx2total sum of weight*X*X for each dimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~THnSparse(); Destruct a THnSparse. void AddBinContent(const Int_t* x, Double_t v = 1.); Add ""v"" to the content of bin with coordinates ""coord"". void AddBinContent(Long64_t bin, Double_t v = 1.); Add ""v"" to the content of bin with index ""bin"". THnSparseArrayChunk* AddChunk(); Create a new chunk of bin content. THnSparse* CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; Create a new THnSparse object that is of the same type as *this,; but w",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:16042,Testability,log,log-likelihood,16042,"t TObjArray* axes, Bool_t keepTargetAxis) const; Create an empty histogram with name and title with a given; set of axes. Create a TH1D/TH2D/TH3D, depending on the number; of elements in axes. THnSparse* CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); Create a THnSparse object from a histogram deriving from TH1. void FillExMap(); We have been streamed; set up fBins. TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); Fit a THnSparse with function f. since the data is sparse by default a likelihood fit is performed; merging all the regions with empty bins for betetr performance efficiency. Since the THnSparse is not drawn no graphics options are passed; Here is the list of possible options. = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range. Long64_t GetBin(const Double_t* x, Bool_t allocate = kTRUE); Get the bin index for the n dimensional tuple x,; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const char* name[], Bool_t allocate /* = kTRUE */); Get the bin index for the n dimensional tuple addressed by ""name"",; allocate one if it doesn't exist yet and ""allocate"" is true. Long64_t GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Get the bin index for the n dimensional coordinates coord,; allocate one if it doesn't exist yet and ""allocate"" is true. Double_t GetBinContent(const Int_t* idx) const; Get content of bin with coordinates ""coord"". Double_t GetBinContent(Long64_t bin",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparse.html:18755,Usability,simpl,simply,18755," for fCurrentBinIndex.; If it doesn't exist then return -1, or allocate a new bin if allocate is set. THnSparseCompactBinCoord* GetCompactCoord() const; Return THnSparseCompactBinCoord object. void GetRandom(Double_t* rand, Bool_t subBinRandom = kTRUE); Generate an n-dimensional random tuple based on the histogrammed; distribution. If subBinRandom, the returned tuple will be additionally; randomly distributed within the randomized bin, using a flat; distribution. Double_t GetSparseFractionBins() const; Return the amount of filled bins over all bins. Double_t GetSparseFractionMem() const; Return the amount of used memory over memory that would be used by a; non-sparse n-dimensional histogram. The value is approximate. Bool_t IsInRange(Int_t* coord) const; Check whether bin coord is in range, as defined by TAxis::SetRange().; Currently, TAxis::SetRange() does not allow to select all but over- and; underflow bins (it instead resets the axis to ""no range selected"").; Instead, simply call; TAxis* axis12 = hsparse.GetAxis(12);; axis12->SetRange(1, axis12->GetNbins());; axis12->SetBit(TAxis::kAxisRange);; to deselect the under- and overflow bins in the 12th dimension. TH1D* Projection(Int_t xDim, Option_t* option = """") const; Project all bins into a 1-dimensional histogram,; keeping only axis ""xDim"".; If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored.; ""O"" original axis range of the taget axes will be; kept, but only bins inside the selected range; will be filled. TH2D* Projection(Int_t yDim, Int_t xDim, Option_t* option = """") const; Project all bins into a 2-dimensional histogram,; keeping only axes ""xDim"" and ""yDim"". WARNING: just like TH3::Project3D(""yx"") and TTree::Draw(""y:x""),; Projection(y,x) uses the first argument to define the y-axis and the; second for the x-axis!. If ""option"" contains ""E"" errors will be calculated.; ""A"" ranges of the taget axes will be ignored. TH3D* Projection(Int_t xDim, Int_t yDim, Int_t zDim, O",MatchSource.WIKI,root/html530/THnSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparse.html
https://root.cern/root/html530/THnSparseArrayChunk.html:466,Availability,error,errors,466,". THnSparseArrayChunk. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseArrayChunk. class THnSparseArrayChunk: public TObject. THnSparseArrayChunk is used internally by THnSparse. THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time. Function Members (Methods); public:. THnSparseArrayChunk(); THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); virtual~THnSparseArrayChunk(); voidTObject::AbstractMethod(const char* method) const; voidAddBin(Int_t idx, const Char_t* idxbuf); voidAddBinContent(Int_t idx, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:818,Availability,error,errors,818,". THnSparseArrayChunk. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseArrayChunk. class THnSparseArrayChunk: public TObject. THnSparseArrayChunk is used internally by THnSparse. THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time. Function Members (Methods); public:. THnSparseArrayChunk(); THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); virtual~THnSparseArrayChunk(); voidTObject::AbstractMethod(const char* method) const; voidAddBin(Int_t idx, const Char_t* idxbuf); voidAddBinContent(Int_t idx, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:1876,Availability,error,error,1876,"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:1960,Availability,error,error,1960,"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteE",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:6138,Availability,error,errors,6138,"idTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:6279,Availability,error,errors,6279," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash().  Author: Axel Naumann (2007-09-11)  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $  Last generat",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:6417,Availability,error,errors,6417,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash().  Author: Axel Naumann (2007-09-11)  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:6428,Availability,error,errors,6428,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash().  Author: Axel Naumann (2007-09-11)  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:6592,Availability,error,errors,6592,"unk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash().  Author: Axel Naumann (2007-09-11)  Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *;  Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseArrayChunk.html:5872,Energy Efficiency,allocate,allocated,5872,"idTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don",MatchSource.WIKI,root/html530/THnSparseArrayChunk.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:3360,Availability,error,error,3360,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:3444,Availability,error,error,3444,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:4108,Energy Efficiency,allocate,allocate,4108,,MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:4179,Energy Efficiency,allocate,allocate,4179,,MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:4250,Energy Efficiency,allocate,allocate,4250,,MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:10339,Energy Efficiency,allocate,allocate,10339,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayC_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayC>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseT<TArrayC>. class THnSparseT<TArrayC>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_r; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseC. Function Members (Methods); public:. THnSparseT<TArrayC>(); THnSparseT<TArrayC>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayC>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voi",MatchSource.WIKI,root/html530/THnSparseT_TArrayC_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayC_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:3360,Availability,error,error,3360,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:3444,Availability,error,error,3444,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:4108,Energy Efficiency,allocate,allocate,4108,,MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:4179,Energy Efficiency,allocate,allocate,4179,,MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:4250,Energy Efficiency,allocate,allocate,4250,,MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:10339,Energy Efficiency,allocate,allocate,10339,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayD_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayD>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseT<TArrayD>. class THnSparseT<TArrayD>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_r; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseD. Function Members (Methods); public:. THnSparseT<TArrayD>(); THnSparseT<TArrayD>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayD>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voi",MatchSource.WIKI,root/html530/THnSparseT_TArrayD_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayD_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:3360,Availability,error,error,3360,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:3444,Availability,error,error,3444,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:4108,Energy Efficiency,allocate,allocate,4108,,MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:4179,Energy Efficiency,allocate,allocate,4179,,MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:4250,Energy Efficiency,allocate,allocate,4250,,MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:10339,Energy Efficiency,allocate,allocate,10339,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayF_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayF>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseT<TArrayF>. class THnSparseT<TArrayF>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_r; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseF. Function Members (Methods); public:. THnSparseT<TArrayF>(); THnSparseT<TArrayF>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayF>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voi",MatchSource.WIKI,root/html530/THnSparseT_TArrayF_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayF_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:3360,Availability,error,error,3360,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:3444,Availability,error,error,3444,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:4108,Energy Efficiency,allocate,allocate,4108,,MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:4179,Energy Efficiency,allocate,allocate,4179,,MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:4250,Energy Efficiency,allocate,allocate,4250,,MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:10339,Energy Efficiency,allocate,allocate,10339,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayI_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayI>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseT<TArrayI>. class THnSparseT<TArrayI>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_r; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseI. Function Members (Methods); public:. THnSparseT<TArrayI>(); THnSparseT<TArrayI>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayI>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voi",MatchSource.WIKI,root/html530/THnSparseT_TArrayI_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayI_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:3360,Availability,error,error,3360,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:3444,Availability,error,error,3444,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:4108,Energy Efficiency,allocate,allocate,4108,,MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:4179,Energy Efficiency,allocate,allocate,4179,,MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:4250,Energy Efficiency,allocate,allocate,4250,,MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:10339,Energy Efficiency,allocate,allocate,10339,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayL_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayL>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseT<TArrayL>. class THnSparseT<TArrayL>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_r; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseL. Function Members (Methods); public:. THnSparseT<TArrayL>(); THnSparseT<TArrayL>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayL>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voi",MatchSource.WIKI,root/html530/THnSparseT_TArrayL_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayL_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:3360,Availability,error,error,3360,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:3444,Availability,error,error,3444,"ject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; Double_tTHnSparse::ComputeIntegral(); virtual voidTNamed::Copy(TObject& named) const; static THnSparse*THnSparse::CreateSparse(const char* name, const char* title, const TH1* h1, Int_t ChunkSize = 1024*16); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); voidTHnSparse::Divide(const THnSparse* h); voidTHnSparse::Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Long64_tTHnSparse::Fill(const Double_t* x, Double_t w = 1.); Long64_tTHnSparse::Fill(const char** name, Double_t w = 1.); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TFitResultPtrTHnSparse::Fit(TF1* f1, Option_t* option = """", Option_t* goption = """"); virtual TArray*GenerateArray() const; TAxis*THnSparse::GetAxis(Int_t dim) const; Long64_tTHnSparse::GetBin(const Int_t* idx, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const Double_t* x, Bool_t allocate = kTRUE); Long64_tTHnSparse::GetBin(const char** name, Bool_t allocate = kTRUE); Double_tTHnSparse::GetBinContent(const Int_t* idx",MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:4108,Energy Efficiency,allocate,allocate,4108,,MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:4179,Energy Efficiency,allocate,allocate,4179,,MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:4250,Energy Efficiency,allocate,allocate,4250,,MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:10339,Energy Efficiency,allocate,allocate,10339,"Error(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. THnSparseArrayChunk*THnSparse::AddChunk(); voidTHnSparse::AddInternal(const THnSparse* h, Double_t c, Bool_t rebinned); Bool_tTHnSparse::CheckConsistency(const THnSparse* h, const char* tag) const; THnSparse*THnSparse::CloneEmpty(const char* name, const char* title, const TObjArray* axes, Int_t chunksize, Bool_t keepTargetAxis) const; TH1*THnSparse::CreateHist(const char* name, const char* title, const TObjArray* axes, Bool_t keepTargetAxis) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tTHnSparse::Fill(Long64_t bin, Double_t w); voidTHnSparse::FillExMap(); Long64_tTHnSparse::GetBinIndexForCurrentBin(Bool_t allocate); THnSparseArrayChunk*THnSparse::GetChunk(Int_t idx) const; Int_tTHnSparse::GetChunkSize() const; THnSparseCompactBinCoord*THnSparse::GetCompactCoord() const; Bool_tTHnSparse::IsInRange(Int_t* coord) const; voidTObject::MakeZombie(); Bool_tTHnSparse::PrintBin(Long64_t idx, Int_t* coord, Option_t* options) const; TObject*THnSparse::ProjectionAny(Int_t ndim, const Int_t* dim, Bool_t wantSparse, Option_t* option = """") const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function doc",MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THnSparseT_TArrayS_.html:380,Integrability,interface,interfaces,380,". THnSparseT<TArrayS>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THnSparseT<TArrayS>. class THnSparseT<TArrayS>: public THnSparse. Templated implementation of the abstract base THnSparse.; All functionality and the interfaces to be used are in THnSparse!. THnSparse does not know how to store any bin content itself. Instead, this; is delegated to the derived, templated class: the template parameter decides; what the format for the bin content is. In fact it even defines the array; itself; possible implementations probably derive from TArray. Typedefs exist for template parematers with ROOT's generic types:. Templated name Typedef Bin content type; THnSparseT<TArrayC> THnSparseC Char_r; THnSparseT<TArrayS> THnSparseS Short_t; THnSparseT<TArrayI> THnSparseI Int_t; THnSparseT<TArrayL> THnSparseL Long_t; THnSparseT<TArrayF> THnSparseF Float_t; THnSparseT<TArrayD> THnSparseD Double_t. We recommend to use THnSparseC wherever possible, and to map its value space; of 256 possible values to e.g. float values outside the class. This saves an; enourmous amount of memory. Only if more than 256 values need to be; distinguished should e.g. THnSparseS or even THnSparseF be chosen. Implementation detail: the derived, templated class is kept extremely small; on purpose. That way the (templated thus inlined) uses of this class will; only create a small amount of machine code, in contrast to e.g. STL. This class is also known as (typedefs to this class)THnSparseS. Function Members (Methods); public:. THnSparseT<TArrayS>(); THnSparseT<TArrayS>(const char* name, const char* title, Int_t dim, const Int_t* nbins, const Double_t* xmin = 0, const Double_t* xmax = 0, Int_t chunksize = 1024*16); ~THnSparseT<TArrayS>(); voidTObject::AbstractMethod(const char* method) const; voidTHnSparse::Add(const THnSparse* h, Double_t c = 1.); voi",MatchSource.WIKI,root/html530/THnSparseT_TArrayS_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THnSparseT_TArrayS_.html
https://root.cern/root/html530/THostAuth.html:2327,Availability,error,error,2327,"t; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCountFailure(Int_t level); voidCountSuccess(Int_t level); TRootSecContext*CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); voidDeActivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; TList*Established() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDetails(Int_t level); const char*GetDetailsByIdx(Int_t idx) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFailure(Int_t idx) const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; Int_tGetMethod(Int_t idx) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetServer() const; Int_tGetSuccess(Int_t idx) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:2411,Availability,error,error,2411,"char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCountFailure(Int_t level); voidCountSuccess(Int_t level); TRootSecContext*CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); voidDeActivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; TList*Established() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDetails(Int_t level); const char*GetDetailsByIdx(Int_t idx) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFailure(Int_t idx) const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; Int_tGetMethod(Int_t idx) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetServer() const; Int_tGetSuccess(Int_t idx) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUser() const; virtual Bool_tTObject::HandleTimer(TTimer* tim",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:10759,Availability,failure,failures,10759," Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local list; Return pointer to it to be stored in TAuthenticate. void AsString(TString& out) const; Return a static string with all info in a serialized form. Int_t NumMethods() const; { return fNumMethods; }. Int_t GetMethod(Int_t idx) const; { return fMethods[idx]; }. Int_t GetFailure(Int_t idx) const; { return fFailure[idx]; }. Int_t GetSuccess(Int_t idx) const; { return fSuccess[idx]; }. Bool_t IsActive() const; { return fActive; }. void DeActivate(); { fActive = kFALSE; }. void Activate(); { fActive = kTRUE; }. const char * GetDetailsByIdx(Int_t idx) const; { return fDetails[idx]; }. const char * GetHost() const; { return fHost; }. Int_t GetServer() const; { return (Int_t)fServer; }. const char * GetUser() const; { r",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:335,Security,authenticat,authentication,335,". THostAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  NET;  AUTH;  THostAuth. class THostAuth: public TObject. THostAuth. Contains details about host-specific authentication methods and the; result of their application.; Used by TAuthenticate. Function Members (Methods); public:. THostAuth(); THostAuth(const char* asstring); THostAuth(THostAuth& ha); THostAuth(const char* host, const char* user, Int_t authmeth, const char* details); THostAuth(const char* host, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); THostAuth(const char* host, Int_t server, const char* user, Int_t authmeth, const char* details); THostAuth(const char* host, Int_t server, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); virtual~THostAuth(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); voidAddFirst(Int_t level, const char* details = 0); voidAddMethod(Int_t level, const char* details = 0); virtual voidTObject::AppendPad(Option_t* option = """"); voidAsString(TString& out) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCountFailure(Int_t level); voidCountSuccess(Int_t level); TRootSecContext*CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); voidDeActivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtua",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:9618,Security,authenticat,authentication,9618,"nst char* host, const char* user, Int_t nmeth = 0, Int_t* authmeth = 0, char** details = 0); Create hostauth object.; 'host' may contain also the server for whicb these directives; are valid in the form 'host:server' or 'server://host'; with server either ""sock[d]"", ""root[d]"", ""proof[d]"" or; 0, 1, 2, respectively. THostAuth(const char* asstring); Create hostauth object from directives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFi",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:9870,Security,authenticat,authentication,9870,"or 'server://host'; with server either ""sock[d]"", ""root[d]"", ""proof[d]"" or; 0, 1, 2, respectively. THostAuth(const char* asstring); Create hostauth object from directives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth,",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:10037,Security,authenticat,authentication,10037,"rectives given as a compact string; See THostAuth::AsString().; Used in proof context only; fServer not set; to be set by hand; with SetServer() method if really needed. THostAuth(THostAuth& ha); Copy ctor ... void AddMethod(Int_t level, const char* details = 0); Add method to the list. If already there, change its; details to 'details'. void RemoveMethod(Int_t level); Remove method 'meth' from the list, if there ... void Reset(); Remove all methods, leaving Active status and; list of associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THostAuth.html:10576,Security,authenticat,authentication,10576,"associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local list; Return pointer to it to be stored in TAuthenticate. void AsString(TString& out) const; Return a static string with all info in a serialized form. Int_t NumMethods() const; { return fNumMethods; }. Int_t GetMethod(Int_t idx) const; { return fMethods[idx]; }. Int_t GetFailure(Int_t idx) const; { return fFailure[idx]; }. Int_t GetSuccess(Int_t idx) const; { return fSuccess[idx]; }. Bool_t IsActive() const; { return fActive; }. void DeActivate(); { fActive = kFALSE; }. void Activate",MatchSource.WIKI,root/html530/THostAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THostAuth.html
https://root.cern/root/html530/THStack.html:2517,Availability,error,error,2517,"j_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; TList*GetHists() const; virtual const char*TObject::GetIconName() const; virtual Double_tGetMaximum(Option_t* option = """"); virtual Double_tGetMinimum(Option_t* option = """"); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObjArray*GetStack(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TAxis",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:2601,Availability,error,error,2601,"Method(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; TList*GetHists() const; virtual const char*TObject::GetIconName() const; virtual Double_tGetMaximum(Option_t* option = """"); virtual Double_tGetMinimum(Option_t* option = """"); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObjArray*GetStack(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TAxis*GetXaxis() const; TAxis*GetYaxis() const; virtual Bool_tTObject::HandleTimer(TTimer",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:11020,Availability,error,error,11020,"options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from the list of histograms. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetMaximum(Double_t maximum = -1111); Set maximum. void SetMinimum(Double_t minimum = -1111); Set mi",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:9956,Integrability,depend,depends,9956,"tion = """"); add a new histogram to the list; Only 1-d and 2-d histograms currently supported.; A drawing option may be specified. void Browse(TBrowser* b); Browse. void BuildStack(); build sum of all histograms; Build a separate list fStack containing the running sum of all histograms. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to each graph. void Draw(Option_t* chopt = """"); Draw this multihist with its current attributes. Options to draw histograms are described in THistPainter::Paint; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other. TH1 * GetHistogram() const; Returns a pointer to the histogram used to draw the axis; Takes into account the two following cases.; 1- option 'A' was specified in THStack::Draw. Return fHistogram; 2- user had called TPad::DrawFrame. return pointer to hframe histogram. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the tot",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:10532,Integrability,depend,depends,10532,"ed), histograms will be paint; stacked on top of each other. TH1 * GetHistogram() const; Returns a pointer to the histogram used to draw the axis; Takes into account the two following cases.; 1- option 'A' was specified in THStack::Draw. Return fHistogram; 2- user had called TPad::DrawFrame. return pointer to hframe histogram. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a s",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:10737,Integrability,depend,depends,10737," was specified in THStack::Draw. Return fHistogram; 2- user had called TPad::DrawFrame. return pointer to hframe histogram. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. Double_t GetMaximum(Option_t* option = """"); returns the maximum of all added histograms; returns the maximum of all histograms if option ""nostack"". Double_t GetMinimum(Option_t* option = """"); returns the minimum of all added histograms; returns the minimum of all histograms if option ""nostack"". TObjArray * GetStack(); Return pointer to Stack. Build it if not yet done. TAxis * GetXaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. TAxis * GetYaxis() const; Get x axis of the histogram used to draw the stack. IMPORTANT NOTE; You must call Draw before calling this function. The returned histogram; depends on the selected Draw options. void ls(Option_t* option = """") const; List histograms in the stack. Long64_t Merge(TCollection* li, TFileMergeInfo* info); Merge the THStack in the TList into this stack.; Returns the total number of histograms in the result or -1 in case of an error. void Modified(); invalidate sum of histograms. void Paint(Option_t* chopt = """"); paint the list of histograms; By default, histograms are shown stacked.; -the first histogram is paint; -then the sum of the first and second, etc. If option ""nostack"" is specified, histograms are all paint in the same pad; as if the option ""same"" had been specified. if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is paint into a separate pad. See THistPainter::Paint for a list of valid options. void Print(Option_t* chopt = """") const; Print the list of histograms. void RecursiveRemove(TObject* obj); Recursively remove object from th",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:576,Testability,test,test,576,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:630,Testability,test,test,630,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:750,Testability,test,test,750,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THStack.html:871,Testability,test,test,871,". THStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  THStack. class THStack: public TNamed. A THStack is a collection of TH1 (or derived) objects; Use THStack::Add to add a new histogram to the list.; The THStack does not own the objects in the list.; By default (if option ""nostack"" is not specified), histograms will be paint; stacked on top of each other.; Example;; THStack hs(""hs"",""test stacked histograms"");; TH1F *h1 = new TH1F(""h1"",""test hstack"",100,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs.Add(h1);; TH1F *h2 = new TH1F(""h2"",""test hstack"",100,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs.Add(h2);; TH1F *h3 = new TH1F(""h3"",""test hstack"",100,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs.Add(h3);; TCanvas c1(""c1"",""stacked hists"",10,10,700,900);; c1.Divide(1,2);; c1.cd(1);; hs.Draw();; c1.cd(2);; hs->Draw(""nostack"");. See a more complex example in $ROOTSYS/tutorials/hist/hstack.C. Note that picking is supported for all drawing modes. Function Members (Methods); public:. THStack(); THStack(const THStack& hstack); THStack(const char* name, const char* title); THStack(const TH1* hist, Option_t* axis = ""x"", const char* name = 0, const char* title = 0, Int_t firstbin = 1, Int_t lastbin = -1, Int_t firstbin2 = 1, Int_t lastbin2 = -1, Option_t* proj_option = """", Option_t* draw_option = """"); virtual~THStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TH1* h, Option_t* option = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* ",MatchSource.WIKI,root/html530/THStack.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THStack.html
https://root.cern/root/html530/THtml.html:18327,Availability,error,error,18327,,MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:18411,Availability,error,error,18411,,MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:27515,Availability,error,error,27515,"tml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive is run on. void CreateAuxiliaryFiles() const; copy CSS, javascript file, etc to the output dir. const char* GetEtcDir() const; Get the directory containing THtml's auxiliary files ($ROOTSYS/etc/html). TClassDocInfo * GetNextClass(); Return the next class to be generated for MakeClassThreaded. const char* GetURL(const char* lib = 0) const; Get the documentation URL for library lib.; If lib == 0 or no documentation URL has been set for lib, return the ROOT; documentation URL. The return value is always != 0. Bool_t HaveDot(); Check whether dot is available in $PATH or in the directory set; by SetDotPath(). void HelperDeleted(THtml::THelperBase* who); Inform the THtml object that ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:28392,Availability,avail,available,28392,"; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive is run on. void CreateAuxiliaryFiles() const; copy CSS, javascript file, etc to the output dir. const char* GetEtcDir() const; Get the directory containing THtml's auxiliary files ($ROOTSYS/etc/html). TClassDocInfo * GetNextClass(); Return the next class to be generated for MakeClassThreaded. const char* GetURL(const char* lib = 0) const; Get the documentation URL for library lib.; If lib == 0 or no documentation URL has been set for lib, return the ROOT; documentation URL. The return value is always != 0. Bool_t HaveDot(); Check whether dot is available in $PATH or in the directory set; by SetDotPath(). void HelperDeleted(THtml::THelperBase* who); Inform the THtml object that one of its helper objects was deleted.; Called by THtml::HelperBase::~HelperBase(). void Convert(const char* filename, const char* title, const char* dirname = """", const char* relpath = ""../"", Int_t includeOutput = kNoOutput, const char* context = """"); It converts a single text file to HTML. Input: filename - name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:33023,Availability,avail,available,33023,"n for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is avaliable. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining obj",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:33552,Availability,avail,available,33552,"t: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is avaliable. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining object to be used; can also be a user derived; object (a la traits). void SetInputDir(const char* dir); Set the directory containing the source files.; The source file for a class MyClass will be searched; by prepending dir to the value of; MyClass::Class()->GetImplFileName() - which can contain; directory information!; Also resets the class structure, in case new files can; be found after this call. void SetOutputDir(const char* dir); Set the directory where the HTML pages shuold be written to.; If the directory does not exist it will be created when ne",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2015,Deployability,configurat,configuration,2015," documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set thes",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2509,Deployability,configurat,configuration,2509,".MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2946,Deployability,configurat,configuration,2946,"se:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentatio",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:3622,Deployability,update,updated,3622,"tputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file,",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:5344,Deployability,configurat,configuration,5344,"name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Foote",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:6307,Deployability,configurat,configuration,6307,"TML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:7515,Deployability,update,update,7515,"to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by TClass::GetImplFileName(),; TClass::GetDeclFileName()).; If the header is not generated for a class, they will be replaced by """".; Root's footer starts with the tag <!--SIGNATURE-->. It includes the; author(s), last update, copyright, the links to the Root home page, to the; user home page, to the index file (ClassIndex.html), to the top of the page; and this page is automatically generated infomation. It ends with the; tags </body></html>. If you want to replace it,; THtml will search for some; tags in your footer: Occurrences of the strings %AUTHOR%, %UPDATE%, and; %COPYRIGHT% are replaced by their; corresponding values before writing the html file. The %AUTHOR% tag will be; replaced by the exact string that follows Root.Html.Author, no link; generation will occur.; II.7 Links to searches, home page, ViewVC; Additional parameters can be set by Root.Html.Homepage (address of the; user's home page), Root.Html.SearchEngine (search engine for the class; documentation), Root.Html.Search (search URL, where %u is replaced by the; referer and %s by the escaped search expression), and a ViewVC base URL; Root.Html.ViewCVS. For the latter, the file name is appended or, if; the URL contains %f, %f is replaced by the file name.; All values def",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15425,Deployability,install,install,15425,"asses.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15616,Deployability,configurat,configuration,15616,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15929,Deployability,update,update,15929," javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/people?) - URL of CERN's xWho; Root.Html.Charset (default: ISO-8859-1) - HTML character set. IX. Behind the scene; Internally, THtml is just an API class that sets up the list of known; classes, and forwards API invocations to the ""work horses"".; TDocOutput; generates the output by letting a; TDocP",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:26564,Deployability,configurat,configuration,26564,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:26748,Deployability,configurat,configuration,26748,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:27019,Deployability,configurat,configuration,27019,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:27140,Deployability,configurat,configuration,27140,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:3685,Integrability,depend,dependencies,3685,"tputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file,",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15346,Integrability,depend,dependencies,15346,"index,; either by linking it or by including it.; The files for modules are searched based on the source file directory of the; module's classes.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:31510,Integrability,depend,depending,31510,"d) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bool GetImplFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return implementation file name. bool GetDeclImplFileName(TClass* cl, bool filesys, bool decl, TString& out_name) const; Combined implementation for GetDeclFileName(), GetImplFileName():; Return declaration / implementation file name (depending on decl);; return the full path if filesys is true. const TString& GetOutputDir(Bool_t createDir = kTRUE) const; Return the output directory as set by SetOutputDir().; Create it if it doesn't exist and if createDir is kTRUE. Bool_t IsNamespace(const TClass* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the numbe",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:1384,Modifiability,variab,variables,1384,"ted text files (like change logs). It generates HTML; pages conforming to the XHTML 1.0 transitional specifications; an example of; these pages is ROOT's own ; reference guide. This page was verified to be valid XHTML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.S",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2015,Modifiability,config,configuration,2015," documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set thes",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2081,Modifiability,variab,variable,2081," documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set thes",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2509,Modifiability,config,configuration,2509,".MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2523,Modifiability,variab,variable,2523,".MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2946,Modifiability,config,configuration,2946,"se:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentatio",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:2960,Modifiability,variab,variable,2960,"se:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Configuration; Most configuration options can be set as a call to THtml, or as a TEnv variable,; which you can set in your .rootrc.; II.1 Input files; In your .rootrc, define Root.Html.SourceDir to point to directories containing; .cxx and .h files (see: TEnv); of the classes you want to document, or call THtml::SetInputDir(); Example:; Root.Html.SourceDir: .:src:include; Root.Html.Root: http://root.cern.ch/root/html; II.2 Output directory; The output directory can be specified using the Root.Html.OutputDir; configuration variable (default value: ""htmldoc""). If that directory; doesn't exist THtml; will create it.; Example:; Root.Html.OutputDir: htmldoc; II.3 Linking other documentation; When trying to document a class, THtml searches for a source file in; the directories set via SetInputDir(). If it cannot find it, it assumes; that this class must have been documented before. Based on the library; this class is defined in, it checks the configuration variable; Root.Html.LibName, and creates a link using its value.; Alternatively, you can set these URLs via THtml::SetLibURL().; Example:; If a class MyClass is defined in class mylibs/libMyLib.so, and .rootrc; contains; Root.Html.MyLib: ../mylib/; THtml will create a link to ""../mylib/MyClass.html"".; The library name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentatio",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:4785,Modifiability,variab,variables,4785,"LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:5344,Modifiability,config,configuration,5344,"name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Foote",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:5359,Modifiability,variab,variable,5359,"name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alpha).; THtml will generate an; HTML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Foote",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:6307,Modifiability,config,configuration,6307,"TML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:6321,Modifiability,variab,variables,6321,"TML link for Name, taking the Root.Html.XWho configuration; variable (defaults to ""http://consult.cern.ch/xwho/people?"") and adding; all parts of the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:6417,Modifiability,variab,variables,6417,"f the name with spaces replaces by '+'. Non-alphanumerical; characters are printed out behind Name.; Example:; // Author: Enrico Fermi appears in the source file.; THtml will generate the link; http://consult.cern.ch/xwho/people?Enrico+Fermi. This works well for; people at CERN.; Name <link> Info.; THtml will generate; an HTML link for Name as specified by link and print; Info behind Name.; Example:; // Author: Enrico Fermi <http://www.enricos-home.it> or; // Author: Enrico Fermi <mailto:enrico@fnal.gov> in the; source file. That's world compatible. Example (with defaults given):; Root.Html.Author: // Author:; Root.Html.LastUpdate: // @(#); Root.Html.Copyright: * Copyright; Root.Html.XWho: http://consult.cern.ch/xwho/people?; II.6 Header and footer; THtml generates; a default header and footer for all pages. You can; specify your own versions with the configuration variables Root.Html.Header; and Root.Html.Footer, or by calling SetHeader(), SetFooter().; Both variables default to """", using the standard Root; versions. If it has a ""+"" appended, THtml will; write both versions (user and root) to a file, for the header in the order; 1st root, 2nd user, and for the footer 1st user, 2nd root (the root; versions containing ""<html>"" and </html> tags, resp).; If you want to replace root's header you have to write a file containing; all HTML elements necessary starting with the <doctype> tag and ending with; (and including) the <body> tag. If you add your header it will be added; directly after Root's <body> tag. Any occurrence of the string %TITLE%; in the user's header file will be replaced by; a sensible, automatically generated title. If the header is generated for a; class, occurrences of %CLASS% will be replaced by the current class's name,; %SRCFILE% and %INCFILE% by the name of the source and header file, resp.; (as given by TClass::GetImplFileName(),; TClass::GetDeclFileName()).; If the header is not generated for a class, they will be replaced by """".; Root's footer",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:9460,Modifiability,variab,variable,9460,"ame is appended or, if; the URL contains %f, %f is replaced by the file name.; All values default to """".; Examples:; Root.Html.Homepage: http://www.enricos-home.it; Root.Html.SearchEngine: http://root.cern.ch/root/Search.phtml; Root.Html.Search: http://www.google.com/search?q=%s+site%3A%u; II.8 HTML Charset; XHTML 1.0 transitional recommends the specification of the charset in the; content type meta tag, see e.g. http://www.w3.org/TR/2002/REC-xhtml1-20020801/; THtml generates it for the HTML output files. It defaults to ISO-8859-1, and; can be changed using Root.Html.Charset.; Example:; Root.Html.Charset: EUC-JP; III. Documentation syntax; III.1 Class description; A class description block, which must be placed before the first; member function, has a following form:. ////////////////////////////////////////////////////////////////; // //; // TMyClass //; // //; // This is the description block. //; // //; ////////////////////////////////////////////////////////////////. The environment variable Root.Html.Description; (see: TEnv) contains; the delimiter string (default value: //_________________). It means; that you can also write your class description block like this:. //_____________________________________________________________; // A description of the class starts with the line above, and; // will take place here !; //. Note that everything until the first non-commented line is considered; as a valid class description block.; III.2 Class index; All classes to be documented will have an entry in the ClassIndex.html,; showing their name with a link to their documentation page and a miniature; description. This discription for e.g. the class MyClass has to be given; in MyClass's header as a comment right after ClassDef(MyClass, n).; III.3 Method documentation; A member function description block starts immediately after '{'; and looks like this:. void TWorld::HelloWorldFunc(string *text); {; // This is an example of description for the; // TWorld member function;",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:10648,Modifiability,variab,variable,10648," //_____________________________________________________________; // A description of the class starts with the line above, and; // will take place here !; //. Note that everything until the first non-commented line is considered; as a valid class description block.; III.2 Class index; All classes to be documented will have an entry in the ClassIndex.html,; showing their name with a link to their documentation page and a miniature; description. This discription for e.g. the class MyClass has to be given; in MyClass's header as a comment right after ClassDef(MyClass, n).; III.3 Method documentation; A member function description block starts immediately after '{'; and looks like this:. void TWorld::HelloWorldFunc(string *text); {; // This is an example of description for the; // TWorld member function; helloWorld.Print( text );; }. Like in a class description block, everything until the first; non-commented line is considered as a valid member function; description block.; If the rootrc variable Root.Html.DescriptionStyle is set to; Doc++ THtml will also look for method documentation in front of; the function implementation. This feature is not recommended; source code; making use of this does not comply to the ROOT documentation standards, which; means future versions of THtml might not support it anymore.; III.4 Data member documentation; Data members are documented by putting a C++ comment behind their; declaration in the header file, e.g. int fIAmADataMember; // this is a data member. IV. Documentation directives; NOTE that THtml does not yet support nested directives; (i.e. latex inside html etc)!; IV.1 BEGIN_HTML END_HTML: include 'raw' HTML; You can insert pure html code into your documentation comments. During the; generation of the documentation, this code will be inserted as is; into the html file.; Pure html code must be surrounded by the keywords; BEGIN_HTML and END_HTML, where the; case is ignored.; An example of pure html code is this class description ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15250,Modifiability,inherit,inheritance,15250,"index,; either by linking it or by including it.; The files for modules are searched based on the source file directory of the; module's classes.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15263,Modifiability,inherit,inherited,15263,"index,; either by linking it or by including it.; The files for modules are searched based on the source file directory of the; module's classes.; A filename starting with ""index."" will be included in the index page;; all other files will be linked.; Only files ending on .html or .txt will be taken into account;; the text files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; ",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15583,Modifiability,variab,variables,15583,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15616,Modifiability,config,configuration,15616,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:15630,Modifiability,variab,variables,15630,"xt files will first be run through; THtml::Convert().; You can see an example here;; the part between ""Index of HIST classes"" and ""Jump to"" is created by parsing; the module's doc directory.; VI. Auxiliary files: style sheet, JavaScript, help page; The documentation pages share a common set of javascript and CSS files. They; are generated automatically when running MakeAll();; they can be generated on; demand by calling CreateAuxiliaryFiles().; VII. Class Charts; THtml can generate a number of graphical representations for a class, which; are displayed as a tabbed set of imaged ontop of the class description.; It can show the inheritance, inherited and hidden members, directly and; indirectly included files, and library dependencies.; These graphs are generated using the Graphviz; package. You can install it from http://www.graphviz.org.; You can either put it into your $PATH, or tell THtml where to find it by calling; SetDotDir().; VIII. Configuration variables; Here is a list of all configuration variables that are known to THtml.; You can set them in your .rootrc file, see; TEnv. Root.Html.OutputDir (default: htmldoc); Root.Html.SourceDir (default: .:src/:include/); Root.Html.Author (default: // Author:) - start tag for authors; Root.Html.LastUpdate (default: // @(#)) - start tag for last update; Root.Html.Copyright (default: * Copyright) - start tag for copyright notice; Root.Html.Description (default: //____________________ ) - start tag for class descr; Root.Html.HomePage (default: ) - URL to the user defined home page; Root.Html.Header (default: ) - location of user defined header; Root.Html.Footer (default: ) - location of user defined footer; Root.Html.Root (default: ) - URL of Root's class documentation; Root.Html.SearchEngine (default: ) - link to the search engine; Root.Html.Search (defualt: ) - link to search by replacing ""%s"" with user input; Root.Html.ViewCVS (default: ) - URL of ViewCVS base; Root.Html.XWho (default: http://consult.cern.ch/xwho/peopl",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:26564,Modifiability,config,configuration,26564,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:26748,Modifiability,config,configuration,26748,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:27019,Modifiability,config,configuration,27019,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:27140,Modifiability,config,configuration,27140,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:30197,Modifiability,inherit,inheritance,30197,"sed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer than the script. If kCompiledOutput is; passed, the script is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bo",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:30479,Modifiability,inherit,inheriting,30479,"cript is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bool GetImplFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return implementation file name. bool GetDeclImplFileName(TClass* cl, bool filesys, bool decl, TString& out_name) const; Combined implementation for GetDeclFileName(), GetImplFileNam",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:30508,Modifiability,inherit,inheritance,30508,"cript is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html file name for a class named classname.; Returns 0 if the class is not documented. TClass * GetClass(const char* name) const; Return pointer to class with name*-*-*-*-*-*-*-*-; *-* =================================. bool GetDeclFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return declaration file name; return the full path if filesys is true. bool GetImplFileName(TClass* cl, Bool_t filesys, TString& out_name) const; Return implementation file name. bool GetDeclImplFileName(TClass* cl, bool filesys, bool decl, TString& out_name) const; Combined implementation for GetDeclFileName(), GetImplFileNam",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:33349,Modifiability,inherit,inheritance,33349,"ter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is avaliable. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFileDefinition(const THtml::TFileDefinition& fd); Set the file defining object to be used; can also be a user derived; object (a la traits). void SetPathDefinition(const THtml::TPathDefinition& pd); Set the path defining object to be used; can also be a user derived; object (a la traits). void SetInputDir(const char* dir); Set the directory containing the source files.; The source file for a class MyClass will be searched; by prepending dir to the value of; MyClass::Class()->GetImplFileName() - which can contain; directory information!; Also res",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:26678,Performance,cache,cached,26678,"tatic void*MakeClassThreaded(void* info); voidTObject::MakeZombie(); voidSetLocalFiles() const. Data Members; public:. enum EConvertOutput { kNoOutput; kInterpretedOutput; kCompiledOutput; kForceOutput; kSeparateProcessOutput; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfBatchWhether to enable GUI output; TStringfCountercounter string; TStringfCounterFormatcounter printf-like format; THtml::DocEntityInfo_tfDocEntityInfodata for documented entities; THtml::DocSyntax_tfDocSyntaxdoc syntax configuration; THtml::TFileDefinition*fFileDefobject translating classes to file names; TGClient*fGClientgClient, cached and queried through CINT; THtml::LinkInfo_tfLinkInfolink (URL) configuration; THtml::TFileSysDB*fLocalFilesfiles found locally for a given source path; TVirtualMutex*fMakeClassMutexMutex for MakeClassThreaded; THtml::TModuleDefinition*fModuleDefobject translating classes to module names; THtml::OutputStyle_tfOutputStyleoutput style configuration; THtml::TPathDefinition*fPathDefobject translating classes to module names; THtml::PathInfo_tfPathInfopath configuration; TStringfProductNamename of the product to document; Int_tfThreadedClassCountcounter of processed classes for MakeClassThreaded; TIter*fThreadedClassIterfClasses iterator for MakeClassThreaded. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THtml(); Create a THtml object.; In case output directory does not exist an error; will be printed and gHtml stays 0 also zombie bit will be set. ~THtml(); Default destructor. void AddMacroPath(const char* path); Add path to the directories to be searched for macro files; that are to be executed via the TDocMacroDirective; (""Begin_Macro""/""End_Macro""); relative to the source file; that the directive i",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:29823,Performance,cache,cached,29823," name of the file to convert; title - title which will be placed at the top of the HTML file; dirname - optional parameter, if it's not specified, output will; be placed in htmldoc/examples directory.; relpath - optional parameter pointing to the THtml generated doc; on the server, relative to the current page.; includeOutput - if != kNoOutput, run the script passed as filename and; store all created canvases in PNG files that are; shown next to the converted source. Bitwise-ORing with; kForceOutput re-runs the script even if output PNGs exist; that are newer than the script. If kCompiledOutput is; passed, the script is run through ACLiC (.x filename+); context - line shown verbatim at the top of the page; e.g. for links.; If context is non-empty it is expected to also print the; title. NOTE: Output file name is the same as filename, but with extension .html. void GetModuleNameForClass(TString& module, TClass* cl) const; Return the module name for a given class.; Use the cached information from fDocEntityInfo.fClasses. void CreateListOfClasses(const char* filter); Create the list of all known classes. void CreateListOfTypes(); Create index of all data types and a page for each typedef-to-class. Bool_t CopyFileFromEtcDir(const char* filename) const; Copy a file from $ROOTSYS/etc/html into GetOutputDir(). void CreateHierarchy(); Create the inheritance hierarchy diagram for all classes. void CreateJavascript() const; Write the default ROOT style sheet. void CreateStyleSheet() const; Write the default ROOT style sheet. void GetDerivedClasses(TClass* cl, map<TClass*,Int_t>& derived) const; fill derived with all classes inheriting from cl and their inheritance; distance to cl. void GetHtmlFileName(TClass* classPtr, TString& filename) const; Return real HTML filename. Input: classPtr - pointer to a class; filename - string containing a full name; of the corresponding HTML file after the function returns. const char* GetHtmlFileName(const char* classname) const; Get the html",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:32798,Performance,multi-thread,multi-threaded,32798,"ss* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is avaliable. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFil",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:4339,Security,access,access,4339,"brary name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alph",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:372,Testability,log,logs,372,". THtml. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HTML;  THtml. class THtml: public TObject. The THtml class is designed to easily document; classes, code, and code related text files (like change logs). It generates HTML; pages conforming to the XHTML 1.0 transitional specifications; an example of; these pages is ROOT's own ; reference guide. This page was verified to be valid XHTML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Config",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml.html:514,Usability,guid,guide,514,". THtml. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HTML;  THtml. class THtml: public TObject. The THtml class is designed to easily document; classes, code, and code related text files (like change logs). It generates HTML; pages conforming to the XHTML 1.0 transitional specifications; an example of; these pages is ROOT's own ; reference guide. This page was verified to be valid XHTML 1.0 transitional,; which proves that all pages generated by THtml can be valid, as long as the user; provided XHTML (documentation, header, etc) is valid. You can check the current; THtml by clicking this icon:. Overview:. Usage; Configuration; Input files; Output directory; Linking other documentation; Recognizing class documentation; Author, copyright, etc.; Header and footer; Links to searches, home page, ViewVC; HTML Charset. Documentation syntax; Class description; Class index; Method documentation; Data member documentation. Documentation directives; BEGIN_HTML END_HTML: include 'raw' HTML; BEGIN_MACRO END_MACRO: include a picture generated by a macro; BEGIN_LATEX END_LATEX: include a latex picture. Product and module index; Auxiliary files: style sheet, JavaScript, help page; Class Charts; Configuration variables; Behind the scenes. I. Usage; These are typical things people do with THtml:. root[] THtml html; // create a THtml object; root[] html.MakeAll(); // generate documentation for all changed classes. or to run on just a few classes:. root[] THtml html; // create a THtml object; root[] html.MakeIndex(); // create auxilliary files (style sheet etc) and indices; root[] html.MakeClass(""TMyClass""); // create documentation for TMyClass only. To ""beautify"" (i.e. create links to documentation for class names etc) some text; file or macro, use:. root[] html.Convert( ""hsimple.C"", ""Histogram example"" ). II. Config",MatchSource.WIKI,root/html530/THtml.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml.html
https://root.cern/root/html530/THtml__TFileDefinition.html:1363,Availability,error,error,1363," ~TFileDefinition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDeclFileName(const TClass* cl, TString& out_filename, TString& out_fsys, THtml::TFileSysEntry** fse = 0) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGe",MatchSource.WIKI,root/html530/THtml__TFileDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileDefinition.html
https://root.cern/root/html530/THtml__TFileDefinition.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDeclFileName(const TClass* cl, TString& out_filename, TString& out_fsys, THtml::TFileSysEntry** fse = 0) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGetImplFileName(const TClass* cl, TString& out_filename, TString& out_fsys, THtml::TFileSysEntry** fse = 0) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*THtml::THelperBase::GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bo",MatchSource.WIKI,root/html530/THtml__TFileDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileDefinition.html
https://root.cern/root/html530/THtml__TFileSysDB.html:1343,Availability,error,error,1343," ~TFileSysDB(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); THashTable&GetEntries(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() co",MatchSource.WIKI,root/html530/THtml__TFileSysDB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysDB.html
https://root.cern/root/html530/THtml__TFileSysDB.html:1427,Availability,error,error,1427," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); THashTable&GetEntries(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; const TString&GetIgnore() const; Int_tTHtml::TFileSysEntry::GetLevel() const; TExMap&GetMapIno(); Int_tGetMaxLevel() const; virtual const char*THtml::TFileSysEntry::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*THtml::TFileSysEntry::GetParent() const; const TList*THtml::TFileSysDir::Get",MatchSource.WIKI,root/html530/THtml__TFileSysDB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysDB.html
https://root.cern/root/html530/THtml__TFileSysDB.html:6449,Safety,detect,detect,6449,"ect::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFill(); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TListTHtml::TFileSysDir::fDirs; TListTHtml::TFileSysDir::fFiles; Int_tTHtml::TFileSysEntry::fLevellevel of directory; TStringTHtml::TFileSysEntry::fNamename of the element; THtml::TFileSysDir*THtml::TFileSysEntry::fParentparent directory. private:. THashTablefEntrieshash map of all filenames without paths; TStringfIgnorePathregexp of path to ignore while building entry tree; TExMapfMapInoinode to TFileSysDir map, to detect softlinks; Int_tfMaxLevelmaximum level of directory nesting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileSysDB(const char* path, const char* ignore, Int_t maxdirlevel); { Fill(); }. TExMap& GetMapIno(); { return fMapIno; }. THashTable& GetEntries(); { return fEntries; }. const TString& GetIgnore() const; { return fIgnorePath; }. Int_t GetMaxLevel() const; { return fMaxLevel; }. void Fill(). TString fInputPath; // directories to look for classes; prepended to Decl/ ImplFileName().  Author: Nenad Buncic 18/10/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/html:$Id: THtml.h 27910 2009-03-21 17:26:55Z axel $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/THtml__TFileSysDB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysDB.html
https://root.cern/root/html530/THtml__TFileSysDir.html:1349,Availability,error,error,1349," ~TFileSysDir(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLeve",MatchSource.WIKI,root/html530/THtml__TFileSysDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysDir.html
https://root.cern/root/html530/THtml__TFileSysDir.html:1433,Availability,error,error,1433," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetFiles() const; virtual voidTHtml::TFileSysEntry::GetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLevel() const; virtual const char*THtml::TFileSysEntry::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*THtml::TFileSysEntry::GetParent() const; const TList*GetSubDirs() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TT",MatchSource.WIKI,root/html530/THtml__TFileSysDir.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysDir.html
https://root.cern/root/html530/THtml__TFileSysEntry.html:1344,Availability,error,error,1344," ~TFileSysEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual const char*GetName() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html530/THtml__TFileSysEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysEntry.html
https://root.cern/root/html530/THtml__TFileSysEntry.html:1428,Availability,error,error,1428," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*GetParent() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFro",MatchSource.WIKI,root/html530/THtml__TFileSysEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysEntry.html
https://root.cern/root/html530/THtml__TFileSysRoot.html:1351,Availability,error,error,1351," ~TFileSysRoot(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLeve",MatchSource.WIKI,root/html530/THtml__TFileSysRoot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysRoot.html
https://root.cern/root/html530/THtml__TFileSysRoot.html:1435,Availability,error,error,1435," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*THtml::TFileSysDir::GetFiles() const; virtual voidGetFullName(TString& fullname, Bool_t asIncluded) const; virtual const char*TObject::GetIconName() const; Int_tTHtml::TFileSysEntry::GetLevel() const; virtual const char*THtml::TFileSysEntry::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml::TFileSysDir*THtml::TFileSysEntry::GetParent() const; const TList*THtml::TFileSysDir::GetSubDirs() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObje",MatchSource.WIKI,root/html530/THtml__TFileSysRoot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TFileSysRoot.html
https://root.cern/root/html530/THtml__THelperBase.html:1343,Availability,error,error,1343," virtual~THelperBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option",MatchSource.WIKI,root/html530/THtml__THelperBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__THelperBase.html
https://root.cern/root/html530/THtml__THelperBase.html:1427,Availability,error,error,1427," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root/html530/THtml__THelperBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__THelperBase.html
https://root.cern/root/html530/THtml__TModuleDefinition.html:1371,Availability,error,error,1371," ~TModuleDefinition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGetModule(TClass* cl, THtml::TFileSysEntry* fse, TString& out_modulename) const; virtual const char*TObject::GetName() co",MatchSource.WIKI,root/html530/THtml__TModuleDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TModuleDefinition.html
https://root.cern/root/html530/THtml__TModuleDefinition.html:1455,Availability,error,error,1455," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual boolGetModule(TClass* cl, THtml::TFileSysEntry* fse, TString& out_modulename) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*THtml::THelperBase::GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html530/THtml__TModuleDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TModuleDefinition.html
https://root.cern/root/html530/THtml__TPathDefinition.html:1363,Availability,error,error,1363," ~TPathDefinition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDocDir(const TString& module, TString& doc_dir) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual boolGetFileNameFromInclude(const char* included, TString& out_fsname) const; virtual const char*TObject::GetIcon",MatchSource.WIKI,root/html530/THtml__TPathDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TPathDefinition.html
https://root.cern/root/html530/THtml__TPathDefinition.html:1447,Availability,error,error,1447," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual boolGetDocDir(const TString& module, TString& doc_dir) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual boolGetFileNameFromInclude(const char* included, TString& out_fsname) const; virtual const char*TObject::GetIconName() const; virtual boolGetIncludeAs(TClass* cl, TString& out_include_as) const; virtual boolGetMacroPath(const TString& module, TString& out_dir) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THtml*THtml::THelperBase::GetOwner() const; virtual const char*TObject::GetTitle() const; virtual UIn",MatchSource.WIKI,root/html530/THtml__TPathDefinition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THtml__TPathDefinition.html
https://root.cern/root/html530/THYPE.html:1771,Availability,error,error,1771,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html530/THYPE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THYPE.html
https://root.cern/root/html530/THYPE.html:1855,Availability,error,error,1855,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTTUBE::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTTUBE::GetAspectRatio() const; virtual const TBuffer3D&TTUBE::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tTTUBE::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTTUBE::GetNdiv() const; virtual Int_tTShape::GetNumber() con",MatchSource.WIKI,root/html530/THYPE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/THYPE.html
https://root.cern/root/html530/TImage.html:3885,Availability,error,error,3885,"nt_t = 16, UInt_t = 16); virtual voidDrawLine(UInt_t, UInt_t, UInt_t, UInt_t, const char* = ""#000000"", UInt_t = 1); virtual voidDrawPolyLine(UInt_t, TPoint*, const char* = ""#000000"", UInt_t = 1, TImage::ECoordMode = kCoordModeOrigin); virtual voidDrawRectangle(UInt_t, UInt_t, UInt_t, UInt_t, const char* = ""#000000"", UInt_t = 1); virtual voidDrawSegments(UInt_t, Segment_t*, const char* = ""#000000"", UInt_t = 1); virtual voidDrawStraightEllips(Int_t, Int_t, Int_t, Int_t, const char* = ""#000000"", Int_t = 1); virtual voidDrawText(TText*, Int_t = 0, Int_t = 0); virtual voidDrawText(Int_t = 0, Int_t = 0, const char* = """", Int_t = 12, const char* = 0, const char* = ""fixed"", TImage::EText3DType = TImage::kPlain, const char* = 0, Float_t = 0); virtual voidTObject::Dump() constMENU ; virtual voidTAttImage::EditorClosed(); virtual voidEndPaint(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(UInt_t, TPoint*, TImage*); virtual voidFillPolygon(UInt_t, TPoint*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual voidFillRectangle(const char* = 0, Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, TImage*); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlip(Int_t = 180); virtual voidFloodFill(Int_t, Int_t, const char*, const char*, const char* = 0); virtual voidFromGLBuffer(UChar_t*, UInt_t, UInt_t); virtu",MatchSource.WIKI,root/html530/TImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImage.html
https://root.cern/root/html530/TImage.html:3969,Availability,error,error,3969,"char* = ""#000000"", UInt_t = 1); virtual voidDrawPolyLine(UInt_t, TPoint*, const char* = ""#000000"", UInt_t = 1, TImage::ECoordMode = kCoordModeOrigin); virtual voidDrawRectangle(UInt_t, UInt_t, UInt_t, UInt_t, const char* = ""#000000"", UInt_t = 1); virtual voidDrawSegments(UInt_t, Segment_t*, const char* = ""#000000"", UInt_t = 1); virtual voidDrawStraightEllips(Int_t, Int_t, Int_t, Int_t, const char* = ""#000000"", Int_t = 1); virtual voidDrawText(TText*, Int_t = 0, Int_t = 0); virtual voidDrawText(Int_t = 0, Int_t = 0, const char* = """", Int_t = 12, const char* = 0, const char* = ""fixed"", TImage::EText3DType = TImage::kPlain, const char* = 0, Float_t = 0); virtual voidTObject::Dump() constMENU ; virtual voidTAttImage::EditorClosed(); virtual voidEndPaint(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(UInt_t, TPoint*, TImage*); virtual voidFillPolygon(UInt_t, TPoint*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual voidFillRectangle(const char* = 0, Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, TImage*); virtual voidFillSpans(UInt_t, TPoint*, UInt_t*, const char* = ""#000000"", const char* = 0, UInt_t = 16, UInt_t = 16); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFlip(Int_t = 180); virtual voidFloodFill(Int_t, Int_t, const char*, const char*, const char* = 0); virtual voidFromGLBuffer(UChar_t*, UInt_t, UInt_t); virtual voidFromPad(TVirtualPad*, Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual ",MatchSource.WIKI,root/html530/TImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImage.html
https://root.cern/root/html530/TImage.html:333,Integrability,interface,interface,333,". TImage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GRAF;  TImage. class TImage: public TNamed, public TAttImage. Image class; TImage is an abstract interface to image processing library.; It allows for the reading and writing of images in different formats, several; image manipulations (scaling, tiling, merging, etc.) and displaying in pads. The concrete implementation of this class is done by the; TASImage class. The ; methods are documented in that class.; . Function Members (Methods); public:. TImage(const TImage& img); TImage(UInt_t, UInt_t); virtual~TImage(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TImage*, const char* = ""+"", const char* = ""#00000000""); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginPaint(Bool_t = kTRUE); virtual voidBevel(Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0, const char* = ""#ffdddddd"", const char* = ""#ff555555"", UShort_t = 1, Bool_t = kFALSE); virtual voidBlur(Double_t = 3, Double_t = 3); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char*) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyArea(TImage*, Int_t, Int_t, UInt_t, UInt_t, Int_t = 0, Int_t = 0, Int_t = 3, TImage::EColorChan = kAllChan); static TImage*Create(); virtual voidCrop(Int_t = 0, Int_t = 0, UInt_t = 0, UInt_t = 0); virtual voidCropPolygon(UInt_t, TPoint*); virtual voidCropSpans(UInt_t, TPoint*, UInt_t*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Int_t, Int_t, In",MatchSource.WIKI,root/html530/TImage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImage.html
https://root.cern/root/html530/TImageDump.html:2429,Availability,error,error,2429,":Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; TImage*GetImage() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virt",MatchSource.WIKI,root/html530/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImageDump.html
https://root.cern/root/html530/TImageDump.html:2513,Availability,error,error,2513,"y, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; TImage*GetImage() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Get",MatchSource.WIKI,root/html530/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImageDump.html
https://root.cern/root/html530/TImageDump.html:12752,Energy Efficiency,green,green,12752,"_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn > 0 a line is drawn.; If nn < 0 a closed polygon is drawn. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); not used. void DrawDashPolyLine(Int_t npoints, TPoint* pt, UInt_t nDash, const char* pDash, const char* col, UInt_t thick); draw dashed polyline. void NewPage(); new page. void Text(Double_t x, Double_t y, const char* string); Draw text. x: x position of the text; y: y position of the text. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); cell array begin. void CellArrayFill(Int_t r, Int_t g, Int_t b); Cell array fill. void CellArrayEnd(); Cell array end. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. Int_t XtoPixel(Double_t x); x to pixel. Int_t YtoPixel(Double_t y); y to pixel. void * GetStream() const; { return (void*)fImage; }. void SetType(Int_t type = -111); { fType = type; }. Int_t GetType() const; { return fType; }. TImage * GetImage() const; { return fImage; }.  Author: Valeriy Onuchin 29/04/2005  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/postscript:$Id: TImageDump.h 22872 2008-03-27 16:59:12Z couet $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImageDump.html
https://root.cern/root/html530/TImageDump.html:10953,Integrability,interface,interface,10953,"irtualPS::fLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypePostScript workstation type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImageDump(); Default SVG constructor. TImageDump(const char* filename, Int_t type = -111); Initialize batch image interface. fname : image file name. The possible workstation types are:; 111 - Portrait; 112 - Landscape; 114 - preview, keep in memory (do not write on delete). void Open(const char* filename, Int_t type = -111); Open a image file. ~TImageDump(); destructor. void Close(Option_t* opt = """"); Close a image file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); not used. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); draw polymarker. void DrawPS(Int_t n, Double_t* xw",MatchSource.WIKI,root/html530/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImageDump.html
https://root.cern/root/html530/TImageDump.html:582,Testability,test,test,582,". TImageDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  POSTSCRIPT;  TImageDump. class TImageDump: public TVirtualPS. TImageDump. save canvas as an image (GIF, JPEG, PNG, XPM, TIFF etc.); in batch mode. Example:. $ root -b; root [0] .x hsimple.C; root [1] c1->Print(""c1.gif"");. TImageDump can be used in any mode (batch, interactive) as follows. TCanvas *c1;; TImageDump *imgdump = new TImageDump(""test.png"");; c1->Paint();; imgdump->Close();. Function Members (Methods); public:. TImageDump(); TImageDump(const char* filename, Int_t type = -111); virtual~TImageDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light)",MatchSource.WIKI,root/html530/TImageDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImageDump.html
https://root.cern/root/html530/TImagePalette.html:3783,Availability,error,error,3783,"_t numPoints); TImagePalette(Int_t ncolors, Int_t* colors); virtual~TImagePalette(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindColor(UShort_t r, UShort_t g, UShort_t b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t*GetRootColors(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:3867,Availability,error,error,3867," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindColor(UShort_t r, UShort_t g, UShort_t b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t*GetRootColors(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classna",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:1414,Energy Efficiency,allocate,allocated,1414,"rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : ",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:1767,Energy Efficiency,monitor,monitors,1767,"he size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors. TPaletteEditor. This class provides a way to edit the palette via a GUI. Function Members (Methods); public:. TImagePalette(); TImagePalette(const TImagePalette& palett",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:1823,Energy Efficiency,monitor,monitors,1823,"he size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors. TPaletteEditor. This class provides a way to edit the palette via a GUI. Function Members (Methods); public:. TImagePalette(); TImagePalette(const TImagePalette& palett",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:7802,Energy Efficiency,green,green,7802,"t char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:8250,Energy Efficiency,allocate,allocates,8250," = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. UShort_t*fColorAlpha[fNumPoints] alpha at each anchor point; UShort_t*fColorBlue[fNumPoints] blue color at each anchor point; UShort_t*fColorGreen[fNumPoints] green color at each anchor point; UShort_t*fColorRed[fNumPoints] red color at each anchor point; UInt_tfNumPointsnumber of anchor points; Double_t*fPoints[fNumPoints] value of each anchor point [0..1]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TImagePalette(); Default constructor, sets all pointers to 0. TImagePalette(UInt_t numPoints); Constructor for a palette with numPoints anchor points.; It allocates the memory but does not set any colors. TImagePalette(const TImagePalette& palette); Copy constructor. TImagePalette(Int_t ncolors, Int_t* colors); Creates palette in the same way as TStyle::SetPalette. ~TImagePalette(); Destructor. TImagePalette & operator=(const TImagePalette& palette); Assignment operator. Int_t FindColor(UShort_t r, UShort_t g, UShort_t b); returns an index of the closest color. Int_t * GetRootColors(); Returns a list of ROOT colors. Could be used to set histogram palette.; See also http://root.cern.ch/root/htmldoc/TStyle.html#TStyle:SetPalette.  Author: Reiner Rohlfs 24/03/02  Copyright (C) 2001-2002, Rene Brun, Fons Rademakers and Reiner Rohlfs *;  Last changed: root/graf:$Id: TAttImage.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:507,Integrability,depend,depends,507,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GRAF;  TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:751,Integrability,depend,depends,751,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GRAF;  TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:901,Modifiability,inherit,inheritance,901,". TImagePalette. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GRAF;  TImagePalette. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolor",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePalette.html:1241,Modifiability,variab,variables,1241,"te. class TImagePalette: public TObject. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::C",MatchSource.WIKI,root/html530/TImagePalette.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePalette.html
https://root.cern/root/html530/TImagePlugin.html:423,Availability,avail,available,423,". TImagePlugin. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GRAF;  TImagePlugin. class TImagePlugin: public TObject. TImagePlugin. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html530/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePlugin.html
https://root.cern/root/html530/TImagePlugin.html:1393,Availability,error,error,1393," virtual~TImagePlugin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html530/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePlugin.html
https://root.cern/root/html530/TImagePlugin.html:1477,Availability,error,error,1477," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect",MatchSource.WIKI,root/html530/TImagePlugin.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TImagePlugin.html
https://root.cern/root/html530/timespec.html:306,Modifiability,extend,extends,306,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Author: R. Hatcher 30/9/2001  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TTimeStamp.h 32404 2010-02-25 12:06:10Z rdm $  Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/timespec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/timespec.html
https://root.cern/root/html530/timespec.html:698,Usability,simpl,simply,698,". timespec. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  timespec. class timespec. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. This class is also known as (typedefs to this class)timespec_t. Function Members (Methods); public:. timespec(); timespec(const timespec&); ~timespec(); timespec&operator=(const timespec&). Data Members; public:. longtv_nsecnanoseconds; time_ttv_secseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation.  Author: R. Hatcher 30/9/2001  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TTimeStamp.h 32404 2010-02-25 12:06:10Z rdm $  Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/timespec.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/timespec.html
https://root.cern/root/html530/TIndexTable.html:3669,Availability,error,error,3669," named) const; Int_tTTable::CopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html530/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIndexTable.html
https://root.cern/root/html530/TIndexTable.html:3753,Availability,error,error,3753,"_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html530/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIndexTable.html
https://root.cern/root/html530/TIndexTable.html:16411,Testability,assert,assert,16411,"he one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }.  Author: Valery Fine(fine@bnl.gov) 01/03/2001  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id: TIndexTable.h 35145 2010-09-04 19:01:19Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIndexTable.html
https://root.cern/root/html530/TIndexTable.html:16508,Testability,assert,assert,16508,"he one element (row) of the table; Char_t*TTable::fTableArray of (fN*fSize) longs; TStringTNamed::fTitleobject title; static TTableDescriptor*fgColDescriptors; static TDataSet*TDataSet::fgMainSetpointer the main dataset;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Dictionary(); to be documented. TIndexTable(const TTable* table); to be documented. TTableDescriptor * CreateDescriptor(); to be documented. TTableDescriptor * GetDescriptorPointer() const; return column descriptor. void SetDescriptorPointer(TTableDescriptor* list); set table descriptor. const TTable * Table() const; to be documented. int * GetTable(Int_t i = 0). { return ((int *)GetArray())+i;}. const int * GetTable(Int_t i = 0) const. { return ((int *)GetArray())+i;}. Bool_t IsValid() const. void push_back(Long_t next). { AddAt(&next); }. TIndexTable(const TTable* table). TIndexTable(const TIndexTable& indx); {}. iterator begin(); { return ((const TIndexTable *)this)->begin();}. iterator begin() const; { return GetNRows() ? iterator(*Table(),*GetTable(0)):end();}. iterator end(); { return ((const TIndexTable *)this)->end(); }. iterator end() const; {Long_t i = GetNRows(); return i? iterator(*Table(), *GetTable(i)):iterator(*this);}. TIndexTable(); {SetType(""int"");}. TIndexTable(const char* name); {SetType(""int"");}. TIndexTable(Int_t n); {SetType(""int"");}. virtual ~TIndexTable(); {}. int & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const int & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const int *)(GetTable(i))); }.  Author: Valery Fine(fine@bnl.gov) 01/03/2001  Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *;  Last changed: root/table:$Id: TIndexTable.h 35145 2010-09-04 19:01:19Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TIndexTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIndexTable.html
https://root.cern/root/html530/TInetAddress.html:1396,Availability,error,error,1396," TInetAddress(); TInetAddress(const TInetAddress& adr); virtual~TInetAddress(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root/html530/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInetAddress.html
https://root.cern/root/html530/TInetAddress.html:1480,Availability,error,error,1480," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAddress() const; UChar_t*GetAddressBytes() const; const TInetAddress::AddressList_t&GetAddresses() const; const TInetAddress::AliasList_t&GetAliases() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFamily() const; const char*GetHostAddress() const; static const char*GetHostAddress(UInt_t addr); const char*GetHostName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::Ge",MatchSource.WIKI,root/html530/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInetAddress.html
https://root.cern/root/html530/TInetAddress.html:6698,Energy Efficiency,allocate,allocated,6698,"resses in host byte order; vector<TString>fAliaseslist of aliases; Int_tfFamilyaddress family; TStringfHostnamefully qualified hostname; Int_tfPortport through which we are connected. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInetAddress(); Default ctor. Used in case of unknown host. Not a valid address. TInetAddress(const char* host, UInt_t addr, Int_t family, Int_t port = -1); Create TInetAddress. Private ctor. TInetAddress objects can only; be created via the friend classes TSystem, TServerSocket and TSocket.; Use the IsValid() method to check the validity of a TInetAddress. TInetAddress(const TInetAddress& adr); TInetAddress copy ctor. TInetAddress& operator=(const TInetAddress& rhs); TInetAddress assignment operator. UChar_t * GetAddressBytes() const; Returns the raw IP address in host byte order. The highest; order byte position is in addr[0]. To be prepared for 64-bit; IP addresses an array of bytes is returned.; User must delete allocated memory. const char * GetHostAddress(UInt_t addr); Returns the IP address string ""%d.%d.%d.%d"", use it to convert; alternative addresses obtained via GetAddresses().; Copy string immediately, it will be reused. Static function. const char * GetHostAddress() const; Returns the IP address string ""%d.%d.%d.%d"".; Copy string immediately, it will be reused. void Print(Option_t* option = """") const; Print internet address as string. void AddAddress(UInt_t addr); Add alternative address to list of addresses. void AddAlias(const char* alias); Add alias to list of aliases. void Streamer(TBuffer& b); Stream an object of class TInetAddress. virtual ~TInetAddress(); { }. UInt_t GetAddress() const; { return fAddresses[0]; }. const char * GetHostName() const; { return (const char *) fHostname; }. Int_t GetFamily() const; { return fFamily; }. Int_t GetPort() const; { return fPort; }. const AddressList_t & GetAddresses() const; { return fAddresses; }. const AliasList_t & GetAliases() const; {",MatchSource.WIKI,root/html530/TInetAddress.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInetAddress.html
https://root.cern/root/html530/TInspectCanvas.html:6033,Availability,error,error,6033,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas:",MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInspectCanvas.html:6117,Availability,error,error,6117,"ect::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas::GetCanvasID() const; virtual TCanvasImp*TCanvas::GetCanvasImp() const; TVirtualPadP",MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInspectCanvas.html:27737,Availability,down,down,27737,,MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInspectCanvas.html:35496,Integrability,interface,interface,35496," fYtoPixelk + fYtoPixel*yworld; Double_tTPad::fYtoPixelkConversion coefficient for Y World to pixel; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static Bool_tTCanvas::fgIsFolderIndicates if canvas can be browsed as a folder; static Int_tTPad::fgMaxPickDistanceMaximum Pick Distance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInspectCanvas(); InspectCanvas default constructor. TInspectCanvas(UInt_t ww, UInt_t wh); InspectCanvas constructor. ~TInspectCanvas(); InspectCanvas default destructor. void InspectObject(TObject* obj); Dump contents of obj in a graphics canvas.; Same action as TObject::Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. void GoBackward(); static function , inspect previous object. void GoForward(); static function , inspect next object. void Inspector(TObject* obj); static function , interface to InspectObject.; Create the InspectCanvas if it does not exist yet. void RecursiveRemove(TObject* obj); Recursively remove object from the list of objects. void Divide(Int_t nx = 1, Int_t ny = 1, Float_t xmargin = 0.01, Float_t ymargin = 0.01, Int_t color = 0); { }. void SetGrid(Int_t valuex = 1, Int_t valuey = 1); { }. void SetGridx(Int_t value = 1); { }. void SetGridy(Int_t value = 1); { }. void SetLogx(Int_t value = 1); { }. void SetLogy(Int_t value = 1); { }. void SetLogz(Int_t value = 1); { }. void SetTickx(Int_t value = 1); { }. void SetTicky(Int_t value = 1); { }. void x3d(Option_t* option = """"); { }. TButton * GetBackward() const; {return fBackward;}. TButton * GetForward() const; {return fForward;}. TObject * GetCurObject() const; {return fCurObject;}. TList * GetObjects() const; {return fObjects;}.  Author: Rene Brun 08/01/2000  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/gpad:$Id: TInspectCanvas.h 20882 2007-11-19 ",MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInspectCanvas.html:30240,Testability,log,log,30240,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInspectCanvas.html:30297,Testability,log,log,30297,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInspectCanvas.html:30354,Testability,log,log,30354,":fEventX!Last X mouse position in canvas; Int_tTCanvas::fEventY!Last Y mouse position in canvas; TList*TPad::fExecsList of commands to be executed when a pad event occurs; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tTPad::fFixedAspectRatioTrue if fixed aspect ratio; TButton*fForwardPointer to the Forward button; TFrame*TPad::fFrame! Pointer to 2-D frame (if one exists); Int_tTAttPad::fFrameBorderModepad frame border mode; Width_tTAttPad::fFrameBorderSizepad frame border size; Color_tTAttPad::fFrameFillColorpad frame fill color; Style_tTAttPad::fFrameFillStylepad frame fill style; Color_tTAttPad::fFrameLineColorpad frame line color; Style_tTAttPad::fFrameLineStylepad frame line style; Width_tTAttPad::fFrameLineWidthpad frame line width; Int_tTPad::fGLDevice! OpenGL off-screen pixmap identifier; Bool_tTPad::fGridxSet to true if grid along X; Bool_tTPad::fGridySet to true if grid along Y; Double_tTPad::fHNDCHeight of pad along Y in NDC; Color_tTCanvas::fHighLightColorHighlight color of active pad; Float_tTAttPad::fLeftMarginLeftMargin; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTPad::fLogx(=0 if X linear scale, =1 if log scale); Int_tTPad::fLogy(=0 if Y linear scale, =1 if log scale); Int_tTPad::fLogz(=0 if Z linear scale, =1 if log scale); Bool_tTPad::fModifiedSet to true when pad is modified; TPad*TPad::fMother! pointer to mother of the list; TStringTPad::fNamePad name; Int_tTPad::fNumberpad number identifier; TList*fObjectsList of objects inspected; Int_tTPad::fPadPaintSet to 1 while painting the pad; TObject*TPad::fPadPointer! free pointer; TPad*TCanvas::fPadSave!Pointer to saved pad in HandleInput; TObject*TPad::fPadView3D! 3D View of this TPad; TVirtualPadPainter*TCanvas::fPainter!Canvas (pad) painter.",MatchSource.WIKI,root/html530/TInspectCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInspectCanvas.html
https://root.cern/root/html530/TInterpreter.html:525,Availability,avail,available,525,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFunc",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:1510,Availability,error,error,1510," virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFunc",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:6979,Availability,error,error,6979,"r*DataMemberInfo_TypeName(DataMemberInfo_t*) const; virtual Long_tDataMemberInfo_TypeProperty(DataMemberInfo_t*) const; virtual intDataMemberInfo_TypeSize(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual ",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:7082,Availability,error,error,7082,"rInfo_t*) const; virtual intDataMemberInfo_TypeSize(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual ",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:7181,Availability,error,error,7181,"taMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInter",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:7336,Availability,error,error,7336,"(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE*, char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char*) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* method, const char* params); virtual void*GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* pr",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:10334,Availability,error,error,10334,"); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Int_tInitializeDictionaries(); virtual voidTObject::Inspect() constMENU ; static TInterpreter*&Instance(); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsErrorMessagesEnabled() const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tIsLoaded(const char* filename) const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsProcessLineLocked() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual Int_tLoad(const char* filenam, Bool_t system = kFALSE); virtual intLoadFile(const char*) const; virtual Int_tLoadLibraryMap(const char* rootmapfile = 0); virtual voidLoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidLoadText(const char*) const; virtual voidTNamed::ls(Option_t* option = """") const; virtual const char*MapCppName(const char*) const; voidTObject::MayNotUse(const char* method) const; virtual const char*MethodArgInfo_DefaultValue(MethodArgInfo_t*) const; virtual voidMethodArgInfo_Delete(MethodArgInfo_t*) const; virtual MethodArgInfo_t*MethodArgInfo_Factory() const; virtual MethodArgInfo_t*MethodArgInfo_FactoryCopy(MethodArgInfo_t*) const; virtual boolMethodArgInfo_IsValid(MethodArgInfo_t*) const; virtual const char*MethodArgInfo_Name(MethodArgInfo_t*) const; virtual intMethodArgInfo_Next(MethodArgInfo_t*) const; virtual Long_tMethodArgInfo_Property(MethodArgInfo_t*) const; virtual const char*MethodArgInfo_TypeName(MethodArgInfo_t*) const; virtual voidMethodInfo_CreateSignature(MethodInfo_t*, TString&) const; virtual voidMethodInfo_Delete(MethodInfo_t*) const; virtual MethodInfo_t*MethodInfo_Factory() const; virtual MethodInfo_t*MethodInfo_FactoryCopy(MethodInfo_t*) c",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:12846,Availability,error,error,12846,"Info_t*) const; virtual const char*MethodInfo_Title(MethodInfo_t*) const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t*) const; virtual const char*MethodInfo_TypeName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual voidTObject::SetDrawOption(Option_t* option ",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:12933,Availability,error,error,12933,"nfo_t*MethodInfo_Type(MethodInfo_t*) const; virtual const char*MethodInfo_TypeName(MethodInfo_t*) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TInterpreter&operator=(const TInterpreter&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetErrmsgcallback(v",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:16856,Availability,error,error,16856,"virtual const char*TypeInfo_Name(TypeInfo_t*) const; virtual Long_tTypeInfo_Property(TypeInfo_t*) const; virtual intTypeInfo_RefType(TypeInfo_t*) const; virtual intTypeInfo_Size(TypeInfo_t*) const; virtual const char*TypeInfo_TrueName(TypeInfo_t*) const; virtual const char*TypeName(const char* s); virtual Int_tUnloadAllSharedLibraryMaps(); virtual intUnloadFile(const char*) const; virtual Int_tUnloadLibraryMap(const char* library); virtual voidUpdateListOfGlobalFunctions(); virtual voidUpdateListOfGlobals(); virtual voidUpdateListOfMethods(TClass* cl); virtual voidUpdateListOfTypes(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidExecute(TMethod* method, TObjArray* params, int* error = 0); voidTObject::MakeZombie(). Data Members; public:. enum EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile()",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:17538,Availability,error,error,17538,"TObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidExecute(TMethod* method, TObjArray* params, int* error = 0); voidTObject::MakeZombie(). Data Members; public:. enum EErrorCode { kNoError; kRecoverable; kDangerous; kFatal; kProcessing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllShar",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:18408,Availability,error,error,18408," Includes; Libraries. Function documentation; TInterpreter *& Instance(); returns gInterpreter global. void Execute(TMethod* method, TObjArray* params, int* error = 0). virtual ~TInterpreter(); { }. void AddIncludePath(const char* path). Int_t AutoLoad(const char* classname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass*",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:18677,Availability,error,error,18677,"sname). void ClearFileBusy(). void ClearStack(). void EnableAutoLoading(). void EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWith",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:18757,Availability,error,error,18757,"d EndOfLineAction(). Int_t GetExitCode() const. TEnv * GetMapfile() const; { return 0; }. Int_t GetMore() const. Int_t GenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0). char * GetPrompt(). const char * GetSharedLibs(). const char * GetClassSharedLibs(const char* cls). const char * GetSharedLibDeps(const char* lib). const char * GetIncludePath(). const char * GetSTLIncludePath() const; { return """"; }. TObjArray * GetRootMapFiles() const. Int_t InitializeDictionaries(). Bool_t IsLoaded(const char* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * Ge",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:19334,Availability,error,error,19334,"filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void ResetGlobalVar(void* obj). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsEr",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:20020,Availability,error,error,20020,"DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. cons",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:20116,Availability,error,error,20116,"istOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroNa",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:20208,Availability,error,error,20208,"o(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurit",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:20288,Availability,error,error,20288,"autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadT",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:341,Integrability,interface,interface,341,". TInterpreter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  META;  TInterpreter. class TInterpreter: public TNamed. TInterpreter. This class defines an abstract interface to a generic command line; interpreter. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TInterpreter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIncludePath(const char* path); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tAutoLoad(const char* classname); virtual voidBaseClassInfo_Delete(BaseClassInfo_t*) const; virtual BaseClassInfo_t*BaseClassInfo_Factory(ClassInfo_t*) const; virtual const char*BaseClassInfo_FullName(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_Name(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*) const; virtual intBaseClassInfo_Next(BaseClassInfo_t*, int) const; virtual Long_tBaseClassInfo_Offset(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Property(BaseClassInfo_t*) const; virtual Long_tBaseClassInfo_Tagnum(BaseClassInfo_t*) const; virtual const char*BaseClassInfo_TmpltName(BaseClassInfo_t*) const; virtual voidTObject::Browse(TBrowser* b); virtual Long_tCalc(const char* line, TInterpreter::EErrorCode* error = 0); virtual voidCallFunc_Delete(void*) const; virtual voidCallFunc_Exec(CallFunc_t*, void*) const; virtual Double_tCallFunc_ExecDouble(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt(CallFunc_t*, void*) const; virtual Long_tCallFunc_ExecInt64(CallFunc_t*, void*) const; virtual CallFunc_t*CallFunc_Factory() const; virtual CallFunc_t*CallFunc_FactoryCopy(CallFunc_t*) const; virtual MethodInfo_t*CallFunc_FactoryMethod(CallFunc_t*) const; virtual voidCallFunc_Init(CallFunc",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:21765,Integrability,interface,interface,21765,"; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadText(const char* ) const; {;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void (*)() ) const; {;}. void SetAllocunlockfunc(void (*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {return 0;}. void CallFunc_Delete(void* ) const; G__CallFunc interface. {;}. void CallFunc_Exec(CallFunc_t* , void* ) const; {;}. Long_t CallFunc_ExecInt(CallFunc_t* , void* ) const; {return 0;}. Long_t CallFunc_ExecInt64(CallFunc_t* , void* ) const; {return 0;}. Double_t CallFunc_ExecDouble(CallFunc_t* , void* ) const; {return 0;}. CallFunc_t * CallFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_Init(CallFunc_t* ) const; {;}. bool CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. void CallFunc_ResetArg(CallFunc_t* ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Double_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long64_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , ULong64_t ) const; {;}. void CallFunc_SetArgArray(CallFunc_t* , Long_t* , Int_t ) const; {;}. void CallFunc_SetArgs(CallFunc_t* , const char* ) const; {;}. vo",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:23081,Integrability,interface,interface,23081,"CallFunc_Factory() const; {return 0;}. CallFunc_t * CallFunc_FactoryCopy(CallFunc_t* ) const; {return 0;}. MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t* ) const; {return 0;}. void CallFunc_Init(CallFunc_t* ) const; {;}. bool CallFunc_IsValid(CallFunc_t* ) const; {return 0;}. void CallFunc_ResetArg(CallFunc_t* ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Double_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , Long64_t ) const; {;}. void CallFunc_SetArg(CallFunc_t* , ULong64_t ) const; {;}. void CallFunc_SetArgArray(CallFunc_t* , Long_t* , Int_t ) const; {;}. void CallFunc_SetArgs(CallFunc_t* , const char* ) const; {;}. void CallFunc_SetFunc(CallFunc_t* , ClassInfo_t* , const char* , const char* , Long_t* ) const; {;}. void CallFunc_SetFunc(CallFunc_t* , MethodInfo_t* ) const; {;}. void CallFunc_SetFuncProto(CallFunc_t* , ClassInfo_t* , const char* , const char* , Long_t* ) const; {;}. Long_t ClassInfo_ClassProperty(ClassInfo_t* ) const; G__ClassInfo interface. {return 0;}. void ClassInfo_Delete(ClassInfo_t* ) const; {;}. void ClassInfo_Delete(ClassInfo_t* , void* ) const; {;}. void ClassInfo_DeleteArray(ClassInfo_t* , void* , bool ) const; {;}. void ClassInfo_Destruct(ClassInfo_t* , void* ) const; {;}. ClassInfo_t * ClassInfo_Factory() const; {return 0;}. ClassInfo_t * ClassInfo_Factory(G__value* ) const; {return 0;}. ClassInfo_t * ClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. ClassInfo_t * ClassInfo_Factory(const char* ) const; {return 0;}. int ClassInfo_GetMethodNArg(ClassInfo_t* , const char* , const char* ) const; {return 0;}. bool ClassInfo_HasDefaultConstructor(ClassInfo_t* ) const; {return 0;}. bool ClassInfo_HasMethod(ClassInfo_t* , const char* ) const; {return 0;}. void ClassInfo_Init(ClassInfo_t* , const char* ) const; {;}. void ClassInfo_Init(ClassInfo_t* , int ) const; {;}. bool ClassInfo_IsBase(ClassInfo_t* , const char* ) const; {return 0;}. bool ClassInfo_IsEnum(const char* ) const",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:25223,Integrability,interface,interface,25223,"ssInfo_IsValidMethod(ClassInfo_t* , const char* , const char* , Long_t* ) const; {return 0;}. int ClassInfo_Next(ClassInfo_t* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , int ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , int , void* ) const; {return 0;}. void * ClassInfo_New(ClassInfo_t* , void* ) const; {return 0;}. Long_t ClassInfo_Property(ClassInfo_t* ) const; {return 0;}. int ClassInfo_RootFlag(ClassInfo_t* ) const; {return 0;}. int ClassInfo_Size(ClassInfo_t* ) const; {return 0;}. Long_t ClassInfo_Tagnum(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_FileName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_FullName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Name(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Title(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_TmpltName(ClassInfo_t* ) const; {return 0;}. void BaseClassInfo_Delete(BaseClassInfo_t* ) const; G__BaseClassInfo interface. {;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* , int ) const; {return 0;}. Long_t BaseClassInfo_Offset(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Property(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_FullName(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_Name(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* ) const; {return 0;}. int DataMemberInfo_ArrayDim(DataMemberInfo_t* ) const; G__DataMemberInfo interface. {return 0;}. void DataMemberInfo_Delete(DataMemberInfo_t* ) const; {;}. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* = 0) const; {return 0;}. DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. bo",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:25942,Integrability,interface,interface,25942,"Info_FullName(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Name(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_Title(ClassInfo_t* ) const; {return 0;}. const char * ClassInfo_TmpltName(ClassInfo_t* ) const; {return 0;}. void BaseClassInfo_Delete(BaseClassInfo_t* ) const; G__BaseClassInfo interface. {;}. BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* ) const; {return 0;}. int BaseClassInfo_Next(BaseClassInfo_t* , int ) const; {return 0;}. Long_t BaseClassInfo_Offset(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Property(BaseClassInfo_t* ) const; {return 0;}. Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_FullName(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_Name(BaseClassInfo_t* ) const; {return 0;}. const char * BaseClassInfo_TmpltName(BaseClassInfo_t* ) const; {return 0;}. int DataMemberInfo_ArrayDim(DataMemberInfo_t* ) const; G__DataMemberInfo interface. {return 0;}. void DataMemberInfo_Delete(DataMemberInfo_t* ) const; {;}. DataMemberInfo_t * DataMemberInfo_Factory(ClassInfo_t* = 0) const; {return 0;}. DataMemberInfo_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. bool DataMemberInfo_IsValid(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_MaxIndex(DataMemberInfo_t* , Int_t ) const; {return 0;}. int DataMemberInfo_Next(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Offset(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Property(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_TypeSize(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return 0;",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:27151,Integrability,interface,interface,27151,"Info_t * DataMemberInfo_FactoryCopy(DataMemberInfo_t* ) const; {return 0;}. bool DataMemberInfo_IsValid(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_MaxIndex(DataMemberInfo_t* , Int_t ) const; {return 0;}. int DataMemberInfo_Next(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Offset(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_Property(DataMemberInfo_t* ) const; {return 0;}. Long_t DataMemberInfo_TypeProperty(DataMemberInfo_t* ) const; {return 0;}. int DataMemberInfo_TypeSize(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Name(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_Title(DataMemberInfo_t* ) const; {return 0;}. const char * DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* ) const; {return 0;}. void MethodInfo_CreateSignature(MethodInfo_t* , TString& ) const; G__MethodInfo interface. {;}. void MethodInfo_Delete(MethodInfo_t* ) const; {;}. MethodInfo_t * MethodInfo_Factory() const; {return 0;}. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. bool MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const; {return 0;}. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetPrototype(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Name(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_TypeName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Title(MethodInfo_t* )",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:28206,Integrability,interface,interface,28206,"odInfo_Delete(MethodInfo_t* ) const; {;}. MethodInfo_t * MethodInfo_Factory() const; {return 0;}. MethodInfo_t * MethodInfo_FactoryCopy(MethodInfo_t* ) const; {return 0;}. MethodInfo_t * MethodInfo_InterfaceMethod(MethodInfo_t* ) const; {return 0;}. bool MethodInfo_IsValid(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_NDefaultArg(MethodInfo_t* ) const; {return 0;}. int MethodInfo_Next(MethodInfo_t* ) const; {return 0;}. Long_t MethodInfo_Property(MethodInfo_t* ) const; {return 0;}. TypeInfo_t * MethodInfo_Type(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetMangledName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetPrototype(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Name(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_TypeName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Title(MethodInfo_t* ) const; {return 0;}. void MethodArgInfo_Delete(MethodArgInfo_t* ) const; G__MethodArgInfo interface. {;}. MethodArgInfo_t * MethodArgInfo_Factory() const; {return 0;}. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* ) const; {return 0;}. bool MethodArgInfo_IsValid(MethodArgInfo_t* ) const; {return 0;}. int MethodArgInfo_Next(MethodArgInfo_t* ) const; {return 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. void TypeInfo_Delete(TypeInfo_t* ) const; G__TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(G__value* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. bool TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInf",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:28843,Integrability,interface,interface,28843,"ledName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_GetPrototype(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Name(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_TypeName(MethodInfo_t* ) const; {return 0;}. const char * MethodInfo_Title(MethodInfo_t* ) const; {return 0;}. void MethodArgInfo_Delete(MethodArgInfo_t* ) const; G__MethodArgInfo interface. {;}. MethodArgInfo_t * MethodArgInfo_Factory() const; {return 0;}. MethodArgInfo_t * MethodArgInfo_FactoryCopy(MethodArgInfo_t* ) const; {return 0;}. bool MethodArgInfo_IsValid(MethodArgInfo_t* ) const; {return 0;}. int MethodArgInfo_Next(MethodArgInfo_t* ) const; {return 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. void TypeInfo_Delete(TypeInfo_t* ) const; G__TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(G__value* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. bool TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_Name(TypeInfo_t* ) const; {return 0;}. Long_t TypeInfo_Property(TypeInfo_t* ) const; {return 0;}. int TypeInfo_RefType(TypeInfo_t* ) const; {return 0;}. int TypeInfo_Size(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_TrueName(TypeInfo_t* ) const; {return 0;}. void TypedefInfo_Delete(TypedefInfo_t* ) const; G__TypedefInfo interface. {;}. TypedefInfo_t * TypedefInfo_Factory() const; {return 0;}. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* ) const; {return 0;}. void TypedefInfo_Init(TypedefInfo_t* , const char* ) const; {;}. bool TypedefInfo_IsValid(TypedefInfo_t* ) const; {return 0;}. Long_t TypedefInfo_Property(Type",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:29511,Integrability,interface,interface,29511,"eturn 0;}. Long_t MethodArgInfo_Property(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_DefaultValue(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_Name(MethodArgInfo_t* ) const; {return 0;}. const char * MethodArgInfo_TypeName(MethodArgInfo_t* ) const; {return 0;}. void TypeInfo_Delete(TypeInfo_t* ) const; G__TypeInfo interface. {;}. TypeInfo_t * TypeInfo_Factory() const; {return 0;}. TypeInfo_t * TypeInfo_Factory(G__value* ) const; {return 0;}. TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t* ) const; {return 0;}. void TypeInfo_Init(TypeInfo_t* , const char* ) const; {;}. bool TypeInfo_IsValid(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_Name(TypeInfo_t* ) const; {return 0;}. Long_t TypeInfo_Property(TypeInfo_t* ) const; {return 0;}. int TypeInfo_RefType(TypeInfo_t* ) const; {return 0;}. int TypeInfo_Size(TypeInfo_t* ) const; {return 0;}. const char * TypeInfo_TrueName(TypeInfo_t* ) const; {return 0;}. void TypedefInfo_Delete(TypedefInfo_t* ) const; G__TypedefInfo interface. {;}. TypedefInfo_t * TypedefInfo_Factory() const; {return 0;}. TypedefInfo_t * TypedefInfo_FactoryCopy(TypedefInfo_t* ) const; {return 0;}. void TypedefInfo_Init(TypedefInfo_t* , const char* ) const; {;}. bool TypedefInfo_IsValid(TypedefInfo_t* ) const; {return 0;}. Long_t TypedefInfo_Property(TypedefInfo_t* ) const; {return 0;}. int TypedefInfo_Size(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_TrueName(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_Name(TypedefInfo_t* ) const; {return 0;}. const char * TypedefInfo_Title(TypedefInfo_t* ) const; {return 0;}.  Author: Fons Rademakers 01/03/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/meta:$Id: TInterpreter.h 39402 2011-05-26 12:56:31Z axel $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support.",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TInterpreter.html:20694,Safety,avoid,avoids,20694,"o). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsErrorMessagesEnabled() const. Bool_t SetErrorMessages(Bool_t enable = kTRUE). Bool_t IsProcessLineLocked() const. void SetProcessLineLock(Bool_t lock = kTRUE). const char * TypeName(const char* s). int DisplayClass(FILE* , char* , int , int ) const; All the functions below must be virtual with a dummy implementation; These functions are redefined in TCint.; The dummy implementation avoids an implementation in TGWin32InterpreterProxy; Misc. {return 0;}. int DisplayIncludePath(FILE* ) const; {return 0;}. void * FindSym(const char* ) const; {return 0;}. void GenericError(const char* ) const; {;}. Long_t GetExecByteCode() const; {return 0;}. Long_t Getgvp() const; {return 0;}. const char * Getp2f2funcname(void* ) const; {return 0;}. const char * GetTopLevelMacroName() const; {return 0;}. const char * GetCurrentMacroName() const; {return 0;}. int GetSecurityError() const; {return 0;}. int LoadFile(const char* ) const; {return 0;}. void LoadText(const char* ) const; {;}. const char * MapCppName(const char* ) const; {return 0;}. void SetAlloclockfunc(void (*)() ) const; {;}. void SetAllocunlockfunc(void (*)() ) const; {;}. int SetClassAutoloading(int ) const; {return 0;}. void SetErrmsgcallback(void* ) const; {;}. void Setgvp(Long_t ) const; {;}. void SetRTLD_NOW() const; {;}. void SetRTLD_LAZY() const; {;}. void SetTempLevel(int ) const; {;}. int UnloadFile(const char* ) const; {retur",MatchSource.WIKI,root/html530/TInterpreter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TInterpreter.html
https://root.cern/root/html530/TIter.html:1120,Deployability,release,release,1120,"e. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub class and assigning it with the original. TIter & operator=(const TIter& rhs); As",MatchSource.WIKI,root/html530/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIter.html
https://root.cern/root/html530/TIter.html:323,Integrability,protocol,protocol,323,". TIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. Thi",MatchSource.WIKI,root/html530/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIter.html
https://root.cern/root/html530/TIter.html:441,Modifiability,inherit,inherit,441,". TIter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. Thi",MatchSource.WIKI,root/html530/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIter.html
https://root.cern/root/html530/TIter.html:1025,Modifiability,inherit,inherits,1025,"rarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TIter. class TIter. Collection abstract base class. This class describes the base; protocol all collection classes have to implement. The ROOT; collection classes always store pointers to objects that inherit; from TObject. They never adopt the objects. Therefore, it is the; user's responsability to take care of deleting the actual objects; once they are not needed anymore. In exceptional cases, when the; user is 100% sure nothing else is referencing the objects in the; collection, one can delete all objects and the collection at the; same time using the Delete() function. Collections can be iterated using an iterator object (see; TIterator). Depending on the concrete collection class there may be; some additional methods of iterating. See the repective classes. TCollection inherits from TObject since we want to be able to have; collections of collections. In a later release the collections may become templatized. /*. */. Function Members (Methods); public:. TIter(TIterator* it); TIter(const TIter& iter); TIter(const TCollection* col, Bool_t dir = kIterForward); virtual~TIter(); TIter&Begin(); static TClass*Class(); static TIterEnd(); const TCollection*GetCollection() const; Option_t*GetOption() const; virtual TClass*IsA() const; TObject*Next(); booloperator!=(const TIter& aIter) const; TObject*operator()(); TObject*operator*() const; TIter&operator++(); TIter&operator=(const TIter& rhs); voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TIter(). Data Members; private:. TIterator*fIteratorcollection iterator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TIter(const TIter& iter); Copy a TIter. This involves allocating a new TIterator of the right; sub cla",MatchSource.WIKI,root/html530/TIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIter.html
https://root.cern/root/html530/TIterator.html:513,Availability,avail,available,513,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }.  Author: Fons Rademakers 13/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: TIterator.h 23212 2008-04-14 15:30:20Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html530/TIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIterator.html
https://root.cern/root/html530/TIterator.html:342,Integrability,interface,interface,342,". TIterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TIterator. class TIterator. TIterator. Iterator abstract base class. This base class provides the interface; for collection iterators. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~TIterator(); static TClass*Class(); virtual const TCollection*GetCollection() const; virtual Option_t*GetOption() const; virtual TClass*IsA() const; virtual TObject*Next(); virtual booloperator!=(const TIterator&) const; TObject*operator()(); virtual TObject*operator*() const; virtual TIterator&operator=(const TIterator&); virtual voidReset(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool operator!=(const TIterator& ) const; Compare two iterator objects.; For backward compatibility reasons we have to provide this; default implementation. TObject * operator*() const; Return current object or nullptr.; For backward compatibility reasons we have to provide this; default implementation. TIterator & operator=(const TIterator& ); { return *this; }. virtual ~TIterator(); { }. const TCollection * GetCollection() const. Option_t * GetOption() const; { return """"; }. TObject * Next(). void Reset(). TObject * operator()(); { return Next(); }.  Author: Fons Rademakers 13/08/95  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/cont:$Id: TIterator.h 23212 2008-04-14 15:30:20Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root/html530/TIterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TIterator.html
https://root.cern/root/html530/TKDE.html:1443,Availability,error,error,1443,"ss TKDE: public TNamed. Function Members (Methods); public:. TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); virtual~TKDE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t data); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetAdaptiveWeights() const; TF1*GetApproximateBias(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Double_tGetBias(Double_t x) const; TF1*GetDrawnFunction(); TGraphErrors*GetDrawnGraph(); TF1*GetDrawnLowerFunction(); TF1*GetDrawnUpperFunction(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetE",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:1527,Availability,error,error,1527,"ss TKDE: public TNamed. Function Members (Methods); public:. TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); virtual~TKDE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t data); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetAdaptiveWeights() const; TF1*GetApproximateBias(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0); Double_tGetBias(Double_t x) const; TF1*GetDrawnFunction(); TGraphErrors*GetDrawnGraph(); TF1*GetDrawnLowerFunction(); TF1*GetDrawnUpperFunction(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetE",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:9669,Availability,error,errors,9669,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:10375,Availability,robust,robust,10375,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:15282,Availability,error,errors,15282,". void Fill(Double_t data); Fills data member with User input data event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Retur",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:15427,Availability,error,errors,15427,". void Fill(Double_t data); Fills data member with User input data event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Retur",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:15952,Availability,error,errors,15952,"rding to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:9295,Energy Efficiency,adapt,adaptive,9295,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:11972,Energy Efficiency,adapt,adaptive,11972,"_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); Class constructor. ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, Double_t xMin, Double_t xMax, Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitF",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:12469,Energy Efficiency,adapt,adaptive,12469,"tDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKernelS",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:16229,Energy Efficiency,adapt,adaptive,16229," option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:16319,Energy Efficiency,adapt,adaptive,16319,"s; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. Double_t ComputeMidspread(); Co",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:9295,Modifiability,adapt,adaptive,9295,"nnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Double_tfAdaptiveBandwidthFactorGeometric mean of the kernel density estimation from the data for adaptive iteration; TF1*fApproximateBiasOutput Kernel Density Estimation approximate bias; Bool_tfAsymLeft; Bool_tfAsymRight; vector<UInt_t>fBinCountNumber of events per bin for binned data option; TKDE::EBinningfBinning; vector<Double_t>fCanonicalBandwidths; vector<Double_t>fDataData events; vector<Double_t>fEventsOriginal data storage; TGraphErrors*fGraphGraph with the errors; TKDE::EIterationfIteration; TKDE::TKernel*fKernel; ROOT::Math::IBaseFunctionOneDim*fKernelFunction; vector<Double_t>fKernelSigmas2; TKDE::EKernelTypefKernelType; TF1*fLowerPDFOutput Kernel Density Estimation lower confidence interval PDF function; Double_tfMeanData mean; TKDE::EMirrorfMirror; Bool_tfMirrorLeft; Bool_tfMirrorRight; UInt_tfNBinsNumber of bins for binned data option; UInt_tfNEventsData's number of events; Bool_tfNewDataflag to control when new data are given; TF1*fPDFOutput Kernel Density Estimation PDF function; Double_tfRhoAdjustment factor for sigma; vector<Bool_t>fSettedOptionsUser input options flag; Double_tfSigmaData std deviation; Double_tfSigmaRobData std deviation (robust estimation); TF1*fUpperPDFOutput Kernel Density Estimation upper confidence interval PDF function; Bool_tfUseBins; UInt_tfUseBinsNEventsIf the algorithm is allowed to use binning this is the minimum number of events to do so; Bool_tfUseMinMaxFromDataflag top control if min and max must be used from data; Bool_tfUseMirroring; Double_tfWeightSizeCaches the weight size; Double_tfXMaxData maximum value; Double_tfXMinData minimum value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKDE(UInt_t events = 0, const Double_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:11972,Modifiability,adapt,adaptive,11972,"_t* data = 0, Double_t xMin = 0.0, Double_t xMax = 0.0, Option_t* option = ""KernelType:Gaussian;Iteration:Adaptive;Mirror:noMirror;Binning:RelaxedBinning"", Double_t rho = 1.0); Class constructor. ~TKDE(); Class destructor. void Instantiate(TKDE::KernelFunction_Ptr kernfunc, UInt_t events, const Double_t* data, Double_t xMin, Double_t xMax, Option_t* option, Double_t rho); Template's constructor surrogate. void SetOptions(Option_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitF",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:12469,Modifiability,adapt,adaptive,12469,"tDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths(); Sets the canonical bandwidths according to the kernel type. void SetKernelS",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:16229,Modifiability,adapt,adaptive,16229," option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Co",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:16319,Modifiability,adapt,adaptive,16319,"s; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Returns the indices (bins) for the binned weights. Double_t UpperConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise upper estimated density. Double_t LowerConfidenceInterval(const Double_t* x, const Double_t* p) const; Returns the pointwise lower estimated density. Double_t GetBias(Double_t x) const; Returns the pointwise approximate estimated density bias. Double_t GetError(Double_t x) const; Returns the pointwise sigma of estimated density. void CheckKernelValidity(); Checks if kernel has unit integral, mu = 0 and positive finite sigma conditions. Double_t ComputeKernelL2Norm() const; Computes the kernel's L2 norm. Double_t ComputeKernelSigma2() const; Computes the kernel's sigma squared. Double_t ComputeKernelMu() const; Computes the kernel's mu. Double_t ComputeKernelIntegral() const; Computes the kernel's integral which ought to be unity. Double_t ComputeMidspread(); Co",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDE.html:12394,Performance,tune,tune,12394,"tion_t* option, Double_t rho); Sets User defined construction options. void SetDrawOptions(Option_t* option, TString& plotOpt, TString& drawOpt); Sets User defined drawing options. void GetOptions(string optionType, string option); Gets User defined KDE construction options. void AssureOptions(); Sets missing construction options to default ones. void CheckOptions(Bool_t isUserDefinedKernel = kFALSE); Sets User global options. void SetKernelType(TKDE::EKernelType kern); Sets User option for the choice of kernel estimator. void SetIteration(TKDE::EIteration iter); Sets User option for fixed or adaptive iteration. void SetMirror(TKDE::EMirror mir); Sets User option for mirroring the data. void SetBinning(TKDE::EBinning ); Sets User option for binning the weights. void SetNBins(UInt_t nbins); Sets User option for number of bins. void SetUseBinsNEvents(UInt_t nEvents); Sets User option for the minimum number of events for allowing automatic binning. void SetTuneFactor(Double_t rho); Factor which can be used to tune the smoothing.; It is used as multiplicative factor for the fixed and adaptive bandwidth.; A value < 1 will reproduce better the tails but oversmooth the peak; while a factor > 1 will overestimate the tail. void SetRange(Double_t xMin, Double_t xMax); Sets minimum range value and maximum range value. void SetUseBins(); Sets User option for using binned weights. void SetMirror(); Sets the mirroring. void SetData(const Double_t* data); Sets the data events input sample or bin centres for binned option and computes basic estimators. void InitFromNewData(); re-initialize when new data have been filled in TKDE; re-compute kernel quantities and mean and sigma. void SetMirroredEvents(); Mirrors the data. void SetMean(); Computes input data's mean. void SetSigma(Double_t R); Computes input data's sigma. void SetKernel(); Sets the kernel density estimator. void SetKernelFunction(TKDE::KernelFunction_Ptr kernfunc = 0); Sets kernel estimator. void SetCanonicalBandwidths",MatchSource.WIKI,root/html530/TKDE.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDE.html
https://root.cern/root/html530/TKDTreeBinning.html:2393,Availability,error,error,2393,"t* data, UInt_t nBins = 100, bool adjustBinEdges = false); virtual~TKDTreeBinning(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinData(ROOT::Fit::BinData& data) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetBinCenter(UInt_t bin) const; UInt_tGetBinContent(UInt_t bin) const; Double_tGetBinDensity(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinEdges(UInt_t bin) const; UInt_tGetBinMaxDensity() const; const Double_t*GetBinMaxEdges(UInt_t bin) const; UInt_tGetBinMinDensity() const; const Double_t*GetBinMinEdges(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinsEdges() const; const Double_t*GetBinsMaxEdges() const; const Double_t*GetBinsMinEdges() const; Double_tGetBinVolume(UInt_t bin) const; const Double_t*GetBinWidth(UInt_t bin) const; Double_tGe",MatchSource.WIKI,root/html530/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTreeBinning.html
https://root.cern/root/html530/TKDTreeBinning.html:2477,Availability,error,error,2477," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinData(ROOT::Fit::BinData& data) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const Double_t*GetBinCenter(UInt_t bin) const; UInt_tGetBinContent(UInt_t bin) const; Double_tGetBinDensity(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinEdges(UInt_t bin) const; UInt_tGetBinMaxDensity() const; const Double_t*GetBinMaxEdges(UInt_t bin) const; UInt_tGetBinMinDensity() const; const Double_t*GetBinMinEdges(UInt_t bin) const; pair<const Double_t*,const Double_t*>GetBinsEdges() const; const Double_t*GetBinsMaxEdges() const; const Double_t*GetBinsMinEdges() const; Double_tGetBinVolume(UInt_t bin) const; const Double_t*GetBinWidth(UInt_t bin) const; Double_tGetDataMax(UInt_t dim) const; Double_tGetDataMin(UInt_t dim) const; UInt_tGetDim() con",MatchSource.WIKI,root/html530/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTreeBinning.html
https://root.cern/root/html530/TKDTreeBinning.html:9990,Safety,avoid,avoid,9990,"ion. Thus data[] = x1,x2,x3,......xN, y1,y2,y3......yN, z1,z2,...........zN,.... Note that the passed dataSize is not the size of the array but is the number of points (N); The size of the array must be at least dataDim*dataSize. ~TKDTreeBinning(); Class's destructor. void SetNBins(UInt_t bins); Sets binning inner structure. void SortBinsByDensity(Bool_t sortAsc = kTRUE); Sorts bins by their density. void SetData(Double_t* data); Sets the data and finds minimum and maximum by dimensional coordinate. void SetTreeData(); Sets the data for constructing the kD-tree. void SetBinsContent(); Sets the bins' content. void SetBinsEdges(); Sets the bins' edges; Double_t* rawBinEdges = fDataBins->GetBoundaryExact(fDataBins->GetNNodes());. void SetBinMinMaxEdges(Double_t* binEdges); Sets the bins' minimum and maximum edges. void SetCommonBinEdges(Double_t* binEdges); Sets indexing on the bin edges which have common boundaries. void ReadjustMinBinEdges(Double_t* binEdges); Readjusts the bins' minimum edge by shifting it slightly lower; to avoid overlapping with the data. void ReadjustMaxBinEdges(Double_t* binEdges); Readjusts the bins' maximum edge; and shift it sligtly higher. const Double_t* GetBinsMinEdges() const; Returns the bins' minimum edges. const Double_t* GetBinsMaxEdges() const; Returns the bins' maximum edges. std::pair<const Double_t*, const Double_t*> GetBinsEdges() const; Returns the bins' edges. const Double_t* GetBinMinEdges(UInt_t bin) const; Returns the bin's minimum edges. 'bin' is between 0 and fNBins - 1. const Double_t* GetBinMaxEdges(UInt_t bin) const; Returns the bin's maximum edges. 'bin' is between 0 and fNBins - 1. std::pair<const Double_t*, const Double_t*> GetBinEdges(UInt_t bin) const; Returns the bin's edges. 'bin' is between 0 and fNBins - 1. UInt_t GetNBins() const; Returns the number of bins. UInt_t GetDim() const; Returns the number of dimensions. UInt_t GetBinContent(UInt_t bin) const; Returns the number of points in bin. 'bin' is between 0 a",MatchSource.WIKI,root/html530/TKDTreeBinning.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTreeBinning.html
https://root.cern/root/html530/TKDTree_int_double_.html:1960,Availability,down,down,1960,"ng a multidimensional search key (e.g. range searches and; nearest neighbour searches). kd-trees are a special case of BSP trees. A kd-tree uses only splitting planes that are perpendicular to one of the coordinate system axes.; This differs from BSP trees, in which arbitrary splitting planes can be used.; In addition, in the typical definition every node of a kd-tree, from the root to the leaves, stores a point.; This differs from BSP trees, in which leaves are typically the only nodes that contain points; (or other geometric primitives). As a consequence, each splitting plane must go through one of; the points in the kd-tree. kd-trees are a variant that store data only in leaf nodes. 2. Constructing a classical kd-tree ( Pseudo code). Since there are many possible ways to choose axis-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return n",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:11211,Availability,error,error,11211,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:11295,Availability,error,error,11295,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode) const; virtual const char*TObject::GetName() const; intGetNDim(); Int_",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:18050,Availability,failure,failure,18050,"tfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; double*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); double*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const double* point, Int_t kNN, int* ind, double* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const double* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const double* point) const; returns the in",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:19118,Availability,failure,failure,19118,"turns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const double* point, Int_t kNN, int* ind, double* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const double* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const double* point) const; returns the index of the terminal node to which point belongs; (index in the fAxis, fValue, etc arrays); returns -1 in case of failure. void TKDTree<Index, Value> FindPoint(double* point, int& index, Int_t& iter). find the index of point; works only if we keep fData pointers. void TKDTree<Index, Value> FindInRange(double* point, double range, vector<int>& res); Find all points in the sphere of a given radius ""range"" around the given point; 1st argument - the point; 2nd argument - radius of the shere; 3rd argument - a vector, in which the results will be returned. void TKDTree<Index, Value> UpdateRange(int inode, double* point, double range, vector<int>& res); Internal recursive function with the implementation of range searches. Index* TKDTree<Index, Value> GetPointsIndexes(Int_t node) const; return the indices of the points in that terminal node; for all the nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize. void TKDTree<Index, Value> GetNodePointsIndexes(Int_t node, Int_t& first1, ",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:6589,Energy Efficiency,consumption,consumption,6589," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:4038,Integrability,interface,interface,4038,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:4348,Modifiability,variab,variables,4348,"ave memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npoints; i++){; data0[i]=gRandom->Uniform(xmin, xmax);; data1[i]=gRandom->Uniform(xmin, xmax);; data2[i]=gRandom->Uniform(xmin, xmax);; }; TKDTreeID *kdtree = new TKDTreeID(npoints, ndim, bsize);; kdtree->SetData(0, data0);; kdtree->SetData(1, data1);; kdtree->SetData(2, data2);; kdtree->Build();; }. By default, the kd-tree doesn't own the data and doesn't delete it with itself. If you want the; data to ",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:24102,Modifiability,variab,variables,24102,"l node with just one point minimum and maximum for each; dimension are the same.; Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> FindBNodeA(double* point, double* delta, Int_t& inode). find the smallest node covering the full range - start. Value* TKDTree<Index, Value> GetBoundaries(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundariesExact(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundary(const Int_t node); Get a boundary. Value* TKDTree<Index, Value> GetBoundaryExact(const Int_t node); Get a boundary. Int_t GetLeft(Int_t inode) const; Get indexes of left and right daughter nodes. {return inode*2+1;}. Int_t GetRight(Int_t inode) const; {return (inode+1)*2;}. Int_t GetParent(Int_t inode) const. Other getters. {return (inode-1)/2;}. UChar_t GetNodeAxis(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fAxis[id];}. Value GetNodeValue(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fValue[id];}. Int_t GetNNodes() const; {return fNNodes;}. Int_t GetTotalNodes() const; {return fTotalNodes;}. Index GetNPoints(); { return fNPoints; }. Index GetNDim(); { return fNDim; }. Int_t GetRowT0(); Getters for internal variables. {return fRowT0;}. Int_t GetCrossNode(); {return fCrossNode;}. Int_t GetOffset(); {return fOffset;}. Index* GetIndPoints(); {return fIndPoints;}. Index GetBucketSize(); {return fBucketSize;}. Bool_t IsTerminal(int inode) const; {return (inode>=fNNodes);}. Int_t IsOwner(); { return fDataOwner; }. void SetOwner(Int_t owner); { fDataOwner = owner; }. TKDTree<Index, Value>& operator=(const TKDTree<int,double>& ).  Last changed: Mon Jul 4 15:33:40 2011  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:3473,Performance,optimiz,optimized,3473,"is method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtre",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:6560,Performance,optimiz,optimized,6560," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:8725,Performance,perform,performed,8725,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:21594,Performance,perform,performed,21594," the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, double** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, double* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, double* a, int* index, double& min, double& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, double* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(double* range = 0x0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, ",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:7100,Security,access,access,7100,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:2864,Usability,simpl,simple,2864,"-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tre",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_double_.html:4118,Usability,simpl,simplify,4118,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html530/TKDTree_int_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_double_.html
https://root.cern/root/html530/TKDTree_int_float_.html:1957,Availability,down,down,1957,"ng a multidimensional search key (e.g. range searches and; nearest neighbour searches). kd-trees are a special case of BSP trees. A kd-tree uses only splitting planes that are perpendicular to one of the coordinate system axes.; This differs from BSP trees, in which arbitrary splitting planes can be used.; In addition, in the typical definition every node of a kd-tree, from the root to the leaves, stores a point.; This differs from BSP trees, in which leaves are typically the only nodes that contain points; (or other geometric primitives). As a consequence, each splitting plane must go through one of; the points in the kd-tree. kd-trees are a variant that store data only in leaf nodes. 2. Constructing a classical kd-tree ( Pseudo code). Since there are many possible ways to choose axis-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return n",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:11198,Availability,error,error,11198,"tion_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const float* point, int ind, Int_t type = 2) const; voidDistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(float* point, float* delta, Int_t& inode); voidFindInRange(float* point, float range, vector<int>& res); voidFindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); intFindNode(const float* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(float* point, int& index, Int_t& iter); float*GetBoundaries(); float*GetBoundariesExact(); float*GetBoundary(const Int_t node); float*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:11282,Availability,error,error,11282,"TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const float* point, int ind, Int_t type = 2) const; voidDistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(float* point, float* delta, Int_t& inode); voidFindInRange(float* point, float range, vector<int>& res); voidFindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); intFindNode(const float* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(float* point, int& index, Int_t& iter); float*GetBoundaries(); float*GetBoundariesExact(); float*GetBoundary(const Int_t node); float*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft(Int_t inode) const; virtual const char*TObject::GetName() const; intGetNDim(); Int_tGetNNodes()",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:18002,Availability,failure,failure,18002," intfNDimnumber of dimensions; intfNDimmdummy 2*fNDim; Int_tfNNodessize of node array; intfNPointsnumber of multidimensional points; Int_tfOffset! offset in fIndPoints - if there are 2 rows, that contain terminal nodes; float*fRange[fNDimm] range of data for each dimension; Int_tfRowT0! smallest terminal row - first row that contains terminal nodes; Int_tfTotalNodestotal number of nodes (fNNodes + terminal nodes); float*fValue[fNNodes] nodes cutting value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TKDTree<Index, Value> Build(). Build the kd-tree. 1. calculate number of nodes; 2. calculate first terminal row; 3. initialize index array; 4. non recursive building of the binary tree. The tree is divided recursively. See class description, section 4b for the details; of the division alogrithm. void TKDTree<Index, Value> FindNearestNeighbors(const float* point, Int_t k, int* ind, float* dist); Find kNN nearest neighbors to the point in the first argument; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of t",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:19063,Availability,failure,failure,19063,"nt; Returns 1 on success, 0 on failure; Arrays ind and dist are provided by the user and are assumed to be at least kNN elements long. void TKDTree<Index, Value> UpdateNearestNeighbors(int inode, const float* point, Int_t kNN, int* ind, float* dist); Update the nearest neighbors values by examining the node inode. Double_t TKDTree<Index, Value> Distance(const float* point, int ind, Int_t type = 2) const; Find the distance between point of the first argument and the point at index value ind; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric. void TKDTree<Index, Value> DistanceToNode(const float* point, int inode, float& min, float& max, Int_t type = 2); Find the minimal and maximal distance from a given point to a given node.; Type argument specifies the metric: type=2 - L2 metric, type=1 - L1 metric; If the point is inside the node, both min and max are set to 0. Index TKDTree<Index, Value> FindNode(const float* point) const; returns the index of the terminal node to which point belongs; (index in the fAxis, fValue, etc arrays); returns -1 in case of failure. void TKDTree<Index, Value> FindPoint(float* point, int& index, Int_t& iter). find the index of point; works only if we keep fData pointers. void TKDTree<Index, Value> FindInRange(float* point, float range, vector<int>& res); Find all points in the sphere of a given radius ""range"" around the given point; 1st argument - the point; 2nd argument - radius of the shere; 3rd argument - a vector, in which the results will be returned. void TKDTree<Index, Value> UpdateRange(int inode, float* point, float range, vector<int>& res); Internal recursive function with the implementation of range searches. Index* TKDTree<Index, Value> GetPointsIndexes(Int_t node) const; return the indices of the points in that terminal node; for all the nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize. void TKDTree<Index, Value> GetNodePointsIndexes(Int_t node, Int_t& first1, Int_t",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:6586,Energy Efficiency,consumption,consumption,6586," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:4035,Integrability,interface,interface,4035,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:4345,Modifiability,variab,variables,4345,"ave memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npoints; i++){; data0[i]=gRandom->Uniform(xmin, xmax);; data1[i]=gRandom->Uniform(xmin, xmax);; data2[i]=gRandom->Uniform(xmin, xmax);; }; TKDTreeID *kdtree = new TKDTreeID(npoints, ndim, bsize);; kdtree->SetData(0, data0);; kdtree->SetData(1, data1);; kdtree->SetData(2, data2);; kdtree->Build();; }. By default, the kd-tree doesn't own the data and doesn't delete it with itself. If you want the; data to ",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:24033,Modifiability,variab,variables,24033,"inal node with just one point minimum and maximum for each; dimension are the same.; Boundaries can be retrieved by calling GetBoundaryExact(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value> FindBNodeA(float* point, float* delta, Int_t& inode). find the smallest node covering the full range - start. Value* TKDTree<Index, Value> GetBoundaries(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundariesExact(); Get the boundaries. Value* TKDTree<Index, Value> GetBoundary(const Int_t node); Get a boundary. Value* TKDTree<Index, Value> GetBoundaryExact(const Int_t node); Get a boundary. Int_t GetLeft(Int_t inode) const; Get indexes of left and right daughter nodes. {return inode*2+1;}. Int_t GetRight(Int_t inode) const; {return (inode+1)*2;}. Int_t GetParent(Int_t inode) const. Other getters. {return (inode-1)/2;}. UChar_t GetNodeAxis(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fAxis[id];}. Value GetNodeValue(Int_t id) const; {return (id < 0 || id >= fNNodes) ? 0 : fValue[id];}. Int_t GetNNodes() const; {return fNNodes;}. Int_t GetTotalNodes() const; {return fTotalNodes;}. Index GetNPoints(); { return fNPoints; }. Index GetNDim(); { return fNDim; }. Int_t GetRowT0(); Getters for internal variables. {return fRowT0;}. Int_t GetCrossNode(); {return fCrossNode;}. Int_t GetOffset(); {return fOffset;}. Index* GetIndPoints(); {return fIndPoints;}. Index GetBucketSize(); {return fBucketSize;}. Bool_t IsTerminal(int inode) const; {return (inode>=fNNodes);}. Int_t IsOwner(); { return fDataOwner; }. void SetOwner(Int_t owner); { fDataOwner = owner; }. TKDTree<Index, Value>& operator=(const TKDTree<int,float>& ).  Last changed: Mon Jul 4 15:33:41 2011  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:3470,Performance,optimiz,optimized,3470,"is method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtre",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:6557,Performance,optimiz,optimized,6557," the kd-tree don't require the original data to be present after the tree; has been built. Check the functions documentation for more details. 3b. Navigating the kd-tree. Nodes of the tree are indexed top to bottom, left to right. The root node has index 0. Functions; TKDTree::GetLeft(Index inode), TKDTree::GetRight(Index inode) and TKDTree::GetParent(Index inode); allow to find the children and the parent of a given node. For a given node, one can find the indexes of the original points, contained in this node,; by calling the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the ",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:8722,Performance,perform,performed,8722,"Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the following way:; Ideal case:; Number of _terminal_ nodes = 2^N, N=3. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 4 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes. Non ideal case:; Number of _terminal_ nodes = 2^N+k, N=3 k=1. INode; irow 0 0 - 1 inode; irow 1 1 2 - 2 inodes; irow 2 3 4 5 6 - 3 inodes; irow 3 7 8 9 10 11 12 13 14 - 8 inodes; irow 4 15 16 - 2 inodes. 3b. The division algorithm:. As described above, the kd-tree is built by repeatingly dividing the given set of points into; 2 smaller sets. The cut is made on the axis with the biggest spread, and the value on the axis,; on which the cut is performed, is chosen based on the following formula:; Suppose, we want to divide n nodes into 2 groups, left and right. Then the left and right; will have the following number of nodes:. n=2^k+rest. Left = 2^k-1 + ((rest>2^k-2) ? 2^k-2 : rest); Right = 2^k-1 + ((rest>2^k-2) ? rest-2^k-2 : 0). For example, let n_nodes=67. Then, the closest 2^k=64, 2^k-1=32, 2^k-2=16.; Left node gets 32+3=35 sub-nodes, and the right node gets 32 sub-nodes. The division process continues until all the nodes contain not more than a predefined number; of points. 3c. The order of nodes in boundary-related arrays. Some kd-tree based algorithms need to know the boundaries of each node. This information can; be computed by calling the TKDTree::MakeBoundaries() function. It fills the following arrays:. fRange : array containing the boundaries of the domain:; | 1st dimension (min + max) | 2nd dimension (min + max) | ...; fBoundaries : nodes boundaries; | 1st node {1st dim * 2 elements | 2nd dim * 2 elements | ...} | 2nd n",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:21532,Performance,perform,performed,21532,"of the node #inode, one can do, for example:; Index *indices = kdtree->GetPointsIndexes();; Int_t first1, last1, first2, last2;; kdtree->GetPointsIndexes(inode, first1, last1, first2, last2);; for (Int_t ipoint=first1; ipoint<=last1; ipoint++){; point = indices[ipoint];; //do something with point;; }; for (Int_t ipoint=first2; ipoint<=last2; ipoint++){; point = indices[ipoint];; //do something with point;; }. Index TKDTree<Index, Value> GetNPointsNode(Int_t node) const; Get number of points in this node; for all the terminal nodes except last, the size is fBucketSize; for the last node it's fOffset%fBucketSize, or if fOffset%fBucketSize==0, it's also fBucketSize. void TKDTree<Index, Value> SetData(int npoints, int ndim, UInt_t bsize, float** data); Set the data array. See the constructor function comments for details. Int_t TKDTree<Index, Value> SetData(int idim, float* data); Set the coordinate #ndim of all points (the column #ndim of the data matrix); After setting all the data columns, proceed by calling Build() function; Note, that calling this function after Build() is not possible; Note also, that no checks on the array sizes is performed anywhere. void TKDTree<Index, Value> Spread(int ntotal, float* a, int* index, float& min, float& max) const; Calculate spread of the array a. Value TKDTree<Index, Value> KOrdStat(int ntotal, float* a, int k, int* index) const. copy of the TMath::KOrdStat because I need an Index work array. void TKDTree<Index, Value> MakeBoundaries(float* range = 0x0); Build boundaries for each node. Note, that the boundaries here are built; based on the splitting planes of the kd-tree, and don't necessarily pass; through the points of the original dataset. For the latter functionality; see function MakeBoundariesExact(); Boundaries can be retrieved by calling GetBoundary(inode) function that would; return an array of boundaries for the specified node, or GetBoundaries() function; that would return the complete array. void TKDTree<Index, Value>",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:7097,Security,access,access,7097,"ing the GetNodePointsIndexes(Index inode) function. Additionally, for terminal nodes,; there is a function GetPointsIndexes(Index inode) that returns a pointer to the relevant; part of the index array. To find the number of point in the node; (not only terminal), call TKDTree::GetNpointsNode(Index inode). 4. TKDtree implementation details - internal information, not needed to use the kd-tree.; 4a. Order of nodes in the node information arrays:. TKDtree is optimized to minimize memory consumption.; Nodes of the TKDTree do not store pointers to the left and right children or to the parent node,; but instead there are several 1-d arrays of size fNNodes with information about the nodes.; The order of the nodes information in the arrays is described below. It's important to understand; it, if one's class needs to store some kind of additional information on the per node basis, for; example, the fit function parameters. Drawback: Insertion to the TKDtree is not supported.; Advantage: Random access is supported. As noted above, the construction of the kd-tree involves choosing the axis and the point on; that axis to divide the remaining points approximately in half. The exact algorithm for choosing; the division point is described in the next section. The sequence of divisions is; recorded in the following arrays:; fAxix[fNNodes] - Division axis (0,1,2,3 ...); fValue[fNNodes] - Division value. Given the index of a node in those arrays, it's easy to find the indices, corresponding to; children nodes or the parent node:; Suppose, the parent node is stored under the index inode. Then:; Left child index = inode*2+1; Right child index = (inode+1)*2; Suppose, that the child node is stored under the index inode. Then:; Parent index = inode/2. Number of division nodes and number of terminals :; fNNodes = (fNPoints/fBucketSize). The nodes are filled always from left side to the right side:; Let inode be the index of a node, and irow - the index of a row; The TKDTree looks the follo",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:2861,Usability,simpl,simple,2861,"-aligned splitting planes, there are many different ways; to construct kd-trees. The canonical method of kd-tree construction has the following constraints:. * As one moves down the tree, one cycles through the axes used to select the splitting planes.; (For example, the root would have an x-aligned plane, the root's children would both have y-aligned; planes, the root's grandchildren would all have z-aligned planes, and so on.); * At each step, the point selected to create the splitting plane is the median of the points being; put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption; that we feed the entire set of points into the algorithm up-front.). This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root.; However, balanced trees are not necessarily optimal for all applications.; The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used; by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the; concept):. function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tre",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKDTree_int_float_.html:4115,Usability,simpl,simplify,4115,"r int axis := depth mod k;. // Sort point list and choose median as pivot element; select median from pointList;. // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }. Our construction method is optimized to save memory, and differs a bit from the constraints above.; In particular, the division axis is chosen as the one with the biggest spread, and the point to create the; splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal nodes and is a; perfectly balanced binary tree, and, while at the same time, trying to keep the number of terminal nodes; in the 2 subtrees as close as possible. The following section gives more details about our implementation. 3. Using TKDTree. 3a. Creating the tree and setting the data; The interface of the TKDTree, that allows to set input data, has been developped to simplify using it; together with TTree::Draw() functions. That's why the data has to be provided column-wise. For example:; {; TTree *datatree = ... datatree->Draw(""x:y:z"", ""selection"", ""goff"");; //now make a kd-tree on the drawn variables; TKDTreeID *kdtree = new TKDTreeID(npoints, 3, 1);; kdtree->SetData(0, datatree->GetV1());; kdtree->SetData(1, datatree->GetV2());; kdtree->SetData(2, datatree->GetV3());; kdtree->Build();; }; NOTE, that this implementation of kd-tree doesn't support adding new points after the tree has been built; Of course, it's not necessary to use TTree::Draw(). What is important, is to have data columnwise.; An example with regular arrays:; {; Int_t npoints = 100000;; Int_t ndim = 3;; Int_t bsize = 1;; Double_t xmin = -0.5;; Double_t xmax = 0.5;; Double_t *data0 = new Double_t[npoints];; Double_t *data1 = new Double_t[npoints];; Double_t *data2 = new Double_t[npoints];; Double_t *y = new Double_t[npoints];; for (Int_t i=0; i<npo",MatchSource.WIKI,root/html530/TKDTree_int_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKDTree_int_float_.html
https://root.cern/root/html530/TKey.html:897,Availability,redundant,redundant,897,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:3040,Availability,error,error,3040," const char* name, Int_t bufsize, TDirectory* motherDir = 0); virtual~TKey(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*GetBufferRef() const; virtual const char*GetClassName() const; Short_tGetCycle() const; const TDatime&GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*GetIconName() const; Short_tGetKeep() const; Int_tGetKeylen() const; TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetObjlen() const; virtual Option_t*",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:3124,Availability,error,error,3124,"bject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*GetBufferRef() const; virtual const char*GetClassName() const; Short_tGetCycle() const; const TDatime&GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*GetFile() const; virtual const char*GetIconName() const; Short_tGetKeep() const; Int_tGetKeylen() const; TDirectory*GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tGetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetObjlen() const; virtual Option_t*TObject::GetOption() const; virtual Long64_tGetSeekKey() const; virtual Long64_tGetS",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:16809,Availability,error,error,16809,"The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& b); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fV",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:17025,Availability,error,error,17025,"tuation will add key to gDirectory ???. void ReadKeyBuffer(char*& buffer); Decode input buffer. Bool_t ReadFile(); Read the key structure from the file. void SetParent(const TObject* parent); Set parent in key buffer. void Reset(); Reset the key as it had not been 'filled' yet. Int_t Sizeof() const; Return the size in bytes of the key header structure.; Int_t nbytes = sizeof fNbytes; 4; += sizeof(Version_t); 2; += sizeof fObjlen; 4; += sizeof fKeylen; 2; += sizeof fCycle; 2; += sizeof fSeekKey; 4 or 8; += sizeof fSeekPdir; 4 or 8; = 22. void Streamer(TBuffer& b); Stream a class object. Int_t WriteFile(Int_t cycle = 1, TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. Int_t WriteFileKeepBuffer(TFile* f = 0); Write the encoded object supported by this key.; The function returns the number of bytes committed to the file.; If a write error occurs, the number of bytes returned is -1. const char * GetIconName() const; Title can keep 32x32 xpm thumbnail/icon of the parent object. const char * GetTitle() const; Returns title (title can contain 32x32 xpm thumbnail/icon). TKey(const TKey& ). TKey& operator=(const TKey& ). Int_t Read(const char* name); { return TObject::Read(name); }. const char * GetClassName() const; {return fClassName.Data();}. char * GetBuffer() const; {return fBuffer+fKeylen;}. TBuffer * GetBufferRef() const; {return fBufferRef;}. const TDatime & GetDatime() const; {return fDatime;}. Int_t GetKeylen() const; {return fKeylen;}. TDirectory* GetMotherDir() const; { return fMotherDir; }. Int_t GetNbytes() const; {return fNbytes;}. Int_t GetObjlen() const; {return fObjlen;}. Int_t GetVersion() const; {return fVersion;}. Long64_t GetSeekKey() const; {return fSeekKey;}. Long64_t GetSeekPdir() const; {return fSeekPdir;}. void SetBuffer(); { fBuffer = new char[fNbytes];}. void SetMotherDir(TDirectory* dir); { fMotherDir = dir;",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:11153,Energy Efficiency,allocate,allocated,11153,"ion parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You still have to call ""delete key"".; This is different from the behaviour of TObject::Delete()!. void DeleteBuffer(); Delete key buffer(s). Short_t GetCycle() const; Return cycle number associated to this key. TFile * GetFile() const; Returns file to which key belong. Short_t GetKeep() const; Returns the ""KEEP"" status. void FillBuffer(char*& buffer); Encode key header into output buffer. ULong_t Hash() const; This Hash function should redefine the default from TNamed. void IncrementPidOffset(UShort_t offset); Increment fPidOffset by 'offset'.; This offset is used when a key (or basket) is transfered from one file to; the other. In this case the TRef and TObject might have stored a pid; index (to retrieve TProcessIDs) which refered to their order on the; origin",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:13306,Modifiability,inherit,inheritance,13306,"ed and need to be zero for new key/basket. Bool_t IsFolder() const; Check if object referenced by the key is a folder. void Keep(); Set the ""KEEP"" status.; When the KEEP flag is set to 1 the object cannot be purged. void ls(Option_t* option = """") const; List Key contents. void Print(Option_t* option = """") const; Print key contents. TObject * ReadObj(); To read a TObject* from the file. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. see TKey::ReadObjectAny to read any object non-derived from TObject. NOTE:; In case the class of this object derives from TObject but not; as a first inheritance, one must cast the return value twice.; Example1: Normal case:; class MyClass : public TObject, public AnotherClass; then on return, one can do:; MyClass *obj = (MyClass*)key->ReadObj();. Example2: Special case:; class MyClass : public AnotherClass, public TObject; then on return, one must do:; MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());. Of course, dynamic_cast<> can also be used in the example 1. TObject * ReadObjWithBuffer(char* bufferRead); To read a TObject* from bufferRead.; This function is identical to TKey::ReadObj, but it reads directly; from bufferRead instead of reading from a file.; The object associated to this key is read from the buffer into memory; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer ",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:15028,Modifiability,inherit,inherits,15028,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:897,Safety,redund,redundant,897,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:9486,Safety,avoid,avoid,9486," of bytes for the object on file; Int_tfObjlenLength of uncompressed object in bytes; UShort_tfPidOffset! Offset to be added to the pid index in this key/buffer. This is actually saved in the high bits of fSeekPdir; Long64_tfSeekKeyLocation of object on file; Long64_tfSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir,",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:9789,Safety,avoid,avoid,9789,"ry on file; TStringTNamed::fTitleobject title; Int_tfVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKey(); TKey default constructor. TKey(TDirectory* motherDir); TKey default constructor. TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If obj",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:10057,Safety,avoid,avoid,10057,"(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object to read keys.; Constructor called by TDirectoryFile::ReadKeys and by TFile::TFile.; A TKey object is created to read the keys structure itself. TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, ",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:10359,Safety,avoid,avoid,10359,"irectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); Create a TKey object with the specified name, title for the given class. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for a TObject* and fill output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). TKey(const void* obj, const TClass* cl, const char* name, Int_t bufsize, TDirectory* motherDir = 0); Create a TKey object for any object obj of class cl d and fill; output buffer. WARNING: in name avoid special characters like '^','$','.' that are used; by the regular expression parser (see TRegexp). void Build(TDirectory* motherDir, const char* classname, Long64_t filepos); method used in all TKey constructor to initialize basic data fields; filepos is used to calculate correct version number of key; if filepos==-1, end of file position is used. void Browse(TBrowser* b); Read object from disk and call its Browse() method.; If object with same name already exist in memory delete it (like; TDirectoryFile::Get() is doing), except when the key references a; folder in which case we don't want to re-read the folder object; since it might contain new objects not yet saved. void Create(Int_t nbytes, TFile* f = 0); Create a TKey object of specified size; if externFile!=0, key will be allocated in specified file,; otherwise file of mother directory will be used. ~TKey(); TKey default destructor. void Delete(Option_t* option = """"); Delete an object from the file.; Note: the key is not deleted. You s",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:15095,Safety,safe,safely,15095,"object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. NOTE :; This function is called only internally by ROOT classes.; Although being public it is not supposed to be used outside ROOT.; If used, you must make sure that the bufferRead is large enough to; accomodate the object being read. void * ReadObjectAny(const TClass* expectedClass); To read an object (non deriving from TObject) from the file. If expectedClass is not null, we checked that that actual class of; the object stored is suitable to be stored in a pointer pointing; to an object of class 'expectedClass'. We also adjust the value; of the returned address so that it is suitable to be cast (C-Style); a a pointer pointing to an object of class 'expectedClass'. So for example if the class Bottom inherits from Top and the object; stored is of type Bottom you can safely do:. TClass *TopClass = TClass::GetClass(""Top"");; Top *ptr = (Top*) key->ReadObjectAny( TopClass );; if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");. The object associated to this key is read from the file into memory; Once the key structure is read (via Streamer) the class identifier; of the object is known.; Using the class identifier we find the TClass object for this class.; A TClass object contains a full description (i.e. dictionary) of the; associated class. In particular the TClass object can create a new; object of the class type it describes. This new object now calls its; Streamer function to rebuilt itself. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. void ReadBuffer(char*& buffer); Decode input buffer.; In some situatio",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKey.html:954,Security,integrity,integrity,954,". TKey. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TKey. class TKey: public TNamed. The TKey class includes functions to book space in a file,; to create I/O buffers, to fill these buffers,; to compress/uncompress data buffers. Before saving (making persistent) an object in a file, a key must; be created. The key structure contains all the information to; uniquely identify a persistent object in a file.; fNbytes = Number of bytes for the compressed object+key; fObjlen = Length of uncompressed object; fDatime = Date/Time when the object was written; fKeylen = Number of bytes for the key structure; fCycle = Cycle number of the object; fSeekKey = Address of the object on file (points to fNbytes); This is a redundant information used to cross-check; the data base integrity.; fSeekPdir = Pointer to the directory supporting this object; fClassName = Object class name; fName = Name of the object; fTitle = Title of the object. In the 16 highest bits of fSeekPdir is encoded a pid offset. This; offset is to be added to the pid index stored in the TRef object; and the referenced TObject. The TKey class is used by ROOT to:; - to write an object in the current directory; - to write a new ntuple buffer. The structure of a file is shown in TFile::TFile.; The structure of a directory is shown in TDirectoryFile ctor.; The TKey class is used by the TBasket class.; See also TTree. Function Members (Methods); public:. TKey(); TKey(TDirectory* motherDir); TKey(Long64_t pointer, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TObject* obj, const char* name, Int_t bufsize, TDirectory* motherDir = 0); TKey(const char* name, const char* title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0); TKey(const TString& name, const TString& title, const TClass* cl, Int_t nbytes, TDirectory* motherDir = 0",MatchSource.WIKI,root/html530/TKey.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKey.html
https://root.cern/root/html530/TKeyMapFile.html:1695,Availability,error,error,1695,"MapFile(const char* name, const char* classname, TMapFile* mapfile); virtual~TKeyMapFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html530/TKeyMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyMapFile.html
https://root.cern/root/html530/TKeyMapFile.html:1779,Availability,error,error,1779,"File(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html530/TKeyMapFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyMapFile.html
https://root.cern/root/html530/TKeySQL.html:1777,Availability,error,error,1777,"r* keydatetime, Int_t cycle, const char* classname); virtual~TKeySQL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Long64_tGetDBDirId() const; Long64_tGetDBKeyId() const; Long64_tGetDBObjId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtua",MatchSource.WIKI,root/html530/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeySQL.html
https://root.cern/root/html530/TKeySQL.html:1861,Availability,error,error,1861,":AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; Long64_tGetDBDirId() const; Long64_tGetDBKeyId() const; Long64_tGetDBObjId() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetOb",MatchSource.WIKI,root/html530/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeySQL.html
https://root.cern/root/html530/TKeySQL.html:9909,Availability,error,error,9909,"st char* classname); Create TKeySQL object, which correponds to single entry in keys table. ~TKeySQL(); TKeySQL destructor. Bool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type from SQL database. void* ReadKeyObject(void* obj, const TClass* expectedClass); Read object, associated with key, from database. TKeySQL(const TKeySQL& ). TKeySQL& operator=(const TKeySQL& ). Int_t Read(const char* name); { return TKey::Read(name); }. Long64_t GetDBKeyId() const; { return fKeyId; }. Long64_t GetDBObjId() const; { return fObjId; }. void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return GetDBObjId() > 0 ? GetDBObjId() : 0; }. Long64_t GetSeekPdir() const; { return GetDBDirId() > 0 ? GetDBDirId() : 0; }. void Keep(); {}. void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t W",MatchSource.WIKI,root/html530/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeySQL.html
https://root.cern/root/html530/TKeySQL.html:10047,Availability,error,error,10047,"ool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type from SQL database. void* ReadKeyObject(void* obj, const TClass* expectedClass); Read object, associated with key, from database. TKeySQL(const TKeySQL& ). TKeySQL& operator=(const TKeySQL& ). Int_t Read(const char* name); { return TKey::Read(name); }. Long64_t GetDBKeyId() const; { return fKeyId; }. Long64_t GetDBObjId() const; { return fObjId; }. void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return GetDBObjId() > 0 ? GetDBObjId() : 0; }. Long64_t GetSeekPdir() const; { return GetDBDirId() > 0 ? GetDBDirId() : 0; }. void Keep(); {}. void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t WriteFile(Int_t = 1, TFile* = 0); { return 0; }.  Author: Sergey Linev 20/11/2005  Copyright (C) 1995-2005, Rene Brun and Fo",MatchSource.WIKI,root/html530/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeySQL.html
https://root.cern/root/html530/TKeySQL.html:9273,Deployability,update,updated,9273,"64_tTKey::fSeekPdirLocation of parent directory on file; TStringTNamed::fTitleobject title; Int_tTKey::fVersionKey version identifier. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKeySQL(); default constructor. TKeySQL(TDirectory* mother, const TObject* obj, const char* name, const char* title = 0); Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. TKeySQL(TDirectory* mother, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeySQL and convert obj data to TSQLStructure via TBufferSQL2. TKeySQL(TDirectory* mother, Long64_t keyid, Long64_t objid, const char* name, const char* title, const char* keydatetime, Int_t cycle, const char* classname); Create TKeySQL object, which correponds to single entry in keys table. ~TKeySQL(); TKeySQL destructor. Bool_t IsKeyModified(const char* keyname, const char* keytitle, const char* keydatime, Int_t cycle, const char* classname); Compares keydata with provided and return kTRUE if key was modified; Used in TFile::StreamKeysForDirectory() method to verify data for that keys; should be updated. void Delete(Option_t* option = """"); Removes key from current directory; Note: TKeySQL object is not deleted. You still have to call ""delete key"". Long64_t GetDBDirId() const; return sql id of parent directory. void StoreKeyObject(const void* obj, const TClass* cl); Stores object, associated with key, into data tables. Int_t Read(TObject* obj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); Read object derived from TObject class; If it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); Read object derived from TObject class; If it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type",MatchSource.WIKI,root/html530/TKeySQL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeySQL.html
https://root.cern/root/html530/TKeyXML.html:1707,Availability,error,error,1707,"Class* cl, const char* name, const char* title = 0); virtual~TKeyXML(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Long64_tGetKeyId() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; s",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKeyXML.html:1791,Availability,error,error,1791,":AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTKey::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); virtual voidDeleteBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual char*GetBuffer() const; TBuffer*TKey::GetBufferRef() const; virtual const char*TKey::GetClassName() const; Short_tTKey::GetCycle() const; const TDatime&TKey::GetDatime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFile*TKey::GetFile() const; virtual const char*TKey::GetIconName() const; Short_tTKey::GetKeep() const; Long64_tGetKeyId() const; Int_tTKey::GetKeylen() const; TDirectory*TKey::GetMotherDir() const; virtual const char*TNamed::GetName() const; Int_tTKey::GetNbytes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTKey::GetObjlen() const; virtual Option_t",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKeyXML.html:9736,Availability,error,error,9736,"es TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return fKeyNode ? 1024 : 0;}. Long64_t GetSeekPdir() const; virtual ULong_t Hash() const { return 0; }. { return fKeyNode ? 1024 : 0;}. void Keep(); virtual void ls(Option_t* ="""") const;; virtual void Print(Option_t* ="""") const {}. {}. Int_t Read(TObject* tobj). void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. ",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKeyXML.html:9884,Availability,error,error,9884,"ML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return fKeyNode ? 1024 : 0;}. Long64_t GetSeekPdir() const; virtual ULong_t Hash() const { return 0; }. { return fKeyNode ? 1024 : 0;}. void Keep(); virtual void ls(Option_t* ="""") const;; virtual void Print(Option_t* ="""") const {}. {}. Int_t Read(TObject* tobj). void ReadBuffer(char*& ); {}. Bool_t ReadFile(); { return kTRUE; }. void SetBuffer(); { fBuffer = 0; }. Int_t WriteFile(Int_t = 1, TFile* = 0); { return 0; }. XMLNodePointer_t KeyNode() const; TKeyXML sp",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKeyXML.html:9281,Deployability,update,update,9281,"rts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKeyXML.html:9349,Deployability,update,updates,9349," TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKeyXML.html:9410,Deployability,update,update,9410," TKeyXML(); default constructor. TKeyXML(TDirectory* mother, Long64_t keyid, const TObject* obj, const char* name = 0, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, const void* obj, const TClass* cl, const char* name, const char* title = 0); Creates TKeyXML and convert obj data to xml structures. TKeyXML(TDirectory* mother, Long64_t keyid, XMLNodePointer_t keynode); Creates TKeyXML and takes ownership over xml node, from which object can be restored. ~TKeyXML(); TKeyXML destructor. void Delete(Option_t* option = """"); Delete key from current directory; Note: TKeyXML object is not deleted. You still have to call ""delete key"". void StoreKeyAttributes(); Stores keys attributes in key node. void StoreObject(const void* obj, const TClass* cl); convert object to xml structure and keep this structure in key. void UpdateAttributes(); update key attributes in key node. void UpdateObject(TObject* obj); updates object, stored in the node; Used for TDirectory data update. Int_t Read(TObject* tobj); To read an object from the file.; The object associated to this key is read from the file into memory.; Before invoking this function, obj has been created via the; default constructor. TObject* ReadObj(); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. TObject* ReadObjWithBuffer(char* bufferRead); read object derived from TObject class, from key; if it is not TObject or in case of error, return 0. void* ReadObjectAny(const TClass* expectedClass); read object of any type. void* XmlReadAny(void* obj, const TClass* expectedClass); read object from key and cast to expected class. TXMLEngine* XMLEngine(); return pointer on TXMLEngine object, used for xml conversion. TKeyXML(const TKeyXML& ). TKeyXML& operator=(const TKeyXML& ). void DeleteBuffer(); {}. void FillBuffer(char*& ); {}. char * GetBuffer() const; { return 0; }. Long64_t GetSeekKey() const; { return",MatchSource.WIKI,root/html530/TKeyXML.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKeyXML.html
https://root.cern/root/html530/TKSocket.html:1467,Availability,error,error,1467,"tion = """"); Int_tBlockRead(char*& buf, TKSocket::EEncoding& type); Int_tBlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TKSocket*Connect(const char* server, Int_t port); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKSocket.html
https://root.cern/root/html530/TKSocket.html:1551,Availability,error,error,1551,"onst char* buf, Int_t len, TKSocket::EEncoding type); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; static TKSocket*Connect(const char* server, Int_t port); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKSocket.html
https://root.cern/root/html530/TKSocket.html:5989,Availability,error,error,5989,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0).  Last changed: root/krb5auth:$Id: TKSocket.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKSocket.html
https://root.cern/root/html530/TKSocket.html:5471,Performance,cache,cache,5471,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0).  Last changed: root/krb5auth:$Id: TKSocket.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKSocket.html
https://root.cern/root/html530/TKSocket.html:5338,Security,authenticat,authentication,5338,"onst; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TKSocket(TSocket* s = 0). Data Members; public:. enum EEncoding { kNone; kSafe; kPriv; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. void*fAuthContextper connection kerberos authentication context; void*fServerserver principal; TSocket*fSocketunderlying socket; static void*fgCCDefshared default credential cache; static void*fgClientclient principal; static void*fgContextshared kerberos context. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TKSocket(TSocket* s = 0); Constructor. ~TKSocket(); Destructor. TKSocket * Connect(const char* server, Int_t port); Connect to 'server' on 'port'. Int_t BlockRead(char*& buf, TKSocket::EEncoding& type); Read block on information from server. The result is stored in buf.; The number of read bytes is returned; -1 is returned in case of error. Int_t BlockWrite(const char* buf, Int_t len, TKSocket::EEncoding type); Block-send 'length' bytes to server from 'buf'. TKSocket(TSocket* s = 0).  Last changed: root/krb5auth:$Id: TKSocket.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TKSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TKSocket.html
https://root.cern/root/html530/TLatex.html:4008,Availability,down,downarrow,4008,"q"") ; Tl.DrawText(x2, y, ""#leq"");; y -= step ; Tl.DrawLatex(x1, y, ""#approx"") ; Tl.DrawText(x2, y, ""#approx"");; y -= step ; Tl.DrawLatex(x1, y, ""#in"") ; Tl.DrawText(x2, y, ""#in"");; y -= step ; Tl.DrawLatex(x1, y, ""#supset"") ; Tl.DrawText(x2, y, ""#supset"");; y -= step ; Tl.DrawLatex(x1, y, ""#cap"") ; Tl.DrawText(x2, y, ""#cap"");; y -= step ; Tl.DrawLatex(x1, y, ""#ocopyright"") ; Tl.DrawText(x2, y, ""#ocopyright"");; y -= step ; Tl.DrawLatex(x1, y, ""#trademark"") ; Tl.DrawText(x2, y, ""#trademark"");; y -= step ; Tl.DrawLatex(x1, y, ""#times"") ; Tl.DrawText(x2, y, ""#times"");; y -= step ; Tl.DrawLatex(x1, y, ""#bullet"") ; Tl.DrawText(x2, y, ""#bullet"");; y -= step ; Tl.DrawLatex(x1, y, ""#voidb"") ; Tl.DrawText(x2, y, ""#voidb"");; y -= step ; Tl.DrawLatex(x1, y, ""#doublequote"") ; Tl.DrawText(x2, y, ""#doublequote"");; y -= step ; Tl.DrawLatex(x1, y, ""#lbar"") ; Tl.DrawText(x2, y, ""#lbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbottom"") ; Tl.DrawText(x2, y, ""#arcbottom"");; y -= step ; Tl.DrawLatex(x1, y, ""#downarrow"") ; Tl.DrawText(x2, y, ""#downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#leftrightarrow"") ; Tl.DrawText(x2, y, ""#leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Downarrow"") ; Tl.DrawText(x2, y, ""#Downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Leftrightarrow"") ; Tl.DrawText(x2, y, ""#Leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#void8"") ; Tl.DrawText(x2, y, ""#void8"");; y -= step ; Tl.DrawLatex(x1, y, ""#hbar"") ; Tl.DrawText(x2, y, ""#hbar"");. // Draw Second Column; y = 0.96; step = 0.0465; x1 = 0.27; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#diamond"") ; Tl.DrawText(x2, y, ""#diamond"");; y -= step ; Tl.DrawLatex(x1, y, ""#aleph"") ; Tl.DrawText(x2, y, ""#aleph"");; y -= step ; Tl.DrawLatex(x1, y, ""#geq"") ; Tl.DrawText(x2, y, ""#geq"");; y -= step ; Tl.DrawLatex(x1, y, ""#neq"") ; Tl.DrawText(x2, y, ""#neq"");; y -= step ; Tl.DrawLatex(x1, y, ""#notin"") ; Tl.DrawText(x2, y, ""#notin"");; y -= step ; Tl.DrawLatex(x1, y, ""#subseteq"") ; Tl.DrawText(x2, y, ""#subseteq"");; y -= step ; Tl.Draw",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:4043,Availability,down,downarrow,4043,"tep ; Tl.DrawLatex(x1, y, ""#approx"") ; Tl.DrawText(x2, y, ""#approx"");; y -= step ; Tl.DrawLatex(x1, y, ""#in"") ; Tl.DrawText(x2, y, ""#in"");; y -= step ; Tl.DrawLatex(x1, y, ""#supset"") ; Tl.DrawText(x2, y, ""#supset"");; y -= step ; Tl.DrawLatex(x1, y, ""#cap"") ; Tl.DrawText(x2, y, ""#cap"");; y -= step ; Tl.DrawLatex(x1, y, ""#ocopyright"") ; Tl.DrawText(x2, y, ""#ocopyright"");; y -= step ; Tl.DrawLatex(x1, y, ""#trademark"") ; Tl.DrawText(x2, y, ""#trademark"");; y -= step ; Tl.DrawLatex(x1, y, ""#times"") ; Tl.DrawText(x2, y, ""#times"");; y -= step ; Tl.DrawLatex(x1, y, ""#bullet"") ; Tl.DrawText(x2, y, ""#bullet"");; y -= step ; Tl.DrawLatex(x1, y, ""#voidb"") ; Tl.DrawText(x2, y, ""#voidb"");; y -= step ; Tl.DrawLatex(x1, y, ""#doublequote"") ; Tl.DrawText(x2, y, ""#doublequote"");; y -= step ; Tl.DrawLatex(x1, y, ""#lbar"") ; Tl.DrawText(x2, y, ""#lbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbottom"") ; Tl.DrawText(x2, y, ""#arcbottom"");; y -= step ; Tl.DrawLatex(x1, y, ""#downarrow"") ; Tl.DrawText(x2, y, ""#downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#leftrightarrow"") ; Tl.DrawText(x2, y, ""#leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Downarrow"") ; Tl.DrawText(x2, y, ""#Downarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#Leftrightarrow"") ; Tl.DrawText(x2, y, ""#Leftrightarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#void8"") ; Tl.DrawText(x2, y, ""#void8"");; y -= step ; Tl.DrawLatex(x1, y, ""#hbar"") ; Tl.DrawText(x2, y, ""#hbar"");. // Draw Second Column; y = 0.96; step = 0.0465; x1 = 0.27; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#diamond"") ; Tl.DrawText(x2, y, ""#diamond"");; y -= step ; Tl.DrawLatex(x1, y, ""#aleph"") ; Tl.DrawText(x2, y, ""#aleph"");; y -= step ; Tl.DrawLatex(x1, y, ""#geq"") ; Tl.DrawText(x2, y, ""#geq"");; y -= step ; Tl.DrawLatex(x1, y, ""#neq"") ; Tl.DrawText(x2, y, ""#neq"");; y -= step ; Tl.DrawLatex(x1, y, ""#notin"") ; Tl.DrawText(x2, y, ""#notin"");; y -= step ; Tl.DrawLatex(x1, y, ""#subseteq"") ; Tl.DrawText(x2, y, ""#subseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#cup"") ; Tl.DrawText(x2, y, ",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:7126,Availability,down,downleftarrow,7126,"lel"");. // Draw Third Column; y = 0.96; step = 0.0465; x1 = 0.52; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#heart"") ; Tl.DrawText(x2, y, ""#heart"");; y -= step ; Tl.DrawLatex(x1, y, ""#Jgothic"") ; Tl.DrawText(x2, y, ""#Jgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#LT"") ; Tl.DrawText(x2, y, ""#LT"");; y -= step ; Tl.DrawLatex(x1, y, ""#equiv"") ; Tl.DrawText(x2, y, ""#equiv"");; y -= step ; Tl.DrawLatex(x1, y, ""#subset"") ; Tl.DrawText(x2, y, ""#subset"");; y -= step ; Tl.DrawLatex(x1, y, ""#supseteq"") ; Tl.DrawText(x2, y, ""#supseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#wedge"") ; Tl.DrawText(x2, y, ""#wedge"");; y -= step ; Tl.DrawLatex(x1, y, ""#oright"") ; Tl.DrawText(x2, y, ""#oright"");; y -= step ; Tl.DrawLatex(x1, y, ""#AA"") ; Tl.DrawText(x2, y, ""#AA"");; y -= step ; Tl.DrawLatex(x1, y, ""#pm"") ; Tl.DrawText(x2, y, ""#pm"");; y -= step ; Tl.DrawLatex(x1, y, ""#3dots"") ; Tl.DrawText(x2, y, ""#3dots"");; y -= step ; Tl.DrawLatex(x1, y, ""#nabla"") ; Tl.DrawText(x2, y, ""#nabla"");; y -= step ; Tl.DrawLatex(x1, y, ""#downleftarrow"") ; Tl.DrawText(x2, y, ""#downleftarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#topbar"") ; Tl.DrawText(x2, y, ""#topbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbar"") ; Tl.DrawText(x2, y, ""#arcbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#uparrow"") ; Tl.DrawText(x2, y, ""#uparrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#oplus"") ; Tl.DrawText(x2, y, ""#oplus"");; y -= step ; Tl.DrawLatex(x1, y, ""#Uparrow"") ; Tl.DrawText(x2, y, ""#Uparrow"");; y -= step ; Tl.DrawLatex(x1, y-0.01, ""#sum"") ; Tl.DrawText(x2, y, ""#sum"");; y -= step ; Tl.DrawLatex(x1, y, ""#perp"") ; Tl.DrawText(x2, y, ""#perp"");; y -= step ; Tl.DrawLatex(x1, y, ""#forall"") ; Tl.DrawText(x2, y, ""#forall""); . // Draw Fourth Column; y = 0.96; step = 0.0465; x1 = 0.77; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#spade"") ; Tl.DrawText(x2, y, ""#spade"");; y -= step ; Tl.DrawLatex(x1, y, ""#Rgothic"") ; Tl.DrawText(x2, y, ""#Rgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#GT"") ; Tl.DrawText(x2, y, ""#GT"");; y -= step ; Tl.DrawLatex(x1, y, ""#propto"") ; ",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:7165,Availability,down,downleftarrow,7165,"= 0.0465; x1 = 0.52; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#heart"") ; Tl.DrawText(x2, y, ""#heart"");; y -= step ; Tl.DrawLatex(x1, y, ""#Jgothic"") ; Tl.DrawText(x2, y, ""#Jgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#LT"") ; Tl.DrawText(x2, y, ""#LT"");; y -= step ; Tl.DrawLatex(x1, y, ""#equiv"") ; Tl.DrawText(x2, y, ""#equiv"");; y -= step ; Tl.DrawLatex(x1, y, ""#subset"") ; Tl.DrawText(x2, y, ""#subset"");; y -= step ; Tl.DrawLatex(x1, y, ""#supseteq"") ; Tl.DrawText(x2, y, ""#supseteq"");; y -= step ; Tl.DrawLatex(x1, y, ""#wedge"") ; Tl.DrawText(x2, y, ""#wedge"");; y -= step ; Tl.DrawLatex(x1, y, ""#oright"") ; Tl.DrawText(x2, y, ""#oright"");; y -= step ; Tl.DrawLatex(x1, y, ""#AA"") ; Tl.DrawText(x2, y, ""#AA"");; y -= step ; Tl.DrawLatex(x1, y, ""#pm"") ; Tl.DrawText(x2, y, ""#pm"");; y -= step ; Tl.DrawLatex(x1, y, ""#3dots"") ; Tl.DrawText(x2, y, ""#3dots"");; y -= step ; Tl.DrawLatex(x1, y, ""#nabla"") ; Tl.DrawText(x2, y, ""#nabla"");; y -= step ; Tl.DrawLatex(x1, y, ""#downleftarrow"") ; Tl.DrawText(x2, y, ""#downleftarrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#topbar"") ; Tl.DrawText(x2, y, ""#topbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#arcbar"") ; Tl.DrawText(x2, y, ""#arcbar"");; y -= step ; Tl.DrawLatex(x1, y, ""#uparrow"") ; Tl.DrawText(x2, y, ""#uparrow"");; y -= step ; Tl.DrawLatex(x1, y, ""#oplus"") ; Tl.DrawText(x2, y, ""#oplus"");; y -= step ; Tl.DrawLatex(x1, y, ""#Uparrow"") ; Tl.DrawText(x2, y, ""#Uparrow"");; y -= step ; Tl.DrawLatex(x1, y-0.01, ""#sum"") ; Tl.DrawText(x2, y, ""#sum"");; y -= step ; Tl.DrawLatex(x1, y, ""#perp"") ; Tl.DrawText(x2, y, ""#perp"");; y -= step ; Tl.DrawLatex(x1, y, ""#forall"") ; Tl.DrawText(x2, y, ""#forall""); . // Draw Fourth Column; y = 0.96; step = 0.0465; x1 = 0.77; x2 = x1+0.04;; Tl.DrawLatex(x1, y, ""#spade"") ; Tl.DrawText(x2, y, ""#spade"");; y -= step ; Tl.DrawLatex(x1, y, ""#Rgothic"") ; Tl.DrawText(x2, y, ""#Rgothic"");; y -= step ; Tl.DrawLatex(x1, y, ""#GT"") ; Tl.DrawText(x2, y, ""#GT"");; y -= step ; Tl.DrawLatex(x1, y, ""#propto"") ; Tl.DrawText(x2, y, ""#propto"");; y -= step ; Tl",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:14937,Availability,avail,available,14937,"au"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Upsilon : "") ; Tl.DrawLatex(x2, y, ""#Upsilon"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Phi : "") ; Tl.DrawLatex(x2, y, ""#Phi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Chi : "") ; Tl.DrawLatex(x2, y, ""#Chi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Psi : "") ; Tl.DrawLatex(x2, y, ""#Psi"");; y -= 0.0375 ; Tl.DrawLatex(x1, y, ""Omega : "") ; Tl.DrawLatex(x2, y, ""#Omega"");. // Draw the variations; x1 = 0.73; x2 = x1+0.2;; y = 0.7500 ; Tl.DrawLatex(x1, y, ""varepsilon : "") ; Tl.DrawLatex(x2, y, ""#varepsilon"");; y = 0.6375 ; Tl.DrawLatex(x1, y, ""vartheta : "") ; Tl.DrawLatex(x2, y, ""#vartheta"");; y = 0.2625 ; Tl.DrawLatex(x1, y, ""varsigma : "") ; Tl.DrawLatex(x2, y, ""#varsigma"");; y = 0.1875 ; Tl.DrawLatex(x1, y, ""varUpsilon : "") ; Tl.DrawLatex(x2, y, ""#varUpsilon"");; y = 0.1500 ; Tl.DrawLatex(x1, y, ""varphi : "") ; Tl.DrawLatex(x2, y, ""#varphi"");; y = 0.0375 ; Tl.DrawLatex(x1, y, ""varomega : "") ; Tl.DrawLatex(x2, y, ""#varomega"");. return Gl;; }. Accents; Several kind of accents are available:. #hat = ; #check = ; #acute = ; #grave = ; #dot = ; #ddot = ; #tilde = . The special sign: #slash draws a slash on top of the text between brackets:. #slash{E}_{T} : . Bar and vectors sign are done the following way:. #bar{a}: ; #vec{a}: . Changing Style; One can change the font, the text color, or the text size at any time using :; #font[font-number]{...}, #color[color-number]{...}; and #scale[scale-factor]{...}; Examples:. #font[12]{Times Italic} and #font[22]{Times bold} : ; #color[2]{Red} and #color[4]{Blue} : ; #scale[1.2]{Bigger} and #scale[0.8]{Smaller} : . Alignment Rules; The TText alignment rules apply to the TLatex objects with one exception; concerning the vertical alignment:. if the vertical alignment = 1 , subscripts are not taken into account ; if the vertical alignment = 0 , the text is aligned to the box surrounding; the full text with sub and superscripts. This is illustrated by the following example:. Picture; Source. {; TCanvas Tlva(""Tlva"",""T",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:17292,Availability,down,down,17292,"ex(.2,.9,""K_{S}"");; latex.DrawLatex(.3,.9,""K^{*0}"");; latex.DrawLatex(.2,.8,longstring);. latex.SetTextAlign(12); //centered; latex.DrawLatex(.2,.6,""K_{S}"");; latex.DrawLatex(.3,.6,""K^{*0}"");; latex.DrawLatex(.2,.5,longstring);. latex.SetTextAlign(11); //default bottom alignment; latex.DrawLatex(.2,.4,""K_{S}"");; latex.DrawLatex(.3,.4,""K^{*0}"");; latex.DrawLatex(.2,.3,longstring);. latex.SetTextAlign(10); //special bottom alignment; latex.DrawLatex(.2,.2,""K_{S}"");; latex.DrawLatex(.3,.2,""K^{*0}"");; latex.DrawLatex(.2,.1,longstring);. latex.SetTextAlign(12);; latex->SetTextFont(72);; latex->DrawLatex(.1,.80,""13"");; latex->DrawLatex(.1,.55,""12"");; latex->DrawLatex(.1,.35,""11"");; latex->DrawLatex(.1,.18,""10"");; return Tlva;; }. Character Adjustement; The two commands #kern and #lower enable a better control; over character placement. The command #kern[(Float_t)dx]{text} moves; the output string horizontally by the fraction dx of its length.; Similarly, #lower[(Float_t)dy]{text} shifts the text up or down by; the fraction dy of its height.; Examples:. Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g}:. Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g}:. Vertical a#lower[0.2]{d}#lower[0.4]{j}#lower[0.1]{u}#lower[-0.1]{s}#lower[-0.3]{t}#lower[-0.4]{m}#lower[-0.2]{e}#lower[0.1]{n}t:. Italic and Boldface; Text can be turned italic or boldface using the commands; #it and #bf.; Examples:. #bf{bold}, #it{italic}, #bf{#it{bold italic}}, #bf{#bf{unbold}}}:. abc#alpha#beta#gamma, #it{abc#alpha#beta#gamma}:. Examples. Picture; Source. {; TCanvas ex1(""ex1"",""Latex"",500,600);; TLatex Tl;; Tl.SetTextAlign(12);; Tl.SetTextSize(0.04);; Tl.DrawLatex(0.1,0.8,""1) C(x) = d #sqrt{#frac{2}{#lambdaD}} #int^{x}_{0}cos(#frac{#pi}{2}t^{2})dt"");; Tl.DrawLatex(0.1,0.6,""2) C(x) = d #sqrt{#frac{2}{#lambdaD}} #int^{x}cos(#frac{#pi}{2}t^{2})dt"");; Tl.DrawLatex(0.1,0.4,""3) R = |A|^{2} = #frac{1}{2}(#[]{#frac{1}{2}+C(V)}^{",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:20831,Availability,error,error,20831,"virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TLatex*DrawLatex(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetHeight() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObj",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:20915,Availability,error,error,20915,"t char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TLatex*DrawLatex(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetHeight() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:28105,Availability,error,error,28105,"e, Double_t size, const Char_t* text); voidTObject::MakeZombie(); TLatex&operator=(const TLatex&); TLatexFormSizeReadfs(); voidSavefs(TLatexFormSize* fs). Data Members; public:. enum { kTextNDC; };; enum TText::[unnamed] { kTextNDC; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. const Char_t*fError!error code; Double_tfFactorPos!Relative position of subscripts and superscripts; Double_tfFactorSize!Relative size of subscripts and superscripts; Bool_tfItalic!Currently inside #it operator; Int_tfLimitFactorSizelower bound for subscripts/superscripts size; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TStringTNamed::fNameobject identifier; Double_tfOriginSizeFont size of the starting font; Int_tfPos!Current position in array fTabSize;; Bool_tfShow!is true during the second pass (Painting); Int_tfTabMax!Maximum allocation for array fTabSize;; FormSize_t*fTabSize!array of values for the different zones; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Double_tTText::fXX position of text (left,center,etc..); Double_tTText::fYY position of text (left,center,etc..). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLatex(); Default constructor. TLatex(Double_t x, Double_t y, const char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:30201,Availability,down,down,30201,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void Paint(Option_t* option = """"); Paint. void PaintLatex(Double_t x, Double_t y, Doub",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:30356,Availability,down,down,30356,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void Paint(Option_t* option = """"); Paint. void PaintLatex(Double_t x, Double_t y, Doub",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLatex.html:30501,Availability,down,down,30501,"nst char* text); Normal constructor. ~TLatex(); Destructor. TLatex(const TLatex& text); Copy constructor. TLatex& operator=(const TLatex& ); assignment operator. void Copy(TObject& text) const; Copy this TLatex object to another TLatex. TLatexFormSize Anal1(TextSpec_t spec, const Char_t* t, Int_t length); Analyse function. TLatexFormSize Analyse(Double_t x, Double_t y, TextSpec_t spec, const Char_t* t, Int_t length); Analyse and paint the TLatex formula. It is called twice : first for calculating the size of; each portion of the formula, then to paint the formula.; When analyse finds an operator or separator, it calls; itself recursively to analyse the arguments of the operator.; when the argument is an atom (normal text), it calculates; the size of it and return it as the result.; for example : if the operator #frac{arg1}{arg2} is found :; Analyse(arg1) return the size of arg1 (width, up, down); Analyse(arg2) return the size of arg2; now, we know the size of #frac{arg1}{arg2} :; width = max(width_arg1, width_arg2); up = up_arg1 + down_arg1; down = up_arg2 + down_arg2; so, when the user wants to paint a fraction at position (x,y),; the rect used for the formula is : (x,y-up,x+width,y+down). return size of zone occupied by the text/formula; t : chain to be analyzed; length : number of chars in t. TLatex * DrawLatex(Double_t x, Double_t y, const char* text); Make a copy of this object with the new parameters; And copy object attributes. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TextSpec_t spec); Draw a line in a Latex formula. void DrawCircle(Double_t x1, Double_t y1, Double_t r, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void DrawParenthesis(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, TextSpec_t spec); Draw an arc of ellipse in a Latex formula (right or left parenthesis). void Paint(Option_t* option = """"); Paint. void PaintLatex(Double_t x, Double_t y, Doub",MatchSource.WIKI,root/html530/TLatex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLatex.html
https://root.cern/root/html530/TLDAPAttribute.html:1478,Availability,error,error,1478,"PAttribute(); voidTObject::AbstractMethod(const char* method) const; voidAddValue(const char* value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteValue(const char* value); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html530/TLDAPAttribute.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPAttribute.html
https://root.cern/root/html530/TLDAPAttribute.html:1562,Availability,error,error,1562,"nst char* value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteValue(const char* value); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html530/TLDAPAttribute.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPAttribute.html
https://root.cern/root/html530/TLDAPEntry.html:1407,Availability,error,error,1407,"voidTObject::AbstractMethod(const char* method) const; voidAddAttribute(const TLDAPAttribute& attr); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteAttribute(const char* name); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPAttribute*GetAttribute() const; TLDAPAttribute*GetAttribute(const char* name) const; Int_tGetCount() const; const char*GetDn() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetReferrals() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtua",MatchSource.WIKI,root/html530/TLDAPEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPEntry.html
https://root.cern/root/html530/TLDAPEntry.html:1491,Availability,error,error,1491,"ttribute& attr); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteAttribute(const char* name); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPAttribute*GetAttribute() const; TLDAPAttribute*GetAttribute(const char* name) const; Int_tGetCount() const; const char*GetDn() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetReferrals() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const ",MatchSource.WIKI,root/html530/TLDAPEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPEntry.html
https://root.cern/root/html530/TLDAPResult.html:1265,Availability,error,error,1265," virtual~TLDAPResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; TLDAPEntry*GetNext(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vi",MatchSource.WIKI,root/html530/TLDAPResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPResult.html
https://root.cern/root/html530/TLDAPResult.html:1349,Availability,error,error,1349," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; TLDAPEntry*GetNext(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom",MatchSource.WIKI,root/html530/TLDAPResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPResult.html
https://root.cern/root/html530/TLDAPResult.html:5607,Integrability,wrap,wrapper,5607,"bufsize = 0) const. protected:. TLDAPResult(const TLDAPResult&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLDAPResult&operator=(const TLDAPResult&). private:. TLDAPResult(); TLDAPResult(LDAP* ld, LDAPMessage* searchresult); TLDAPEntry*CreateEntry(LDAPMessage* entry). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. LDAPMessage*fCurrentEntryPointer to the current entry to be returned from the next GetNext() call; LDAP*fLdLDAP handle of current connection; LDAPMessage*fSearchResultPointer to the LDAP structure that contain search results. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPResult(LDAP* ld, LDAPMessage* searchresult); TLDAPResult object is just a wrapper of the LDAPMessage structure.; LDAP *ld: The current session handler; LDAPMessage *searchresult: The LDAPMessage structure returned from; the ldap_search_s() call. TLDAPResult(const TLDAPResult& ); Copy constructor. TLDAPResult& operator=(const TLDAPResult& ); Equal operator. ~TLDAPResult(); Deletes the LDAPMessage structure. TLDAPEntry * GetNext(); Returns next entry from the search result.; After the last entry it returns a zero pointer; and after this it returns the first entry again.; The user is responsable for deleting the returned object after use. TLDAPEntry * CreateEntry(LDAPMessage* entry); Creates TLDAPEntry object from the data containing in the LDAPMessage; structure and returns pointer to it.; The user is responsable for deleting the returned object after use.; LDAPMessage *entry: Pointer to the LDAPMessage structure containing; the entry data. Int_t GetCount() const; Returns the number of entries in the search result. void Print(O",MatchSource.WIKI,root/html530/TLDAPResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPResult.html
https://root.cern/root/html530/TLDAPServer.html:1469,Availability,error,error,1469,"l~TLDAPServer(); voidTObject::AbstractMethod(const char* method) const; Int_tAddEntry(TLDAPEntry& entry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteEntry(const char* dn); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPResult*GetAttributeTypes(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; const char*GetNamingContexts(); TLDAPResult*GetObjectClasses(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSubschemaSubentry(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:1553,Availability,error,error,1553,"y(TLDAPEntry& entry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteEntry(const char* dn); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPResult*GetAttributeTypes(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; const char*GetNamingContexts(); TLDAPResult*GetObjectClasses(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSubschemaSubentry(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_t",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:7147,Availability,error,error,7147," construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_S",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:8325,Availability,error,error,8325," an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boolean specifying whether both; types and values should be returned with each; attribute (zero) or types only should be returned; (non-zero). Int_t AddEntry(TLDAPEntry& entry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPL",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:8868,Availability,avail,available,8868,"""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boolean specifying whether both; types and values should be returned with each; attribute (zero) or types only should be returned; (non-zero). Int_t AddEntry(TLDAPEntry& entry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPLACE); Modifies specified entry.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = success.; TLDAPEntry &entry: Entry to be modified.; Int_t mode: Modifying mode.; Should be one of LDAP_MOD_ADD (==0),; LDAP_MOD_DELETE (==1) or LDAP_MOD_REPLACE (==2); Specifies what to do with all the entry's attributes; and its values - add to the corresponding entry on; the server, delete from it, or replace the; corresponding attributes with",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:9227,Availability,error,error,9227,"ly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boolean specifying whether both; types and values should be returned with each; attribute (zero) or types only should be returned; (non-zero). Int_t AddEntry(TLDAPEntry& entry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPLACE); Modifies specified entry.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = success.; TLDAPEntry &entry: Entry to be modified.; Int_t mode: Modifying mode.; Should be one of LDAP_MOD_ADD (==0),; LDAP_MOD_DELETE (==1) or LDAP_MOD_REPLACE (==2); Specifies what to do with all the entry's attributes; and its values - add to the corresponding entry on; the server, delete from it, or replace the; corresponding attributes with new values. Int_t DeleteEntry(const char* dn); Deletes the entry with specified DN, the base entry must exist.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = succes. Int_t RenameEntry(const char* dn, const char* newrdn, Bool_t removeattr = kFALSE); Renames the entry with specified DN, the entry must be leaf; Be sure that you are bound with the write permissions; Return value: LDAP error code, 0 = succes; cha",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:9406,Availability,error,error,9406,"object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boolean specifying whether both; types and values should be returned with each; attribute (zero) or types only should be returned; (non-zero). Int_t AddEntry(TLDAPEntry& entry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPLACE); Modifies specified entry.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = success.; TLDAPEntry &entry: Entry to be modified.; Int_t mode: Modifying mode.; Should be one of LDAP_MOD_ADD (==0),; LDAP_MOD_DELETE (==1) or LDAP_MOD_REPLACE (==2); Specifies what to do with all the entry's attributes; and its values - add to the corresponding entry on; the server, delete from it, or replace the; corresponding attributes with new values. Int_t DeleteEntry(const char* dn); Deletes the entry with specified DN, the base entry must exist.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = succes. Int_t RenameEntry(const char* dn, const char* newrdn, Bool_t removeattr = kFALSE); Renames the entry with specified DN, the entry must be leaf; Be sure that you are bound with the write permissions; Return value: LDAP error code, 0 = succes; char *dn: Distinguished name of entry to be renamed.; This entry must be a leaf in the LDAP directory tree.; char *newrdn: The new relative distinguished name to give the entry; being renam",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:9953,Availability,error,error,9953,"n specifying whether both; types and values should be returned with each; attribute (zero) or types only should be returned; (non-zero). Int_t AddEntry(TLDAPEntry& entry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPLACE); Modifies specified entry.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = success.; TLDAPEntry &entry: Entry to be modified.; Int_t mode: Modifying mode.; Should be one of LDAP_MOD_ADD (==0),; LDAP_MOD_DELETE (==1) or LDAP_MOD_REPLACE (==2); Specifies what to do with all the entry's attributes; and its values - add to the corresponding entry on; the server, delete from it, or replace the; corresponding attributes with new values. Int_t DeleteEntry(const char* dn); Deletes the entry with specified DN, the base entry must exist.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = succes. Int_t RenameEntry(const char* dn, const char* newrdn, Bool_t removeattr = kFALSE); Renames the entry with specified DN, the entry must be leaf; Be sure that you are bound with the write permissions; Return value: LDAP error code, 0 = succes; char *dn: Distinguished name of entry to be renamed.; This entry must be a leaf in the LDAP directory tree.; char *newrdn: The new relative distinguished name to give the entry; being renamed.; Bool_t removeattr: This parameter specifies whether or not the; attribute values in the old relative distinguished; name should be removed from the entry; or retained as non-distinguished attributes. void DeleteMods(LDAPMod** mods); Deletes the array of LDAPMod structures and frees its memory.; LDAPMod **mods: Pointer to the zero-terminated array of pointers; to LDAPMod structures. Bool_t IsConnected() const; { return fIsConnected; }.  Last changed: root/ldap:$Id: TLDAPServer.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-0",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:10195,Availability,error,error,10195,"ry); Adds entry to the LDAP tree.; Be sure that you are bound with write permissions.; Return value: LDAP error code. Int_t ModifyEntry(TLDAPEntry& entry, Int_t mode = LDAP_MOD_REPLACE); Modifies specified entry.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = success.; TLDAPEntry &entry: Entry to be modified.; Int_t mode: Modifying mode.; Should be one of LDAP_MOD_ADD (==0),; LDAP_MOD_DELETE (==1) or LDAP_MOD_REPLACE (==2); Specifies what to do with all the entry's attributes; and its values - add to the corresponding entry on; the server, delete from it, or replace the; corresponding attributes with new values. Int_t DeleteEntry(const char* dn); Deletes the entry with specified DN, the base entry must exist.; Be sure that you are bound with write permissions.; Return value: LDAP error code, 0 = succes. Int_t RenameEntry(const char* dn, const char* newrdn, Bool_t removeattr = kFALSE); Renames the entry with specified DN, the entry must be leaf; Be sure that you are bound with the write permissions; Return value: LDAP error code, 0 = succes; char *dn: Distinguished name of entry to be renamed.; This entry must be a leaf in the LDAP directory tree.; char *newrdn: The new relative distinguished name to give the entry; being renamed.; Bool_t removeattr: This parameter specifies whether or not the; attribute values in the old relative distinguished; name should be removed from the entry; or retained as non-distinguished attributes. void DeleteMods(LDAPMod** mods); Deletes the array of LDAPMod structures and frees its memory.; LDAPMod **mods: Pointer to the zero-terminated array of pointers; to LDAPMod structures. Bool_t IsConnected() const; { return fIsConnected; }.  Last changed: root/ldap:$Id: TLDAPServer.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:6806,Integrability,protocol,protocol,6806,"dCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The retu",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:7724,Performance,perform,performs,7724,"t is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filte",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:7941,Performance,perform,performs,7941,"LDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrsonly = 0); Performs searching at the LDAP directory.; Return value: a TLDAPResult object or 0 in case of error.; Result needs to be deleted by user.; const char *base: Specifies the base object for the search operation; Int_t scope: Specifies the portion of the LDAP tree, relative to; the base object, to search.; Must be one of LDAP_SCOPE_BASE (==0),; LDAP_SCOPE_ONELEVEL (==1) or LDAP_SCOPE_SUBTREE (==2).; char *filter: The criteria during the search to determine which; entries to return, 0 means that the filter; ""(objectclass=*)"" will be applied; TList *attrs: The TList of attributes to be returned along with; each entry, 0 means that all available attributes; should be returned.; Int_t attrsonly: This parameter is a boole",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:420,Security,password,password,420," TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); virtual~TLDAPServer(); voidTObject::AbstractMethod(const char* method) const; Int_tAddEntry(TLDAPEntry& entry); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tDeleteEntry(const char* dn); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TLDAPResult*GetAttributeTypes(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; vi",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:6102,Security,password,password,6102,"tion = 0, Int_t bufsize = 0) const. protected:. TLDAPServer(const TLDAPServer&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLDAPServer&operator=(const TLDAPServer&). private:. Int_tBind(); static voidDeleteMods(LDAPMod** mods); voidUnbind(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfu",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:6540,Security,password,password,6540,"its { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschem",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:6601,Security,password,password,6601,"ed; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of ",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:6673,Security,password,password,6673,"ed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectCla",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:7117,Security,password,password,7117,"onst char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. ",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLDAPServer.html:7249,Security,password,password,7249,"d server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrso",MatchSource.WIKI,root/html530/TLDAPServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLDAPServer.html
https://root.cern/root/html530/TLeaf.html:1387,Availability,error,error,1387," TLeaf(); TLeaf(TBranch* parent, const char* name, const char* type); virtual~TLeaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const ",MatchSource.WIKI,root/html530/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeaf.html
https://root.cern/root/html530/TLeaf.html:1471,Availability,error,error,1471,"Leaf(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*GetLeafCount() const; virtual TLeaf*GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tGetLenStatic() const; virtual Int_tGetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual I",MatchSource.WIKI,root/html530/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeaf.html
https://root.cern/root/html530/TLeaf.html:8584,Integrability,rout,routine,8584," Browse(TBrowser* b); Browse the content of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the pointer to; the leaf named nelem, otherwise return 0.; If leaf name has the form var[nelem], where nelem is a digit, then; return countval = nelem and a null pointer.; If leaf name has the form of a multi dimenantion array (eg var[nelem][nelem2]; where nelem and nelem2 are digits) then; return countval = product of all dimension size and a null pointer.; If leaf name has the form var[... (and do not match the previous 2; cases) return countval = -1 and null pointer;; Otherwise return countval=1 and a null pointer. Int_t GetLen() const; -- Return the number of effective elements of this leaf. Int_t ResetAddress(void* add, Bool_t destructor = kFALSE); -- Helper routine for TLeafX::SetAddress. The return value is non-zero if we owned the old; value buffer and must delete it now. The size; of the value buffer is recalculated and stored,; and a decision is made whether or not we own the; new value buffer. void SetLeafCount(TLeaf* leaf); -- Set the leaf count of this leaf. void Streamer(TBuffer& b); -- Stream a class object. Double_t GetValue(Int_t i = 0) const; { return 0.0; }. void PrintValue(Int_t i = 0) const; {}. void SetAddress(void* add = 0); {}. void Export(TClonesArray* , Int_t ); {}. TBranch * GetBranch() const; { return fBranch; }. TLeaf * GetLeafCount() const; { return fLeafCount; }. Int_t GetLenStatic() const; { return fLen; }. Int_t GetLenType() const; { return fLenType; }. Int_t GetMaximum() const; { return 0; }. Int_t GetMinimum() const; { return 0; }. Int_t GetNdata() const; { return fNdata; }. Int_t GetOffset() const; { return fOffset; }. void * GetValuePointer() const; { return 0; }. const char * GetTypeName(",MatchSource.WIKI,root/html530/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeaf.html
https://root.cern/root/html530/TLeaf.html:6877,Modifiability,variab,variable,6877,"onst char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TLeaf(const TLeaf&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&operator=(const TLeaf&). Data Members; public:. enum { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*fBranch! Pointer to supporting branch (we do not own the branch); Bool_tfIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tfIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tfLenNumber of fixed length elements; Int_tfLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tfNdata! Number of elements in fAddress data buffer; Int_tfOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeaf(). TLeaf(TBranch* parent, const char* name, const char* type); Create a Leaf. See the TTree and TBranch constructors for explanation of parameters. TLeaf(const TLeaf& ); copy constructor. TLeaf& operator=(const TLeaf& ); assignement operator. ~TLeaf(); -- Destructor. void Browse(TBrowser* b); Browse the content of this leaf. void FillBasket(TBuffer& b); -- Pack leaf elements in Basket output buffer. TLeaf* GetLeafCounter(Int_t& countval) const; -- Return a pointer to the counter of this leaf. If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, return countval = 1 and the po",MatchSource.WIKI,root/html530/TLeaf.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeaf.html
https://root.cern/root/html530/TLeafB.html:1378,Availability,error,error,1378,"fB&); TLeafB(TBranch* parent, const char* name, const char* type); virtual~TLeafB(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html530/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafB.html
https://root.cern/root/html530/TLeafB.html:1462,Availability,error,error,1462," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html530/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafB.html
https://root.cern/root/html530/TLeafB.html:7119,Modifiability,variab,variable,7119,"t::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Char_tfMaximumMaximum value if leaf range is specified; Char_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Char_t**fPointer!Address of a pointer to data buffer!; TStringTNamed::fTitleobject title; Char_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafB(); -- Default constructor. TLeafB(TBranch* parent, const char* name, const char* type); -- Create a LeafB. ~TLeafB(); -- Destructor. void Export(TClonesArray* list, Int_t n); -- Export element from local leaf buffer to a ClonesArray. void FillBasket(TBuffer& b); -- Pack leaf elements into Basket output buffer. const char * GetTypeName() const; -- Returns name of leaf type. void Import(TClonesArray* list, Int_t n); -- Import element from ClonesArray into local leaf buffer. void PrintValue(In",MatchSource.WIKI,root/html530/TLeafB.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafB.html
https://root.cern/root/html530/TLeafC.html:1376,Availability,error,error,1376,"fC&); TLeafC(TBranch* parent, const char* name, const char* type); virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html530/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafC.html
https://root.cern/root/html530/TLeafC.html:1460,Availability,error,error,1460," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html530/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafC.html
https://root.cern/root/html530/TLeafC.html:291,Modifiability,variab,variable,291,". TLeafC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  TREE;  TREE;  TLeafC. class TLeafC: public TLeaf. A TLeaf for a variable length string. Function Members (Methods); public:. TLeafC(); TLeafC(const TLeafC&); TLeafC(TBranch* parent, const char* name, const char* type); virtual~TLeafC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual con",MatchSource.WIKI,root/html530/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafC.html
https://root.cern/root/html530/TLeafC.html:7079,Modifiability,variab,variable,7079,"ect::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Int_tfMaximumMaximum value if leaf range is specified; Int_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Char_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Char_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafC(); Default constructor for LeafC*-*-*-*-*-*-*-*-; *-* ============================. TLeafC(TBranch* parent, const char* name, const char* type); Create a LeafC*-*-; *-* ==============; -. ~TLeafC(); Default destructor for a LeafC*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Ba",MatchSource.WIKI,root/html530/TLeafC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafC.html
https://root.cern/root/html530/TLeafD.html:1385,Availability,error,error,1385,"fD&); TLeafD(TBranch* parent, const char* name, const char* type); virtual~TLeafD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html530/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafD.html
https://root.cern/root/html530/TLeafD.html:1469,Availability,error,error,1469," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html530/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafD.html
https://root.cern/root/html530/TLeafD.html:7073,Modifiability,variab,variable,7073,"Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Double_tfMaximumMaximum value if leaf range is specified; Double_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Double_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Double_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements ",MatchSource.WIKI,root/html530/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafD.html
https://root.cern/root/html530/TLeafD.html:9053,Usability,simpl,simple,9053,"tance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}.  Author: Rene Brun 12/01/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TLeafD.h 36407 2010-10-22 02:04:08Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLeafD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafD.html
https://root.cern/root/html530/TLeafElement.html:1501,Availability,error,error,1501,"nt(TBranch* parent, const char* name, Int_t id, Int_t type); virtual~TLeafElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; v",MatchSource.WIKI,root/html530/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafElement.html
https://root.cern/root/html530/TLeafElement.html:1585,Availability,error,error,1585," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTLeaf::FillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tGetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNdata() const; virtual ch",MatchSource.WIKI,root/html530/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafElement.html
https://root.cern/root/html530/TLeafElement.html:7368,Modifiability,variab,variable,7368,"option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*fAbsAddress! Absolute leaf Address; TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Int_tfIDelement serial number in fInfo; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Int_tfTypeleaf type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafElement(); Default constructor for LeafObject. TLeafElement(TBranch* parent, const char* name, Int_t id, Int_t type); Create a LeafObject. ~TLeafElement(); Default destructor for a LeafObject. TMethodCall * GetMethodCall(const char* name); Returns pointer to method corresponding to name name is a string; with the general form ""method(list of params)"" If list of params is; omitted, () is assumed;. Bool_t IsOnTerminalBranch() const; Return true if this leaf is does not have any sub-branch/leaf. TLeafElement(). Int_t GetLen() const; {return ((TB",MatchSource.WIKI,root/html530/TLeafElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafElement.html
https://root.cern/root/html530/TLeafF.html:1385,Availability,error,error,1385,"fF&); TLeafF(TBranch* parent, const char* name, const char* type); virtual~TLeafF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html530/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafF.html
https://root.cern/root/html530/TLeafF.html:1469,Availability,error,error,1469," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html530/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafF.html
https://root.cern/root/html530/TLeafF.html:7073,Modifiability,variab,variable,7073,":Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Float_tfMaximumMaximum value if leaf range is specified; Float_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Float_t**fPointer!Addresss of pointer to data buffer!; TStringTNamed::fTitleobject title; Float_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements i",MatchSource.WIKI,root/html530/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafF.html
https://root.cern/root/html530/TLeafF.html:9050,Usability,simpl,simple,9050,"ritance; Inherited Members; Includes; Libraries. Function documentation; TLeafF(); Default constructor for LeafF*-*-*-*-*-*-*-*-; *-* ============================. TLeafF(TBranch* parent, const char* name, const char* type); Create a LeafF*-*-; *-* ==============; -. ~TLeafF(); Default destructor for a LeafF*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a float from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafF(). const char * GetTypeName() const; {return ""Float_t"";}. void * GetValuePointer() const; {return fValue;}.  Author: Rene Brun 12/01/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TLeafF.h 36407 2010-10-22 02:04:08Z pcanal $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLeafF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafF.html
https://root.cern/root/html530/TLeafI.html:1372,Availability,error,error,1372,"fI&); TLeafI(TBranch* parent, const char* name, const char* type); virtual~TLeafI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html530/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafI.html
https://root.cern/root/html530/TLeafI.html:1456,Availability,error,error,1456," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html530/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafI.html
https://root.cern/root/html530/TLeafI.html:7116,Modifiability,variab,variable,7116,"ject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Int_tfMaximumMaximum value if leaf range is specified; Int_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in B",MatchSource.WIKI,root/html530/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafI.html
https://root.cern/root/html530/TLeafI.html:8506,Usability,simpl,simple,8506,"Array object (if one); Int_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Int_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafI(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafI(TBranch* parent, const char* name, const char* type); Create a LeafI*-*-; *-* ==============; -. ~TLeafI(); Default destructor for a LeafI*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read an integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafI(). Int_t GetMaximum() const; {return fMaximum;}. Int_t GetMinimum() const; {return fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Int_t max); {fMaximum = max;",MatchSource.WIKI,root/html530/TLeafI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafI.html
https://root.cern/root/html530/TLeafL.html:1378,Availability,error,error,1378,"fL&); TLeafL(TBranch* parent, const char* name, const char* type); virtual~TLeafL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html530/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafL.html
https://root.cern/root/html530/TLeafL.html:1462,Availability,error,error,1462," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tGetMaximum() const; virtual Int_tGetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py)",MatchSource.WIKI,root/html530/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafL.html
https://root.cern/root/html530/TLeafL.html:7128,Modifiability,variab,variable,7128,"Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Long64_tfMaximumMaximum value if leaf range is specified; Long64_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf element",MatchSource.WIKI,root/html530/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafL.html
https://root.cern/root/html530/TLeafL.html:8530,Usability,simpl,simple,8530,"object (if one); Long64_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Long64_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafL(); Default constructor for LeafI*-*-*-*-*-*-*-*-; *-* ============================. TLeafL(TBranch* parent, const char* name, const char* type); Create a LeafL*-*-; *-* ==============; -. ~TLeafL(); Default destructor for a LeafL*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ======================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a long integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafL(). Int_t GetMaximum() const; {return (Int_t)fMaximum;}. Int_t GetMinimum() const; {return (Int_t)fMinimum;}. void * GetValuePointer() const; {return fValue;}. void SetMaximum(Long64_t m",MatchSource.WIKI,root/html530/TLeafL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafL.html
https://root.cern/root/html530/TLeafO.html:1368,Availability,error,error,1368,"fO&); TLeafO(TBranch* parent, const char* name, const char* type); virtual~TLeafO(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html530/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafO.html
https://root.cern/root/html530/TLeafO.html:1452,Availability,error,error,1452," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html530/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafO.html
https://root.cern/root/html530/TLeafO.html:7056,Modifiability,variab,variable,7056,"t::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Bool_tfMaximumMaximum value if leaf range is specified; Bool_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Bool_t**fPointer!Address of a pointer to data buffer!; TStringTNamed::fTitleobject title; Bool_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafO(); Default constructor for LeafB*-*-*-*-*-*-*-*-; *-* ============================. TLeafO(TBranch* parent, const char* name, const char* type); Create a LeafB*-*-; *-* ==============; -. ~TLeafO(); Default destructor for a LeafB*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in ",MatchSource.WIKI,root/html530/TLeafO.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafO.html
https://root.cern/root/html530/TLeafObject.html:1429,Availability,error,error,1429,"fObject(TBranch* parent, const char* name, const char* type); virtual~TLeafObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual I",MatchSource.WIKI,root/html530/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafObject.html
https://root.cern/root/html530/TLeafObject.html:1513,Availability,error,error,1513," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTLeaf::Export(TClonesArray*, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; TClass*GetClass() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; TMethodCall*GetMethodCall(const char* name); virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual I",MatchSource.WIKI,root/html530/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafObject.html
https://root.cern/root/html530/TLeafObject.html:7331,Modifiability,variab,variable,7331,"ct::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum { kWarn; };; enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); TClassReffClass! pointer to class; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; void**fObjAddress! Address of Pointer to object; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Bool_tfVirtualSupport for polymorphism, when set classname is written with object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafObject(); Default constructor for LeafObject*-*-*-*-*-*-*-*-; *-* =================================. TLeafObject(TBranch* parent, const char* name, const char* type); Create a LeafObject*-*-; *-* ==================; -. ~TLeafObject(); Default destructor for a LeafObject*-*-*-*-*-*-; *-* ==================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. TMethodCall * GetMethodCall(const char* name); -*Returns pointer",MatchSource.WIKI,root/html530/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafObject.html
https://root.cern/root/html530/TLeafObject.html:7752,Modifiability,polymorphi,polymorphism,7752,"ct::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum { kWarn; };; enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); TClassReffClass! pointer to class; Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; void**fObjAddress! Address of Pointer to object; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); TStringTNamed::fTitleobject title; Bool_tfVirtualSupport for polymorphism, when set classname is written with object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafObject(); Default constructor for LeafObject*-*-*-*-*-*-*-*-; *-* =================================. TLeafObject(TBranch* parent, const char* name, const char* type); Create a LeafObject*-*-; *-* ==================; -. ~TLeafObject(); Default destructor for a LeafObject*-*-*-*-*-*-; *-* ==================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* =========================================. TMethodCall * GetMethodCall(const char* name); -*Returns pointer",MatchSource.WIKI,root/html530/TLeafObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafObject.html
https://root.cern/root/html530/TLeafS.html:1378,Availability,error,error,1378,"fS&); TLeafS(TBranch* parent, const char* name, const char* type); virtual~TLeafS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html530/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafS.html
https://root.cern/root/html530/TLeafS.html:1462,Availability,error,error,1462," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTLeaf::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExport(TClonesArray* list, Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBasket(TBuffer& b); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TBranch*TLeaf::GetBranch() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TLeaf*TLeaf::GetLeafCount() const; virtual TLeaf*TLeaf::GetLeafCounter(Int_t& countval) const; virtual Int_tTLeaf::GetLen() const; virtual Int_tTLeaf::GetLenStatic() const; virtual Int_tTLeaf::GetLenType() const; virtual Int_tTLeaf::GetMaximum() const; virtual Int_tTLeaf::GetMinimum() const; virtual const char*TNamed::GetName() const; virtual Int_tTLeaf::GetNdata() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html530/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafS.html
https://root.cern/root/html530/TLeafS.html:7066,Modifiability,variab,variable,7066,"::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TLeaf&TLeaf::operator=(const TLeaf&). Data Members; public:. enum TLeaf::[unnamed] { kIndirectAddress; kNewValue; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TBranch*TLeaf::fBranch! Pointer to supporting branch (we do not own the branch); Bool_tTLeaf::fIsRange(=kTRUE if leaf has a range, kFALSE otherwise); Bool_tTLeaf::fIsUnsigned(=kTRUE if unsigned, kFALSE otherwise); TLeaf*TLeaf::fLeafCountPointer to Leaf count if variable length (we do not own the counter); Int_tTLeaf::fLenNumber of fixed length elements; Int_tTLeaf::fLenTypeNumber of bytes for this data type; Short_tfMaximumMaximum value if leaf range is specified; Short_tfMinimumMinimum value if leaf range is specified; TStringTNamed::fNameobject identifier; Int_tTLeaf::fNdata! Number of elements in fAddress data buffer; Int_tTLeaf::fOffsetOffset in ClonesArray object (if one); Short_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Short_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafS(); Default constructor for LeafS*-*-*-*-*-*-*-*-; *-* ============================. TLeafS(TBranch* parent, const char* name, const char* type); Create a LeafS*-*-; *-* ==============; -. ~TLeafS(); Default destructor for a LeafS*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in",MatchSource.WIKI,root/html530/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafS.html
https://root.cern/root/html530/TLeafS.html:8463,Usability,simpl,simple,8463,"ay object (if one); Short_t**fPointer!Address of pointer to data buffer; TStringTNamed::fTitleobject title; Short_t*fValue!Pointer to data buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafS(); Default constructor for LeafS*-*-*-*-*-*-*-*-; *-* ============================. TLeafS(TBranch* parent, const char* name, const char* type); Create a LeafS*-*-; *-* ==============; -. ~TLeafS(); Default destructor for a LeafS*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. const char * GetTypeName() const; Returns name of leaf type*-*-*-*-; *-* =========================. Double_t GetValue(Int_t i = 0) const; Returns current value of leaf; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s); read a integer integer from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. TLeafS(). void * GetValuePointer() const; {return fValue;}.  Author: Rene Brun 12/01/96  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/tree:$Id: TLeafS.h",MatchSource.WIKI,root/html530/TLeafS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLeafS.html
https://root.cern/root/html530/TLegend.html:2226,Availability,error,error,2226," matching; name is found, the coresponding object is added in the legend using its pointer. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }; Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:2852,Availability,error,error,2852,"9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }; Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l""); ; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. Function Members (Methods); public:. TLegend(); TLegend(const TLegend& legend); TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* header = """", Option_t* option = ""brNDC""); virtual~TLegend(); voidTObject::AbstractMethod(const char* method) const; TLegendEntry*AddEntry(const TObject* ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:5252,Availability,error,error,5252,"onvertNDCtoPad(); virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteEntry()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditEntryAttFill(); virtual voidEditEntryAttLine(); virtual voidEditEntryAttMarker(); virtual voidEditEntryAttText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Float_tGetColumnSeparation() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TLegendEntry*GetEntry() const; Float_tGetEntrySeparation() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetHeader() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfPrimitives() const; Float_tGetMargin() cons",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:5336,Availability,error,error,5336,"Option_t* option = """")MENU ; virtual voidDeleteEntry()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditEntryAttFill(); virtual voidEditEntryAttLine(); virtual voidEditEntryAttMarker(); virtual voidEditEntryAttText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Float_tGetColumnSeparation() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TLegendEntry*GetEntry() const; Float_tGetEntrySeparation() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetHeader() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfPrimitives() const; Float_tGetMargin() const; virtual Option_t*TPave::GetName() const; Int_tGetNColumns() const; Int_tGetNRows(",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:15943,Availability,error,error,15943,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:16564,Availability,error,error,16564,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:2658,Modifiability,inherit,inherits,2658,"9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }; Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l""); ; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. Function Members (Methods); public:. TLegend(); TLegend(const TLegend& legend); TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* header = """", Option_t* option = ""brNDC""); virtual~TLegend(); voidTObject::AbstractMethod(const char* method) const; TLegendEntry*AddEntry(const TObject* ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:2735,Modifiability,inherit,inherits,2735,"9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }; Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l""); ; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. Function Members (Methods); public:. TLegend(); TLegend(const TLegend& legend); TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* header = """", Option_t* option = ""brNDC""); virtual~TLegend(); voidTObject::AbstractMethod(const char* method) const; TLegendEntry*AddEntry(const TObject* ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:2816,Modifiability,inherit,inherits,2816,"9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeader(""The Legend Title"");; leg->AddEntry(h1,""Histogram filled with random numbers"",""f"");; leg->AddEntry(""f1"",""Function abs(#frac{sin(x)}{x})"",""l"");; leg->AddEntry(""gr"",""Graph with error bars"",""lep"");; leg->Draw();. return c1;; }; Note that the TPad class has a method to build automatically a legend; for all objects in the pad. It is called TPad::BuildLegend(). Each item in the legend is added using the AddEntry method. This; method defines the object to be added (by reference or name), the label; associated to this object and an option which a combination of:. L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified. As shown in the following example, passing a NULL pointer as first parameter in; AddEntry is also valid. This allows to add text or blank lines in a; legend. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",500,300);. TLegend* leg = new TLegend(0.2, 0.2, .8, .8);; TH1* h = new TH1F("""", """", 1, 0, 1);. leg->AddEntry(h, ""Histogram \""h\"""", ""l""); ; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry((TObject*)0, ""Some text"", """");; leg->AddEntry((TObject*)0, """", """"); ; leg->AddEntry(h, ""Histogram \""h\"" again"", ""l"");. leg->Draw();; return c2;; }. Function Members (Methods); public:. TLegend(); TLegend(const TLegend& legend); TLegend(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* header = """", Option_t* option = ""brNDC""); virtual~TLegend(); voidTObject::AbstractMethod(const char* method) const; TLegendEntry*AddEntry(const TObject* ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:15749,Modifiability,inherit,inherits,15749,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:15826,Modifiability,inherit,inherits,15826,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:15907,Modifiability,inherit,inherits,15907,"tor.; ; A TLegend is a Pave with several TLegendEntry(s).; x1,y1,x2,y2 are the coordinates of the Legend in the current pad; (in normalized coordinates by default); ""header"" is the title that will be displayed at the top of the legend; it is treated like a regular entry and supports TLatex. The default; is no header (header = 0).; The options are the same as for TPave Default = ""brNDC""; ; . TLegend(const TLegend& legend). Copy constuctor.; ; . TLegend& operator=(const TLegend& ). Assignment operator.; ; . ~TLegend(). Default destructor.; ; . TLegendEntry * AddEntry(const TObject* obj, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:16370,Modifiability,inherit,inherits,16370,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:16447,Modifiability,inherit,inherits,16447,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:16528,Modifiability,inherit,inherits,16528,"n_t* option = ""lpf""). Add a new entry to this legend. ""obj"" is the object to be represented.; ""label"" is the text you wish to associate with obj in the legend.; If ""label"" is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . TLegendEntry * AddEntry(const char* name, const char* label = """", Option_t* option = ""lpf""). Add a new entry to this legend. ""name"" is the name of an object in the pad to; be represented label is the text you wish to associate with obj in the legend; if label is null or empty, the title of the object will be used.; ; Options are:; ; L: draw line associated with TAttLine if obj inherits from TAttLine; P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; E: draw vertical error bar if option ""L"" is also specified; ; . void Clear(Option_t* option = """"). Clear all entries in this legend, including the header.; ; . void Copy(TObject& obj) const. Copy this legend into ""obj"".; ; . void DeleteEntry(). Delete entry at the mouse position.; ; . void Draw(Option_t* option = """"). Draw this legend with its current attributes.; ; . void EditEntryAttFill(). Edit the fill attributes for the entry pointed by the mouse.; ; . void EditEntryAttLine(). Edit the line attributes for the entry pointed by the mouse.; ; . void EditEntryAttMarker(). Edit the marker attributes for the entry pointed by the mouse.; ; . void EditEntryAttText(). Edit the text attributes for the entry pointed by the mouse.; ; . TLegendEntry * GetEntry() const. Get entry pointed to by the mouse.; This method is mostly a tool for other methods inside this class.; ; . const char * GetHeader() const. ",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegend.html:1001,Performance,perform,performed,1001,"dex; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  GRAF2D;  GRAF;  TLegend. class TLegend: public TPave, public TAttText. Legend class; This class displays a legend box (TPaveText) containing several legend entries.; Each legend entry is made of a reference to a ROOT object, a text label and an; option specifying which graphical attributes (marker/line/fill) should be; displayed. The following example shows how to create a legend. In this example the legend; contains a histogram, a function and a graph. The histogram is put in the legend; using its reference pointer whereas the graph and the function are added; using their names. Note that, because TGraph contructors do not have the; TGraph name as parameter, the graph name should be specified using the; SetName method. When an object is added by name, a scan is performed on the list of objects; contained in the current pad (gPad) and also in the possible; TMultiGraph and THStack present in the pad. If a matching; name is found, the coresponding object is added in the legend using its pointer. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,500);; gStyle->SetOptStat(0);. TH1F *h1 = new TH1F(""h1"",""TLegend Example"",200,-10,10);; h1->FillRandom(""gaus"",30000);; h1->SetFillColor(kGreen);; h1->SetFillStyle(3003);; h1->Draw();. TF1 *f1=new TF1(""f1"",""1000*TMath::Abs(sin(x)/x)"",-10,10);; f1->SetLineColor(kBlue);; f1->SetLineWidth(4);; f1->Draw(""same"");. const Int_t n = 20;; Double_t x[n], y[n], ex[n], ey[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 1000*sin(x[i]+0.2);; x[i] = 17.8*x[i]-8.9;; ex[i] = 1.0;; ey[i] = 10.*i;; }; TGraphErrors *gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetName(""gr"");; gr->SetLineColor(kRed);; gr->SetLineWidth(2);; gr->SetMarkerStyle(21);; gr->SetMarkerSize(1.3);; gr->SetMarkerColor(7);; gr->Draw(""P"");. leg = new TLegend(0.1,0.7,0.48,0.9);; leg->SetHeade",MatchSource.WIKI,root/html530/TLegend.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegend.html
https://root.cern/root/html530/TLegendEntry.html:1676,Availability,error,error,1676,"t::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual TObject*GetObject() const; vir",MatchSource.WIKI,root/html530/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegendEntry.html
https://root.cern/root/html530/TLegendEntry.html:1760,Availability,error,error,1760,"* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& obj) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::Ge",MatchSource.WIKI,root/html530/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegendEntry.html
https://root.cern/root/html530/TLegendEntry.html:9545,Modifiability,inherit,inherits,9545,"rker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TObject*fObjectpointer to object being represented by this entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void Se",MatchSource.WIKI,root/html530/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegendEntry.html
https://root.cern/root/html530/TLegendEntry.html:9615,Modifiability,inherit,inherits,9615,"is entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void SetOption(Option_t* option = ""lpf""); { fOption = option; }. TLegendEntry& operator=(const TLegendEntry& ).  Author: Matthew.Adam.Dob",MatchSource.WIKI,root/html530/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegendEntry.html
https://root.cern/root/html530/TLegendEntry.html:9694,Modifiability,inherit,inherits,9694,"is entry; TStringfOptionOptions associated with this entry; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLegendEntry(); TLegendEntry do-nothing default constructor. TLegendEntry(const TObject* obj, const char* label = 0, Option_t* option = ""lpf""); TLegendEntry normal constructor for one entry in a TLegend; obj is the object this entry will represent. If obj has; line/fill/marker attributes, then the TLegendEntry will display; these attributes.; label is the text that will describe the entry, it is displayed using; TLatex, so may have a complex format.; option may have values; L draw line associated w/ TAttLine if obj inherits from TAttLine; P draw polymarker assoc. w/ TAttMarker if obj inherits from TAttMarker; F draw a box with fill associated w/ TAttFill if obj inherits TAttFill; default is object = ""LPF"". TLegendEntry(const TLegendEntry& entry); TLegendEntry copy constructor. ~TLegendEntry(); TLegendEntry default destructor. void Copy(TObject& obj) const; copy this TLegendEntry into obj. void Print(Option_t* option = """") const; dump this TLegendEntry to cout. void SaveEntry(ostream& out, const char* name); Save this TLegendEntry as C++ statements on output stream out; to be used with the SaveAs .C option. void SetObject(TObject* obj); (re)set the obj pointed to by this entry. void SetObject(const char* objectName); (re)set the obj pointed to by this entry. const char * GetLabel() const; { return fLabel.Data(); }. TObject * GetObject() const; { return fObject; }. Option_t * GetOption() const; { return fOption.Data(); }. void SetLabel(const char* label = """"); { fLabel = label; }. void SetOption(Option_t* option = ""lpf""); { fOption = option; }. TLegendEntry& operator=(const TLegendEntry& ).  Author: Matthew.Adam.Dob",MatchSource.WIKI,root/html530/TLegendEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLegendEntry.html
https://root.cern/root/html530/TLibraryDocInfo.html:1451,Availability,error,error,1451,"Info(); voidTObject::AbstractMethod(const char* method) const; voidAddDependency(const string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; set<std::string>&GetModules(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Inf",MatchSource.WIKI,root/html530/TLibraryDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLibraryDocInfo.html
https://root.cern/root/html530/TLibraryDocInfo.html:1535,Availability,error,error,1535,"st string& lib); voidAddModule(const string& module); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; set<std::string>&GetDependencies(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; set<std::string>&GetModules(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom",MatchSource.WIKI,root/html530/TLibraryDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLibraryDocInfo.html
https://root.cern/root/html530/TLimit.html:748,Availability,avail,available,748,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp); ",MatchSource.WIKI,root/html530/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimit.html
https://root.cern/root/html530/TLimit.html:303,Energy Efficiency,adapt,adapted,303,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp); ",MatchSource.WIKI,root/html530/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimit.html
https://root.cern/root/html530/TLimit.html:2790,Integrability,wrap,wrapped,2790,"ray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static boolFluctuate(TLimitDataSource* input, TLimitDataSource* output, bool init, TRandom*, bool stat = false); static Double_tLogLikelihood(Double_t s, Double_t b, Double_t b2, Double_t d). Data Members; private:. static TOrdCollection*fgSystNamesCollection of systematics names; static TArrayD*fgTablea log table... just to speed up calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");;",MatchSource.WIKI,root/html530/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimit.html
https://root.cern/root/html530/TLimit.html:303,Modifiability,adapt,adapted,303,". TLimit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TLimit. class TLimit. TLimit. Class to compute 95% CL limits. adapted from the mclimit code from Tom Junk (CLs method); see http://root.cern.ch/root/doc/TomJunk.pdf; see http://cern.ch/thomasj/searchlimits/ecl.html; see: Tom Junk,NIM A434, p. 435-443, 1999. see also the following interesting references:; Alex Read, ""Presentation of search results: the CLs technique""; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; http://www.iop.org/EJ/abstract/0954-3899/28/10/313. A nice article is also available in the CERN yellow report with the proceeding; of the 2000 CERN workshop on confidence intervals. Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; CERN 2000-005 (30 May 2000). see note about: ""Should I use TRolke, TFeldmanCousins, TLimit?""; in the TRolke class description. Function Members (Methods); public:. TLimit(); TLimit(const TLimit&); virtual~TLimit(); static TClass*Class(); static TConfidenceLevel*ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp); ",MatchSource.WIKI,root/html530/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimit.html
https://root.cern/root/html530/TLimit.html:3527,Performance,perform,performed,3527,"mentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm...; From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. /*; ; Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; cout << "" CLs : "" << myconfidence->CLs() << endl;; cout << "" CLsb : "" << myconfidence->CLsb() << endl;; cout << "" CLb : "" << myconfidence->CLb() << endl;; cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << endl;; cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << endl;; cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << endl;; delete myconfidence;; delete mydatasource;; infile->Clos",MatchSource.WIKI,root/html530/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimit.html
https://root.cern/root/html530/TLimit.html:2387,Testability,log,log,2387,"Double_t b, Int_t d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(Double_t s, Double_t b, Int_t d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); static TConfidenceLevel*ComputeLimit(TH1* s, TH1* b, TH1* d, TVectorD* se, TVectorD* be, TObjArray*, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); virtual TClass*IsA() const; TLimit&operator=(const TLimit&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static boolFluctuate(TLimitDataSource* input, TLimitDataSource* output, bool init, TRandom*, bool stat = false); static Double_tLogLikelihood(Double_t s, Double_t b, Double_t b2, Double_t d). Data Members; private:. static TOrdCollection*fgSystNamesCollection of systematics names; static TArrayD*fgTablea log table... just to speed up calculation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TConfidenceLevel * ComputeLimit(TLimitDataSource* data, Int_t nmc = 50000, bool stat = false, TRandom* generator = 0); class TLimit. Algorithm to compute 95% C.L. limits using the Likelihood ratio; semi-bayesian method.; It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. class TLimitDataSource. Takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. class TConfidenceLevel. Final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, ",MatchSource.WIKI,root/html530/TLimit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimit.html
https://root.cern/root/html530/TLimitDataSource.html:1642,Availability,error,error,1642," char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual ",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:1726,Availability,error,error,1726,"el(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TObjArray*GetBackground(); virtual TObjArray*GetCandidates(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TObjArray*GetErrorNames(); virtual TObjArray*GetErrorOnBackground(); virtual TObjArray*GetErrorOnSignal(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TObjArray*GetSignal(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:5919,Availability,error,error,5919,"tBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:5979,Availability,error,error,5979,"tBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:6047,Availability,error,error,6047,"tBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArrayfBackgroundpacked input background; TObjArrayfCandidatespacked input candidates (data); TObjArrayfDummyIdsarray of dummy object (used for bookeeping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bi",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:6810,Availability,error,error,6810,"eping); TObjArrayfDummyTAarray of dummy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bin has to be seen as; an error source (relative).; names is an array of strings containing the names of the sources.; Sources with the same name are correlated. void SetOwner(bool swtch = kTRUE); Gives to the TLimitDataSource the ownership of the various objects; given as input.; Objects are then deleted by the TLimitDataSource destructor. virtual ~TLimitDataSource(); {}. TObjArray* GetSignal(); { return &fSignal;}. TObjArray* GetBackground(); { return &fBackground;}. TObjArray* GetCandidates(); { return &fCandidates;}. TObjArray* GetErrorOnSignal(); { return &fErrorOnSignal;}. TObjArray* GetErrorOnBackground(); { return &fErrorOnBackground;}. TObjArray* GetErrorNames(); { return &fIds;}.  Last changed: root/hist:$Id: TLimitDataSource.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:6904,Availability,error,error,6904,"mmy object (used for bookeeping); TObjArrayfErrorOnBackgroundpacked error sources for background; TObjArrayfErrorOnSignalpacked error sources for signal; TObjArrayfIdspacked IDs for the different error sources; TObjArrayfSignalpacked input signal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLimitDataSource(); Default constructor. TLimitDataSource(TH1* s, TH1* b, TH1* d); Another constructor, directly adds one channel; with signal, background and data given as input. TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); Another constructor, directly adds one channel; with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* ); Adds a channel with signal, background and data given as input. void AddChannel(TH1* , TH1* , TH1* , TVectorD* , TVectorD* , TObjArray* ); Adds a channel with signal, background and data given as input.; In addition, error sources are defined.; TH1 are here used for convenience: each bin has to be seen as; an error source (relative).; names is an array of strings containing the names of the sources.; Sources with the same name are correlated. void SetOwner(bool swtch = kTRUE); Gives to the TLimitDataSource the ownership of the various objects; given as input.; Objects are then deleted by the TLimitDataSource destructor. virtual ~TLimitDataSource(); {}. TObjArray* GetSignal(); { return &fSignal;}. TObjArray* GetBackground(); { return &fBackground;}. TObjArray* GetCandidates(); { return &fCandidates;}. TObjArray* GetErrorOnSignal(); { return &fErrorOnSignal;}. TObjArray* GetErrorOnBackground(); { return &fErrorOnBackground;}. TObjArray* GetErrorNames(); { return &fIds;}.  Last changed: root/hist:$Id: TLimitDataSource.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:348,Integrability,interface,interface,348,". TLimitDataSource. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TLimitDataSource. class TLimitDataSource: public TObject. TLimitDataSource. This class serves as interface to feed data into the TLimit routines. Function Members (Methods); public:. TLimitDataSource(); TLimitDataSource(TH1* s, TH1* b, TH1* d); TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); virtual~TLimitDataSource(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) cons",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLimitDataSource.html:387,Integrability,rout,routines,387,". TLimitDataSource. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  HIST;  HIST;  TLimitDataSource. class TLimitDataSource: public TObject. TLimitDataSource. This class serves as interface to feed data into the TLimit routines. Function Members (Methods); public:. TLimitDataSource(); TLimitDataSource(TH1* s, TH1* b, TH1* d); TLimitDataSource(TH1* s, TH1* b, TH1* d, TVectorD* es, TVectorD* eb, TObjArray* names); virtual~TLimitDataSource(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddChannel(TH1*, TH1*, TH1*); virtual voidAddChannel(TH1*, TH1*, TH1*, TVectorD*, TVectorD*, TObjArray*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) cons",MatchSource.WIKI,root/html530/TLimitDataSource.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLimitDataSource.html
https://root.cern/root/html530/TLine.html:1615,Availability,error,error,1615,"c TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; ",MatchSource.WIKI,root/html530/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLine.html
https://root.cern/root/html530/TLine.html:1699,Availability,error,error,1699,"::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& line) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TLine*DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual TLine*DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX1() const; Double_tGetX2() const; Double_tGetY1() const; Double_tGetY2() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() co",MatchSource.WIKI,root/html530/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLine.html
https://root.cern/root/html530/TLine.html:7606,Deployability,release,released,7606,"th; Double_tfX1X of 1st point; Double_tfX2X of 2nd point; Double_tfY1Y of 1st point; Double_tfY2Y of 2nd point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLine(); Line default constructor. TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Line normal constructor. ~TLine(); Line default destructor. TLine(const TLine& line); Line copy constructor. void Copy(TObject& line) const; Copy this line to line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. TLine * DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates in NDC. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event.; This member function is called when a line is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TAr",MatchSource.WIKI,root/html530/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLine.html
https://root.cern/root/html530/TLine.html:7700,Deployability,release,released,7700,"d point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLine(); Line default constructor. TLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Line normal constructor. ~TLine(); Line default destructor. TLine(const TLine& line); Line copy constructor. void Copy(TObject& line) const; Copy this line to line. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. TLine * DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. TLine * DrawLineNDC(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates in NDC. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event.; This member function is called when a line is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the ",MatchSource.WIKI,root/html530/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLine.html
https://root.cern/root/html530/TLine.html:8601,Modifiability,inherit,inheritance,8601," button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the line to be drawn vertically.; Makes fX2 equal to fX1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void Streamer(TBuffer& b); Stream an object of class TLine. Double_t GetX1() const; {return fX1;}. Double_t GetX2() const; {return fX2;}. Double_t GetY1() const; {return fY1;}. Double_t GetY2() const; {return fY2;}. void SetX1(Double_t x1); {fX1=x1;}. void SetX2(Double_t x2); {fX2=x2;}. void SetY1(Double_t y1); {fY1=y1;}. void SetY2(Double_t y2); {fY2=y2;}.  Author: Rene Brun 12/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/graf:$Id: TLine.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLine.html
https://root.cern/root/html530/TLine.html:8786,Modifiability,inherit,inheritance,8786," button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this line with its attributes. void Paint(Option_t* option = """"); Paint this line with its current attributes. void PaintLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw this line with new coordinates. void PaintLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Draw this line with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this line with its attributes. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Bool_t IsHorizontal(); Check whether this line is to be drawn horizontally. Bool_t IsVertical(); Check whether this line is to be drawn vertically. void SetHorizontal(Bool_t set = kTRUE); Force the line to be drawn horizontally.; Makes fY2 equal to fY1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void SetVertical(Bool_t set = kTRUE); Force the line to be drawn vertically.; Makes fX2 equal to fX1. The line length is kept.; TArrow and TGaxis also get this function by inheritance. void Streamer(TBuffer& b); Stream an object of class TLine. Double_t GetX1() const; {return fX1;}. Double_t GetX2() const; {return fX2;}. Double_t GetY1() const; {return fY1;}. Double_t GetY2() const; {return fY2;}. void SetX1(Double_t x1); {fX1=x1;}. void SetX2(Double_t x2); {fX2=x2;}. void SetY1(Double_t y1); {fY1=y1;}. void SetY2(Double_t y2); {fY2=y2;}.  Author: Rene Brun 12/12/94  Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *;  Last changed: root/graf:$Id: TLine.h 20882 2007-11-19 11:31:26Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLine.html
https://root.cern/root/html530/TLinearFitter.html:5792,Availability,error,errors,5792,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:5998,Availability,robust,robust,5998,"();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(con",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:6682,Availability,robust,robust,6682," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual ",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:6819,Availability,error,errors,6819,"t be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObje",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:8430,Availability,error,error,8430,"ual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(); virtual Int_tEvalRobust(Double_t h = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidFixParameter(Int_t ipar, Double_t parvalue); virtual voidGetAtbVector(TVectorD& v); virtual Double_tGetChisquare(); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:8514,Availability,error,error,8514,"ual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(); virtual Int_tEvalRobust(Double_t h = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualFitter*TVirtualFitter::Fitter(TObject* obj, Int_t maxpar = 25); virtual voidFixParameter(Int_t ipar); virtual voidFixParameter(Int_t ipar, Double_t parvalue); virtual voidGetAtbVector(TVectorD& v); virtual Double_tGetChisquare(); virtual voidGetConfidenceIntervals(TObject* obj, Double_t cl = 0.",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:18635,Availability,error,errors,18635,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:18707,Availability,robust,robust,18707,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:18923,Availability,robust,robust,18923,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:19361,Availability,robust,robust,19361,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:21788,Availability,error,error,21788," of the following kind:; TFormula(""f"", ""x++y++z++x*x"") or; TFormula(""f"", ""x[0]++x[1]++x[2]*x[2]"");; Other than the look, it's in no; way different from the regular formula, it can be evaluated,; drawn, etc.; The option is to store or not to store the data; If you don't want to store the data, choose """" for the option, or run; StoreData(kFalse) member function after the constructor. TLinearFitter(const TLinearFitter& tlf); Copy ctor. ~TLinearFitter(); Linear fitter cleanup. TLinearFitter& operator=(const TLinearFitter& tlf); Assignment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates t",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:22908,Availability,error,errors,22908,"_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set ",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:24254,Availability,error,errors,24254,"t_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argum",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:24267,Availability,error,errors,24267,"t_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argum",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:24504,Availability,error,error,24504,"t_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argum",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:25057,Availability,error,errors,25057,"eter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. ",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:25408,Availability,error,error,25408,"ach bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:25708,Availability,robust,robust,25708,"2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level,",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:26827,Availability,error,errors,26827,"t fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level, Double_t amin = 0) const; Level = 3 (to be consistent with minuit) prints parameters and parameter; errors. Int_t GraphLinearFitter(Double_t h); Used in TGraph::Fit(). Int_t Graph2DLinearFitter(Double_t h); Minimisation function for a TGraph2D. Int_t MultiGraphLinearFitter(Double_t h); Minimisation function for a TMultiGraph. Int_t HistLinearFitter(); Minimization function for H1s using a Chisquare method. void Streamer(TBuffer& b). Int_t EvalRobust(Double_t h = -1); Finds the parameters of the fitted function in case data contains; outliers.; Parameter h stands for the minimal fraction of good points in the; dataset (h < 1, i.e. for 70% of good points take h=0.7).; The default value of h*Npoints is (Npoints + Nparameters+1)/2; If the user provides a value of h smaller than above, default is taken; See class description for the algorithm details. void CreateSubset(Int_t ntotal, Int_t h, Int_t* index); Creates a p-subset to start; ntotal - total number of points from which the subset is chosen. Double_t CStep(Int_t step, In",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:18763,Deployability,release,released,18763,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:538,Integrability,depend,dependency,538,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:2607,Modifiability,variab,variables,2607,"ion by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional formula, one can create a; TF123 based on a linear expression and pass this function; to the fitter:; --Example:; TLinearFitter *lf = new TLinearFitter();; TF2 *f2 = new TF2(""f2"", ""x ++ y ++ x*x*y*y"", -2, 2, -2, 2);; lf->SetFormula(f2);; --The results of the fit are then stored in the function,; just like when the TH1::Fit or TGraph::Fit is used; --A linear function of this kind is by no means different; from any other function, it can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:4285,Modifiability,variab,variables,4285,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:5756,Modifiability,variab,variable,5756,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:19668,Modifiability,variab,variable,19668,".stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands for number of dimensions in the fitting formula; The input data is stored. If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); First parameter stands for number of dimensions in the fitting formula; Second parameter is the fitting formula: see class description for formula syntax; Options:; The option is to store or not to store the data; If you don't want to store the data, choose """" for the option, or run; StoreData(kFalse) member function afte",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:22214,Modifiability,variab,variables,22214,"gnment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisqua",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:22260,Modifiability,variab,variables,22260,"gnment operator. void Add(TLinearFitter* tlf); Add another linear fitter to this linear fitter. Points and Design matrices; are added, but the previos fitting results (if any) are deleted.; Fitters must have same formulas (this is not checked). Fixed parameters are not changed. void AddPoint(Double_t* x, Double_t y, Double_t e = 1); Adds 1 point to the fitter.; First parameter stands for the coordinates of the point, where the function is measured; Second parameter - the value being fitted; Third parameter - weight(measurement error) of this point (=1 by default). void AssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisqua",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:23783,Modifiability,inherit,inherits,23783," Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set as a string or as a pure TFormula. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.95); Computes confidence intervals at level cl. Default is 0.95; The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH123.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:837,Performance,perform,performed,837,". TLinearFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearFitter. class TLinearFitter: public TVirtualFitter. The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS. Linear fitter is used to fit a set of data points with a linear; combination of specified functions. Note, that ""linear"" in the name; stands only for the model dependency on parameters, the specified; functions can be nonlinear.; The general form of this kind of model is. y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x). Functions f are fixed functions of x. For example, fitting with a; polynomial is linear fitting in this sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula sy",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:4189,Performance,perform,performance,4189,"t can be drawn, evaluated, etc. --For multidimensional fitting, TFormulas of the form:; x[0]++...++x[n] can be used; 2.2.2 There is no need to create the function if you don't want to,; the formula can be set by expression:; --Example:; // 2 is the number of dimensions; TLinearFitter *lf = new TLinearFitter(2);; lf->SetFormula(""x ++ y ++ x*x*y*y"");. 2.2.3 The fastest functions to compute are polynomials and hyperplanes.; --Polynomials are set the usual way: ""pol1"", ""pol2"",...; --Hyperplanes are set by expression ""hyp3"", ""hyp4"", ...; ---The ""hypN"" expressions only work when the linear fitter; is used directly, not through TH1::Fit or TGraph::Fit.; To fit a graph or a histogram with a hyperplane, define; the function as ""1++x++y"".; ---A constant term is assumed for a hyperplane, when using; the ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCova",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:6672,Performance,perform,perform,6672," underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points and setting the fitting function.; Note, that standard errors on parameters are not computed!. Function Members (Methods); public:. TLinearFitter(); TLinearFitter(Int_t ndim); TLinearFitter(const TLinearFitter& tlf); TLinearFitter(TFormula* function, Option_t* opt = ""D""); TLinearFitter(Int_t ndim, const char* formula, Option_t* opt = ""D""); virtual~TLinearFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TLinearFitter* tlf); virtual voidAddPoint(Double_t* x, Double_t y, Double_t e = 1); virtual voidAddTempMatrices(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAssignData(Int_t npoints, Int_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); virtual voidTObject::Browse(TBrowser* b); virtual voidChisquare(); virtual Double_tChisquare(Int_t, Double_t*) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual voidClearPoints(); virtual ",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:17430,Performance,cache,cache,17430,"Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*TVirtualFitter::fCache[fCacheSize] array of points data (fNpoints*fPointSize < fCacheSize words); Int_tTVirtualFitter::fCacheSizeSize of the fCache array; voidTVirtualFitter::fFCN; TMethodCall*TVirtualFitter::fMethodCallPointer to MethodCall in case of interpreted function; TStringTNamed::fNameobject identifier; Int_tTVirtualFitter::fNpointsNumber of points to fit; TObject*TVirtualFitter::fObjectFitpointer to object being fitted; Foption_tTVirtualFitter::fOptionstruct with the fit options; Int_tTVirtualFitter::fPointSizeNumber of words per point in the cache; TStringTNamed::fTitleobject title; TObject*TVirtualFitter::fUserFuncpointer to user theoretical function (a TF1*); Int_tTVirtualFitter::fXfirstfirst bin on X axis; Int_tTVirtualFitter::fXlastlast bin on X axis; Int_tTVirtualFitter::fYfirstfirst bin on Y axis; Int_tTVirtualFitter::fYlastlast bin on Y axis; Int_tTVirtualFitter::fZfirstfirst bin on Z axis; Int_tTVirtualFitter::fZlastlast bin on Z axis; static TStringTVirtualFitter::fgDefaultname of the default fitter (""Minuit"",""Fumili"",etc); static Double_tTVirtualFitter::fgErrorDefError definition (default=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSym",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:19348,Performance,perform,performing,19348,"efault=1); static TVirtualFitter*TVirtualFitter::fgFitterCurrent fitter (default TFitter); static Int_tTVirtualFitter::fgMaxiterMaximum number of iterations; static Int_tTVirtualFitter::fgMaxparMaximum number of fit parameters for current fitter; static Double_tTVirtualFitter::fgPrecisionmaximum precision. private:. TVectorDfAtbvector Atb; TVectorDfAtbTemp! temporary vector, used for num.stability; TVectorDfAtbTemp2!; TVectorDfAtbTemp3!; Double_tfChisquareChisquare of the fit; TMatrixDSymfDesignmatrix AtA; TMatrixDSymfDesignTemp! temporary matrix, used for num.stability; TMatrixDSymfDesignTemp2!; TMatrixDSymfDesignTemp3!; TVectorDfEthe errors if they are known; TBitsfFitsampleindices of points, used in the robust fit; Bool_t*fFixedParams[fNfixed] array of fixed/released params; char*fFormulathe formula; Int_tfFormulaSizelength of the formula; TObjArrayfFunctionsarray of basis functions; Int_tfHnumber of good points in robust fit; TFormula*fInputFunctionthe function being fit; Bool_tfIsSetHas the formula been set?; Int_tfNdimnumber of dimensions in the formula; Int_tfNfixednumber of fixed parameters; Int_tfNfunctionsnumber of basis functions; Int_tfNpointsnumber of points; TMatrixDSymfParCovarmatrix of parameters' covariances; TVectorDfParSignsignificance levels of parameters; TVectorDfParamsvector of parameters; Bool_tfRobusttrue when performing a robust fit; Int_tfSpecial=100+n if fitting a polynomial of deg.n; Bool_tfStoreDataIs the data stored?; TVectorDfTValuesT-Values of parameters; Double_tfVal[1000]! temporary; TMatrixDfXvalues of x; TVectorDfYthe values being fit; Double_tfY2sum of square of y, used for chisquare; Double_tfY2Temp! temporary variable used for num.stability. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearFitter(); default c-tor, input data is stored; If you don't want to store the input data,; run the function StoreData(kFALSE) after constructor. TLinearFitter(Int_t ndim); The parameter stands",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:5174,Security,access,access,5174,"d give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficie",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:1669,Usability,simpl,simply,1669,"is sense. The fitting method. The fit is performed using the Normal Equations method with Cholesky; decomposition. Why should it be used?. The linear fitter is considerably faster than general non-linear; fitters and doesn't require to set the initial values of parameters. Using the fitter:. 1.Adding the data points:; 1.1 To store or not to store the input data?; - There are 2 options in the constructor - to store or not; store the input data. The advantages of storing the data; are that you'll be able to reset the fitting model without; adding all the points again, and that for very large sets; of points the chisquare is calculated more precisely.; The obvious disadvantage is the amount of memory used to; keep all the points.; - Before you start adding the points, you can change the; store/not store option by StoreData() method.; 1.2 The data can be added:; - simply point by point - AddPoint() method; - an array of points at once:; If the data is already stored in some arrays, this data; can be assigned to the linear fitter without physically; coping bytes, thanks to the Use() method of; TVector and TMatrix classes - AssignData() method. 2.Setting the formula; 2.1 The linear formula syntax:; -Additive parts are separated by 2 plus signes ""++""; --for example ""1 ++ x"" - for fitting a straight line; -All standard functions, undrestood by TFormula, can be used; as additive parts; --TMath functions can be used too; -Functions, used as additive parts, shouldn't have any parameters,; even if those parameters are set.; --for example, if normalizing a sum of a gaus(0, 1) and a; gaus(0, 2), don't use the built-in ""gaus"" of TFormula,; because it has parameters, take TMath::Gaus(x, 0, 1) instead.; -Polynomials can be used like ""pol3"", ..""polN""; -If fitting a more than 3-dimensional formula, variables should; be numbered as follows:; -- x[0], x[1], x[2]... For example, to fit ""1 ++ x[0] ++ x[1] ++ x[2] ++ x[3]*x[3]""; 2.2 Setting the formula:; 2.2.1 If fitting a 1-2-3-dimensional",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearFitter.html:5028,Usability,clear,cleared,5028," ""hypN"" expression, so ""hyp3"" is in fact fitting with; ""1++x++y++z"" function.; --Fitting hyperplanes is much faster than fitting other; expressions so if performance is vital, calculate the; function values beforehand and give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recomme",MatchSource.WIKI,root/html530/TLinearFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearFitter.html
https://root.cern/root/html530/TLinearMinimizer.html:4987,Availability,error,errors,4987,"rtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:5600,Availability,robust,robust,5600,"tion calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum fu",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:5852,Availability,error,error,5852,"bsolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7321,Availability,error,error,7321,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7331,Availability,error,error,7331,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7401,Availability,error,errors,7401,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7664,Availability,error,errors,7664,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:395,Integrability,interface,interface,395,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); vir",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:577,Integrability,depend,dependence,577,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); vir",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:742,Modifiability,plug-in,plug-in,742,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); vir",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:759,Modifiability,plug-in,plug-in,759,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); vir",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:5498,Modifiability,plug-in,plug-ins,5498,"ath::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double )",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:6275,Modifiability,variab,variable,6275,"ctor<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:6481,Modifiability,variab,variable,6481," needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7065,Modifiability,variab,variables,7065,"rming a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or RO",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7162,Modifiability,variab,variables,7162,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7578,Modifiability,variab,variable,7578,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:7636,Modifiability,variab,variables,7636,"ich are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total. { return fNFree; }. bool ProvidesError() const; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.empty()) ? 0 : &fErrors.front(); }. double CovMatrix(unsigned int i, unsigned int j) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Oct 25 16:28:55 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/minuit:$Id: TLinearMinimizer.h 34753 2010-08-10 10:02:27Z moneta $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:6059,Performance,perform,performing,6059,"; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const ROOT::Math::IMultiGradFunction & objfunc); Set the function to be minimized. The function must be a Chi2 gradient function; When performing a linear fit we need the basis functions, which are the partial derivatives with respect to the parameters of the model function. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool Minimize(); find directly the minimum of the chi2 function; solving the linear equation. Use TVirtualFitter::Eval. bool SetVariable(unsigned int , const string& , double , double ); set free variable (dummy impl. ). { return false; }. double MinValue() const; return minimum function value. { return fMinVal; }. double Edm() const; return expected distance reached from the minimum. { return 0; }. const double * X() const; return pointer to X values at the minimum. { return &fParams.front(); }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return 0; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). { ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:5004,Security,validat,validated,5004,"rtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. ",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLinearMinimizer.html:343,Usability,simpl,simple,343,". TLinearMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MINUIT;  TLinearMinimizer. class TLinearMinimizer: public ROOT::Math::Minimizer. TLinearMinimizer, simple class implementing the ROOT::Math::Minimizer interface using; TLinearFitter.; This class uses TLinearFitter to find directly (by solving a system of linear equations); the minimum of a; least-square function which has a linear dependence in the fit parameters.; This class is not used directly, but via the ROOT::Fitter class, when calling the; LinearFit method. It is instantiates using the plug-in manager (plug-in name is ""Linear""). Function Members (Methods); public:. TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); virtual~TLinearMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int, unsigned int, unsigned int&, double*, double*); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::Minimizer::GetCovMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double*) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int, double& errLow, double& errUp, int = 0); virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int) const; virtual boolROOT::Math::Minimizer::Hesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); vir",MatchSource.WIKI,root/html530/TLinearMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLinearMinimizer.html
https://root.cern/root/html530/TLineEditor.html:4620,Availability,error,error,4620,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html530/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLineEditor.html
https://root.cern/root/html530/TLineEditor.html:4704,Availability,error,error,4704,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html530/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLineEditor.html
https://root.cern/root/html530/TLineEditor.html:17581,Availability,mask,mask,17581,,MatchSource.WIKI,root/html530/TLineEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLineEditor.html
https://root.cern/root/html530/TLink.html:1679,Availability,error,error,1679," voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTText::Copy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTText::GetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText::GetTextAdvance(UInt_t& a, const char* text, const Bool_t kern = kTRUE) const; virt",MatchSource.WIKI,root/html530/TLink.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLink.html
https://root.cern/root/html530/TLink.html:1763,Availability,error,error,1763,"* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTText::Copy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidTText::GetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTText::GetTextAdvance(UInt_t& a, const char* text, const Bool_t kern = kTRUE) const; virtual Short_tTAttText::GetTextAlign() const; virtual Float_tTAttText::GetTextAngle() c",MatchSource.WIKI,root/html530/TLink.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLink.html
https://root.cern/root/html530/TList.html:3830,Availability,error,error,3830,"; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vi",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:3914,Availability,error,error,3914,"static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; virtual TObjLink*FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() cons",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:436,Integrability,wrap,wrapped,436,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:801,Integrability,wrap,wrapper,801,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:1268,Integrability,wrap,wrap,1268,"inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidAddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); ",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:324,Modifiability,inherit,inheriting,324,". TList. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TList. class TList: public TSeqCollection. TList. A doubly linked list. All classes inheriting from TObject can be; inserted in a TList. Before being inserted into the list the object; pointer is wrapped in a TObjLink object which contains, besides; the object pointer also a previous and next pointer. There are basically four ways to iterate over a TList (in order; of preference, if not forced by other constraints):; 1) Using the R__FOR_EACH macro:; GetListOfPrimitives()->R__FOR_EACH(TObject,Paint)(option);. 2) Using the TList iterator TListIter (via the wrapper class; TIter):; TIter next(GetListOfPrimitives());; while ((TObject *obj = next())); obj->Draw(next.GetOption());. 3) Using the TList iterator TListIter and std::for_each; algorithm:; A function object, which will be applied to each element; of the given range.; struct STestFunctor {; bool operator()(TObject *aObj) {. return true;; }; }. TIter iter(mylist);; for_each( iter.Begin(), TIter::End(), STestFunctor() );. 4) Using the TObjLink list entries (that wrap the TObject*):; TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw(lnk->GetOption());; lnk = lnk->Next();; }. 5) Using the TList's After() and Before() member functions:; TFree *idcur = this;; while (idcur) {. idcur = (TFree*)GetListOfFree()->After(idcur);; }. Methods 2, 3 and 4 can also easily iterate backwards using either; a backward TIter (using argument kIterBackward) or by using; LastLink() and lnk->Prev() or by using the Before() member.; ; . This class is also known as (typedefs to this class)TTabCom::TContainer. Function Members (Methods); public:. TList(); TList(TObject*); virtual~TList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* o",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:10744,Performance,cache,cache,10744,"; voidTObject::MakeZombie(); virtual TObjLink*NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. TList(const TList&); TList&operator=(const TList&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*fFirst! pointer to first entry in linked list; TObjLink*fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TList(); Delete the list. Objects are not deleted unless the TList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TList.html:14013,Security,access,access,14013,"nd using the; object's IsEqual() method. Returns 0 if obj is last in list. TObject * At(Int_t idx) const; Returns the object at position idx. Returns 0 if idx is out of range. TObject * Before(const TObject* obj) const; Returns the object before object obj. Obj is found using the; object's IsEqual() method. Returns 0 if obj is first in list. void Clear(Option_t* option = """"); Remove all objects from the list. Does not delete the objects; unless the TList is the owner (set via SetOwner()) and option; ""nodelete"" is not set.; If option=""nodelete"" then don't delete any heap objects that were; marked with the kCanDelete bit, otherwise these objects will be; deleted (this option is used by THashTable::Clear()). void Delete(Option_t* option = """"); Remove all objects from the list AND delete all heap based objects.; If option=""slow"" then keep list consistent during delete. This allows; recursive list operations during the delete (e.g. during the dtor; of an object in this list one can still access the list to search for; other not yet deleted objects). void DeleteLink(TObjLink* lnk); Delete a TObjLink object. TObject * FindObject(const char* name) const; Find an object in this list using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. This method overrides the generic FindObject(); of TCollection for efficiency reasons. TObject * FindObject(const TObject* obj) const; Find an object in this list using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; This method overrides the generic FindObject() of TCollection for; efficiency reasons. TObjLink * FindLink(const TObject* obj, Int_t& idx) const; Returns the TObjLink object that contains object obj. In idx it returns; the position of the object in the list. TObject * First() const; Return the first object in the list. Returns 0 when list is empty. TObject ** GetObject",MatchSource.WIKI,root/html530/TList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TList.html
https://root.cern/root/html530/TLockFile.html:1569,Availability,error,error,1569," TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root/html530/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockFile.html
https://root.cern/root/html530/TLockFile.html:1653,Availability,error,error,1653," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockFile.html
https://root.cern/root/html530/TLockFile.html:376,Deployability,release,released,376,". TLockFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TLockFile. class TLockFile: public TObject. TLockFile. Lock an object using a file.; Constructor blocks until lock is obtained. Lock is released in the; destructor. Use it in scope-blocks like:; {; TLockFile lock(""path.to.lock.file"");; do something you need the lock for; } // lock is automatically released. Function Members (Methods); public:. TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root/html530/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockFile.html
https://root.cern/root/html530/TLockFile.html:539,Deployability,release,released,539,". TLockFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  IO;  IO;  TLockFile. class TLockFile: public TObject. TLockFile. Lock an object using a file.; Constructor blocks until lock is obtained. Lock is released in the; destructor. Use it in scope-blocks like:; {; TLockFile lock(""path.to.lock.file"");; do something you need the lock for; } // lock is automatically released. Function Members (Methods); public:. TLockFile(const char* path, Int_t timeLimit = 0); virtual~TLockFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject:",MatchSource.WIKI,root/html530/TLockFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockFile.html
https://root.cern/root/html530/TLockGuard.html:376,Availability,avail,available,376,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }.  Author: Fons Rademakers 14/07/2002  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockGuard.html
https://root.cern/root/html530/TLockGuard.html:320,Integrability,interface,interface,320,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }.  Author: Fons Rademakers 14/07/2002  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockGuard.html
https://root.cern/root/html530/TLockGuard.html:419,Performance,load,loaded,419,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }.  Author: Fons Rademakers 14/07/2002  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockGuard.html
https://root.cern/root/html530/TLockGuard.html:521,Safety,safe,safe,521,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }.  Author: Fons Rademakers 14/07/2002  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockGuard.html
https://root.cern/root/html530/TLockGuard.html:775,Safety,safe,safe,775,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }.  Author: Fons Rademakers 14/07/2002  Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $  Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html530/TLockGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLockGuard.html
https://root.cern/root/html530/TLorentzRotation.html:5247,Availability,error,error,5247,"Method(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TLorentzRotation&Boost(const TVector3& b); TLorentzRotation&Boost(Double_t bx, Double_t by, Double_t bz); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html530/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzRotation.html
https://root.cern/root/html530/TLorentzRotation.html:5331,Availability,error,error,5331,"""""); TLorentzRotation&Boost(const TVector3& b); TLorentzRotation&Boost(Double_t bx, Double_t by, Double_t bz); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html530/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzRotation.html
https://root.cern/root/html530/TLorentzRotation.html:2216,Testability,test,test,2216," an other TLorentzRotation,; by a pure TRotation or by a boost:;  TLorentzRotation l; // l is; initialized as identity;  TLorentzRotation m(l); // m = l;  TRotation r;;  TLorentzRotation lr(r);;  TLorentzRotation lb1(bx,by,bz);;  TVector3 b;;  TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:; | 1+gamma'*bx*bx gamma'*bx*by gamma'*bx*bz; gamma*bx |; | gamma'*by*bx 1+gamma'*by*by gamma'*by*bz; gamma*by |; | gamma'*bz*bx gamma'*bz*by 1+gamma'*bz*bz; gamma*bz |; | gamma*bx; gamma*by gamma*bz; gamma |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;  Double_t xx;;  TLorentzRotation l;;  xx = l.XX(); // gets the xx component;  xx = l(0,0); // gets the xx component;  if (l==m) {...} // test for equality;  if (l !=m) {...} // test for inequality;  if (l.IsIdentity()) {...} // test for identity; . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;  TLorentzRotation a,b,c;;  c = b*a;// product;  c = a.MatrixMultiplication(b); // a is unchanged;  a *= b;// Attention: a=a*b;  c = a.Transform(b)// a=b*a then c=a; . Lorentz boosts;  Double_t bx, by, bz;;  TVector3 v(bx,by,bz);;  TLorentzRotation l;;  l.Boost(v);;  l.Boost(bx,by,bz);; . Rotations;  TVector3 axis;;  l.RotateX(TMath::Pi()); // rotation around; x-axis;  l.Rotate(.5,axis);// rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:; ; | xx yx zx -tx |; ; |; |; ; | xy yy zy -ty |; ; |",MatchSource.WIKI,root/html530/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzRotation.html
https://root.cern/root/html530/TLorentzRotation.html:2257,Testability,test,test,2257,"TRotation or by a boost:;  TLorentzRotation l; // l is; initialized as identity;  TLorentzRotation m(l); // m = l;  TRotation r;;  TLorentzRotation lr(r);;  TLorentzRotation lb1(bx,by,bz);;  TVector3 b;;  TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:; | 1+gamma'*bx*bx gamma'*bx*by gamma'*bx*bz; gamma*bx |; | gamma'*by*bx 1+gamma'*by*by gamma'*by*bz; gamma*by |; | gamma'*bz*bx gamma'*bz*by 1+gamma'*bz*bz; gamma*bz |; | gamma*bx; gamma*by gamma*bz; gamma |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;  Double_t xx;;  TLorentzRotation l;;  xx = l.XX(); // gets the xx component;  xx = l(0,0); // gets the xx component;  if (l==m) {...} // test for equality;  if (l !=m) {...} // test for inequality;  if (l.IsIdentity()) {...} // test for identity; . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;  TLorentzRotation a,b,c;;  c = b*a;// product;  c = a.MatrixMultiplication(b); // a is unchanged;  a *= b;// Attention: a=a*b;  c = a.Transform(b)// a=b*a then c=a; . Lorentz boosts;  Double_t bx, by, bz;;  TVector3 v(bx,by,bz);;  TLorentzRotation l;;  l.Boost(v);;  l.Boost(bx,by,bz);; . Rotations;  TVector3 axis;;  l.RotateX(TMath::Pi()); // rotation around; x-axis;  l.Rotate(.5,axis);// rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:; ; | xx yx zx -tx |; ; |; |; ; | xy yy zy -ty |; ; |; |; ; | xz yz ",MatchSource.WIKI,root/html530/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzRotation.html
https://root.cern/root/html530/TLorentzRotation.html:2309,Testability,test,test,2309," // l is; initialized as identity;  TLorentzRotation m(l); // m = l;  TRotation r;;  TLorentzRotation lr(r);;  TLorentzRotation lb1(bx,by,bz);;  TVector3 b;;  TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:; | 1+gamma'*bx*bx gamma'*bx*by gamma'*bx*bz; gamma*bx |; | gamma'*by*bx 1+gamma'*by*by gamma'*by*bz; gamma*by |; | gamma'*bz*bx gamma'*bz*by 1+gamma'*bz*bz; gamma*bz |; | gamma*bx; gamma*by gamma*bz; gamma |; with the boost vector b=(bx,by,bz) and gamma=1/Sqrt(1-beta*beta); and gamma'=(gamma-1)/beta*beta. Access to the matrix components/Comparisons; Access to the matrix components is possible through the member functions; XX(), XY() .. TT(),; through the operator (int,int):;  Double_t xx;;  TLorentzRotation l;;  xx = l.XX(); // gets the xx component;  xx = l(0,0); // gets the xx component;  if (l==m) {...} // test for equality;  if (l !=m) {...} // test for inequality;  if (l.IsIdentity()) {...} // test for identity; . Transformations of a LorentzRotation. Compound transformations; There are four possibilities to find the product of two TLorentzRotation; transformations:;  TLorentzRotation a,b,c;;  c = b*a;// product;  c = a.MatrixMultiplication(b); // a is unchanged;  a *= b;// Attention: a=a*b;  c = a.Transform(b)// a=b*a then c=a; . Lorentz boosts;  Double_t bx, by, bz;;  TVector3 v(bx,by,bz);;  TLorentzRotation l;;  l.Boost(v);;  l.Boost(bx,by,bz);; . Rotations;  TVector3 axis;;  l.RotateX(TMath::Pi()); // rotation around; x-axis;  l.Rotate(.5,axis);// rotation around specified vector. Inverse transformation; The matrix for the inverse transformation of a TLorentzRotation is as follows:; ; | xx yx zx -tx |; ; |; |; ; | xy yy zy -ty |; ; |; |; ; | xz yz zz -tz |; ; |; |; ",MatchSource.WIKI,root/html530/TLorentzRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzRotation.html
https://root.cern/root/html530/TLorentzVector.html:8529,Availability,error,error,8529,"ual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector& v) const; Double_tDeltaR(const TLorentzVector& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector& q) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector& v) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3& v) const; Double_tEt2() const; Double_tEt2(const TVector3& v) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:8613,Availability,error,error,8613,"ct& object) const; Double_tCosTheta() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TLorentzVector& v) const; Double_tDeltaR(const TLorentzVector& v) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TLorentzVector& q) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TLorentzVector& v) const; virtual voidTObject::Dump() constMENU ; Double_tE() const; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEt() const; Double_tEt(const TVector3& v) const; Double_tEt2() const; Double_tEt2(const TVector3& v) const; Double_tEta() const; TVector2EtaPhiVector(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGamma() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZT(Double_t* carray) const; voidGetXYZT(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:951,Energy Efficiency,energy,energy,951,". TLorentzVector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TLorentzVector. class TLorentzVector: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).; . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;  TLorentzVector v1; // initialized; by (0., 0., 0., 0.);  TLorentzVector v2(1., 1., 1., 1.);;  TLorentzVector v3(v1);;  TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t C array.; . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;  Double_t xx =v.X();;  ...;  Double_t tt = v.T();;  Double_t px = v.Px();;  ...;  Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;  xx = v(0); or; xx = v[0];;  yy = ",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:1774,Energy Efficiency,energy,energy,1774,"asha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).; . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;  TLorentzVector v1; // initialized; by (0., 0., 0., 0.);  TLorentzVector v2(1., 1., 1., 1.);;  TLorentzVector v3(v1);;  TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t C array.; . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;  Double_t xx =v.X();;  ...;  Double_t tt = v.T();;  Double_t px = v.Px();;  ...;  Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;  xx = v(0); or; xx = v[0];;  yy = v(1);; yy = v[1];;  zz = v(2);; zz = v[2];;  tt = v(3);; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;  TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:; ;  v.SetX(1.); or; v.SetPx(1.);;  ...; ...;  v.SetT(1.);; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;  v.SetVect(TVector3(1,2,3));;  v.SetXYZT(x,y,z,t);;",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:4427,Energy Efficiency,energy,energy,4427,"r convenience there are two more set functions SetPtEtaPhiE(pt,eta,phi,e);; and SetPtEtaPhiM(pt,eta,phi,m);. Arithmetic and comparison operators; The TLorentzVector class provides operators to add, subtract or; compare four-vectors:;  v3 = -v1;;  v1 = v2+v3;;  v1+= v3;;  v1 = v2 + v3;;  v1-= v3;;  if (v1 == v2) {...};  if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;  i.e. s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;  mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;  Double_t s, s2;;  s = v1.Dot(v2); // scalar; product;  s = v1*v2;// scalar product;  s2 = v.Mag2(); or s2 = v.M2();;  s = v.Mag();; s = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;  x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;  x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;  t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;  TVector3 b;;  v.Boost(bx,by,bz);;  v.Boost(b);;  b = v.BoostVector(); // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation aro",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:6372,Energy Efficiency,adapt,adapt,6372,"st(b);;  b = v.BoostVector(); // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;  v.RotateX(TMath::Pi()/2.);;  v.RotateY(.5);;  v.RotateZ(.99);. rotation around an arbitary axis;  v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;  v.RotateUz(direction); // direction must be a unit TVector3. by TRotation (see TRotation);  TRotation r;;  v.Transform(r); or; v *= r; // Attention v=M*v. Misc. Angle between two vectors;  Double_t a = v1.Angle(v2.Vect()); // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;  Double_t pcone = v.Plus();;  Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly.; . Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;  TLorentzRotation l;;  v.Transform(l);;  v = l*v; or; v *= l; // Attention v = l*v. Function Members (Methods); public:. TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x = 0.0, Double_t y = 0.0, Double_t z = 0.0, Double_t t = 0.0); virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3& b); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:14826,Energy Efficiency,energy,energy,14826,"() const; TLorentzVector&Transform(const TRotation& m); TLorentzVector&Transform(const TLorentzRotation&); virtual voidTObject::UseCurrentStyle(); TVector3Vect() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Double_tX() const; Double_tY() const; Double_tZ() const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum { kX; kY; kZ; kT; kNUM_COORDINATES; kSIZE; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfEtime or energy of (x,y,z,t) or (px,py,pz,e); TVector3fP3 vector component. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLorentzVector(Double_t x = 0.0, Double_t y = 0.0, Double_t z = 0.0, Double_t t = 0.0); {}. TLorentzVector(const Double_t* carray); {}. TLorentzVector(const Float_t* carray); {}. TLorentzVector(const TVector3& vector3, Double_t t); {}. TLorentzVector(const TLorentzVector& lorentzvector); {}. ~TLorentzVector(); {}. void Boost(Double_t , Double_t , Double_t ); Boost this Lorentz vector. Double_t Rapidity() const; return rapidity. TLorentzVector & Transform(const TLorentzRotation& ); Transform this Lorentzvector. void Streamer(TBuffer& b); Stream an object of class TLorentzVector. void Print(Option_t* option = """") const; Print the TLorentz vector components as (x,y,z,t) and (P,eta,phi,E) representations. Double_t X() const; { return fP.X(); }. Double_t Y() const; { return fP.Y(); }. Double_t Z() const; { return fP.Z(); }. Double_t T() const; { return fE; }.",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:1060,Modifiability,variab,variable,1060,"k Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  MATH;  PHYSICS;  TLorentzVector. class TLorentzVector: public TObject. The Physics Vector package ; -* ========================== ; -* The Physics Vector package consists of five classes: ; -* - TVector2 ; -* - TVector3 ; -* - TRotation ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).; . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;  TLorentzVector v1; // initialized; by (0., 0., 0., 0.);  TLorentzVector v2(1., 1., 1., 1.);;  TLorentzVector v3(v1);;  TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t C array.; . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;  Double_t xx =v.X();;  ...;  Double_t tt = v.T();;  Double_t px = v.Px();;  ...;  Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;  xx = v(0); or; xx = v[0];;  yy = v(1);; y",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:4691,Modifiability,parameteriz,parameterized,4691,"act or; compare four-vectors:;  v3 = -v1;;  v1 = v2+v3;;  v1+= v3;;  v1 = v2 + v3;;  v1-= v3;;  if (v1 == v2) {...};  if(v1 != v3) {...}. Magnitude/Invariant mass, beta, gamma, scalar product; The scalar product of two four-vectors is calculated with the (-,-,-,+); metric,;  i.e. s = v1*v2 = t1*t2-x1*x2-y1*y2-z1*z2; The magnitude squared mag2 of a four-vector is therfore:;  mag2; = v*v = t*t-x*x-y*y-z*z; It mag2 is negative mag = -Sqrt(-mag*mag). The member; functions are:;  Double_t s, s2;;  s = v1.Dot(v2); // scalar; product;  s = v1*v2;// scalar product;  s2 = v.Mag2(); or s2 = v.M2();;  s = v.Mag();; s = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;  x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;  x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;  t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;  TVector3 b;;  v.Boost(bx,by,bz);;  v.Boost(b);;  b = v.BoostVector(); // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;  v.RotateX(TMath::Pi()/2.);;  v.RotateY(.5);;  v.RotateZ(.99);. rotation around an arbitary axis;  v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;  v",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:6372,Modifiability,adapt,adapt,6372,"st(b);;  b = v.BoostVector(); // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;  v.RotateX(TMath::Pi()/2.);;  v.RotateY(.5);;  v.RotateZ(.99);. rotation around an arbitary axis;  v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;  v.RotateUz(direction); // direction must be a unit TVector3. by TRotation (see TRotation);  TRotation r;;  v.Transform(r); or; v *= r; // Attention v=M*v. Misc. Angle between two vectors;  Double_t a = v1.Angle(v2.Vect()); // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;  Double_t pcone = v.Plus();;  Double_t mcone = v.Minus();; CAVEAT: The values returned are T{+,-}Z. It is known that some authors; find it easier to define these components as (T{+,-}Z)/sqrt(2). Thus; check what definition is used in the physics you're working in and adapt; your code accordingly.; . Transformation by TLorentzRotation; A general Lorentz transformation see class TLorentzRotation can; be used by the Transform() member function, the *= or; * operator of the TLorentzRotation class:;  TLorentzRotation l;;  v.Transform(l);;  v = l*v; or; v *= l; // Attention v = l*v. Function Members (Methods); public:. TLorentzVector(const Double_t* carray); TLorentzVector(const Float_t* carray); TLorentzVector(const TLorentzVector& lorentzvector); TLorentzVector(const TVector3& vector3, Double_t t); TLorentzVector(Double_t x = 0.0, Double_t y = 0.0, Double_t z = 0.0, Double_t t = 0.0); virtual~TLorentzVector(); voidTObject::AbstractMethod(const char* method) const; Double_tAngle(const TVector3& v) const; virtual voidTObject::AppendPad(Option_t* option = """"); Double_tBeta() const; voidBoost(const TVector3& b); voidBoost(Double_t, Double_t, Double_t); TVector3BoostVector() const; virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:5138,Performance,perform,performs,5138,"tive mag = -Sqrt(-mag*mag). The member; functions are:;  Double_t s, s2;;  s = v1.Dot(v2); // scalar; product;  s = v1*v2;// scalar product;  s2 = v.Mag2(); or s2 = v.M2();;  s = v.Mag();; s = v.M();; Since in case of momentum and energy the magnitude has the meaning of; invariant mass TLorentzVector provides the more meaningful aliases; M2() and M();; The member functions Beta() and Gamma() returns; beta and gamma = 1/Sqrt(1-beta*beta). Lorentz boost; A boost in a general direction can be parameterized with three parameters; which can be taken as the components of a three vector b = (bx,by,bz).; With;  x = (x,y,z) and gamma = 1/Sqrt(1-beta*beta) (beta being the module of vector b),; an arbitary active Lorentz boost transformation (from the rod frame; to the original frame) can be written as:;  x; = x' + (gamma-1)/(beta*beta) * (b*x') * b +; gamma * t' * b;  t; = gamma (t'+ b*x').; The member function Boost() performs a boost transformation; from the rod frame to the original frame. BoostVector() returns; a TVector3 of the spatial components divided by the time component:;  TVector3 b;;  v.Boost(bx,by,bz);;  v.Boost(b);;  b = v.BoostVector(); // b=(x/t,y/t,z/t). Rotations; There are four sets of functions to rotate the TVector3 component; of a TLorentzVector:. rotation around axes;  v.RotateX(TMath::Pi()/2.);;  v.RotateY(.5);;  v.RotateZ(.99);. rotation around an arbitary axis;  v.Rotate(TMath::Pi()/4., v1); // rotation around v1. transformation from rotated frame;  v.RotateUz(direction); // direction must be a unit TVector3. by TRotation (see TRotation);  TRotation r;;  v.Transform(r); or; v *= r; // Attention v=M*v. Misc. Angle between two vectors;  Double_t a = v1.Angle(v2.Vect()); // get angle between v1 and; v2. Light-cone components; Member functions Plus() and Minus() return the positive; and negative light-cone components:;  Double_t pcone = v.Plus();;  Double_t mcone = v.Minus()",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:1443,Security,access,access,1443," ; -* - TLorentzVector ; -* - TLorentzRotation ; -* It is a combination of CLHEPs Vector package written by ; -* Leif Lonnblad, Andreas Nilsson and Evgueni Tcherniaev ; -* and a ROOT package written by Pasha Murat. ; -* for CLHEP see: http://wwwinfo.cern.ch/asd/lhc++/clhep/ ; -* Adaption to ROOT by Peter Malzacher ; *. ; TLorentzVector; TLorentzVector is a general four-vector class, which can be used; either for the description of position and time (x,y,z,t) or momentum and; energy (px,py,pz,E).; . Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable.; By default all components are initialized by zero.;  TLorentzVector v1; // initialized; by (0., 0., 0., 0.);  TLorentzVector v2(1., 1., 1., 1.);;  TLorentzVector v3(v1);;  TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t C array.; . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;  Double_t xx =v.X();;  ...;  Double_t tt = v.T();;  Double_t px = v.Px();;  ...;  Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;  xx = v(0); or; xx = v[0];;  yy = v(1);; yy = v[1];;  zz = v(2);; zz = v[2];;  tt = v(3);; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;  TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:; ;  v.SetX(1.); or; v.SetPx(1.);;  ...; ...;  v.SetT(1.);; v.SetE(1.);; To set more the one com",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TLorentzVector.html:1935,Security,access,accessed,1935,"Double_t variable.; By default all components are initialized by zero.;  TLorentzVector v1; // initialized; by (0., 0., 0., 0.);  TLorentzVector v2(1., 1., 1., 1.);;  TLorentzVector v3(v1);;  TLorentzVector v4(TVector3(1., 2., 3.),4.);; For backward compatibility there are two constructors from an Double_t; and Float_t C array.; . Access to the components; There are two sets of access functions to the components of a LorentzVector:; X(), Y(), Z(), T() and Px(),; Py(), Pz() and E(). Both sets return the same values; but the first set is more relevant for use where TLorentzVector; describes a combination of position and time and the second set is more; relevant where TLorentzVector describes momentum and energy:;  Double_t xx =v.X();;  ...;  Double_t tt = v.T();;  Double_t px = v.Px();;  ...;  Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:;  xx = v(0); or; xx = v[0];;  yy = v(1);; yy = v[1];;  zz = v(2);; zz = v[2];;  tt = v(3);; tt = v[3];; You can use the Vect() member function to get the vector component; of TLorentzVector:;  TVector3 p = v.Vect();; For setting components also two sets of member functions can be used:; SetX(),.., SetPx(),..:; ;  v.SetX(1.); or; v.SetPx(1.);;  ...; ...;  v.SetT(1.);; v.SetE(1.);; To set more the one component by one call you can use the SetVect(); function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():;  v.SetVect(TVector3(1,2,3));;  v.SetXYZT(x,y,z,t);;  v.SetPxPyPzE(px,py,pz,e);;  v.SetXYZM(x,y,z,m); // ->; v=(x,y,z,e=Sqrt(x*x+y*y+z*z+m*m)). Vector components in noncartesian coordinate systems; There are a couple of memberfunctions to get and set the TVector3; part of the parameters in; sherical coordinate systems:;  Double_t m, theta, cost, phi, pp, pp2, ppv2, pp2v2;;  m = v.Rho();;  t = v.Theta();;  cost = v.C",MatchSource.WIKI,root/html530/TLorentzVector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TLorentzVector.html
https://root.cern/root/html530/TMacro.html:2418,Availability,error,error,2418,"me, const char* title = """"); virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; ",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:2511,Availability,error,error,2511,") const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtu",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:2595,Availability,error,error,2595,"d(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExec(const char* params = 0, Int_t* error = 0)MENU ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjString*GetLineWith(const char* text) const; TList*GetListOfLines() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTO",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:8539,Availability,error,error,8539,"& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}.  Author: Rene Brun 16/08/2005  Copyright (",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:8589,Availability,error,error,8589,"ist of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}.  Author: Rene Brun 16/08/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMacro.h 208",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:8700,Availability,error,error,8700,"ed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this macro. TList * GetListOfLines() const; {return fLines;}.  Author: Rene Brun 16/08/2005  Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *;  Last changed: root/base:$Id: TMacro.h 20877 2007-11-19 11:17:07Z rdm $  Last generated: 2011-07-04 15:34; This page has been automatically generated. For c",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:722,Deployability,update,updated,722,". TMacro. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  BASE;  TMacro. class TMacro: public TNamed. TMacro. Class supporting a collection of lines with C++ code.; A TMacro can be executed, saved to a ROOT file, edited, etc. A macro can be built line by line by calling the AddLine function.; or it can be created directly from a file via the special constructor; when the first argument is a file name. A macro can be executed via the Exec function.; Arguments can be specified when calling Exec. A macro can be drawn in a pad. When the pad is updated, the macro is; automatically executed. The code in the macro can be saved via the SaveSource function.; If the macro is in the list of primitives of a pad/canvas, the macro; will be saved in the script generated by TCanvas::SaveSource. A macro can be written to a ROOT file via TObject::Write. Examples:; TMacro m(""Peaks.C""); //macro m with name ""Peaks"" is created; from file Peaks.C; m.Exec(); //macro executed with default arguments; m.Exec(""4""); //macro executed with argument; m.SaveSource(""newPeaks.C"");; TFile f(""mymacros.root"",""recreate"");; m.Write(); //macro saved to file with name ""Peaks"". Function Members (Methods); public:. TMacro(); TMacro(const TMacro&); TMacro(const char* name, const char* title = """"); virtual~TMacro(); voidTObject::AbstractMethod(const char* method) const; virtual TObjString*AddLine(const char* text); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); virtual TMD5*Checksum(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:7755,Integrability,depend,depending,7755,"otected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:7784,Modifiability,variab,variable,7784,"otected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:7729,Performance,perform,performed,7729,"otected:. TList*fLinescollection of lines; TStringTNamed::fNameobject identifier; TStringfParamsdefault string of macro parameters; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMacro(); Create an empty macro, use AddLine() or ReadFile() to fill this macro. TMacro(const char* name, const char* title = """"); Create a macro with a name and a title.; If name contains a '.' it is assumed to be the name of a file, and; * the macro is automatically filled by reading all the lines in the file,; * if the title is empty, it will be set to the name of the file,; * the name will be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInte",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:8430,Security,checksum,checksum,8430,"cro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this ma",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:8359,Testability,log,log,8359,"ill be set to the filename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const cha",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMacro.html:8391,Testability,log,log,8391,"ename without path or extension. TMacro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set de",MatchSource.WIKI,root/html530/TMacro.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMacro.html
https://root.cern/root/html530/TMap.html:2291,Availability,error,error,2291,"ar(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTit",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:2375,Availability,error,error,2375,""""") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TObject*GetValue(const char*",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:10533,Availability,down,downcast,10533,"ts in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; Returns a pointer to the value associated with key. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key f",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:10788,Availability,down,downcast,10788,"ption = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; Returns a pointer to the value associated with key. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Create an iterator for TMap. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print the collection entry. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the underlaying THashTable (see THashTable::Rehash()). TObject * Remove(TObject* key); Remove the (key,value) pair with key from the map. Returns the; key object or 0 in case key was not found. If map is the owner; of values, the value is deleted. TPair * RemoveEntry(TObject* key); Remove (key,value) pair with key from the map. Returns the; pair object or 0 in case the key was ",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:365,Energy Efficiency,efficient,efficient,365,". TMap. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  CORE;  CONT;  TMap. class TMap: public TCollection. TMap. TMap implements an associative array of (key,value) pairs using a; THashTable for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function and the; key comparison is done via the IsEqual() function.; Both key and value must inherit from TObject. /*. */. Function Members (Methods); public:. TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); virtual~TMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); voidAdd(TObject* key, TObject* value); virtual voidTCollection::AddAll(const TCollection* col); voidTCollection::AddVector(TObject* obj1); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; Float_tAverageCollisions() const; virtual voidTCollection::Browse(TBrowser* b); Int_tCapacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TOb",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:9875,Energy Efficiency,allocate,allocated,9875,"s() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Va",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:9998,Energy Efficiency,allocate,allocated,9998,"tSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) con",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:10127,Energy Efficiency,allocate,allocated,10127," the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const; Check if a (key,value) pair exists with key as key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * GetValue(const char* keyname) const; Returns a pointer to the value associated with keyname as name of the key. TObject * GetValue(const TObject* key) const; R",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
https://root.cern/root/html530/TMap.html:9123,Integrability,depend,depending,9123,"number of elements in collection. private:. THashTable*fTableHash table used to store TPair's. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMap(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); TMap ctor. See THashTable for a description of the arguments. ~TMap(); TMap dtor. Objects are not deleted unless the TMap is the; owner (set via SetOwner()). void Add(TObject* obj); This function may not be used (but we need to provide it since it is; a pure virtual in TCollection). Use Add(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool",MatchSource.WIKI,root/html530/TMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html530/TMap.html
